diff --git a/cores/nRF5/nordic/config/nrf52840/config/Makefile.am b/cores/nRF5/nordic/config/nrf52840/config/Makefile.am
new file mode 100644
index 000000000..176a96661
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/Makefile.am
@@ -0,0 +1,45 @@
+#
+#    Copyright 2015-2017 Nest Labs Inc. All Rights Reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License");
+#    you may not use this file except in compliance with the License.
+#    You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS,
+#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#    See the License for the specific language governing permissions and
+#    limitations under the License.
+#
+
+#
+#    Description:
+#      This file is the GNU automake template for the Nest Labs Memory-
+#      mapped I/O library public headers.
+#
+
+include $(abs_top_nlbuild_autotools_dir)/automake/pre.am
+
+include_HEADERS =             \
+    nlbyteorder-big.h         \
+    nlbyteorder.h             \
+    nlbyteorder.hpp           \
+    nlbyteorder-little.h      \
+    nlio-base.h               \
+    nlio-base.hpp             \
+    nlio-byteorder-big.h      \
+    nlio-byteorder-big.hpp    \
+    nlio-byteorder-little.h   \
+    nlio-byteorder-little.hpp \
+    nlio-byteorder.h          \
+    nlio-byteorder.hpp        \
+    nlio-private.h            \
+    nlio.h                    \
+    nlio.hpp                  \
+    $(NULL)
+
+install-headers: install-data
+
+include $(abs_top_nlbuild_autotools_dir)/automake/post.am
diff --git a/cores/nRF5/nordic/config/nrf52840/config/Makefile.in b/cores/nRF5/nordic/config/nrf52840/config/Makefile.in
new file mode 100644
index 000000000..7129e8f95
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/Makefile.in
@@ -0,0 +1,664 @@
+# Makefile.in generated by automake 1.14.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+#
+#    Copyright 2015-2017 Nest Labs Inc. All Rights Reserved.
+#
+#    Licensed under the Apache License, Version 2.0 (the "License");
+#    you may not use this file except in compliance with the License.
+#    You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+#    Unless required by applicable law or agreed to in writing, software
+#    distributed under the License is distributed on an "AS IS" BASIS,
+#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#    See the License for the specific language governing permissions and
+#    limitations under the License.
+#
+
+#
+#    Description:
+#      This file is the GNU automake template for the Nest Labs Memory-
+#      mapped I/O library public headers.
+#
+
+VPATH = @srcdir@
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+subdir = include
+DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
+	$(srcdir)/nlio-config.h.in \
+	$(top_srcdir)/third_party/nlbuild-autotools/repo/third_party/autoconf/mkinstalldirs \
+	$(include_HEADERS)
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/third_party/nlbuild-autotools/repo/autoconf/m4/ax_check_compiler.m4 \
+	$(top_srcdir)/third_party/nlbuild-autotools/repo/autoconf/m4/nl_enable_coverage.m4 \
+	$(top_srcdir)/third_party/nlbuild-autotools/repo/autoconf/m4/nl_enable_coverage_reporting.m4 \
+	$(top_srcdir)/third_party/nlbuild-autotools/repo/autoconf/m4/nl_enable_debug.m4 \
+	$(top_srcdir)/third_party/nlbuild-autotools/repo/autoconf/m4/nl_enable_docs.m4 \
+	$(top_srcdir)/third_party/nlbuild-autotools/repo/autoconf/m4/nl_enable_optimization.m4 \
+	$(top_srcdir)/third_party/nlbuild-autotools/repo/autoconf/m4/nl_enable_tests.m4 \
+	$(top_srcdir)/third_party/nlbuild-autotools/repo/autoconf/m4/nl_filtered_canonical.m4 \
+	$(top_srcdir)/third_party/nlbuild-autotools/repo/autoconf/m4/nl_werror.m4 \
+	$(top_srcdir)/third_party/nlbuild-autotools/repo/autoconf/m4/nl_with_package.m4 \
+	$(top_srcdir)/third_party/nlbuild-autotools/repo/third_party/autoconf/m4/libtool.m4 \
+	$(top_srcdir)/third_party/nlbuild-autotools/repo/third_party/autoconf/m4/ltoptions.m4 \
+	$(top_srcdir)/third_party/nlbuild-autotools/repo/third_party/autoconf/m4/ltsugar.m4 \
+	$(top_srcdir)/third_party/nlbuild-autotools/repo/third_party/autoconf/m4/ltversion.m4 \
+	$(top_srcdir)/third_party/nlbuild-autotools/repo/third_party/autoconf/m4/lt~obsolete.m4 \
+	$(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) \
+	$(top_srcdir)/third_party/nlbuild-autotools/repo/third_party/autoconf/mkinstalldirs
+CONFIG_HEADER = nlio-config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
+SOURCES =
+DIST_SOURCES =
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__uninstall_files_from_dir = { \
+  test -z "$$files" \
+    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
+    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
+         $(am__cd) "$$dir" && rm -f $$files; }; \
+  }
+am__installdirs = "$(DESTDIR)$(includedir)"
+HEADERS = $(include_HEADERS)
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) \
+	$(LISP)nlio-config.h.in
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CMP = @CMP@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DOXYGEN_USE_DOT = @DOXYGEN_USE_DOT@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GENHTML = @GENHTML@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LCOV = @LCOV@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBNLIO_VERSION_AGE = @LIBNLIO_VERSION_AGE@
+LIBNLIO_VERSION_CURRENT = @LIBNLIO_VERSION_CURRENT@
+LIBNLIO_VERSION_INFO = @LIBNLIO_VERSION_INFO@
+LIBNLIO_VERSION_REVISION = @LIBNLIO_VERSION_REVISION@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MANIFEST_TOOL = @MANIFEST_TOOL@
+MKDIR_P = @MKDIR_P@
+NLUNIT_TEST_CPPFLAGS = @NLUNIT_TEST_CPPFLAGS@
+NLUNIT_TEST_FOREIGN_SUBDIR_DEPENDENCY = @NLUNIT_TEST_FOREIGN_SUBDIR_DEPENDENCY@
+NLUNIT_TEST_LDFLAGS = @NLUNIT_TEST_LDFLAGS@
+NLUNIT_TEST_LIBS = @NLUNIT_TEST_LIBS@
+NLUNIT_TEST_SUBDIRS = @NLUNIT_TEST_SUBDIRS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJCOPY = @OBJCOPY@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PERL = @PERL@
+PKG_CONFIG = @PKG_CONFIG@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_nlbuild_autotools_dir = @abs_top_nlbuild_autotools_dir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+nl_filtered_build = @nl_filtered_build@
+nl_filtered_build_cpu = @nl_filtered_build_cpu@
+nl_filtered_build_os = @nl_filtered_build_os@
+nl_filtered_build_vendor = @nl_filtered_build_vendor@
+nl_filtered_host = @nl_filtered_host@
+nl_filtered_host_cpu = @nl_filtered_host_cpu@
+nl_filtered_host_os = @nl_filtered_host_os@
+nl_filtered_host_vendor = @nl_filtered_host_vendor@
+nl_filtered_target = @nl_filtered_target@
+nl_filtered_target_cpu = @nl_filtered_target_cpu@
+nl_filtered_target_os = @nl_filtered_target_os@
+nl_filtered_target_vendor = @nl_filtered_target_vendor@
+nlbuild_autotools_stem = @nlbuild_autotools_stem@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+subdirs = @subdirs@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+include_HEADERS = \
+    nlbyteorder-big.h         \
+    nlbyteorder.h             \
+    nlbyteorder.hpp           \
+    nlbyteorder-little.h      \
+    nlio-base.h               \
+    nlio-base.hpp             \
+    nlio-byteorder-big.h      \
+    nlio-byteorder-big.hpp    \
+    nlio-byteorder-little.h   \
+    nlio-byteorder-little.hpp \
+    nlio-byteorder.h          \
+    nlio-byteorder.hpp        \
+    nlio-private.h            \
+    nlio.h                    \
+    nlio.hpp                  \
+    $(NULL)
+
+all: nlio-config.h
+	$(MAKE) $(AM_MAKEFLAGS) all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign include/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign include/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+nlio-config.h: stamp-h1
+	@test -f $@ || rm -f stamp-h1
+	@test -f $@ || $(MAKE) $(AM_MAKEFLAGS) stamp-h1
+
+stamp-h1: $(srcdir)/nlio-config.h.in $(top_builddir)/config.status
+	@rm -f stamp-h1
+	cd $(top_builddir) && $(SHELL) ./config.status include/nlio-config.h
+$(srcdir)/nlio-config.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps) 
+	($(am__cd) $(top_srcdir) && $(AUTOHEADER))
+	rm -f stamp-h1
+	touch $@
+
+distclean-hdr:
+	-rm -f nlio-config.h stamp-h1
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+install-includeHEADERS: $(include_HEADERS)
+	@$(NORMAL_INSTALL)
+	@list='$(include_HEADERS)'; test -n "$(includedir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(includedir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(includedir)" || exit 1; \
+	fi; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_HEADER) $$files '$(DESTDIR)$(includedir)'"; \
+	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(includedir)" || exit $$?; \
+	done
+
+uninstall-includeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(include_HEADERS)'; test -n "$(includedir)" || list=; \
+	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
+	dir='$(DESTDIR)$(includedir)'; $(am__uninstall_files_from_dir)
+
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
+
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	set x; \
+	here=`pwd`; \
+	$(am__define_uniq_tagged_files); \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS) nlio-config.h
+installdirs:
+	for dir in "$(DESTDIR)$(includedir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-hdr distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-includeHEADERS
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-includeHEADERS
+
+.MAKE: all install-am install-strip
+
+.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
+	clean-libtool cscopelist-am ctags ctags-am distclean \
+	distclean-generic distclean-hdr distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-includeHEADERS install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \
+	uninstall-am uninstall-includeHEADERS
+
+
+include $(abs_top_nlbuild_autotools_dir)/automake/pre.am
+
+install-headers: install-data
+
+include $(abs_top_nlbuild_autotools_dir)/automake/post.am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/cores/nRF5/nordic/config/nrf52840/config/app/util/common.h b/cores/nRF5/nordic/config/nrf52840/config/app/util/common.h
new file mode 100644
index 000000000..05cef1747
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/app/util/common.h
@@ -0,0 +1,57 @@
+/**
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *
+ *    Copyright (c) 2020 Silicon Labs
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+/***************************************************************************/
+/**
+ * @file
+ * @brief This file contains the includes that are
+ *common to all clusters in the util.
+ *******************************************************************************
+ ******************************************************************************/
+
+#pragma once
+
+// App framework
+#include <app/util/af.h>
+#include <app/util/attribute-storage.h>
+#include <app/util/attribute-table.h>
+#include <app/util/time-util.h>
+#include <app/util/util.h>
+
+#include <messaging/ExchangeContext.h>
+
+// the variables used to setup and send responses to cluster messages
+extern EmberApsFrame emberAfResponseApsFrame;
+extern uint8_t appResponseData[EMBER_AF_RESPONSE_BUFFER_LEN];
+extern uint16_t appResponseLength;
+extern chip::Messaging::ExchangeContext * emberAfResponseDestination;
diff --git a/cores/nRF5/nordic/config/nrf52840/config/basic.h b/cores/nRF5/nordic/config/nrf52840/config/basic.h
new file mode 100644
index 000000000..712a1dcce
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/basic.h
@@ -0,0 +1,29 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#pragma once
+
+#include <app/util/basic-types.h>
+
+/** @brief Basic Cluster Server Init
+ *
+ * This function is called at startup for a given endpoint to initialize
+ * attributes of the Basic Cluster.
+ *
+ * @param endpoint Endpoint that is being initialized  Ver.: always
+ */
+void emberAfBasicClusterServerInitCallback(chip::EndpointId endpoint);
diff --git a/cores/nRF5/nordic/config/nrf52840/config/basic/basic.h b/cores/nRF5/nordic/config/nrf52840/config/basic/basic.h
new file mode 100644
index 000000000..712a1dcce
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/basic/basic.h
@@ -0,0 +1,29 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+#pragma once
+
+#include <app/util/basic-types.h>
+
+/** @brief Basic Cluster Server Init
+ *
+ * This function is called at startup for a given endpoint to initialize
+ * attributes of the Basic Cluster.
+ *
+ * @param endpoint Endpoint that is being initialized  Ver.: always
+ */
+void emberAfBasicClusterServerInitCallback(chip::EndpointId endpoint);
diff --git a/cores/nRF5/nordic/config/nrf52840/config/controller/README.md b/cores/nRF5/nordic/config/nrf52840/config/controller/README.md
new file mode 100644
index 000000000..035aa3579
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/controller/README.md
@@ -0,0 +1,65 @@
+# CHIP controller
+
+There are currently 4 implementations of the CHIP device controller with varying
+support for certain CHIP features.
+
+## Implementations
+
+### iOS
+
+The iOS chip-tool is located in [../darwin/CHIPTool](../darwin/CHIPTool).
+
+### Android
+
+The Android chip-tool is located in [../android/CHIPTool](../android/CHIPTool).
+
+### POSIX CLI
+
+The POSIX CLI chip-tool is located in
+[../../examples/chip-tool](../../examples/chip-tool).
+
+### Python
+
+The Python chip-device-ctrl is located in
+[../controller/python/](../controller/python).
+
+## Feature Overview
+
+| Onboarding | iOS | Android | CLI | Python |
+| ---------- | --- | ------- | --- | ------ |
+| Setup code | y?  | n       | y   | y      |
+| QR code    | y   | y       | n   | n      |
+| NFC        | y   | y       | n   | n      |
+
+| Provisioning | iOS    | Android | CLI | Python |
+| ------------ | ------ | ------- | --- | ------ |
+| Soft-AP      | y      | n       | y   | y      |
+| WiFi-BLE     | y?     | y       | y   | y      |
+| Thread-BLE   | n(\*0) | y(\*1)  | n   | y(\*1) |
+
+| Commands/Clusters   | iOS | Android | CLI | Python |
+| ------------------- | --- | ------- | --- | ------ |
+| Echo Client         | y?  | y       | y   | y      |
+| On/Off Client       | y   | y       | y   | y      |
+| LevelControl Client | ?   | y       | y   | y      |
+| Identify Client     | ?   | n(\*2)  | y   | y      |
+| Scene Client        | n?  | n(\*2)  | y   | y      |
+| Group Client        | n?  | n(\*2)  | y   | y      |
+| Binding Client      | n?  | n(\*2)  | y   | y      |
+
+| Attributes/Clusters | iOS | Android | CLI | Python |
+| ------------------- | --- | ------- | --- | ------ |
+| Read                | n   | n(\*2)  | y   | y      |
+| Write               | n   | n(\*2)  | y   | n      |
+
+|                  | iOS | Android | CLI | Python |
+| ---------------- | --- | ------- | --- | ------ |
+| Multiple Devices | y   | n       | ?   | y      |
+
+Notes:
+
+(\*0) <https://github.com/project-chip/connectedhomeip/pull/4829>
+
+(\*1) Only static commissioning, not MeshCoP.
+
+(\*2) Locally a patch exists, could be upstreamed.
diff --git a/cores/nRF5/nordic/config/nrf52840/config/controller/python/README.md b/cores/nRF5/nordic/config/nrf52840/config/controller/python/README.md
new file mode 100644
index 000000000..1e64cf816
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/controller/python/README.md
@@ -0,0 +1,534 @@
+# Python CHIP Device Controller
+
+## Overview
+
+The Python CHIP controller is a tool that allows to commission a Matter device
+into the network and to communicate with it using the Zigbee Cluster Library
+(ZCL) messages. The tool uses the generic [Chip Device Controller](../) library.
+
+The following instruction describes how to build and test the Python CHIP
+controller.
+
+To learn more about advanced usage of the tool, read the
+[advanced usage page](ADVANCED_USAGE.md).
+
+## Building and installing
+
+Before you can use the Python controller, you must compile it from the source on
+Linux (amd64 / aarch64) or macOS.
+
+> To ensure compatibility, build the Python CHIP controller and the Matter
+> device from the same revision of the connectedhomeip repository.
+
+To build and run the Python CHIP controller:
+
+1. Install all necessary packages and prepare the build system. For more
+   details, see the [BUILDING.md](/docs/BUILDING.md) documentation:
+
+    ```
+    sudo apt-get update
+    sudo apt-get upgrade
+
+    sudo apt-get install git gcc g++ python pkg-config libssl-dev libdbus-1-dev libglib2.0-dev libavahi-client-dev ninja-build python3-venv python3-dev python3-pip unzip libgirepository1.0-dev libcairo2-dev bluez
+    ```
+
+    If the Python CHIP controller is built on a Raspberry Pi, install additional
+    packages and reboot the device:
+
+    ```
+    sudo apt-get install pi-bluetooth
+    sudo reboot
+    ```
+
+2. Clone the Project CHIP repository:
+
+    ```
+    git clone https://github.com/project-chip/connectedhomeip.git
+    ```
+
+3. Enter the `connectedhomeip` directory:
+
+    ```
+    cd connectedhomeip
+    ```
+
+4. Initialize the git submodules:
+
+    ```
+    git submodule update --init
+    ```
+
+5. Build and install the Python CHIP controller:
+
+    ```
+    scripts/build_python.sh -m platform
+    ```
+
+    > Note: To get more details about available build configurations, run the
+    > following command: `scripts/build_python.sh --help`
+
+## Running the tool
+
+1. Activate the Python virtual environment:
+
+    ```
+    source out/python_env/bin/activate
+    ```
+
+2. Run the Python CHIP controller with root privileges, which is required to
+   obtain access to the Bluetooth interface:
+
+    ```
+    sudo out/python_env/bin/chip-device-ctrl
+    ```
+
+    You can also select the Bluetooth LE interface using command line argument:
+
+    ```
+    sudo out/python_env/bin/chip-device-ctrl --bluetooth-adapter=hci2
+    ```
+
+## Working with Python CHIP Controller
+
+This section describes how to use Python CHIP controller to test the Matter
+accessory. Below steps depend on the application clusters that you implemented
+on the device side and may be different for your accessory.
+
+### Step 1: Prepare the Matter accessory.
+
+This tutorial is using the [Matter Light Bulb](/examples/lighting-app) example
+with the Bluetooth LE commissioning. However, you can adapt this procedure to
+other available [Matter examples](/examples).
+
+Build and program the device with the Matter accessory firmware by following the
+example's documentation.
+
+### Step 2: Enable Bluetooth LE advertising on Matter accessory device.
+
+Some examples are configured to advertise automatically on boot. Other examples
+require physical trigger, for example pushing a button. Follow the documentation
+of the Matter accessory example to learn how Bluetooth LE advertising is enabled
+for the given example.
+
+### Step 3: Discover Matter accessory device over Bluetooth LE
+
+An uncommissioned accessory device advertises over Bluetooth LE. Run the
+following command to scan all advertised Matter devices:
+
+```
+chip-device-ctrl > ble-scan
+```
+
+### Step 4: Connect to Matter accessory device over Bluetooth LE
+
+The controller uses a 12-bit value called **discriminator** to discern between
+multiple commissionable device advertisements. Moreover, a 27-bit **PIN code**
+is used by the controller to authenticate in the device. You can find those
+values in the logging terminal of the device (for example, UART). For example:
+
+```
+I: 254 [DL]Device Configuration:
+I: 257 [DL] Serial Number: TEST_SN
+I: 260 [DL] Vendor Id: 9050 (0x235A)
+I: 263 [DL] Product Id: 20043 (0x4E4B)
+I: 267 [DL] Product Revision: 1
+I: 270 [DL] Setup Pin Code: 20202021
+I: 273 [DL] Setup Discriminator: 3840 (0xF00)
+I: 278 [DL] Manufacturing Date: (not set)
+I: 281 [DL] Device Type: 65535 (0xFFFF)
+```
+
+Run the following command to establish the secure connection over Bluetooth LE,
+with the following assumptions for the Matter accessory device:
+
+-   The discriminator of the device is _3840_
+-   The setup pin code of the device is _20202021_
+-   The temporary Node ID is _1234_
+
+```
+chip-device-ctrl > connect -ble 3840 20202021 1234
+```
+
+You can skip the last parameter, that is the Node ID. If you skip it, the
+controller will assign it randomly. However, note the Node ID down, because it
+is required later in the configuration process.
+
+At the end of the secure connection establishment, the Python controller prints
+the following log:
+
+```
+Secure Session to Device Established
+```
+
+This means that the PASE (Password-Authenticated Session Establishment) session
+using SPAKE2+ protocol is completed.
+
+### Step 5: Commission Matter accessory to the underlying network
+
+The main goal of the network commissioning step is to configure the device with
+a network interface, such as Thread or Wi-Fi. This process provides the device
+with network credentials.
+
+#### Commissioning a Thread device
+
+1. Fetch and store the current Active Operational Dataset and Extended PAN ID
+   from the Thread Border Router. Depending if Thread Border Router is running
+   on Docker or natively on Raspberry Pi, execute the following commands:
+
+    - For Docker:
+
+        ```
+        sudo docker exec -it otbr sh -c "sudo ot-ctl dataset active -x"
+        0e080000000000010000000300001335060004001fffe002084fe76e9a8b5edaf50708fde46f999f0698e20510d47f5027a414ffeebaefa92285cc84fa030f4f70656e5468726561642d653439630102e49c0410b92f8c7fbb4f9f3e08492ee3915fbd2f0c0402a0fff8
+        Done
+
+        sudo docker exec -it otbr sh -c "sudo ot-ctl dataset extpanid”
+        4fe76e9a8b5edaf5
+        Done
+        ```
+
+    - For native installation:
+
+        ```
+        sudo ot-ctl dataset active -x
+        0e080000000000010000000300001335060004001fffe002084fe76e9a8b5edaf50708fde46f999f0698e20510d47f5027a414ffeebaefa92285cc84fa030f4f70656e5468726561642d653439630102e49c0410b92f8c7fbb4f9f3e08492ee3915fbd2f0c0402a0fff8
+        Done
+
+        sudo ot-ctl dataset extpanid
+        4fe76e9a8b5edaf5
+        Done
+        ```
+
+    Matter specifiction does not define how the Thread or Wi-Fi credentials are
+    obtained by Controller. For example, for Thread, instead of fetching
+    datasets directly from the Thread Border Router, you might also use a
+    different out-of-band method.
+
+2. Inject the previously obtained Active Operational Dataset as hex-encoded
+   value using ZCL Network Commissioning cluster:
+
+    > Each ZCL command has a following format:
+    > `zcl <Cluster> <Command> <Node Id> <Endpoint Id> <Group Id> [arguments]`
+
+    ```
+    chip-device-ctrl > zcl NetworkCommissioning AddThreadNetwork 1234 0 0 operationalDataset=hex:0e080000000000010000000300001335060004001fffe002084fe76e9a8b5edaf50708fde46f999f0698e20510d47f5027a414ffeebaefa92285cc84fa030f4f70656e5468726561642d653439630102e49c0410b92f8c7fbb4f9f3e08492ee3915fbd2f0c0402a0fff8 breadcrumb=0 timeoutMs=3000
+    ```
+
+3. Enable Thread interface on the device by executing the following command with
+   `networkID` equal to Extended PAN Id of the Thread network:
+
+    ```
+    chip-device-ctrl > zcl NetworkCommissioning EnableNetwork 1234 0 0 networkID=hex:4fe76e9a8b5edaf5 breadcrumb=0 timeoutMs=3000
+    ```
+
+#### Commissioning a Wi-Fi device
+
+1. Assuming your Wi-Fi SSID is _TESTSSID_, and your Wi-Fi password is
+   _P455W4RD_, inject the credentials to the device by excuting the following
+   command:
+
+    ```
+    chip-device-ctrl > zcl NetworkCommissioning AddWiFiNetwork 1234 0 0 ssid=str:TESTSSID credentials=str:P455W4RD breadcrumb=0 timeoutMs=1000
+    ```
+
+2. Enable the Wi-Fi interface on the device by executing the following command:
+
+    ```
+    chip-device-ctrl > zcl NetworkCommissioning EnableNetwork 1234 0 0 networkID=str:TESTSSID breadcrumb=0 timeoutMs=1000
+    ```
+
+### Step 6: Close Bluetooth LE connection.
+
+After the Matter accessory device was provisioned with Thread or Wi-Fi
+credentials (or both), the commissioning process is finished. The Python CHIP
+controller is now using only the IPv6 traffic to reach the device, so you can
+close the Bluetooth LE connection. To close the connection, run the following
+command:
+
+```
+chip-device-ctrl > close-ble
+```
+
+### Step 7: Discover IPv6 address of the Matter accessory.
+
+The Matter controller must discover the IPv6 address of the node that it
+previously commissioned. Depending on the network type:
+
+-   For Thread, the Matter accessory uses SRP (Service Registration Protocol) to
+    register its presence on the Thread Border Router’s SRP Server.
+-   For Wi-Fi or Ethernet devices, the Matter accessory uses the mDNS (Multicast
+    Domain Name System) protocol.
+
+Assuming your Fabric ID is _5544332211_ and Node ID is _1234_ (use the Node ID
+you noted down when you established the secure connection over Bluetooth LE)),
+run the following command:
+
+```
+chip-device-ctrl > resolve 5544332211 1234
+```
+
+A notification in the log indicates that the node address has been updated. The
+IPv6 address of the device is cached in the controller for later usage.
+
+### Step 8: Control application ZCL clusters.
+
+For the light bulb example, execute the following command to toggle the LED
+state:
+
+```
+chip-device-ctrl > zcl OnOff Toggle 1234 1 0
+```
+
+To change the brightness of the LED, use the following command, with the level
+value somewhere between 0 and 255.
+
+```
+chip-device-ctrl > zcl LevelControl MoveToLevel 1234 1 0 level=50
+```
+
+### Step 9: Read basic information out of the accessory.
+
+Every Matter accessory device supports a Basic Cluster, which maintains
+collection of attributes that a controller can obtain from a device, such as the
+vendor name, the product name, or software version. Use `zclread` command to
+read those values from the device:
+
+```
+chip-device-ctrl > zclread Basic VendorName 1234 1 0
+chip-device-ctrl > zclread Basic ProductName 1234 1 0
+chip-device-ctrl > zclread Basic SoftwareVersion 1234 1 0
+```
+
+> Use the `zcl ? Basic` command to list all available commands for Basic
+> Cluster.
+
+## List of commands
+
+### `ble-adapter-print`
+
+Print the available Bluetooth adapters on device. Takes no arguments:
+
+```
+chip-device-ctrl > ble-adapter-print
+2021-03-04 16:09:40,930 ChipBLEMgr   INFO     AdapterName: hci0   AdapterAddress: 00:AA:01:00:00:23
+```
+
+### `ble-debug-log`
+
+Enable the Bluetooth LE debug logs.
+
+```
+chip-device-ctrl > ble-debug-log 1
+```
+
+### `ble-scan [-t <timeout>] [identifier]`
+
+Start a scan action to search for valid CHIP devices over Bluetooth LE (for at
+most _timeout_ seconds). Stop when the device is matching the identifier or the
+counter times out.
+
+```
+chip-device-ctrl > ble-scan
+2021-05-29 22:28:05,461 ChipBLEMgr   INFO     scanning started
+2021-05-29 22:28:07,206 ChipBLEMgr   INFO     Name            = ChipLight
+2021-05-29 22:28:07,206 ChipBLEMgr   INFO     ID              = f016e23d-0d00-35d5-93e7-588acdbc7e54
+2021-05-29 22:28:07,207 ChipBLEMgr   INFO     RSSI            = -79
+2021-05-29 22:28:07,207 ChipBLEMgr   INFO     Address         = E0:4D:84:3C:BB:C3
+2021-05-29 22:28:07,209 ChipBLEMgr   INFO     Pairing State   = 0
+2021-05-29 22:28:07,209 ChipBLEMgr   INFO     Discriminator   = 3840
+2021-05-29 22:28:07,209 ChipBLEMgr   INFO     Vendor Id       = 9050
+2021-05-29 22:28:07,209 ChipBLEMgr   INFO     Product Id      = 20044
+2021-05-29 22:28:07,210 ChipBLEMgr   INFO     Adv UUID        = 0000fff6-0000-1000-8000-00805f9b34fb
+2021-05-29 22:28:07,210 ChipBLEMgr   INFO     Adv Data        = 00000f5a234c4e
+2021-05-29 22:28:07,210 ChipBLEMgr   INFO
+2021-05-29 22:28:16,246 ChipBLEMgr   INFO     scanning stopped
+```
+
+### `connect -ip <address> <SetUpPinCode> [<nodeid>]`
+
+Do key exchange and establish a secure session between controller and device
+using IP transport.
+
+The Node ID will be used by controller to distinguish multiple devices. This
+does not match the spec and will be removed later. The nodeid will not be
+persisted by controller / device.
+
+If no nodeid given, a random Node ID will be used.
+
+### `connect -ble <discriminator> <SetUpPinCode> [<nodeid>]`
+
+Do key exchange and establish a secure session between controller and device
+using Bluetooth LE transport.
+
+The Node ID will be used by controller to distinguish multiple devices. This
+does not match the spec and will be removed later. The nodeid will not be
+persisted by controller / device.
+
+If no nodeid given, a random Node ID will be used.
+
+### `discover`
+
+Discover available Matter accessory devices:
+
+```
+chip-device-ctrl > discover -all
+```
+
+### `resolve <fabric_id> <node_id>`
+
+Resolve DNS-SD name corresponding with the given fabric and Node IDs and update
+address of the node in the device controller:
+
+```
+chip-device-ctrl > resolve 5544332211 1234
+```
+
+### `setup-payload generate [-v <Vendor ID>] [-p <Product ID>] [-cf <Custom Flow>] [-dc <Discovery Capabilities>] [-dv <Discriminator Value>] [-ps <Passcode>]`
+
+Print the generated Onboarding Payload Contents in human-readable (Manual
+Pairing Code) and machine-readable (QR Code) format:
+
+```
+chip-device-ctrl > setup-payload generate -v 9050 -p 65279 -cf 0 -dc 2 -dv 2976 -ps 34567890
+Manual pairing code: [26318621095]
+SetupQRCode: [MT:YNJV7VSC00CMVH7SR00]
+```
+
+### `setup-payload parse-manual <manual-pairing-code>`
+
+Print the commissioning information encoded in the Manual Pairing Code:
+
+```
+chip-device-ctrl > setup-payload parse-manual 34970112332
+Version: 0
+VendorID: 0
+ProductID: 0
+CommissioningFlow: 0
+RendezvousInformation: 0
+Discriminator: 3840
+SetUpPINCode: 20202021
+```
+
+### `setup-payload parse-qr <qr-code>`
+
+Print the commissioning information encoded in the QR Code payload:
+
+```
+chip-device-ctrl > setup-payload parse-qr "VP:vendorpayload%MT:W0GU2OTB00KA0648G00"
+Version: 0
+VendorID: 9050
+ProductID: 20043
+CommissioningFlow: 0
+RendezvousInformation: 2 [BLE]
+Discriminator: 3840
+SetUpPINCode: 20202021
+```
+
+### `zcl <Cluster> <Command> <NodeId> <EndpointId> <GroupId> [arguments]`
+
+Send a ZCL command to the device. For example:
+
+```
+chip-device-ctrl > zcl LevelControl MoveWithOnOff 12344321 1 0 moveMode=1 rate=2
+```
+
+**Format of arguments**
+
+For any integer and char string (null terminated) types, just use `key=value`,
+for example: `rate=2`, `string=123`, `string_2="123 456"`
+
+For byte string type, use `key=encoding:value`, currectly, we support `str` and
+`hex` encoding, the `str` encoding will encode a NULL terminated string. For
+example, `networkId=hex:0123456789abcdef` (for
+`[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]`), `ssid=str:Test` (for
+`['T', 'e', 's', 't', 0x00]`).
+
+### `zcl ?`
+
+List available clusters:
+
+```
+chip-device-ctrl > zcl ?
+AccountLogin
+ApplicationBasic
+ApplicationLauncher
+AudioOutput
+BarrierControl
+Basic
+Binding
+BridgedDeviceBasic
+ColorControl
+ContentLaunch
+Descriptor
+DoorLock
+EthernetNetworkDiagnostics
+FixedLabel
+GeneralCommissioning
+GeneralDiagnostics
+GroupKeyManagement
+Groups
+Identify
+KeypadInput
+LevelControl
+LowPower
+MediaInput
+MediaPlayback
+NetworkCommissioning
+OnOff
+OperationalCredentials
+PumpConfigurationAndControl
+RelativeHumidityMeasurement
+Scenes
+SoftwareDiagnostics
+Switch
+TvChannel
+TargetNavigator
+TemperatureMeasurement
+TestCluster
+Thermostat
+TrustedRootCertificates
+WakeOnLan
+WindowCovering
+```
+
+### `zcl ? <Cluster>`
+
+List available commands in cluster. For example, for _Basic_ cluster:
+
+```
+chip-device-ctrl > zcl ? Basic
+InteractionModelVersion
+VendorName
+VendorID
+ProductName
+ProductID
+UserLabel
+Location
+HardwareVersion
+HardwareVersionString
+SoftwareVersion
+SoftwareVersionString
+ManufacturingDate
+PartNumber
+ProductURL
+ProductLabel
+SerialNumber
+LocalConfigDisabled
+ClusterRevision
+```
+
+### `zclread <Cluster> <Attribute> <NodeId> <EndpointId> <GroupId> [arguments]`
+
+Read the value of ZCL attribute. For example:
+
+```
+chip-device-ctrl > zclread Basic VendorName 1234 1 0
+```
+
+### `zclconfigure <Cluster> <Attribute> <Nodeid> <Endpoint> <MinInterval> <MaxInterval> <Change>`
+
+Configure ZCL attribute reporting settings. For example:
+
+```
+chip-device-ctrl > zclconfigure OccupancySensing Occupancy 1234 1 0 1000 2000 1
+```
diff --git a/cores/nRF5/nordic/config/nrf52840/config/crypto/hsm/nxp/README.md b/cores/nRF5/nordic/config/nrf52840/config/crypto/hsm/nxp/README.md
new file mode 100644
index 000000000..7684b9640
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/crypto/hsm/nxp/README.md
@@ -0,0 +1,33 @@
+# Using SE05X for crypto operations
+
+## Introduction
+
+CHIPCryptoPALHsm_SE05X.cpp file provides the integration of secure element
+(SE05x) in crypto layer of CHIP stack. By enabling the required directives in
+CHIPCryptoPALHsm_config.h header file, required crypto operations can be
+performed using SE05x. By default, the secure element is enabled only for PAKE
+(Verifier role) operations.
+
+Following table shows the operations supported by secure element.
+
++-------------------------+-----------+----------------+---------------------------------+------------+----------------------------+
+| Operation | Software | Default config | Note | Re-entrant | Directive to
+enabled in | | | fallback | value | | | CHIPCryptoPALHsm_config.h |
++-------------------------+-----------+----------------+---------------------------------+------------+----------------------------+
+| SPAKE Verifier | No | Enabled | - | No | ENABLE_HSM_SPAKE_VERIFIER |
++-------------------------+-----------+----------------+---------------------------------+------------+----------------------------+
+| SPAKE Prover | No | Enabled | - | No | ENABLE_HSM_SPAKE_PROVER |
++-------------------------+-----------+----------------+---------------------------------+------------+----------------------------+
+
+## Build
+
+-   Use the following gn build arguments to enable the secure element in crypto
+    layer,
+
+```
+smcom=\"t1oi2c\" chip_with_se05x=1
+```
+
+## Known Limitations:
+
+-   None
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lib/mdns/minimal/core/Constants.h b/cores/nRF5/nordic/config/nrf52840/config/lib/mdns/minimal/core/Constants.h
new file mode 100644
index 000000000..e081edf5e
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lib/mdns/minimal/core/Constants.h
@@ -0,0 +1,72 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+#pragma once
+
+#include <cstddef>
+#include <cstdint>
+
+namespace mdns {
+namespace Minimal {
+
+// Assigned by IANA: https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4
+enum class QType : uint16_t
+{
+    A         = 1,
+    NS        = 2,
+    CNAME     = 5,
+    SOA       = 6,
+    NULLVALUE = 10,
+    WKS       = 11,
+    PTR       = 12,
+    HINFO     = 13,
+    MINFO     = 14,
+    MX        = 15,
+    TXT       = 16,
+    ISDN      = 20,
+    AAAA      = 28,
+    SRV       = 33,
+    DNAM      = 39,
+    ANY       = 255,
+};
+
+/// Flag encoded in QCLASS requesting unicast answers
+constexpr uint16_t kQClassUnicastAnswerFlag = 0x8000;
+// Flag used to indicate receiver should flush cache rather than appending. Used for Response RR's.
+// See https://datatracker.ietf.org/doc/html/rfc6762#section-10.2.
+constexpr uint16_t kQClassResponseFlushBit = 0x8000;
+
+enum class QClass : uint16_t
+{
+    IN  = 1,
+    ANY = 255,
+
+    // Unicast version for the class
+    IN_UNICAST = IN | kQClassUnicastAnswerFlag,
+    IN_FLUSH   = IN | kQClassResponseFlushBit,
+};
+
+enum class ResourceType
+{
+    kAnswer,
+    kAuthority,
+    kAdditional,
+};
+
+constexpr size_t kMaxQNamePartLength = 255;
+
+} // namespace Minimal
+} // namespace mdns
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lib/support/logging/Constants.h b/cores/nRF5/nordic/config/nrf52840/config/lib/support/logging/Constants.h
new file mode 100644
index 000000000..c605e2fd9
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lib/support/logging/Constants.h
@@ -0,0 +1,129 @@
+/* See Project CHIP LICENSE file for licensing information. */
+
+#pragma once
+
+namespace chip {
+namespace Logging {
+
+/**
+ *  @enum LogModule
+ *
+ *  @brief
+ *    Identifies a logical section of code that is a source of log
+ *    messages.
+ *
+ *  @note If you add modules or rearrange this list you must update the
+ *        ModuleNames tables in ChipLogging.cpp.
+ *
+ */
+enum LogModule
+{
+    kLogModule_NotSpecified = 0,
+
+    kLogModule_Inet,
+    kLogModule_Ble,
+    kLogModule_MessageLayer,
+    kLogModule_SecurityManager,
+    kLogModule_ExchangeManager,
+    kLogModule_TLV,
+    kLogModule_ASN1,
+    kLogModule_Crypto,
+    kLogModule_Controller,
+    kLogModule_Alarm,
+    kLogModule_SecureChannel,
+    kLogModule_BDX,
+    kLogModule_DataManagement,
+    kLogModule_DeviceControl,
+    kLogModule_DeviceDescription,
+    kLogModule_Echo,
+    kLogModule_FabricProvisioning,
+    kLogModule_NetworkProvisioning,
+    kLogModule_ServiceDirectory,
+    kLogModule_ServiceProvisioning,
+    kLogModule_SoftwareUpdate,
+    kLogModule_TokenPairing,
+    kLogModule_TimeService,
+    kLogModule_Heartbeat,
+    kLogModule_chipSystemLayer,
+    kLogModule_EventLogging,
+    kLogModule_Support,
+    kLogModule_chipTool,
+    kLogModule_Zcl,
+    kLogModule_Shell,
+    kLogModule_DeviceLayer,
+    kLogModule_SetupPayload,
+    kLogModule_AppServer,
+    kLogModule_Discovery,
+
+    kLogModule_Max
+};
+
+/**
+ *  @enum LogCategory
+ *
+ *  @brief
+ *    Identifies a category to which an particular error message
+ *    belongs.
+ *
+ */
+enum LogCategory
+{
+    /*!<
+     *   This log category indicates, when passed to SetLogFilter(),
+     *   that no messages should be logged.
+     *
+     */
+    kLogCategory_None = 0,
+
+    /*!<
+     *   Indicates a category of log message that describes an unexpected
+     *   or severe failure.
+     *
+     *   This log category indicates that a logged message describes
+     *   an unexpected or severe failure in the code.
+     *
+     *   It should be used for things such as out-of-resource errors,
+     *   internal inconsistencies, API misuse, etc. In general, errors
+     *   that are expected to occur as part of normal operation, or
+     *   that are largely determined by external factors (e.g. network
+     *   errors, user/operator induced errors, etc.) should be logged
+     *   as kLogCategory_Progress messages, not as kLogCategory_Error
+     *   messages.
+     *
+     */
+    kLogCategory_Error = 1,
+
+    /*!<
+     *   Indicates a category of log message that describes an event
+     *   that marks the start or end of a major activity, or a major
+     *   change in the state of the overall system.
+     *
+     *   It should be reserved for high-level events. Such messages
+     *   should provide the log reader with a good sense of the
+     *   overall activity of the system at any point in time, while
+     *   being minimally verbose. Where necessary such messages should
+     *   include identifiers or other values that can be used to
+     *   correlate messages involving a common actor or subject
+     *   (e.g. connection ids, request ids, etc.) and/or to identify
+     *   types of actions being taken or handled (e.g.  message types,
+     *   requested resource types, error numbers, etc.).
+     *
+     */
+    kLogCategory_Progress = 2,
+
+    /*!<
+     *   Indicates a category of log message that describes detailed
+     *   information about an event or the state of the system.
+     *
+     *   Such messages can be used to provide ancillary information
+     *   not suitable for the kLogCategory_Error and
+     *   kLogCategory_Progress categories.
+     *
+     */
+    kLogCategory_Detail = 3,
+
+    kLogCategory_Max = kLogCategory_Detail
+};
+
+} // namespace Logging
+} // namespace chip
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/api.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/api.h
new file mode 100644
index 000000000..516bd163d
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/api.h
@@ -0,0 +1,400 @@
+/**
+ * @file
+ * netconn API (to be used from non-TCPIP threads)
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_API_H
+#define LWIP_HDR_API_H
+
+#include "lwip/opt.h"
+
+#if LWIP_NETCONN || LWIP_SOCKET /* don't build if not configured for use in lwipopts.h */
+/* Note: Netconn API is always available when sockets are enabled -
+ * sockets are implemented on top of them */
+
+#include "lwip/arch.h"
+#include "lwip/netbuf.h"
+#include "lwip/sys.h"
+#include "lwip/ip_addr.h"
+#include "lwip/err.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Throughout this file, IP addresses and port numbers are expected to be in
+ * the same byte order as in the corresponding pcb.
+ */
+
+/* Flags for netconn_write (u8_t) */
+#define NETCONN_NOFLAG    0x00
+#define NETCONN_NOCOPY    0x00 /* Only for source code compatibility */
+#define NETCONN_COPY      0x01
+#define NETCONN_MORE      0x02
+#define NETCONN_DONTBLOCK 0x04
+
+/* Flags for struct netconn.flags (u8_t) */
+/** Should this netconn avoid blocking? */
+#define NETCONN_FLAG_NON_BLOCKING             0x02
+/** Was the last connect action a non-blocking one? */
+#define NETCONN_FLAG_IN_NONBLOCKING_CONNECT   0x04
+/** If a nonblocking write has been rejected before, poll_tcp needs to
+    check if the netconn is writable again */
+#define NETCONN_FLAG_CHECK_WRITESPACE         0x10
+#if LWIP_IPV6
+/** If this flag is set then only IPv6 communication is allowed on the
+    netconn. As per RFC#3493 this features defaults to OFF allowing
+    dual-stack usage by default. */
+#define NETCONN_FLAG_IPV6_V6ONLY              0x20
+#endif /* LWIP_IPV6 */
+
+
+/* Helpers to process several netconn_types by the same code */
+#define NETCONNTYPE_GROUP(t)         ((t)&0xF0)
+#define NETCONNTYPE_DATAGRAM(t)      ((t)&0xE0)
+#if LWIP_IPV6
+#define NETCONN_TYPE_IPV6            0x08
+#define NETCONNTYPE_ISIPV6(t)        (((t)&NETCONN_TYPE_IPV6) != 0)
+#define NETCONNTYPE_ISUDPLITE(t)     (((t)&0xF3) == NETCONN_UDPLITE)
+#define NETCONNTYPE_ISUDPNOCHKSUM(t) (((t)&0xF3) == NETCONN_UDPNOCHKSUM)
+#else /* LWIP_IPV6 */
+#define NETCONNTYPE_ISIPV6(t)        (0)
+#define NETCONNTYPE_ISUDPLITE(t)     ((t) == NETCONN_UDPLITE)
+#define NETCONNTYPE_ISUDPNOCHKSUM(t) ((t) == NETCONN_UDPNOCHKSUM)
+#endif /* LWIP_IPV6 */
+
+/** @ingroup netconn_common
+ * Protocol family and type of the netconn
+ */
+enum netconn_type {
+  NETCONN_INVALID     = 0,
+  /** TCP IPv4 */
+  NETCONN_TCP         = 0x10,
+#if LWIP_IPV6
+  /** TCP IPv6 */
+  NETCONN_TCP_IPV6    = NETCONN_TCP | NETCONN_TYPE_IPV6 /* 0x18 */,
+#endif /* LWIP_IPV6 */
+  /** UDP IPv4 */
+  NETCONN_UDP         = 0x20,
+  /** UDP IPv4 lite */
+  NETCONN_UDPLITE     = 0x21,
+  /** UDP IPv4 no checksum */
+  NETCONN_UDPNOCHKSUM = 0x22,
+
+#if LWIP_IPV6
+  /** UDP IPv6 (dual-stack by default, unless you call @ref netconn_set_ipv6only) */
+  NETCONN_UDP_IPV6         = NETCONN_UDP | NETCONN_TYPE_IPV6 /* 0x28 */,
+  /** UDP IPv6 lite (dual-stack by default, unless you call @ref netconn_set_ipv6only) */
+  NETCONN_UDPLITE_IPV6     = NETCONN_UDPLITE | NETCONN_TYPE_IPV6 /* 0x29 */,
+  /** UDP IPv6 no checksum (dual-stack by default, unless you call @ref netconn_set_ipv6only) */
+  NETCONN_UDPNOCHKSUM_IPV6 = NETCONN_UDPNOCHKSUM | NETCONN_TYPE_IPV6 /* 0x2a */,
+#endif /* LWIP_IPV6 */
+
+  /** Raw connection IPv4 */
+  NETCONN_RAW         = 0x40
+#if LWIP_IPV6
+  /** Raw connection IPv6 (dual-stack by default, unless you call @ref netconn_set_ipv6only) */
+  , NETCONN_RAW_IPV6    = NETCONN_RAW | NETCONN_TYPE_IPV6 /* 0x48 */
+#endif /* LWIP_IPV6 */
+};
+
+/** Current state of the netconn. Non-TCP netconns are always
+ * in state NETCONN_NONE! */
+enum netconn_state {
+  NETCONN_NONE,
+  NETCONN_WRITE,
+  NETCONN_LISTEN,
+  NETCONN_CONNECT,
+  NETCONN_CLOSE
+};
+
+/** Used to inform the callback function about changes
+ * 
+ * Event explanation:
+ * 
+ * In the netconn implementation, there are three ways to block a client:
+ * 
+ * - accept mbox (sys_arch_mbox_fetch(&conn->acceptmbox, &accept_ptr, 0); in netconn_accept())
+ * - receive mbox (sys_arch_mbox_fetch(&conn->recvmbox, &buf, 0); in netconn_recv_data())
+ * - send queue is full (sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0); in lwip_netconn_do_write())
+ * 
+ * The events have to be seen as events signaling the state of these mboxes/semaphores. For non-blocking
+ * connections, you need to know in advance whether a call to a netconn function call would block or not,
+ * and these events tell you about that.
+ * 
+ * RCVPLUS events say: Safe to perform a potentially blocking call call once more. 
+ * They are counted in sockets - three RCVPLUS events for accept mbox means you are safe
+ * to call netconn_accept 3 times without being blocked.
+ * Same thing for receive mbox.
+ * 
+ * RCVMINUS events say: Your call to to a possibly blocking function is "acknowledged".
+ * Socket implementation decrements the counter.
+ * 
+ * For TX, there is no need to count, its merely a flag. SENDPLUS means you may send something.
+ * SENDPLUS occurs when enough data was delivered to peer so netconn_send() can be called again.
+ * A SENDMINUS event occurs when the next call to a netconn_send() would be blocking.
+ */
+enum netconn_evt {
+  NETCONN_EVT_RCVPLUS,
+  NETCONN_EVT_RCVMINUS,
+  NETCONN_EVT_SENDPLUS,
+  NETCONN_EVT_SENDMINUS,
+  NETCONN_EVT_ERROR
+};
+
+#if LWIP_IGMP || (LWIP_IPV6 && LWIP_IPV6_MLD)
+/** Used for netconn_join_leave_group() */
+enum netconn_igmp {
+  NETCONN_JOIN,
+  NETCONN_LEAVE
+};
+#endif /* LWIP_IGMP || (LWIP_IPV6 && LWIP_IPV6_MLD) */
+
+#if LWIP_DNS
+/* Used for netconn_gethostbyname_addrtype(), these should match the DNS_ADDRTYPE defines in dns.h */
+#define NETCONN_DNS_DEFAULT   NETCONN_DNS_IPV4_IPV6
+#define NETCONN_DNS_IPV4      0
+#define NETCONN_DNS_IPV6      1
+#define NETCONN_DNS_IPV4_IPV6 2 /* try to resolve IPv4 first, try IPv6 if IPv4 fails only */
+#define NETCONN_DNS_IPV6_IPV4 3 /* try to resolve IPv6 first, try IPv4 if IPv6 fails only */
+#endif /* LWIP_DNS */
+
+/* forward-declare some structs to avoid to include their headers */
+struct ip_pcb;
+struct tcp_pcb;
+struct udp_pcb;
+struct raw_pcb;
+struct netconn;
+struct api_msg;
+
+/** A callback prototype to inform about events for a netconn */
+typedef void (* netconn_callback)(struct netconn *, enum netconn_evt, u16_t len);
+
+/** A netconn descriptor */
+struct netconn {
+  /** type of the netconn (TCP, UDP or RAW) */
+  enum netconn_type type;
+  /** current state of the netconn */
+  enum netconn_state state;
+  /** the lwIP internal protocol control block */
+  union {
+    struct ip_pcb  *ip;
+    struct tcp_pcb *tcp;
+    struct udp_pcb *udp;
+    struct raw_pcb *raw;
+  } pcb;
+  /** the last error this netconn had */
+  err_t last_err;
+#if !LWIP_NETCONN_SEM_PER_THREAD
+  /** sem that is used to synchronously execute functions in the core context */
+  sys_sem_t op_completed;
+#endif
+  /** mbox where received packets are stored until they are fetched
+      by the netconn application thread (can grow quite big) */
+  sys_mbox_t recvmbox;
+#if LWIP_TCP
+  /** mbox where new connections are stored until processed
+      by the application thread */
+  sys_mbox_t acceptmbox;
+#endif /* LWIP_TCP */
+  /** only used for socket layer */
+#if LWIP_SOCKET
+  int socket;
+#endif /* LWIP_SOCKET */
+#if LWIP_SO_SNDTIMEO
+  /** timeout to wait for sending data (which means enqueueing data for sending
+      in internal buffers) in milliseconds */
+  s32_t send_timeout;
+#endif /* LWIP_SO_RCVTIMEO */
+#if LWIP_SO_RCVTIMEO
+  /** timeout in milliseconds to wait for new data to be received
+      (or connections to arrive for listening netconns) */
+  int recv_timeout;
+#endif /* LWIP_SO_RCVTIMEO */
+#if LWIP_SO_RCVBUF
+  /** maximum amount of bytes queued in recvmbox
+      not used for TCP: adjust TCP_WND instead! */
+  int recv_bufsize;
+  /** number of bytes currently in recvmbox to be received,
+      tested against recv_bufsize to limit bytes on recvmbox
+      for UDP and RAW, used for FIONREAD */
+  int recv_avail;
+#endif /* LWIP_SO_RCVBUF */
+#if LWIP_SO_LINGER
+   /** values <0 mean linger is disabled, values > 0 are seconds to linger */
+  s16_t linger;
+#endif /* LWIP_SO_LINGER */
+  /** flags holding more netconn-internal state, see NETCONN_FLAG_* defines */
+  u8_t flags;
+#if LWIP_TCP
+  /** TCP: when data passed to netconn_write doesn't fit into the send buffer,
+      this temporarily stores how much is already sent. */
+  size_t write_offset;
+  /** TCP: when data passed to netconn_write doesn't fit into the send buffer,
+      this temporarily stores the message.
+      Also used during connect and close. */
+  struct api_msg *current_msg;
+#endif /* LWIP_TCP */
+  /** A callback function that is informed about events for this netconn */
+  netconn_callback callback;
+};
+
+/** Register an Network connection event */
+#define API_EVENT(c,e,l) if (c->callback) {         \
+                           (*c->callback)(c, e, l); \
+                         }
+
+/** Set conn->last_err to err but don't overwrite fatal errors */
+#define NETCONN_SET_SAFE_ERR(conn, err) do { if ((conn) != NULL) { \
+  SYS_ARCH_DECL_PROTECT(netconn_set_safe_err_lev); \
+  SYS_ARCH_PROTECT(netconn_set_safe_err_lev); \
+  if (!ERR_IS_FATAL((conn)->last_err)) { \
+    (conn)->last_err = err; \
+  } \
+  SYS_ARCH_UNPROTECT(netconn_set_safe_err_lev); \
+}} while(0);
+
+/* Network connection functions: */
+
+/** @ingroup netconn_common
+ * Create new netconn connection
+ * @param t @ref netconn_type */
+#define netconn_new(t)                  netconn_new_with_proto_and_callback(t, 0, NULL)
+#define netconn_new_with_callback(t, c) netconn_new_with_proto_and_callback(t, 0, c)
+struct netconn *netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto,
+                                             netconn_callback callback);
+err_t   netconn_delete(struct netconn *conn);
+/** Get the type of a netconn (as enum netconn_type). */
+#define netconn_type(conn) (conn->type)
+
+err_t   netconn_getaddr(struct netconn *conn, ip_addr_t *addr,
+                        u16_t *port, u8_t local);
+/** @ingroup netconn_common */
+#define netconn_peer(c,i,p) netconn_getaddr(c,i,p,0)
+/** @ingroup netconn_common */
+#define netconn_addr(c,i,p) netconn_getaddr(c,i,p,1)
+
+err_t   netconn_bind(struct netconn *conn, const ip_addr_t *addr, u16_t port);
+err_t   netconn_connect(struct netconn *conn, const ip_addr_t *addr, u16_t port);
+err_t   netconn_disconnect (struct netconn *conn);
+err_t   netconn_listen_with_backlog(struct netconn *conn, u8_t backlog);
+/** @ingroup netconn_tcp */
+#define netconn_listen(conn) netconn_listen_with_backlog(conn, TCP_DEFAULT_LISTEN_BACKLOG)
+err_t   netconn_accept(struct netconn *conn, struct netconn **new_conn);
+err_t   netconn_recv(struct netconn *conn, struct netbuf **new_buf);
+err_t   netconn_recv_tcp_pbuf(struct netconn *conn, struct pbuf **new_buf);
+err_t   netconn_sendto(struct netconn *conn, struct netbuf *buf,
+                             const ip_addr_t *addr, u16_t port);
+err_t   netconn_send(struct netconn *conn, struct netbuf *buf);
+err_t   netconn_write_partly(struct netconn *conn, const void *dataptr, size_t size,
+                             u8_t apiflags, size_t *bytes_written);
+/** @ingroup netconn_tcp */
+#define netconn_write(conn, dataptr, size, apiflags) \
+          netconn_write_partly(conn, dataptr, size, apiflags, NULL)
+err_t   netconn_close(struct netconn *conn);
+err_t   netconn_shutdown(struct netconn *conn, u8_t shut_rx, u8_t shut_tx);
+
+#if LWIP_IGMP || (LWIP_IPV6 && LWIP_IPV6_MLD)
+err_t   netconn_join_leave_group(struct netconn *conn, const ip_addr_t *multiaddr,
+                             const ip_addr_t *netif_addr, enum netconn_igmp join_or_leave);
+#endif /* LWIP_IGMP || (LWIP_IPV6 && LWIP_IPV6_MLD) */
+#if LWIP_DNS
+#if LWIP_IPV4 && LWIP_IPV6
+err_t   netconn_gethostbyname_addrtype(const char *name, ip_addr_t *addr, u8_t dns_addrtype);
+#define netconn_gethostbyname(name, addr) netconn_gethostbyname_addrtype(name, addr, NETCONN_DNS_DEFAULT)
+#else /* LWIP_IPV4 && LWIP_IPV6 */
+err_t   netconn_gethostbyname(const char *name, ip_addr_t *addr);
+#define netconn_gethostbyname_addrtype(name, addr, dns_addrtype) netconn_gethostbyname(name, addr)
+#endif /* LWIP_IPV4 && LWIP_IPV6 */
+#endif /* LWIP_DNS */
+
+#define netconn_err(conn)               ((conn)->last_err)
+#define netconn_recv_bufsize(conn)      ((conn)->recv_bufsize)
+
+/** Set the blocking status of netconn calls (@todo: write/send is missing) */
+#define netconn_set_nonblocking(conn, val)  do { if(val) { \
+  (conn)->flags |= NETCONN_FLAG_NON_BLOCKING; \
+} else { \
+  (conn)->flags &= ~ NETCONN_FLAG_NON_BLOCKING; }} while(0)
+/** Get the blocking status of netconn calls (@todo: write/send is missing) */
+#define netconn_is_nonblocking(conn)        (((conn)->flags & NETCONN_FLAG_NON_BLOCKING) != 0)
+
+#if LWIP_IPV6
+/** @ingroup netconn_common
+ * TCP: Set the IPv6 ONLY status of netconn calls (see NETCONN_FLAG_IPV6_V6ONLY)
+ */
+#define netconn_set_ipv6only(conn, val)  do { if(val) { \
+  (conn)->flags |= NETCONN_FLAG_IPV6_V6ONLY; \
+} else { \
+  (conn)->flags &= ~ NETCONN_FLAG_IPV6_V6ONLY; }} while(0)
+/** @ingroup netconn_common
+ * TCP: Get the IPv6 ONLY status of netconn calls (see NETCONN_FLAG_IPV6_V6ONLY)
+ */
+#define netconn_get_ipv6only(conn)        (((conn)->flags & NETCONN_FLAG_IPV6_V6ONLY) != 0)
+#endif /* LWIP_IPV6 */
+
+#if LWIP_SO_SNDTIMEO
+/** Set the send timeout in milliseconds */
+#define netconn_set_sendtimeout(conn, timeout)      ((conn)->send_timeout = (timeout))
+/** Get the send timeout in milliseconds */
+#define netconn_get_sendtimeout(conn)               ((conn)->send_timeout)
+#endif /* LWIP_SO_SNDTIMEO */
+#if LWIP_SO_RCVTIMEO
+/** Set the receive timeout in milliseconds */
+#define netconn_set_recvtimeout(conn, timeout)      ((conn)->recv_timeout = (timeout))
+/** Get the receive timeout in milliseconds */
+#define netconn_get_recvtimeout(conn)               ((conn)->recv_timeout)
+#endif /* LWIP_SO_RCVTIMEO */
+#if LWIP_SO_RCVBUF
+/** Set the receive buffer in bytes */
+#define netconn_set_recvbufsize(conn, recvbufsize)  ((conn)->recv_bufsize = (recvbufsize))
+/** Get the receive buffer in bytes */
+#define netconn_get_recvbufsize(conn)               ((conn)->recv_bufsize)
+#endif /* LWIP_SO_RCVBUF*/
+
+#if LWIP_NETCONN_SEM_PER_THREAD
+void netconn_thread_init(void);
+void netconn_thread_cleanup(void);
+#else /* LWIP_NETCONN_SEM_PER_THREAD */
+#define netconn_thread_init()
+#define netconn_thread_cleanup()
+#endif /* LWIP_NETCONN_SEM_PER_THREAD */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_NETCONN || LWIP_SOCKET */
+
+#endif /* LWIP_HDR_API_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/FILES b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/FILES
new file mode 100644
index 000000000..adfc0f334
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/FILES
@@ -0,0 +1,2 @@
+This directory contains application headers.
+Every application shall provide one api file APP.h and optionally one options file APP_opts.h
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/fs.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/fs.h
new file mode 100644
index 000000000..bb176fa01
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/fs.h
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_APPS_FS_H
+#define LWIP_HDR_APPS_FS_H
+
+#include "httpd_opts.h"
+#include "lwip/err.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define FS_READ_EOF     -1
+#define FS_READ_DELAYED -2
+
+#if HTTPD_PRECALCULATED_CHECKSUM
+struct fsdata_chksum {
+  u32_t offset;
+  u16_t chksum;
+  u16_t len;
+};
+#endif /* HTTPD_PRECALCULATED_CHECKSUM */
+
+#define FS_FILE_FLAGS_HEADER_INCLUDED     0x01
+#define FS_FILE_FLAGS_HEADER_PERSISTENT   0x02
+
+struct fs_file {
+  const char *data;
+  int len;
+  int index;
+  void *pextension;
+#if HTTPD_PRECALCULATED_CHECKSUM
+  const struct fsdata_chksum *chksum;
+  u16_t chksum_count;
+#endif /* HTTPD_PRECALCULATED_CHECKSUM */
+  u8_t flags;
+#if LWIP_HTTPD_CUSTOM_FILES
+  u8_t is_custom_file;
+#endif /* LWIP_HTTPD_CUSTOM_FILES */
+#if LWIP_HTTPD_FILE_STATE
+  void *state;
+#endif /* LWIP_HTTPD_FILE_STATE */
+};
+
+#if LWIP_HTTPD_FS_ASYNC_READ
+typedef void (*fs_wait_cb)(void *arg);
+#endif /* LWIP_HTTPD_FS_ASYNC_READ */
+
+err_t fs_open(struct fs_file *file, const char *name);
+void fs_close(struct fs_file *file);
+#if LWIP_HTTPD_DYNAMIC_FILE_READ
+#if LWIP_HTTPD_FS_ASYNC_READ
+int fs_read_async(struct fs_file *file, char *buffer, int count, fs_wait_cb callback_fn, void *callback_arg);
+#else /* LWIP_HTTPD_FS_ASYNC_READ */
+int fs_read(struct fs_file *file, char *buffer, int count);
+#endif /* LWIP_HTTPD_FS_ASYNC_READ */
+#endif /* LWIP_HTTPD_DYNAMIC_FILE_READ */
+#if LWIP_HTTPD_FS_ASYNC_READ
+int fs_is_file_ready(struct fs_file *file, fs_wait_cb callback_fn, void *callback_arg);
+#endif /* LWIP_HTTPD_FS_ASYNC_READ */
+int fs_bytes_left(struct fs_file *file);
+
+#if LWIP_HTTPD_FILE_STATE
+/** This user-defined function is called when a file is opened. */
+void *fs_state_init(struct fs_file *file, const char *name);
+/** This user-defined function is called when a file is closed. */
+void fs_state_free(struct fs_file *file, void *state);
+#endif /* #if LWIP_HTTPD_FILE_STATE */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_APPS_FS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/httpd.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/httpd.h
new file mode 100644
index 000000000..40f1811e5
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/httpd.h
@@ -0,0 +1,236 @@
+/**
+ * @file
+ * HTTP server
+ */
+
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ * This version of the file has been modified by Texas Instruments to offer
+ * simple server-side-include (SSI) and Common Gateway Interface (CGI)
+ * capability.
+ */
+
+#ifndef LWIP_HDR_APPS_HTTPD_H
+#define LWIP_HDR_APPS_HTTPD_H
+
+#include "httpd_opts.h"
+#include "lwip/err.h"
+#include "lwip/pbuf.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_HTTPD_CGI
+
+/*
+ * Function pointer for a CGI script handler.
+ *
+ * This function is called each time the HTTPD server is asked for a file
+ * whose name was previously registered as a CGI function using a call to
+ * http_set_cgi_handler. The iIndex parameter provides the index of the
+ * CGI within the ppcURLs array passed to http_set_cgi_handler. Parameters
+ * pcParam and pcValue provide access to the parameters provided along with
+ * the URI. iNumParams provides a count of the entries in the pcParam and
+ * pcValue arrays. Each entry in the pcParam array contains the name of a
+ * parameter with the corresponding entry in the pcValue array containing the
+ * value for that parameter. Note that pcParam may contain multiple elements
+ * with the same name if, for example, a multi-selection list control is used
+ * in the form generating the data.
+ *
+ * The function should return a pointer to a character string which is the
+ * path and filename of the response that is to be sent to the connected
+ * browser, for example "/thanks.htm" or "/response/error.ssi".
+ *
+ * The maximum number of parameters that will be passed to this function via
+ * iNumParams is defined by LWIP_HTTPD_MAX_CGI_PARAMETERS. Any parameters in the incoming
+ * HTTP request above this number will be discarded.
+ *
+ * Requests intended for use by this CGI mechanism must be sent using the GET
+ * method (which encodes all parameters within the URI rather than in a block
+ * later in the request). Attempts to use the POST method will result in the
+ * request being ignored.
+ *
+ */
+typedef const char *(*tCGIHandler)(int iIndex, int iNumParams, char *pcParam[],
+                             char *pcValue[]);
+
+/*
+ * Structure defining the base filename (URL) of a CGI and the associated
+ * function which is to be called when that URL is requested.
+ */
+typedef struct
+{
+    const char *pcCGIName;
+    tCGIHandler pfnCGIHandler;
+} tCGI;
+
+void http_set_cgi_handlers(const tCGI *pCGIs, int iNumHandlers);
+
+#endif /* LWIP_HTTPD_CGI */
+
+#if LWIP_HTTPD_CGI || LWIP_HTTPD_CGI_SSI
+
+#if LWIP_HTTPD_CGI_SSI
+/** Define this generic CGI handler in your application.
+ * It is called once for every URI with parameters.
+ * The parameters can be stored to 
+ */
+extern void httpd_cgi_handler(const char* uri, int iNumParams, char **pcParam, char **pcValue
+#if defined(LWIP_HTTPD_FILE_STATE) && LWIP_HTTPD_FILE_STATE
+                                     , void *connection_state
+#endif /* LWIP_HTTPD_FILE_STATE */
+                                     );
+#endif /* LWIP_HTTPD_CGI_SSI */
+
+#endif /* LWIP_HTTPD_CGI || LWIP_HTTPD_CGI_SSI */
+
+#if LWIP_HTTPD_SSI
+
+/*
+ * Function pointer for the SSI tag handler callback.
+ *
+ * This function will be called each time the HTTPD server detects a tag of the
+ * form <!--#name--> in a .shtml, .ssi or .shtm file where "name" appears as
+ * one of the tags supplied to http_set_ssi_handler in the ppcTags array.  The
+ * returned insert string, which will be appended after the the string
+ * "<!--#name-->" in file sent back to the client,should be written to pointer
+ * pcInsert.  iInsertLen contains the size of the buffer pointed to by
+ * pcInsert.  The iIndex parameter provides the zero-based index of the tag as
+ * found in the ppcTags array and identifies the tag that is to be processed.
+ *
+ * The handler returns the number of characters written to pcInsert excluding
+ * any terminating NULL or a negative number to indicate a failure (tag not
+ * recognized, for example).
+ *
+ * Note that the behavior of this SSI mechanism is somewhat different from the
+ * "normal" SSI processing as found in, for example, the Apache web server.  In
+ * this case, the inserted text is appended following the SSI tag rather than
+ * replacing the tag entirely.  This allows for an implementation that does not
+ * require significant additional buffering of output data yet which will still
+ * offer usable SSI functionality.  One downside to this approach is when
+ * attempting to use SSI within JavaScript.  The SSI tag is structured to
+ * resemble an HTML comment but this syntax does not constitute a comment
+ * within JavaScript and, hence, leaving the tag in place will result in
+ * problems in these cases.  To work around this, any SSI tag which needs to
+ * output JavaScript code must do so in an encapsulated way, sending the whole
+ * HTML <script>...</script> section as a single include.
+ */
+typedef u16_t (*tSSIHandler)(
+#if LWIP_HTTPD_SSI_RAW
+                             const char* ssi_tag_name,
+#else /* LWIP_HTTPD_SSI_RAW */
+                             int iIndex,
+#endif /* LWIP_HTTPD_SSI_RAW */
+                             char *pcInsert, int iInsertLen
+#if LWIP_HTTPD_SSI_MULTIPART
+                             , u16_t current_tag_part, u16_t *next_tag_part
+#endif /* LWIP_HTTPD_SSI_MULTIPART */
+#if defined(LWIP_HTTPD_FILE_STATE) && LWIP_HTTPD_FILE_STATE
+                             , void *connection_state
+#endif /* LWIP_HTTPD_FILE_STATE */
+                             );
+
+/** Set the SSI handler function
+ * (if LWIP_HTTPD_SSI_RAW==1, only the first argument is used)
+ */
+void http_set_ssi_handler(tSSIHandler pfnSSIHandler,
+                          const char **ppcTags, int iNumTags);
+
+/** For LWIP_HTTPD_SSI_RAW==1, return this to indicate the tag is unknown.
+ * In this case, the webserver writes a warning into the page.
+ * You can also just return 0 to write nothing for unknown tags.
+ */
+#define HTTPD_SSI_TAG_UNKNOWN 0xFFFF
+
+#endif /* LWIP_HTTPD_SSI */
+
+#if LWIP_HTTPD_SUPPORT_POST
+
+/* These functions must be implemented by the application */
+
+/** Called when a POST request has been received. The application can decide
+ * whether to accept it or not.
+ *
+ * @param connection Unique connection identifier, valid until httpd_post_end
+ *        is called.
+ * @param uri The HTTP header URI receiving the POST request.
+ * @param http_request The raw HTTP request (the first packet, normally).
+ * @param http_request_len Size of 'http_request'.
+ * @param content_len Content-Length from HTTP header.
+ * @param response_uri Filename of response file, to be filled when denying the
+ *        request
+ * @param response_uri_len Size of the 'response_uri' buffer.
+ * @param post_auto_wnd Set this to 0 to let the callback code handle window
+ *        updates by calling 'httpd_post_data_recved' (to throttle rx speed)
+ *        default is 1 (httpd handles window updates automatically)
+ * @return ERR_OK: Accept the POST request, data may be passed in
+ *         another err_t: Deny the POST request, send back 'bad request'.
+ */
+err_t httpd_post_begin(void *connection, const char *uri, const char *http_request,
+                       u16_t http_request_len, int content_len, char *response_uri,
+                       u16_t response_uri_len, u8_t *post_auto_wnd);
+
+/** Called for each pbuf of data that has been received for a POST.
+ * ATTENTION: The application is responsible for freeing the pbufs passed in!
+ *
+ * @param connection Unique connection identifier.
+ * @param p Received data.
+ * @return ERR_OK: Data accepted.
+ *         another err_t: Data denied, http_post_get_response_uri will be called.
+ */
+err_t httpd_post_receive_data(void *connection, struct pbuf *p);
+
+/** Called when all data is received or when the connection is closed.
+ * The application must return the filename/URI of a file to send in response
+ * to this POST request. If the response_uri buffer is untouched, a 404
+ * response is returned.
+ *
+ * @param connection Unique connection identifier.
+ * @param response_uri Filename of response file, to be filled when denying the request
+ * @param response_uri_len Size of the 'response_uri' buffer.
+ */
+void httpd_post_finished(void *connection, char *response_uri, u16_t response_uri_len);
+
+#if LWIP_HTTPD_POST_MANUAL_WND
+void httpd_post_data_recved(void *connection, u16_t recved_len);
+#endif /* LWIP_HTTPD_POST_MANUAL_WND */
+
+#endif /* LWIP_HTTPD_SUPPORT_POST */
+
+void httpd_init(void);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HTTPD_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/httpd_opts.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/httpd_opts.h
new file mode 100644
index 000000000..340db15f6
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/httpd_opts.h
@@ -0,0 +1,323 @@
+/**
+ * @file
+ * HTTP server options list
+ */
+
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ * This version of the file has been modified by Texas Instruments to offer
+ * simple server-side-include (SSI) and Common Gateway Interface (CGI)
+ * capability.
+ */
+
+#ifndef LWIP_HDR_APPS_HTTPD_OPTS_H
+#define LWIP_HDR_APPS_HTTPD_OPTS_H
+
+#include "lwip/opt.h"
+
+/**
+ * @defgroup httpd_opts Options
+ * @ingroup httpd
+ * @{
+ */
+
+/** Set this to 1 to support CGI (old style) */
+#if !defined LWIP_HTTPD_CGI || defined __DOXYGEN__
+#define LWIP_HTTPD_CGI            0
+#endif
+
+/** Set this to 1 to support CGI (new style) */
+#if !defined LWIP_HTTPD_CGI_SSI || defined __DOXYGEN__
+#define LWIP_HTTPD_CGI_SSI        0
+#endif
+
+/** Set this to 1 to support SSI (Server-Side-Includes) */
+#if !defined LWIP_HTTPD_SSI || defined __DOXYGEN__
+#define LWIP_HTTPD_SSI            0
+#endif
+
+/** Set this to 1 to implement an SSI tag handler callback that gets a const char*
+ * to the tag (instead of an index into a pre-registered array of known tags) */
+#if !defined LWIP_HTTPD_SSI_RAW || defined __DOXYGEN__
+#define LWIP_HTTPD_SSI_RAW        0
+#endif
+
+/** Set this to 1 to support HTTP POST */
+#if !defined LWIP_HTTPD_SUPPORT_POST || defined __DOXYGEN__
+#define LWIP_HTTPD_SUPPORT_POST   0
+#endif
+
+/* The maximum number of parameters that the CGI handler can be sent. */
+#if !defined LWIP_HTTPD_MAX_CGI_PARAMETERS || defined __DOXYGEN__
+#define LWIP_HTTPD_MAX_CGI_PARAMETERS 16
+#endif
+
+/** LWIP_HTTPD_SSI_MULTIPART==1: SSI handler function is called with 2 more
+ * arguments indicating a counter for insert string that are too long to be
+ * inserted at once: the SSI handler function must then set 'next_tag_part'
+ * which will be passed back to it in the next call. */
+#if !defined LWIP_HTTPD_SSI_MULTIPART || defined __DOXYGEN__
+#define LWIP_HTTPD_SSI_MULTIPART    0
+#endif
+
+/* The maximum length of the string comprising the tag name */
+#if !defined LWIP_HTTPD_MAX_TAG_NAME_LEN || defined __DOXYGEN__
+#define LWIP_HTTPD_MAX_TAG_NAME_LEN 8
+#endif
+
+/* The maximum length of string that can be returned to replace any given tag */
+#if !defined LWIP_HTTPD_MAX_TAG_INSERT_LEN || defined __DOXYGEN__
+#define LWIP_HTTPD_MAX_TAG_INSERT_LEN 192
+#endif
+
+#if !defined LWIP_HTTPD_POST_MANUAL_WND || defined __DOXYGEN__
+#define LWIP_HTTPD_POST_MANUAL_WND  0
+#endif
+
+/** This string is passed in the HTTP header as "Server: " */
+#if !defined HTTPD_SERVER_AGENT || defined __DOXYGEN__
+#define HTTPD_SERVER_AGENT "lwIP/" LWIP_VERSION_STRING " (http://savannah.nongnu.org/projects/lwip)"
+#endif
+
+/** Set this to 1 if you want to include code that creates HTTP headers
+ * at runtime. Default is off: HTTP headers are then created statically
+ * by the makefsdata tool. Static headers mean smaller code size, but
+ * the (readonly) fsdata will grow a bit as every file includes the HTTP
+ * header. */
+#if !defined LWIP_HTTPD_DYNAMIC_HEADERS || defined __DOXYGEN__
+#define LWIP_HTTPD_DYNAMIC_HEADERS 0
+#endif
+
+#if !defined HTTPD_DEBUG || defined __DOXYGEN__
+#define HTTPD_DEBUG         LWIP_DBG_OFF
+#endif
+
+/** Set this to 1 to use a memp pool for allocating 
+ * struct http_state instead of the heap.
+ */
+#if !defined HTTPD_USE_MEM_POOL || defined __DOXYGEN__
+#define HTTPD_USE_MEM_POOL  0
+#endif
+
+/** The server port for HTTPD to use */
+#if !defined HTTPD_SERVER_PORT || defined __DOXYGEN__
+#define HTTPD_SERVER_PORT                   80
+#endif
+
+/** Maximum retries before the connection is aborted/closed.
+ * - number of times pcb->poll is called -> default is 4*500ms = 2s;
+ * - reset when pcb->sent is called
+ */
+#if !defined HTTPD_MAX_RETRIES || defined __DOXYGEN__
+#define HTTPD_MAX_RETRIES                   4
+#endif
+
+/** The poll delay is X*500ms */
+#if !defined HTTPD_POLL_INTERVAL || defined __DOXYGEN__
+#define HTTPD_POLL_INTERVAL                 4
+#endif
+
+/** Priority for tcp pcbs created by HTTPD (very low by default).
+ *  Lower priorities get killed first when running out of memory.
+ */
+#if !defined HTTPD_TCP_PRIO || defined __DOXYGEN__
+#define HTTPD_TCP_PRIO                      TCP_PRIO_MIN
+#endif
+
+/** Set this to 1 to enable timing each file sent */
+#if !defined LWIP_HTTPD_TIMING || defined __DOXYGEN__
+#define LWIP_HTTPD_TIMING                   0
+#endif
+/** Set this to 1 to enable timing each file sent */
+#if !defined HTTPD_DEBUG_TIMING || defined __DOXYGEN__
+#define HTTPD_DEBUG_TIMING                  LWIP_DBG_OFF
+#endif
+
+/** Set this to one to show error pages when parsing a request fails instead
+    of simply closing the connection. */
+#if !defined LWIP_HTTPD_SUPPORT_EXTSTATUS || defined __DOXYGEN__
+#define LWIP_HTTPD_SUPPORT_EXTSTATUS        0
+#endif
+
+/** Set this to 0 to drop support for HTTP/0.9 clients (to save some bytes) */
+#if !defined LWIP_HTTPD_SUPPORT_V09 || defined __DOXYGEN__
+#define LWIP_HTTPD_SUPPORT_V09              1
+#endif
+
+/** Set this to 1 to enable HTTP/1.1 persistent connections.
+ * ATTENTION: If the generated file system includes HTTP headers, these must
+ * include the "Connection: keep-alive" header (pass argument "-11" to makefsdata).
+ */
+#if !defined LWIP_HTTPD_SUPPORT_11_KEEPALIVE || defined __DOXYGEN__
+#define LWIP_HTTPD_SUPPORT_11_KEEPALIVE     0
+#endif
+
+/** Set this to 1 to support HTTP request coming in in multiple packets/pbufs */
+#if !defined LWIP_HTTPD_SUPPORT_REQUESTLIST || defined __DOXYGEN__
+#define LWIP_HTTPD_SUPPORT_REQUESTLIST      1
+#endif
+
+#if LWIP_HTTPD_SUPPORT_REQUESTLIST
+/** Number of rx pbufs to enqueue to parse an incoming request (up to the first
+    newline) */
+#if !defined LWIP_HTTPD_REQ_QUEUELEN || defined __DOXYGEN__
+#define LWIP_HTTPD_REQ_QUEUELEN             5
+#endif
+
+/** Number of (TCP payload-) bytes (in pbufs) to enqueue to parse and incoming
+    request (up to the first double-newline) */
+#if !defined LWIP_HTTPD_REQ_BUFSIZE || defined __DOXYGEN__
+#define LWIP_HTTPD_REQ_BUFSIZE              LWIP_HTTPD_MAX_REQ_LENGTH
+#endif
+
+/** Defines the maximum length of a HTTP request line (up to the first CRLF,
+    copied from pbuf into this a global buffer when pbuf- or packet-queues
+    are received - otherwise the input pbuf is used directly) */
+#if !defined LWIP_HTTPD_MAX_REQ_LENGTH || defined __DOXYGEN__
+#define LWIP_HTTPD_MAX_REQ_LENGTH           LWIP_MIN(1023, (LWIP_HTTPD_REQ_QUEUELEN * PBUF_POOL_BUFSIZE))
+#endif
+#endif /* LWIP_HTTPD_SUPPORT_REQUESTLIST */
+
+/** This is the size of a static buffer used when URIs end with '/'.
+ * In this buffer, the directory requested is concatenated with all the
+ * configured default file names.
+ * Set to 0 to disable checking default filenames on non-root directories.
+ */
+#if !defined LWIP_HTTPD_MAX_REQUEST_URI_LEN || defined __DOXYGEN__
+#define LWIP_HTTPD_MAX_REQUEST_URI_LEN      63
+#endif
+
+/** Maximum length of the filename to send as response to a POST request,
+ * filled in by the application when a POST is finished.
+ */
+#if !defined LWIP_HTTPD_POST_MAX_RESPONSE_URI_LEN || defined __DOXYGEN__
+#define LWIP_HTTPD_POST_MAX_RESPONSE_URI_LEN 63
+#endif
+
+/** Set this to 0 to not send the SSI tag (default is on, so the tag will
+ * be sent in the HTML page */
+#if !defined LWIP_HTTPD_SSI_INCLUDE_TAG || defined __DOXYGEN__
+#define LWIP_HTTPD_SSI_INCLUDE_TAG           1
+#endif
+
+/** Set this to 1 to call tcp_abort when tcp_close fails with memory error.
+ * This can be used to prevent consuming all memory in situations where the
+ * HTTP server has low priority compared to other communication. */
+#if !defined LWIP_HTTPD_ABORT_ON_CLOSE_MEM_ERROR || defined __DOXYGEN__
+#define LWIP_HTTPD_ABORT_ON_CLOSE_MEM_ERROR  0
+#endif
+
+/** Set this to 1 to kill the oldest connection when running out of
+ * memory for 'struct http_state' or 'struct http_ssi_state'.
+ * ATTENTION: This puts all connections on a linked list, so may be kind of slow.
+ */
+#if !defined LWIP_HTTPD_KILL_OLD_ON_CONNECTIONS_EXCEEDED || defined __DOXYGEN__
+#define LWIP_HTTPD_KILL_OLD_ON_CONNECTIONS_EXCEEDED 0
+#endif
+
+/** Set this to 1 to send URIs without extension without headers
+ * (who uses this at all??) */
+#if !defined LWIP_HTTPD_OMIT_HEADER_FOR_EXTENSIONLESS_URI || defined __DOXYGEN__
+#define LWIP_HTTPD_OMIT_HEADER_FOR_EXTENSIONLESS_URI 0
+#endif
+
+/** Default: Tags are sent from struct http_state and are therefore volatile */
+#if !defined HTTP_IS_TAG_VOLATILE || defined __DOXYGEN__
+#define HTTP_IS_TAG_VOLATILE(ptr) TCP_WRITE_FLAG_COPY
+#endif
+
+/* By default, the httpd is limited to send 2*pcb->mss to keep resource usage low
+   when http is not an important protocol in the device. */
+#if !defined HTTPD_LIMIT_SENDING_TO_2MSS || defined __DOXYGEN__
+#define HTTPD_LIMIT_SENDING_TO_2MSS 1
+#endif
+
+/* Define this to a function that returns the maximum amount of data to enqueue.
+   The function have this signature: u16_t fn(struct tcp_pcb* pcb); */
+#if !defined HTTPD_MAX_WRITE_LEN || defined __DOXYGEN__
+#if HTTPD_LIMIT_SENDING_TO_2MSS
+#define HTTPD_MAX_WRITE_LEN(pcb)    (2 * tcp_mss(pcb))
+#endif
+#endif
+
+/*------------------- FS OPTIONS -------------------*/
+
+/** Set this to 1 and provide the functions:
+ * - "int fs_open_custom(struct fs_file *file, const char *name)"
+ *    Called first for every opened file to allow opening files
+ *    that are not included in fsdata(_custom).c
+ * - "void fs_close_custom(struct fs_file *file)"
+ *    Called to free resources allocated by fs_open_custom().
+ */
+#if !defined LWIP_HTTPD_CUSTOM_FILES || defined __DOXYGEN__
+#define LWIP_HTTPD_CUSTOM_FILES       0
+#endif
+
+/** Set this to 1 to support fs_read() to dynamically read file data.
+ * Without this (default=off), only one-block files are supported,
+ * and the contents must be ready after fs_open().
+ */
+#if !defined LWIP_HTTPD_DYNAMIC_FILE_READ || defined __DOXYGEN__
+#define LWIP_HTTPD_DYNAMIC_FILE_READ  0
+#endif
+
+/** Set this to 1 to include an application state argument per file
+ * that is opened. This allows to keep a state per connection/file.
+ */
+#if !defined LWIP_HTTPD_FILE_STATE || defined __DOXYGEN__
+#define LWIP_HTTPD_FILE_STATE         0
+#endif
+
+/** HTTPD_PRECALCULATED_CHECKSUM==1: include precompiled checksums for
+ * predefined (MSS-sized) chunks of the files to prevent having to calculate
+ * the checksums at runtime. */
+#if !defined HTTPD_PRECALCULATED_CHECKSUM || defined __DOXYGEN__
+#define HTTPD_PRECALCULATED_CHECKSUM  0
+#endif
+
+/** LWIP_HTTPD_FS_ASYNC_READ==1: support asynchronous read operations
+ * (fs_read_async returns FS_READ_DELAYED and calls a callback when finished).
+ */
+#if !defined LWIP_HTTPD_FS_ASYNC_READ || defined __DOXYGEN__
+#define LWIP_HTTPD_FS_ASYNC_READ      0
+#endif
+
+/** Set this to 1 to include "fsdata_custom.c" instead of "fsdata.c" for the
+ * file system (to prevent changing the file included in CVS) */
+#if !defined HTTPD_USE_CUSTOM_FSDATA || defined __DOXYGEN__
+#define HTTPD_USE_CUSTOM_FSDATA 0
+#endif
+
+/**
+ * @}
+ */
+
+#endif /* LWIP_HDR_APPS_HTTPD_OPTS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/lwiperf.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/lwiperf.h
new file mode 100644
index 000000000..7dbebb082
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/lwiperf.h
@@ -0,0 +1,84 @@
+/**
+ * @file
+ * lwIP iPerf server implementation
+ */
+
+/*
+ * Copyright (c) 2014 Simon Goldschmidt
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Simon Goldschmidt
+ *
+ */
+#ifndef LWIP_HDR_APPS_LWIPERF_H
+#define LWIP_HDR_APPS_LWIPERF_H
+
+#include "lwip/opt.h"
+#include "lwip/ip_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define LWIPERF_TCP_PORT_DEFAULT  5001
+
+/** lwIPerf test results */
+enum lwiperf_report_type
+{
+  /** The server side test is done */
+  LWIPERF_TCP_DONE_SERVER,
+  /** The client side test is done */
+  LWIPERF_TCP_DONE_CLIENT,
+  /** Local error lead to test abort */
+  LWIPERF_TCP_ABORTED_LOCAL,
+  /** Data check error lead to test abort */
+  LWIPERF_TCP_ABORTED_LOCAL_DATAERROR,
+  /** Transmit error lead to test abort */
+  LWIPERF_TCP_ABORTED_LOCAL_TXERROR,
+  /** Remote side aborted the test */
+  LWIPERF_TCP_ABORTED_REMOTE
+};
+
+/** Prototype of a report function that is called when a session is finished.
+    This report function can show the test results.
+    @param report_type contains the test result */
+typedef void (*lwiperf_report_fn)(void *arg, enum lwiperf_report_type report_type,
+  const ip_addr_t* local_addr, u16_t local_port, const ip_addr_t* remote_addr, u16_t remote_port,
+  u32_t bytes_transferred, u32_t ms_duration, u32_t bandwidth_kbitpsec);
+
+
+void* lwiperf_start_tcp_server(const ip_addr_t* local_addr, u16_t local_port,
+                               lwiperf_report_fn report_fn, void* report_arg);
+void* lwiperf_start_tcp_server_default(lwiperf_report_fn report_fn, void* report_arg);
+void  lwiperf_abort(void* lwiperf_session);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_APPS_LWIPERF_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/mdns.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/mdns.h
new file mode 100644
index 000000000..d03681611
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/mdns.h
@@ -0,0 +1,69 @@
+/**
+ * @file
+ * MDNS responder
+ */
+
+ /*
+ * Copyright (c) 2015 Verisure Innovation AB
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Erik Ekman <erik@kryo.se>
+ *
+ */
+#ifndef LWIP_HDR_MDNS_H
+#define LWIP_HDR_MDNS_H
+
+#include "lwip/apps/mdns_opts.h"
+#include "lwip/netif.h"
+
+#if LWIP_MDNS_RESPONDER
+
+enum mdns_sd_proto {
+  DNSSD_PROTO_UDP = 0,
+  DNSSD_PROTO_TCP = 1
+};
+
+#define MDNS_LABEL_MAXLEN  63
+
+struct mdns_host;
+struct mdns_service;
+
+/** Callback function to add text to a reply, called when generating the reply */
+typedef void (*service_get_txt_fn_t)(struct mdns_service *service, void *txt_userdata);
+
+void mdns_resp_init(void);
+
+err_t mdns_resp_add_netif(struct netif *netif, const char *hostname, u32_t dns_ttl);
+err_t mdns_resp_remove_netif(struct netif *netif);
+
+err_t mdns_resp_add_service(struct netif *netif, const char *name, const char *service, enum mdns_sd_proto proto, u16_t port, u32_t dns_ttl, service_get_txt_fn_t txt_fn, void *txt_userdata);
+err_t mdns_resp_add_service_txtitem(struct mdns_service *service, const char *txt, u8_t txt_len);
+void mdns_resp_netif_settings_changed(struct netif *netif);
+
+#endif /* LWIP_MDNS_RESPONDER */
+
+#endif /* LWIP_HDR_MDNS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/mdns_opts.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/mdns_opts.h
new file mode 100644
index 000000000..bf186bcce
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/mdns_opts.h
@@ -0,0 +1,74 @@
+/**
+ * @file
+ * MDNS responder
+ */
+
+ /*
+ * Copyright (c) 2015 Verisure Innovation AB
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Erik Ekman <erik@kryo.se>
+ *
+ */
+
+#ifndef LWIP_HDR_APPS_MDNS_OPTS_H
+#define LWIP_HDR_APPS_MDNS_OPTS_H
+
+#include "lwip/opt.h"
+
+/**
+ * @defgroup mdns_opts Options
+ * @ingroup mdns
+ * @{
+ */
+
+/**
+ * LWIP_MDNS_RESPONDER==1: Turn on multicast DNS module. UDP must be available for MDNS
+ * transport. IGMP is needed for IPv4 multicast.
+ */
+#ifndef LWIP_MDNS_RESPONDER
+#define LWIP_MDNS_RESPONDER             0
+#endif /* LWIP_MDNS_RESPONDER */
+
+/** The maximum number of services per netif */
+#ifndef MDNS_MAX_SERVICES
+#define MDNS_MAX_SERVICES               1
+#endif
+
+/**
+ * MDNS_DEBUG: Enable debugging for multicast DNS.
+ */
+#ifndef MDNS_DEBUG
+#define MDNS_DEBUG                       LWIP_DBG_OFF
+#endif
+
+/**
+ * @}
+ */
+
+#endif /* LWIP_HDR_APPS_MDNS_OPTS_H */
+
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/mdns_priv.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/mdns_priv.h
new file mode 100644
index 000000000..8ee6db86a
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/mdns_priv.h
@@ -0,0 +1,66 @@
+/**
+ * @file
+ * MDNS responder private definitions
+ */
+
+ /*
+ * Copyright (c) 2015 Verisure Innovation AB
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Erik Ekman <erik@kryo.se>
+ *
+ */
+#ifndef LWIP_HDR_MDNS_PRIV_H
+#define LWIP_HDR_MDNS_PRIV_H
+
+#include "lwip/apps/mdns_opts.h"
+#include "lwip/pbuf.h"
+
+#if LWIP_MDNS_RESPONDER
+
+/* Domain struct and methods - visible for unit tests */
+
+#define MDNS_DOMAIN_MAXLEN 256
+#define MDNS_READNAME_ERROR 0xFFFF
+
+struct mdns_domain {
+  /* Encoded domain name */
+  u8_t name[MDNS_DOMAIN_MAXLEN];
+  /* Total length of domain name, including zero */
+  u16_t length;
+  /* Set if compression of this domain is not allowed */
+  u8_t skip_compression;
+};
+
+err_t mdns_domain_add_label(struct mdns_domain *domain, const char *label, u8_t len);
+u16_t mdns_readname(struct pbuf *p, u16_t offset, struct mdns_domain *domain);
+int mdns_domain_eq(struct mdns_domain *a, struct mdns_domain *b);
+u16_t mdns_compress_domain(struct pbuf *pbuf, u16_t *offset, struct mdns_domain *domain);
+
+#endif /* LWIP_MDNS_RESPONDER */
+
+#endif /* LWIP_HDR_MDNS_PRIV_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/mqtt.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/mqtt.h
new file mode 100644
index 000000000..34b230b88
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/mqtt.h
@@ -0,0 +1,244 @@
+/**
+ * @file
+ * MQTT client
+ */
+
+/*
+ * Copyright (c) 2016 Erik Andersson
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Erik Andersson
+ *
+ */
+#ifndef LWIP_HDR_APPS_MQTT_CLIENT_H
+#define LWIP_HDR_APPS_MQTT_CLIENT_H
+
+#include "lwip/apps/mqtt_opts.h"
+#include "lwip/err.h"
+#include "lwip/ip_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct mqtt_client_t mqtt_client_t;
+
+/** @ingroup mqtt
+ * Default MQTT port */
+#define MQTT_PORT 1883
+
+/*---------------------------------------------------------------------------------------------- */
+/* Connection with server */
+
+/**
+ * @ingroup mqtt
+ * Client information and connection parameters */
+struct mqtt_connect_client_info_t {
+  /** Client identifier, must be set by caller */
+  const char *client_id;
+  /** User name and password, set to NULL if not used */
+  const char* client_user;
+  const char* client_pass;
+  /** keep alive time in seconds, 0 to disable keep alive functionality*/
+  u16_t keep_alive;
+  /** will topic, set to NULL if will is not to be used,
+      will_msg, will_qos and will retain are then ignored */
+  const char* will_topic;
+  const char* will_msg;
+  u8_t will_qos;
+  u8_t will_retain;
+};
+
+/**
+ * @ingroup mqtt
+ * Connection status codes */
+typedef enum
+{
+  MQTT_CONNECT_ACCEPTED                 = 0,
+  MQTT_CONNECT_REFUSED_PROTOCOL_VERSION = 1,
+  MQTT_CONNECT_REFUSED_IDENTIFIER       = 2,
+  MQTT_CONNECT_REFUSED_SERVER           = 3,
+  MQTT_CONNECT_REFUSED_USERNAME_PASS    = 4,
+  MQTT_CONNECT_REFUSED_NOT_AUTHORIZED_  = 5,
+  MQTT_CONNECT_DISCONNECTED             = 256,
+  MQTT_CONNECT_TIMEOUT                  = 257
+} mqtt_connection_status_t;
+
+/**
+ * @ingroup mqtt
+ * Function prototype for mqtt connection status callback. Called when
+ * client has connected to the server after initiating a mqtt connection attempt by
+ * calling mqtt_connect() or when connection is closed by server or an error
+ *
+ * @param client MQTT client itself
+ * @param arg Additional argument to pass to the callback function
+ * @param status Connect result code or disconnection notification @see mqtt_connection_status_t
+ *
+ */
+typedef void (*mqtt_connection_cb_t)(mqtt_client_t *client, void *arg, mqtt_connection_status_t status);
+
+
+/**
+ * @ingroup mqtt
+ * Data callback flags */
+enum {
+  /** Flag set when last fragment of data arrives in data callback */
+  MQTT_DATA_FLAG_LAST = 1
+};
+
+/** 
+ * @ingroup mqtt
+ * Function prototype for MQTT incoming publish data callback function. Called when data
+ * arrives to a subscribed topic @see mqtt_subscribe
+ *
+ * @param arg Additional argument to pass to the callback function
+ * @param data User data, pointed object, data may not be referenced after callback return,
+          NULL is passed when all publish data are delivered
+ * @param len Length of publish data fragment
+ * @param flags MQTT_DATA_FLAG_LAST set when this call contains the last part of data from publish message
+ *
+ */
+typedef void (*mqtt_incoming_data_cb_t)(void *arg, const u8_t *data, u16_t len, u8_t flags);
+
+
+/** 
+ * @ingroup mqtt
+ * Function prototype for MQTT incoming publish function. Called when an incoming publish
+ * arrives to a subscribed topic @see mqtt_subscribe
+ *
+ * @param arg Additional argument to pass to the callback function
+ * @param topic Zero terminated Topic text string, topic may not be referenced after callback return
+ * @param tot_len Total length of publish data, if set to 0 (no publish payload) data callback will not be invoked
+ */
+typedef void (*mqtt_incoming_publish_cb_t)(void *arg, const char *topic, u32_t tot_len);
+
+
+/**
+ * @ingroup mqtt
+ * Function prototype for mqtt request callback. Called when a subscribe, unsubscribe
+ * or publish request has completed
+ * @param arg Pointer to user data supplied when invoking request
+ * @param err ERR_OK on success
+ *            ERR_TIMEOUT if no response was received within timeout,
+ *            ERR_ABRT if (un)subscribe was denied
+ */
+typedef void (*mqtt_request_cb_t)(void *arg, err_t err);
+
+
+/**
+ * Pending request item, binds application callback to pending server requests
+ */
+struct mqtt_request_t
+{
+  /** Next item in list, NULL means this is the last in chain,
+      next pointing at itself means request is unallocated */
+  struct mqtt_request_t *next;
+  /** Callback to upper layer */
+  mqtt_request_cb_t cb;
+  void *arg;
+  /** MQTT packet identifier */
+  u16_t pkt_id;
+  /** Expire time relative to element before this  */
+  u16_t timeout_diff;
+};
+
+/** Ring buffer */
+struct mqtt_ringbuf_t {
+  u16_t put;
+  u16_t get;
+  u8_t buf[MQTT_OUTPUT_RINGBUF_SIZE];
+};
+
+/** MQTT client */
+struct mqtt_client_t
+{
+  /** Timers and timeouts */
+  u16_t cyclic_tick;
+  u16_t keep_alive;
+  u16_t server_watchdog;
+  /** Packet identifier generator*/
+  u16_t pkt_id_seq;
+  /** Packet identifier of pending incoming publish */
+  u16_t inpub_pkt_id;
+  /** Connection state */
+  u8_t conn_state;
+  struct tcp_pcb *conn;
+  /** Connection callback */
+  void *connect_arg;
+  mqtt_connection_cb_t connect_cb;
+  /** Pending requests to server */
+  struct mqtt_request_t *pend_req_queue;
+  struct mqtt_request_t req_list[MQTT_REQ_MAX_IN_FLIGHT];
+  void *inpub_arg;
+  /** Incoming data callback */
+  mqtt_incoming_data_cb_t data_cb;
+  mqtt_incoming_publish_cb_t pub_cb;
+  /** Input */
+  u32_t msg_idx;
+  u8_t rx_buffer[MQTT_VAR_HEADER_BUFFER_LEN];
+  /** Output ring-buffer */
+  struct mqtt_ringbuf_t output;
+};
+
+
+/** Connect to server */
+err_t mqtt_client_connect(mqtt_client_t *client, const ip_addr_t *ipaddr, u16_t port, mqtt_connection_cb_t cb, void *arg,
+                   const struct mqtt_connect_client_info_t *client_info);
+
+/** Disconnect from server */
+void mqtt_disconnect(mqtt_client_t *client);
+
+/** Create new client */
+mqtt_client_t *mqtt_client_new(void);
+
+/** Check connection status */
+u8_t mqtt_client_is_connected(mqtt_client_t *client);
+
+/** Set callback to call for incoming publish */
+void mqtt_set_inpub_callback(mqtt_client_t *client, mqtt_incoming_publish_cb_t,
+                             mqtt_incoming_data_cb_t data_cb, void *arg);
+
+/** Common function for subscribe and unsubscribe */
+err_t mqtt_sub_unsub(mqtt_client_t *client, const char *topic, u8_t qos, mqtt_request_cb_t cb, void *arg, u8_t sub);
+
+/** @ingroup mqtt
+ *Subscribe to topic */
+#define mqtt_subscribe(client, topic, qos, cb, arg) mqtt_sub_unsub(client, topic, qos, cb, arg, 1)
+/** @ingroup mqtt
+ *  Unsubscribe to topic */
+#define mqtt_unsubscribe(client, topic, cb, arg) mqtt_sub_unsub(client, topic, 0, cb, arg, 0)
+
+
+/** Publish data to topic */
+err_t mqtt_publish(mqtt_client_t *client, const char *topic, const void *payload, u16_t payload_length, u8_t qos, u8_t retain,
+                                    mqtt_request_cb_t cb, void *arg);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_APPS_MQTT_CLIENT_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/mqtt_opts.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/mqtt_opts.h
new file mode 100644
index 000000000..ffefacd25
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/mqtt_opts.h
@@ -0,0 +1,103 @@
+/**
+ * @file
+ * MQTT client options
+ */
+
+/*
+ * Copyright (c) 2016 Erik Andersson
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Erik Andersson
+ *
+ */
+#ifndef LWIP_HDR_APPS_MQTT_OPTS_H
+#define LWIP_HDR_APPS_MQTT_OPTS_H
+
+#include "lwip/opt.h"
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+/**
+ * @defgroup mqtt_opts Options
+ * @ingroup mqtt
+ * @{
+ */
+
+/**
+ * Output ring-buffer size, must be able to fit largest outgoing publish message topic+payloads
+ */
+#ifndef MQTT_OUTPUT_RINGBUF_SIZE
+#define MQTT_OUTPUT_RINGBUF_SIZE 256
+#endif
+
+/**
+ * Number of bytes in receive buffer, must be at least the size of the longest incoming topic + 8
+ * If one wants to avoid fragmented incoming publish, set length to max incoming topic length + max payload length + 8
+ */
+#ifndef MQTT_VAR_HEADER_BUFFER_LEN
+#define MQTT_VAR_HEADER_BUFFER_LEN 128
+#endif
+
+/**
+ * Maximum number of pending subscribe, unsubscribe and publish requests to server .
+ */
+#ifndef MQTT_REQ_MAX_IN_FLIGHT
+#define MQTT_REQ_MAX_IN_FLIGHT 4
+#endif
+
+/**
+ * Seconds between each cyclic timer call.
+ */
+#ifndef MQTT_CYCLIC_TIMER_INTERVAL
+#define MQTT_CYCLIC_TIMER_INTERVAL 5
+#endif
+
+/**
+ * Publish, subscribe and unsubscribe request timeout in seconds.
+ */
+#ifndef MQTT_REQ_TIMEOUT
+#define MQTT_REQ_TIMEOUT 30
+#endif
+
+/**
+ * Seconds for MQTT connect response timeout after sending connect request
+ */
+#ifndef MQTT_CONNECT_TIMOUT
+#define MQTT_CONNECT_TIMOUT 100
+#endif
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_APPS_MQTT_OPTS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/netbiosns.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/netbiosns.h
new file mode 100644
index 000000000..c9f68d8d1
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/netbiosns.h
@@ -0,0 +1,43 @@
+/**
+ * @file
+ * NETBIOS name service responder
+ */
+
+/*
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ */
+#ifndef LWIP_HDR_APPS_NETBIOS_H
+#define LWIP_HDR_APPS_NETBIOS_H
+
+#include "lwip/apps/netbiosns_opts.h"
+
+void netbiosns_init(void);
+#ifndef NETBIOS_LWIP_NAME
+void netbiosns_set_name(const char* hostname);
+#endif
+void netbiosns_stop(void);
+
+#endif /* LWIP_HDR_APPS_NETBIOS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/netbiosns_opts.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/netbiosns_opts.h
new file mode 100644
index 000000000..0909ef7b9
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/netbiosns_opts.h
@@ -0,0 +1,59 @@
+/**
+ * @file
+ * NETBIOS name service responder options
+ */
+
+/*
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ */
+#ifndef LWIP_HDR_APPS_NETBIOS_OPTS_H
+#define LWIP_HDR_APPS_NETBIOS_OPTS_H
+
+#include "lwip/opt.h"
+
+/**
+ * @defgroup netbiosns_opts Options
+ * @ingroup netbiosns
+ * @{
+ */
+
+/** NetBIOS name of lwip device
+ * This must be uppercase until NETBIOS_STRCMP() is defined to a string
+ * comparision function that is case insensitive.
+ * If you want to use the netif's hostname, use this (with LWIP_NETIF_HOSTNAME):
+ * (ip_current_netif() != NULL ? ip_current_netif()->hostname != NULL ? ip_current_netif()->hostname : "" : "")
+ *
+ * If this is not defined, netbiosns_set_name() can be called at runtime to change the name.
+ */
+#ifdef __DOXYGEN__
+#define NETBIOS_LWIP_NAME "NETBIOSLWIPDEV"
+#endif
+
+/**
+ * @}
+ */
+
+#endif /* LWIP_HDR_APPS_NETBIOS_OPTS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/snmp.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/snmp.h
new file mode 100644
index 000000000..10e8ff434
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/snmp.h
@@ -0,0 +1,128 @@
+/**
+ * @file
+ * SNMP server main API - start and basic configuration
+ */
+
+/*
+ * Copyright (c) 2001, 2002 Leon Woestenberg <leon.woestenberg@axon.tv>
+ * Copyright (c) 2001, 2002 Axon Digital Design B.V., The Netherlands.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Leon Woestenberg <leon.woestenberg@axon.tv>
+ *         Martin Hentschel <info@cl-soft.de>
+ *
+ */
+#ifndef LWIP_HDR_APPS_SNMP_H
+#define LWIP_HDR_APPS_SNMP_H
+
+#include "lwip/apps/snmp_opts.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_SNMP /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/err.h"
+#include "lwip/apps/snmp_core.h"
+
+/** SNMP variable binding descriptor (publically needed for traps) */
+struct snmp_varbind
+{
+  /** pointer to next varbind, NULL for last in list */
+  struct snmp_varbind *next;
+  /** pointer to previous varbind, NULL for first in list */
+  struct snmp_varbind *prev;
+
+  /** object identifier */
+  struct snmp_obj_id oid;
+
+  /** value ASN1 type */
+  u8_t type;
+  /** object value length */
+  u16_t value_len;
+  /** object value */
+  void *value;
+};
+
+/**
+ * @ingroup snmp_core
+ * Agent setup, start listening to port 161.
+ */
+void snmp_init(void);
+void snmp_set_mibs(const struct snmp_mib **mibs, u8_t num_mibs);
+
+void snmp_set_device_enterprise_oid(const struct snmp_obj_id* device_enterprise_oid);
+const struct snmp_obj_id* snmp_get_device_enterprise_oid(void);
+
+void snmp_trap_dst_enable(u8_t dst_idx, u8_t enable);
+void snmp_trap_dst_ip_set(u8_t dst_idx, const ip_addr_t *dst);
+
+/** Generic trap: cold start */
+#define SNMP_GENTRAP_COLDSTART 0
+/** Generic trap: warm start */
+#define SNMP_GENTRAP_WARMSTART 1
+/** Generic trap: link down */
+#define SNMP_GENTRAP_LINKDOWN 2
+/** Generic trap: link up */
+#define SNMP_GENTRAP_LINKUP 3
+/** Generic trap: authentication failure */
+#define SNMP_GENTRAP_AUTH_FAILURE 4
+/** Generic trap: EGP neighbor lost */
+#define SNMP_GENTRAP_EGP_NEIGHBOR_LOSS 5
+/** Generic trap: enterprise specific */
+#define SNMP_GENTRAP_ENTERPRISE_SPECIFIC 6
+
+err_t snmp_send_trap_generic(s32_t generic_trap);
+err_t snmp_send_trap_specific(s32_t specific_trap, struct snmp_varbind *varbinds);
+err_t snmp_send_trap(const struct snmp_obj_id* oid, s32_t generic_trap, s32_t specific_trap, struct snmp_varbind *varbinds);
+
+#define SNMP_AUTH_TRAPS_DISABLED 0
+#define SNMP_AUTH_TRAPS_ENABLED  1
+void snmp_set_auth_traps_enabled(u8_t enable);
+u8_t snmp_get_auth_traps_enabled(void);
+
+const char * snmp_get_community(void);
+const char * snmp_get_community_write(void);
+const char * snmp_get_community_trap(void);
+void snmp_set_community(const char * const community);
+void snmp_set_community_write(const char * const community);
+void snmp_set_community_trap(const char * const community);
+
+void snmp_coldstart_trap(void);
+void snmp_authfail_trap(void);
+
+typedef void (*snmp_write_callback_fct)(const u32_t* oid, u8_t oid_len, void* callback_arg);
+void snmp_set_write_callback(snmp_write_callback_fct write_callback, void* callback_arg);
+
+#endif /* LWIP_SNMP */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_APPS_SNMP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/snmp_core.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/snmp_core.h
new file mode 100644
index 000000000..e781c532b
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/snmp_core.h
@@ -0,0 +1,364 @@
+/**
+ * @file
+ * SNMP core API for implementing MIBs
+ */
+
+/*
+ * Copyright (c) 2006 Axon Digital Design B.V., The Netherlands.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * Author: Christiaan Simons <christiaan.simons@axon.tv>
+ *         Martin Hentschel <info@cl-soft.de>
+ */
+
+#ifndef LWIP_HDR_APPS_SNMP_CORE_H
+#define LWIP_HDR_APPS_SNMP_CORE_H
+
+#include "lwip/apps/snmp_opts.h"
+
+#if LWIP_SNMP /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/ip_addr.h"
+#include "lwip/err.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* basic ASN1 defines */
+#define SNMP_ASN1_CLASS_UNIVERSAL   0x00
+#define SNMP_ASN1_CLASS_APPLICATION 0x40
+#define SNMP_ASN1_CLASS_CONTEXT     0x80
+#define SNMP_ASN1_CLASS_PRIVATE     0xC0
+
+#define SNMP_ASN1_CONTENTTYPE_PRIMITIVE   0x00
+#define SNMP_ASN1_CONTENTTYPE_CONSTRUCTED 0x20
+
+/* universal tags (from ASN.1 spec.) */
+#define SNMP_ASN1_UNIVERSAL_END_OF_CONTENT  0
+#define SNMP_ASN1_UNIVERSAL_INTEGER         2
+#define SNMP_ASN1_UNIVERSAL_OCTET_STRING    4
+#define SNMP_ASN1_UNIVERSAL_NULL            5
+#define SNMP_ASN1_UNIVERSAL_OBJECT_ID       6
+#define SNMP_ASN1_UNIVERSAL_SEQUENCE_OF    16
+
+/* application specific (SNMP) tags (from SNMPv2-SMI) */
+#define SNMP_ASN1_APPLICATION_IPADDR    0  /* [APPLICATION 0] IMPLICIT OCTET STRING (SIZE (4)) */
+#define SNMP_ASN1_APPLICATION_COUNTER   1  /* [APPLICATION 1] IMPLICIT INTEGER (0..4294967295) => u32_t */
+#define SNMP_ASN1_APPLICATION_GAUGE     2  /* [APPLICATION 2] IMPLICIT INTEGER (0..4294967295) => u32_t */
+#define SNMP_ASN1_APPLICATION_TIMETICKS 3  /* [APPLICATION 3] IMPLICIT INTEGER (0..4294967295) => u32_t */
+#define SNMP_ASN1_APPLICATION_OPAQUE    4  /* [APPLICATION 4] IMPLICIT OCTET STRING */
+#define SNMP_ASN1_APPLICATION_COUNTER64 6  /* [APPLICATION 6] IMPLICIT INTEGER (0..18446744073709551615) */
+
+/* context specific (SNMP) tags (from RFC 1905) */
+#define SNMP_ASN1_CONTEXT_VARBIND_NO_SUCH_INSTANCE 1
+
+/* full ASN1 type defines */
+#define SNMP_ASN1_TYPE_END_OF_CONTENT (SNMP_ASN1_CLASS_UNIVERSAL | SNMP_ASN1_CONTENTTYPE_PRIMITIVE | SNMP_ASN1_UNIVERSAL_END_OF_CONTENT)
+#define SNMP_ASN1_TYPE_INTEGER        (SNMP_ASN1_CLASS_UNIVERSAL | SNMP_ASN1_CONTENTTYPE_PRIMITIVE | SNMP_ASN1_UNIVERSAL_INTEGER)
+#define SNMP_ASN1_TYPE_OCTET_STRING   (SNMP_ASN1_CLASS_UNIVERSAL | SNMP_ASN1_CONTENTTYPE_PRIMITIVE | SNMP_ASN1_UNIVERSAL_OCTET_STRING)
+#define SNMP_ASN1_TYPE_NULL           (SNMP_ASN1_CLASS_UNIVERSAL | SNMP_ASN1_CONTENTTYPE_PRIMITIVE | SNMP_ASN1_UNIVERSAL_NULL)
+#define SNMP_ASN1_TYPE_OBJECT_ID      (SNMP_ASN1_CLASS_UNIVERSAL | SNMP_ASN1_CONTENTTYPE_PRIMITIVE | SNMP_ASN1_UNIVERSAL_OBJECT_ID)
+#define SNMP_ASN1_TYPE_SEQUENCE       (SNMP_ASN1_CLASS_UNIVERSAL | SNMP_ASN1_CONTENTTYPE_CONSTRUCTED | SNMP_ASN1_UNIVERSAL_SEQUENCE_OF)
+#define SNMP_ASN1_TYPE_IPADDR         (SNMP_ASN1_CLASS_APPLICATION | SNMP_ASN1_CONTENTTYPE_PRIMITIVE | SNMP_ASN1_APPLICATION_IPADDR)
+#define SNMP_ASN1_TYPE_IPADDRESS      SNMP_ASN1_TYPE_IPADDR
+#define SNMP_ASN1_TYPE_COUNTER        (SNMP_ASN1_CLASS_APPLICATION | SNMP_ASN1_CONTENTTYPE_PRIMITIVE | SNMP_ASN1_APPLICATION_COUNTER)
+#define SNMP_ASN1_TYPE_COUNTER32      SNMP_ASN1_TYPE_COUNTER
+#define SNMP_ASN1_TYPE_GAUGE          (SNMP_ASN1_CLASS_APPLICATION | SNMP_ASN1_CONTENTTYPE_PRIMITIVE | SNMP_ASN1_APPLICATION_GAUGE)
+#define SNMP_ASN1_TYPE_GAUGE32        SNMP_ASN1_TYPE_GAUGE
+#define SNMP_ASN1_TYPE_UNSIGNED32     SNMP_ASN1_TYPE_GAUGE
+#define SNMP_ASN1_TYPE_TIMETICKS      (SNMP_ASN1_CLASS_APPLICATION | SNMP_ASN1_CONTENTTYPE_PRIMITIVE | SNMP_ASN1_APPLICATION_TIMETICKS)
+#define SNMP_ASN1_TYPE_OPAQUE         (SNMP_ASN1_CLASS_APPLICATION | SNMP_ASN1_CONTENTTYPE_PRIMITIVE | SNMP_ASN1_APPLICATION_OPAQUE)
+#define SNMP_ASN1_TYPE_COUNTER64      (SNMP_ASN1_CLASS_APPLICATION | SNMP_ASN1_CONTENTTYPE_PRIMITIVE | SNMP_ASN1_APPLICATION_COUNTER64)
+
+#define SNMP_VARBIND_EXCEPTION_OFFSET 0xF0
+#define SNMP_VARBIND_EXCEPTION_MASK   0x0F
+
+/** error codes predefined by SNMP prot. */
+typedef enum {
+  SNMP_ERR_NOERROR             = 0,
+/* 
+outdated v1 error codes. do not use anmore!
+#define SNMP_ERR_NOSUCHNAME 2  use SNMP_ERR_NOSUCHINSTANCE instead
+#define SNMP_ERR_BADVALUE   3  use SNMP_ERR_WRONGTYPE,SNMP_ERR_WRONGLENGTH,SNMP_ERR_WRONGENCODING or SNMP_ERR_WRONGVALUE instead
+#define SNMP_ERR_READONLY   4  use SNMP_ERR_NOTWRITABLE instead
+*/
+  SNMP_ERR_GENERROR            = 5,
+  SNMP_ERR_NOACCESS            = 6,
+  SNMP_ERR_WRONGTYPE           = 7,
+  SNMP_ERR_WRONGLENGTH         = 8,
+  SNMP_ERR_WRONGENCODING       = 9,
+  SNMP_ERR_WRONGVALUE          = 10,
+  SNMP_ERR_NOCREATION          = 11,
+  SNMP_ERR_INCONSISTENTVALUE   = 12,
+  SNMP_ERR_RESOURCEUNAVAILABLE = 13,
+  SNMP_ERR_COMMITFAILED        = 14,
+  SNMP_ERR_UNDOFAILED          = 15,
+  SNMP_ERR_NOTWRITABLE         = 17,
+  SNMP_ERR_INCONSISTENTNAME    = 18,
+
+  SNMP_ERR_NOSUCHINSTANCE      = SNMP_VARBIND_EXCEPTION_OFFSET + SNMP_ASN1_CONTEXT_VARBIND_NO_SUCH_INSTANCE
+} snmp_err_t;
+
+/** internal object identifier representation */
+struct snmp_obj_id
+{
+  u8_t len;
+  u32_t id[SNMP_MAX_OBJ_ID_LEN];
+};
+
+struct snmp_obj_id_const_ref
+{
+  u8_t len;
+  const u32_t* id;
+};
+
+extern const struct snmp_obj_id_const_ref snmp_zero_dot_zero; /* administrative identifier from SNMPv2-SMI */
+
+/** SNMP variant value, used as reference in struct snmp_node_instance and table implementation */
+union snmp_variant_value
+{
+  void* ptr;
+  const void* const_ptr;
+  u32_t u32;
+  s32_t s32;
+};
+
+
+/**
+SNMP MIB node types
+ tree node is the only node the stack can process in order to walk the tree,
+ all other nodes are assumed to be leaf nodes.
+ This cannot be an enum because users may want to define their own node types.
+*/
+#define SNMP_NODE_TREE         0x00
+/* predefined leaf node types */
+#define SNMP_NODE_SCALAR       0x01
+#define SNMP_NODE_SCALAR_ARRAY 0x02
+#define SNMP_NODE_TABLE        0x03
+#define SNMP_NODE_THREADSYNC   0x04
+
+/** node "base class" layout, the mandatory fields for a node  */
+struct snmp_node
+{
+  /** one out of SNMP_NODE_TREE or any leaf node type (like SNMP_NODE_SCALAR) */
+  u8_t node_type;
+  /** the number assigned to this node which used as part of the full OID */
+  u32_t oid;
+};
+
+/** SNMP node instance access types */
+typedef enum {
+  SNMP_NODE_INSTANCE_ACCESS_READ    = 1,
+  SNMP_NODE_INSTANCE_ACCESS_WRITE   = 2,
+  SNMP_NODE_INSTANCE_READ_ONLY      = SNMP_NODE_INSTANCE_ACCESS_READ,
+  SNMP_NODE_INSTANCE_READ_WRITE     = (SNMP_NODE_INSTANCE_ACCESS_READ | SNMP_NODE_INSTANCE_ACCESS_WRITE),
+  SNMP_NODE_INSTANCE_WRITE_ONLY     = SNMP_NODE_INSTANCE_ACCESS_WRITE,
+  SNMP_NODE_INSTANCE_NOT_ACCESSIBLE = 0
+} snmp_access_t;
+
+struct snmp_node_instance;
+
+typedef s16_t (*node_instance_get_value_method)(struct snmp_node_instance*, void*);
+typedef snmp_err_t (*node_instance_set_test_method)(struct snmp_node_instance*, u16_t, void*);
+typedef snmp_err_t (*node_instance_set_value_method)(struct snmp_node_instance*, u16_t, void*);
+typedef void (*node_instance_release_method)(struct snmp_node_instance*);
+
+#define SNMP_GET_VALUE_RAW_DATA 0x8000
+
+/** SNMP node instance */
+struct snmp_node_instance
+{
+  /** prefilled with the node, get_instance() is called on; may be changed by user to any value to pass an arbitrary node between calls to get_instance() and get_value/test_value/set_value */
+  const struct snmp_node* node;
+  /** prefilled with the instance id requested; for get_instance() this is the exact oid requested; for get_next_instance() this is the relative starting point, stack expects relative oid of next node here */
+  struct snmp_obj_id instance_oid;
+
+  /** ASN type for this object (see snmp_asn1.h for definitions) */
+  u8_t asn1_type;
+  /** one out of instance access types defined above (SNMP_NODE_INSTANCE_READ_ONLY,...) */
+  snmp_access_t access;
+
+  /** returns object value for the given object identifier. Return values <0 to indicate an error */
+  node_instance_get_value_method get_value;
+  /** tests length and/or range BEFORE setting */
+  node_instance_set_test_method set_test;
+  /** sets object value, only called when set_test() was successful */
+  node_instance_set_value_method set_value;
+  /** called in any case when the instance is not required anymore by stack (useful for freeing memory allocated in get_instance/get_next_instance methods) */
+  node_instance_release_method release_instance;
+
+  /** reference to pass arbitrary value between calls to get_instance() and get_value/test_value/set_value */
+  union snmp_variant_value reference;
+  /** see reference (if reference is a pointer, the length of underlying data may be stored here or anything else) */
+  u32_t reference_len;
+};
+
+
+/** SNMP tree node */
+struct snmp_tree_node
+{
+  /** inherited "base class" members */
+  struct snmp_node node;
+  u16_t subnode_count;
+  const struct snmp_node* const *subnodes;
+};
+
+#define SNMP_CREATE_TREE_NODE(oid, subnodes) \
+  {{ SNMP_NODE_TREE, (oid) }, \
+  (u16_t)LWIP_ARRAYSIZE(subnodes), (subnodes) }
+
+#define SNMP_CREATE_EMPTY_TREE_NODE(oid) \
+  {{ SNMP_NODE_TREE, (oid) }, \
+  0, NULL }
+
+/** SNMP leaf node */
+struct snmp_leaf_node
+{
+  /** inherited "base class" members */
+  struct snmp_node node;
+  snmp_err_t (*get_instance)(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance* instance);
+  snmp_err_t (*get_next_instance)(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance* instance);
+};
+
+/** represents a single mib with its base oid and root node */
+struct snmp_mib
+{
+  const u32_t *base_oid;
+  u8_t base_oid_len;
+  const struct snmp_node *root_node;
+};
+
+#define SNMP_MIB_CREATE(oid_list, root_node) { (oid_list), (u8_t)LWIP_ARRAYSIZE(oid_list), root_node }
+
+/** OID range structure */
+struct snmp_oid_range
+{
+  u32_t min;
+  u32_t max;
+};
+
+/** checks if incoming OID length and values are in allowed ranges */
+u8_t snmp_oid_in_range(const u32_t *oid_in, u8_t oid_len, const struct snmp_oid_range *oid_ranges, u8_t oid_ranges_len);
+
+typedef enum {
+  SNMP_NEXT_OID_STATUS_SUCCESS,
+  SNMP_NEXT_OID_STATUS_NO_MATCH,
+  SNMP_NEXT_OID_STATUS_BUF_TO_SMALL
+} snmp_next_oid_status_t;
+
+/** state for next_oid_init / next_oid_check functions */
+struct snmp_next_oid_state
+{
+  const u32_t* start_oid;
+  u8_t start_oid_len;
+
+  u32_t* next_oid;
+  u8_t next_oid_len;
+  u8_t next_oid_max_len;
+
+  snmp_next_oid_status_t status;
+  void* reference;
+};
+
+void snmp_next_oid_init(struct snmp_next_oid_state *state,
+  const u32_t *start_oid, u8_t start_oid_len,
+  u32_t *next_oid_buf, u8_t next_oid_max_len);
+u8_t snmp_next_oid_precheck(struct snmp_next_oid_state *state, const u32_t *oid, const u8_t oid_len);
+u8_t snmp_next_oid_check(struct snmp_next_oid_state *state, const u32_t *oid, const u8_t oid_len, void* reference);
+
+void snmp_oid_assign(struct snmp_obj_id* target, const u32_t *oid, u8_t oid_len);
+void snmp_oid_combine(struct snmp_obj_id* target, const u32_t *oid1, u8_t oid1_len, const u32_t *oid2, u8_t oid2_len);
+void snmp_oid_prefix(struct snmp_obj_id* target, const u32_t *oid, u8_t oid_len);
+void snmp_oid_append(struct snmp_obj_id* target, const u32_t *oid, u8_t oid_len);
+u8_t snmp_oid_equal(const u32_t *oid1, u8_t oid1_len, const u32_t *oid2, u8_t oid2_len);
+s8_t snmp_oid_compare(const u32_t *oid1, u8_t oid1_len, const u32_t *oid2, u8_t oid2_len);
+
+#if LWIP_IPV4
+u8_t snmp_oid_to_ip4(const u32_t *oid, ip4_addr_t *ip);
+void snmp_ip4_to_oid(const ip4_addr_t *ip, u32_t *oid);
+#endif /* LWIP_IPV4 */
+#if LWIP_IPV6
+u8_t snmp_oid_to_ip6(const u32_t *oid, ip6_addr_t *ip);
+void snmp_ip6_to_oid(const ip6_addr_t *ip, u32_t *oid);
+#endif /* LWIP_IPV6 */
+#if LWIP_IPV4 || LWIP_IPV6
+u8_t snmp_ip_to_oid(const ip_addr_t *ip, u32_t *oid);
+u8_t snmp_ip_port_to_oid(const ip_addr_t *ip, u16_t port, u32_t *oid);
+
+u8_t snmp_oid_to_ip(const u32_t *oid, u8_t oid_len, ip_addr_t *ip);
+u8_t snmp_oid_to_ip_port(const u32_t *oid, u8_t oid_len, ip_addr_t *ip, u16_t *port);
+#endif /* LWIP_IPV4 || LWIP_IPV6 */
+
+struct netif;
+u8_t netif_to_num(const struct netif *netif);
+
+snmp_err_t snmp_set_test_ok(struct snmp_node_instance* instance, u16_t value_len, void* value); /* generic function which can be used if test is always successful */
+
+err_t snmp_decode_bits(const u8_t *buf, u32_t buf_len, u32_t *bit_value);
+err_t snmp_decode_truthvalue(const s32_t *asn1_value, u8_t *bool_value);
+u8_t  snmp_encode_bits(u8_t *buf, u32_t buf_len, u32_t bit_value, u8_t bit_count);
+u8_t  snmp_encode_truthvalue(s32_t *asn1_value, u32_t bool_value);
+
+struct snmp_statistics
+{
+  u32_t inpkts;
+  u32_t outpkts;
+  u32_t inbadversions;
+  u32_t inbadcommunitynames;
+  u32_t inbadcommunityuses;
+  u32_t inasnparseerrs;
+  u32_t intoobigs;
+  u32_t innosuchnames;
+  u32_t inbadvalues;
+  u32_t inreadonlys;
+  u32_t ingenerrs;
+  u32_t intotalreqvars;
+  u32_t intotalsetvars;
+  u32_t ingetrequests;
+  u32_t ingetnexts;
+  u32_t insetrequests;
+  u32_t ingetresponses;
+  u32_t intraps;
+  u32_t outtoobigs;
+  u32_t outnosuchnames;
+  u32_t outbadvalues;
+  u32_t outgenerrs;
+  u32_t outgetrequests;
+  u32_t outgetnexts;
+  u32_t outsetrequests;
+  u32_t outgetresponses;
+  u32_t outtraps;
+};
+
+extern struct snmp_statistics snmp_stats;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_SNMP */
+
+#endif /* LWIP_HDR_APPS_SNMP_CORE_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/snmp_mib2.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/snmp_mib2.h
new file mode 100644
index 000000000..2f4a68935
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/snmp_mib2.h
@@ -0,0 +1,78 @@
+/**
+ * @file
+ * SNMP MIB2 API
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Dirk Ziegelmeier <dziegel@gmx.de>
+ *
+ */
+#ifndef LWIP_HDR_APPS_SNMP_MIB2_H
+#define LWIP_HDR_APPS_SNMP_MIB2_H
+
+#include "lwip/apps/snmp_opts.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_SNMP /* don't build if not configured for use in lwipopts.h */
+#if SNMP_LWIP_MIB2
+
+#include "lwip/apps/snmp_core.h"
+
+extern const struct snmp_mib mib2;
+
+#if SNMP_USE_NETCONN
+#include "lwip/apps/snmp_threadsync.h"
+void snmp_mib2_lwip_synchronizer(snmp_threadsync_called_fn fn, void* arg);
+extern struct snmp_threadsync_instance snmp_mib2_lwip_locks;
+#endif
+
+#ifndef SNMP_SYSSERVICES
+#define SNMP_SYSSERVICES ((1 << 6) | (1 << 3) | ((IP_FORWARD) << 2))
+#endif
+
+void snmp_mib2_set_sysdescr(const u8_t* str, const u16_t* len); /* read-only be defintion */
+void snmp_mib2_set_syscontact(u8_t *ocstr, u16_t *ocstrlen, u16_t bufsize);
+void snmp_mib2_set_syscontact_readonly(const u8_t *ocstr, const u16_t *ocstrlen);
+void snmp_mib2_set_sysname(u8_t *ocstr, u16_t *ocstrlen, u16_t bufsize);
+void snmp_mib2_set_sysname_readonly(const u8_t *ocstr, const u16_t *ocstrlen);
+void snmp_mib2_set_syslocation(u8_t *ocstr, u16_t *ocstrlen, u16_t bufsize);
+void snmp_mib2_set_syslocation_readonly(const u8_t *ocstr, const u16_t *ocstrlen);
+
+#endif /* SNMP_LWIP_MIB2 */
+#endif /* LWIP_SNMP */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_APPS_SNMP_MIB2_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/snmp_opts.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/snmp_opts.h
new file mode 100644
index 000000000..6c9ba7beb
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/snmp_opts.h
@@ -0,0 +1,293 @@
+/**
+ * @file
+ * SNMP server options list
+ */
+
+/*
+ * Copyright (c) 2015 Dirk Ziegelmeier
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Dirk Ziegelmeier
+ *
+ */
+#ifndef LWIP_HDR_SNMP_OPTS_H
+#define LWIP_HDR_SNMP_OPTS_H
+
+#include "lwip/opt.h"
+
+/**
+ * @defgroup snmp_opts Options
+ * @ingroup snmp
+ * @{
+ */
+
+/**
+ * LWIP_SNMP==1: This enables the lwIP SNMP agent. UDP must be available
+ * for SNMP transport.
+ * If you want to use your own SNMP agent, leave this disabled.
+ * To integrate MIB2 of an external agent, you need to enable
+ * LWIP_MIB2_CALLBACKS and MIB2_STATS. This will give you the callbacks
+ * and statistics counters you need to get MIB2 working.
+ */
+#if !defined LWIP_SNMP || defined __DOXYGEN__
+#define LWIP_SNMP                       0
+#endif
+
+/**
+ * SNMP_USE_NETCONN: Use netconn API instead of raw API.
+ * Makes SNMP agent run in a worker thread, so blocking operations
+ * can be done in MIB calls.
+ */
+#if !defined SNMP_USE_NETCONN || defined __DOXYGEN__
+#define SNMP_USE_NETCONN           0
+#endif
+
+/**
+ * SNMP_USE_RAW: Use raw API.
+ * SNMP agent does not run in a worker thread, so blocking operations
+ * should not be done in MIB calls.
+ */
+#if !defined SNMP_USE_RAW || defined __DOXYGEN__
+#define SNMP_USE_RAW               1
+#endif
+
+#if SNMP_USE_NETCONN && SNMP_USE_RAW
+#error SNMP stack can use only one of the APIs {raw, netconn}
+#endif
+
+#if LWIP_SNMP && !SNMP_USE_NETCONN && !SNMP_USE_RAW
+#error SNMP stack needs a receive API and UDP {raw, netconn}
+#endif
+
+#if SNMP_USE_NETCONN
+/**
+ * SNMP_STACK_SIZE: Stack size of SNMP netconn worker thread
+ */
+#if !defined SNMP_STACK_SIZE || defined __DOXYGEN__
+#define SNMP_STACK_SIZE            DEFAULT_THREAD_STACKSIZE
+#endif
+
+/**
+ * SNMP_THREAD_PRIO: SNMP netconn worker thread priority
+ */
+#if !defined SNMP_THREAD_PRIO || defined __DOXYGEN__
+#define SNMP_THREAD_PRIO           DEFAULT_THREAD_PRIO
+#endif
+#endif /* SNMP_USE_NETCONN */
+
+/**
+ * SNMP_TRAP_DESTINATIONS: Number of trap destinations. At least one trap
+ * destination is required
+ */
+#if !defined SNMP_TRAP_DESTINATIONS || defined __DOXYGEN__
+#define SNMP_TRAP_DESTINATIONS          1
+#endif
+
+/**
+ * Only allow SNMP write actions that are 'safe' (e.g. disabling netifs is not
+ * a safe action and disabled when SNMP_SAFE_REQUESTS = 1).
+ * Unsafe requests are disabled by default!
+ */
+#if !defined SNMP_SAFE_REQUESTS || defined __DOXYGEN__
+#define SNMP_SAFE_REQUESTS              1
+#endif
+
+/**
+ * The maximum length of strings used.
+ */
+#if !defined SNMP_MAX_OCTET_STRING_LEN || defined __DOXYGEN__
+#define SNMP_MAX_OCTET_STRING_LEN       127
+#endif
+
+/**
+ * The maximum number of Sub ID's inside an object identifier.
+ * Indirectly this also limits the maximum depth of SNMP tree.
+ */
+#if !defined SNMP_MAX_OBJ_ID_LEN || defined __DOXYGEN__
+#define SNMP_MAX_OBJ_ID_LEN             50
+#endif
+
+#if !defined SNMP_MAX_VALUE_SIZE || defined __DOXYGEN__
+/**
+ * The maximum size of a value.
+ */
+#define SNMP_MIN_VALUE_SIZE             (2 * sizeof(u32_t*)) /* size required to store the basic types (8 bytes for counter64) */
+/**
+ * The minimum size of a value.
+ */
+#define SNMP_MAX_VALUE_SIZE             LWIP_MAX(LWIP_MAX((SNMP_MAX_OCTET_STRING_LEN), sizeof(u32_t)*(SNMP_MAX_OBJ_ID_LEN)), SNMP_MIN_VALUE_SIZE)
+#endif
+
+/**
+ * The snmp read-access community. Used for write-access and traps, too
+ * unless SNMP_COMMUNITY_WRITE or SNMP_COMMUNITY_TRAP are enabled, respectively.
+ */
+#if !defined SNMP_COMMUNITY || defined __DOXYGEN__
+#define SNMP_COMMUNITY                  "public"
+#endif
+
+/**
+ * The snmp write-access community.
+ * Set this community to "" in order to disallow any write access.
+ */
+#if !defined SNMP_COMMUNITY_WRITE || defined __DOXYGEN__
+#define SNMP_COMMUNITY_WRITE            "private"
+#endif
+
+/**
+ * The snmp community used for sending traps.
+ */
+#if !defined SNMP_COMMUNITY_TRAP || defined __DOXYGEN__
+#define SNMP_COMMUNITY_TRAP             "public"
+#endif
+
+/**
+ * The maximum length of community string.
+ * If community names shall be adjusted at runtime via snmp_set_community() calls,
+ * enter here the possible maximum length (+1 for terminating null character).
+ */
+#if !defined SNMP_MAX_COMMUNITY_STR_LEN || defined __DOXYGEN__
+#define SNMP_MAX_COMMUNITY_STR_LEN LWIP_MAX(LWIP_MAX(sizeof(SNMP_COMMUNITY), sizeof(SNMP_COMMUNITY_WRITE)), sizeof(SNMP_COMMUNITY_TRAP))
+#endif
+
+/**
+ * The OID identifiying the device. This may be the enterprise OID itself or any OID located below it in tree.
+ */
+#if !defined SNMP_DEVICE_ENTERPRISE_OID || defined __DOXYGEN__
+#define SNMP_LWIP_ENTERPRISE_OID 26381
+/**
+ * IANA assigned enterprise ID for lwIP is 26381
+ * @see http://www.iana.org/assignments/enterprise-numbers
+ *
+ * @note this enterprise ID is assigned to the lwIP project,
+ * all object identifiers living under this ID are assigned
+ * by the lwIP maintainers!
+ * @note don't change this define, use snmp_set_device_enterprise_oid()
+ *
+ * If you need to create your own private MIB you'll need
+ * to apply for your own enterprise ID with IANA:
+ * http://www.iana.org/numbers.html
+ */
+#define SNMP_DEVICE_ENTERPRISE_OID {1, 3, 6, 1, 4, 1, SNMP_LWIP_ENTERPRISE_OID}
+/**
+ * Length of SNMP_DEVICE_ENTERPRISE_OID
+ */
+#define SNMP_DEVICE_ENTERPRISE_OID_LEN 7
+#endif
+
+/**
+ * SNMP_DEBUG: Enable debugging for SNMP messages.
+ */
+#if !defined SNMP_DEBUG || defined __DOXYGEN__
+#define SNMP_DEBUG                      LWIP_DBG_OFF
+#endif
+
+/**
+ * SNMP_MIB_DEBUG: Enable debugging for SNMP MIBs.
+ */
+#if !defined SNMP_MIB_DEBUG || defined __DOXYGEN__
+#define SNMP_MIB_DEBUG                  LWIP_DBG_OFF
+#endif
+
+/**
+ * Indicates if the MIB2 implementation of LWIP SNMP stack is used.
+ */
+#if !defined SNMP_LWIP_MIB2 || defined __DOXYGEN__
+#define SNMP_LWIP_MIB2                      LWIP_SNMP
+#endif
+
+/**
+ * Value return for sysDesc field of MIB2.
+ */
+#if !defined SNMP_LWIP_MIB2_SYSDESC || defined __DOXYGEN__
+#define SNMP_LWIP_MIB2_SYSDESC              "lwIP"
+#endif
+
+/**
+ * Value return for sysName field of MIB2.
+ * To make sysName field settable, call snmp_mib2_set_sysname() to provide the necessary buffers.
+ */
+#if !defined SNMP_LWIP_MIB2_SYSNAME || defined __DOXYGEN__
+#define SNMP_LWIP_MIB2_SYSNAME              "FQDN-unk"
+#endif
+
+/**
+ * Value return for sysContact field of MIB2.
+ * To make sysContact field settable, call snmp_mib2_set_syscontact() to provide the necessary buffers.
+ */
+#if !defined SNMP_LWIP_MIB2_SYSCONTACT || defined __DOXYGEN__
+#define SNMP_LWIP_MIB2_SYSCONTACT           ""
+#endif
+
+/**
+ * Value return for sysLocation field of MIB2.
+ * To make sysLocation field settable, call snmp_mib2_set_syslocation() to provide the necessary buffers.
+ */
+#if !defined SNMP_LWIP_MIB2_SYSLOCATION || defined __DOXYGEN__
+#define SNMP_LWIP_MIB2_SYSLOCATION          ""
+#endif
+
+/**
+ * This value is used to limit the repetitions processed in GetBulk requests (value == 0 means no limitation).
+ * This may be useful to limit the load for a single request.
+ * According to SNMP RFC 1905 it is allowed to not return all requested variables from a GetBulk request if system load would be too high.
+ * so the effect is that the client will do more requests to gather all data.
+ * For the stack this could be useful in case that SNMP processing is done in TCP/IP thread. In this situation a request with many
+ * repetitions could block the thread for a longer time. Setting limit here will keep the stack more responsive.
+ */
+#if !defined SNMP_LWIP_GETBULK_MAX_REPETITIONS || defined __DOXYGEN__
+#define SNMP_LWIP_GETBULK_MAX_REPETITIONS 0
+#endif
+
+/**
+ * @}
+ */
+
+/*
+   ------------------------------------
+   ---------- SNMPv3 options ----------
+   ------------------------------------
+*/
+
+/**
+ * LWIP_SNMP_V3==1: This enables EXPERIMENTAL SNMPv3 support. LWIP_SNMP must
+ * also be enabled.
+ * THIS IS UNDER DEVELOPMENT AND SHOULD NOT BE ENABLED IN PRODUCTS.
+ */
+#ifndef LWIP_SNMP_V3
+#define LWIP_SNMP_V3               0
+#endif
+
+#ifndef LWIP_SNMP_V3_CRYPTO
+#define LWIP_SNMP_V3_CRYPTO        LWIP_SNMP_V3
+#endif
+
+#ifndef LWIP_SNMP_V3_MBEDTLS
+#define LWIP_SNMP_V3_MBEDTLS       LWIP_SNMP_V3
+#endif
+
+#endif /* LWIP_HDR_SNMP_OPTS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/snmp_scalar.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/snmp_scalar.h
new file mode 100644
index 000000000..40a060c64
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/snmp_scalar.h
@@ -0,0 +1,113 @@
+/**
+ * @file
+ * SNMP server MIB API to implement scalar nodes
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Martin Hentschel <info@cl-soft.de>
+ *
+ */
+
+#ifndef LWIP_HDR_APPS_SNMP_SCALAR_H
+#define LWIP_HDR_APPS_SNMP_SCALAR_H
+
+#include "lwip/apps/snmp_opts.h"
+#include "lwip/apps/snmp_core.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_SNMP /* don't build if not configured for use in lwipopts.h */
+
+/** basic scalar node */
+struct snmp_scalar_node
+{
+  /** inherited "base class" members */
+  struct snmp_leaf_node node;
+  u8_t asn1_type;
+  snmp_access_t access;
+  node_instance_get_value_method get_value;
+  node_instance_set_test_method set_test;
+  node_instance_set_value_method set_value;
+};
+
+
+snmp_err_t snmp_scalar_get_instance(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance* instance);
+snmp_err_t snmp_scalar_get_next_instance(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance* instance);
+
+#define SNMP_SCALAR_CREATE_NODE(oid, access, asn1_type, get_value_method, set_test_method, set_value_method) \
+  {{{ SNMP_NODE_SCALAR, (oid) }, \
+    snmp_scalar_get_instance, \
+    snmp_scalar_get_next_instance }, \
+    (asn1_type), (access), (get_value_method), (set_test_method), (set_value_method) }
+
+#define SNMP_SCALAR_CREATE_NODE_READONLY(oid, asn1_type, get_value_method) SNMP_SCALAR_CREATE_NODE(oid, SNMP_NODE_INSTANCE_READ_ONLY, asn1_type, get_value_method, NULL, NULL)
+
+/** scalar array node - a tree node which contains scalars only as children */
+struct snmp_scalar_array_node_def
+{
+  u32_t         oid;
+  u8_t          asn1_type;
+  snmp_access_t access;
+};
+
+typedef s16_t (*snmp_scalar_array_get_value_method)(const struct snmp_scalar_array_node_def*, void*);
+typedef snmp_err_t (*snmp_scalar_array_set_test_method)(const struct snmp_scalar_array_node_def*, u16_t, void*);
+typedef snmp_err_t (*snmp_scalar_array_set_value_method)(const struct snmp_scalar_array_node_def*, u16_t, void*);
+
+/** basic scalar array node */
+struct snmp_scalar_array_node
+{
+  /** inherited "base class" members */
+  struct snmp_leaf_node node;
+  u16_t array_node_count;
+  const struct snmp_scalar_array_node_def* array_nodes;
+  snmp_scalar_array_get_value_method get_value;
+  snmp_scalar_array_set_test_method set_test;
+  snmp_scalar_array_set_value_method set_value;
+};
+
+snmp_err_t snmp_scalar_array_get_instance(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance* instance);
+snmp_err_t snmp_scalar_array_get_next_instance(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance* instance);
+
+#define SNMP_SCALAR_CREATE_ARRAY_NODE(oid, array_nodes, get_value_method, set_test_method, set_value_method) \
+  {{{ SNMP_NODE_SCALAR_ARRAY, (oid) }, \
+    snmp_scalar_array_get_instance, \
+    snmp_scalar_array_get_next_instance }, \
+    (u16_t)LWIP_ARRAYSIZE(array_nodes), (array_nodes), (get_value_method), (set_test_method), (set_value_method) }
+
+#endif /* LWIP_SNMP */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_APPS_SNMP_SCALAR_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/snmp_table.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/snmp_table.h
new file mode 100644
index 000000000..4988b51c2
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/snmp_table.h
@@ -0,0 +1,134 @@
+/**
+ * @file
+ * SNMP server MIB API to implement table nodes
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Martin Hentschel <info@cl-soft.de>
+ *
+ */
+
+#ifndef LWIP_HDR_APPS_SNMP_TABLE_H
+#define LWIP_HDR_APPS_SNMP_TABLE_H
+
+#include "lwip/apps/snmp_opts.h"
+#include "lwip/apps/snmp_core.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_SNMP /* don't build if not configured for use in lwipopts.h */
+
+/** default (customizable) read/write table */
+struct snmp_table_col_def
+{
+  u32_t index;
+  u8_t asn1_type;
+  snmp_access_t access;
+};
+
+/** table node */
+struct snmp_table_node
+{
+  /** inherited "base class" members */
+  struct snmp_leaf_node node;
+  u16_t column_count;
+  const struct snmp_table_col_def* columns;
+  snmp_err_t (*get_cell_instance)(const u32_t* column, const u32_t* row_oid, u8_t row_oid_len, struct snmp_node_instance* cell_instance);
+  snmp_err_t (*get_next_cell_instance)(const u32_t* column, struct snmp_obj_id* row_oid, struct snmp_node_instance* cell_instance);
+  /** returns object value for the given object identifier */
+  node_instance_get_value_method get_value;
+  /** tests length and/or range BEFORE setting */
+  node_instance_set_test_method set_test;
+  /** sets object value, only called when set_test() was successful */
+  node_instance_set_value_method set_value;
+};
+
+snmp_err_t snmp_table_get_instance(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance* instance);
+snmp_err_t snmp_table_get_next_instance(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance* instance);
+
+#define SNMP_TABLE_CREATE(oid, columns, get_cell_instance_method, get_next_cell_instance_method, get_value_method, set_test_method, set_value_method) \
+  {{{ SNMP_NODE_TABLE, (oid) }, \
+  snmp_table_get_instance, \
+  snmp_table_get_next_instance }, \
+  (u16_t)LWIP_ARRAYSIZE(columns), (columns), \
+  (get_cell_instance_method), (get_next_cell_instance_method), \
+  (get_value_method), (set_test_method), (set_value_method)}
+
+#define SNMP_TABLE_GET_COLUMN_FROM_OID(oid) ((oid)[1]) /* first array value is (fixed) row entry (fixed to 1) and 2nd value is column, follow3ed by instance */
+
+
+/** simple read-only table */
+typedef enum {
+  SNMP_VARIANT_VALUE_TYPE_U32,
+  SNMP_VARIANT_VALUE_TYPE_S32,
+  SNMP_VARIANT_VALUE_TYPE_PTR,
+  SNMP_VARIANT_VALUE_TYPE_CONST_PTR
+} snmp_table_column_data_type_t;
+
+struct snmp_table_simple_col_def
+{
+  u32_t index;
+  u8_t asn1_type;
+  snmp_table_column_data_type_t data_type; /* depending of what union member is used to store the value*/
+};
+
+/** simple read-only table node */
+struct snmp_table_simple_node
+{
+  /* inherited "base class" members */
+  struct snmp_leaf_node node;
+  u16_t column_count;
+  const struct snmp_table_simple_col_def* columns;
+  snmp_err_t (*get_cell_value)(const u32_t* column, const u32_t* row_oid, u8_t row_oid_len, union snmp_variant_value* value, u32_t* value_len);
+  snmp_err_t (*get_next_cell_instance_and_value)(const u32_t* column, struct snmp_obj_id* row_oid, union snmp_variant_value* value, u32_t* value_len);
+};
+
+snmp_err_t snmp_table_simple_get_instance(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance* instance);
+snmp_err_t snmp_table_simple_get_next_instance(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance* instance);
+
+#define SNMP_TABLE_CREATE_SIMPLE(oid, columns, get_cell_value_method, get_next_cell_instance_and_value_method) \
+  {{{ SNMP_NODE_TABLE, (oid) }, \
+  snmp_table_simple_get_instance, \
+  snmp_table_simple_get_next_instance }, \
+  (u16_t)LWIP_ARRAYSIZE(columns), (columns), (get_cell_value_method), (get_next_cell_instance_and_value_method) }
+
+s16_t snmp_table_extract_value_from_s32ref(struct snmp_node_instance* instance, void* value);
+s16_t snmp_table_extract_value_from_u32ref(struct snmp_node_instance* instance, void* value);
+s16_t snmp_table_extract_value_from_refconstptr(struct snmp_node_instance* instance, void* value);
+
+#endif /* LWIP_SNMP */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_APPS_SNMP_TABLE_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/snmp_threadsync.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/snmp_threadsync.h
new file mode 100644
index 000000000..a25dbf2d0
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/snmp_threadsync.h
@@ -0,0 +1,114 @@
+/**
+ * @file
+ * SNMP server MIB API to implement thread synchronization
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Dirk Ziegelmeier <dziegel@gmx.de>
+ *
+ */
+
+#ifndef LWIP_HDR_APPS_SNMP_THREADSYNC_H
+#define LWIP_HDR_APPS_SNMP_THREADSYNC_H
+
+#include "lwip/apps/snmp_opts.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_SNMP /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/apps/snmp_core.h"
+#include "lwip/sys.h"
+
+typedef void (*snmp_threadsync_called_fn)(void* arg);
+typedef void (*snmp_threadsync_synchronizer_fn)(snmp_threadsync_called_fn fn, void* arg);
+
+
+/** Thread sync runtime data. For internal usage only. */
+struct threadsync_data
+{
+  union {
+    snmp_err_t err;
+    s16_t s16;
+  } retval;
+  union {
+    const u32_t *root_oid;
+    void *value;
+  } arg1;
+  union {
+    u8_t root_oid_len;
+    u16_t len;
+  } arg2;
+  const struct snmp_threadsync_node *threadsync_node;
+  struct snmp_node_instance proxy_instance;
+};
+
+/** Thread sync instance. Needed EXCATLY once for every thread to be synced into. */
+struct snmp_threadsync_instance
+{
+  sys_sem_t                       sem;
+  sys_mutex_t                     sem_usage_mutex;
+  snmp_threadsync_synchronizer_fn sync_fn;
+  struct threadsync_data          data;
+};
+
+/** SNMP thread sync proxy leaf node */
+struct snmp_threadsync_node
+{
+  /* inherited "base class" members */
+  struct snmp_leaf_node           node;
+
+  const struct snmp_leaf_node     *target;
+  struct snmp_threadsync_instance *instance;
+};
+
+snmp_err_t snmp_threadsync_get_instance(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance* instance);
+snmp_err_t snmp_threadsync_get_next_instance(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance* instance);
+
+/** Create thread sync proxy node */
+#define SNMP_CREATE_THREAD_SYNC_NODE(oid, target_leaf_node, threadsync_instance) \
+  {{{ SNMP_NODE_THREADSYNC, (oid) }, \
+    snmp_threadsync_get_instance, \
+    snmp_threadsync_get_next_instance }, \
+    (target_leaf_node), \
+    (threadsync_instance) }
+
+/** Create thread sync instance data */
+void snmp_threadsync_init(struct snmp_threadsync_instance *instance, snmp_threadsync_synchronizer_fn sync_fn);
+
+#endif /* LWIP_SNMP */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_APPS_SNMP_THREADSYNC_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/snmpv3.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/snmpv3.h
new file mode 100644
index 000000000..c99fed4e1
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/snmpv3.h
@@ -0,0 +1,90 @@
+/**
+ * @file
+ * Additional SNMPv3 functionality RFC3414 and RFC3826.
+ */
+
+/*
+ * Copyright (c) 2016 Elias Oenal.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * Author: Elias Oenal <lwip@eliasoenal.com>
+ */
+
+#ifndef LWIP_HDR_APPS_SNMP_V3_H
+#define LWIP_HDR_APPS_SNMP_V3_H
+
+#include "lwip/apps/snmp_opts.h"
+#include "lwip/err.h"
+
+#if LWIP_SNMP && LWIP_SNMP_V3
+
+#define SNMP_V3_AUTH_ALGO_INVAL  0
+#define SNMP_V3_AUTH_ALGO_MD5    1
+#define SNMP_V3_AUTH_ALGO_SHA    2
+
+#define SNMP_V3_PRIV_ALGO_INVAL  0
+#define SNMP_V3_PRIV_ALGO_DES    1
+#define SNMP_V3_PRIV_ALGO_AES    2
+
+#define SNMP_V3_PRIV_MODE_DECRYPT  0
+#define SNMP_V3_PRIV_MODE_ENCRYPT  1
+
+/*
+ * The following callback functions must be implemented by the application.
+ * There is a dummy implementation in snmpv3_dummy.c.
+ */
+
+void snmpv3_get_engine_id(const char **id, u8_t *len);
+err_t snmpv3_set_engine_id(const char* id, u8_t len);
+
+u32_t snmpv3_get_engine_boots(void);
+void snmpv3_set_engine_boots(u32_t boots);
+
+u32_t snmpv3_get_engine_time(void);
+void snmpv3_reset_engine_time(void);
+
+err_t snmpv3_get_user(const char* username, u8_t *auth_algo, u8_t *auth_key, u8_t *priv_algo, u8_t *priv_key);
+
+/* The following functions are provided by the SNMPv3 agent */
+
+void snmpv3_engine_id_changed(void);
+
+void snmpv3_password_to_key_md5(
+    const u8_t *password,     /* IN */
+    u8_t        passwordlen,  /* IN */
+    const u8_t *engineID,     /* IN  - pointer to snmpEngineID  */
+    u8_t        engineLength, /* IN  - length of snmpEngineID */
+    u8_t       *key);         /* OUT - pointer to caller 16-octet buffer */
+
+void snmpv3_password_to_key_sha(
+    const u8_t *password,     /* IN */
+    u8_t        passwordlen,  /* IN */
+    const u8_t *engineID,     /* IN  - pointer to snmpEngineID  */
+    u8_t        engineLength, /* IN  - length of snmpEngineID */
+    u8_t       *key);         /* OUT - pointer to caller 20-octet buffer */
+
+#endif
+
+#endif /* LWIP_HDR_APPS_SNMP_V3_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/sntp.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/sntp.h
new file mode 100644
index 000000000..40df9cc59
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/sntp.h
@@ -0,0 +1,76 @@
+/**
+ * @file
+ * SNTP client API
+ */
+
+/*
+ * Copyright (c) 2007-2009 Frédéric Bernon, Simon Goldschmidt
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Frédéric Bernon, Simon Goldschmidt
+ *
+ */
+#ifndef LWIP_HDR_APPS_SNTP_H
+#define LWIP_HDR_APPS_SNTP_H
+
+#include "lwip/apps/sntp_opts.h"
+#include "lwip/ip_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* SNTP operating modes: default is to poll using unicast.
+   The mode has to be set before calling sntp_init(). */
+#define SNTP_OPMODE_POLL            0
+#define SNTP_OPMODE_LISTENONLY      1
+void sntp_setoperatingmode(u8_t operating_mode);
+u8_t sntp_getoperatingmode(void);
+
+void sntp_init(void);
+void sntp_stop(void);
+u8_t sntp_enabled(void);
+
+void sntp_setserver(u8_t idx, const ip_addr_t *addr);
+const ip_addr_t* sntp_getserver(u8_t idx);
+
+#if SNTP_SERVER_DNS
+void sntp_setservername(u8_t idx, char *server);
+char *sntp_getservername(u8_t idx);
+#endif /* SNTP_SERVER_DNS */
+
+#if SNTP_GET_SERVERS_FROM_DHCP
+void sntp_servermode_dhcp(int set_servers_from_dhcp);
+#else /* SNTP_GET_SERVERS_FROM_DHCP */
+#define sntp_servermode_dhcp(x)
+#endif /* SNTP_GET_SERVERS_FROM_DHCP */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_APPS_SNTP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/sntp_opts.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/sntp_opts.h
new file mode 100644
index 000000000..f3651f90e
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/sntp_opts.h
@@ -0,0 +1,173 @@
+/**
+ * @file
+ * SNTP client options list
+ */
+
+/*
+ * Copyright (c) 2007-2009 Frédéric Bernon, Simon Goldschmidt
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Frédéric Bernon, Simon Goldschmidt
+ *
+ */
+#ifndef LWIP_HDR_APPS_SNTP_OPTS_H
+#define LWIP_HDR_APPS_SNTP_OPTS_H
+
+#include "lwip/opt.h"
+
+/**
+ * @defgroup sntp_opts Options
+ * @ingroup sntp
+ * @{
+ */
+
+/** SNTP macro to change system time in seconds
+ * Define SNTP_SET_SYSTEM_TIME_US(sec, us) to set the time in microseconds instead of this one
+ * if you need the additional precision.
+ */
+#if !defined SNTP_SET_SYSTEM_TIME || defined __DOXYGEN__
+#define SNTP_SET_SYSTEM_TIME(sec)   LWIP_UNUSED_ARG(sec)
+#endif
+
+/** The maximum number of SNTP servers that can be set */
+#if !defined SNTP_MAX_SERVERS || defined __DOXYGEN__
+#define SNTP_MAX_SERVERS           LWIP_DHCP_MAX_NTP_SERVERS
+#endif
+
+/** Set this to 1 to implement the callback function called by dhcp when
+ * NTP servers are received. */
+#if !defined SNTP_GET_SERVERS_FROM_DHCP || defined __DOXYGEN__
+#define SNTP_GET_SERVERS_FROM_DHCP LWIP_DHCP_GET_NTP_SRV
+#endif
+
+/** Set this to 1 to support DNS names (or IP address strings) to set sntp servers
+ * One server address/name can be defined as default if SNTP_SERVER_DNS == 1:
+ * \#define SNTP_SERVER_ADDRESS "pool.ntp.org"
+ */
+#if !defined SNTP_SERVER_DNS || defined __DOXYGEN__
+#define SNTP_SERVER_DNS            0
+#endif
+
+/**
+ * SNTP_DEBUG: Enable debugging for SNTP.
+ */
+#if !defined SNTP_DEBUG || defined __DOXYGEN__
+#define SNTP_DEBUG                  LWIP_DBG_OFF
+#endif
+
+/** SNTP server port */
+#if !defined SNTP_PORT || defined __DOXYGEN__
+#define SNTP_PORT                   123
+#endif
+
+/** Set this to 1 to allow config of SNTP server(s) by DNS name */
+#if !defined SNTP_SERVER_DNS || defined __DOXYGEN__
+#define SNTP_SERVER_DNS             0
+#endif
+
+/** Sanity check:
+ * Define this to
+ * - 0 to turn off sanity checks (default; smaller code)
+ * - >= 1 to check address and port of the response packet to ensure the
+ *        response comes from the server we sent the request to.
+ * - >= 2 to check returned Originate Timestamp against Transmit Timestamp
+ *        sent to the server (to ensure response to older request).
+ * - >= 3 @todo: discard reply if any of the LI, Stratum, or Transmit Timestamp
+ *        fields is 0 or the Mode field is not 4 (unicast) or 5 (broadcast).
+ * - >= 4 @todo: to check that the Root Delay and Root Dispersion fields are each
+ *        greater than or equal to 0 and less than infinity, where infinity is
+ *        currently a cozy number like one second. This check avoids using a
+ *        server whose synchronization source has expired for a very long time.
+ */
+#if !defined SNTP_CHECK_RESPONSE || defined __DOXYGEN__
+#define SNTP_CHECK_RESPONSE         0
+#endif
+
+/** According to the RFC, this shall be a random delay
+ * between 1 and 5 minutes (in milliseconds) to prevent load peaks.
+ * This can be defined to a random generation function,
+ * which must return the delay in milliseconds as u32_t.
+ * Turned off by default.
+ */
+#if !defined SNTP_STARTUP_DELAY || defined __DOXYGEN__
+#define SNTP_STARTUP_DELAY          0
+#endif
+
+/** If you want the startup delay to be a function, define this
+ * to a function (including the brackets) and define SNTP_STARTUP_DELAY to 1.
+ */
+#if !defined SNTP_STARTUP_DELAY_FUNC || defined __DOXYGEN__
+#define SNTP_STARTUP_DELAY_FUNC     SNTP_STARTUP_DELAY
+#endif
+
+/** SNTP receive timeout - in milliseconds
+ * Also used as retry timeout - this shouldn't be too low.
+ * Default is 3 seconds.
+ */
+#if !defined SNTP_RECV_TIMEOUT || defined __DOXYGEN__
+#define SNTP_RECV_TIMEOUT           3000
+#endif
+
+/** SNTP update delay - in milliseconds
+ * Default is 1 hour. Must not be beolw 15 seconds by specification (i.e. 15000)
+ */
+#if !defined SNTP_UPDATE_DELAY || defined __DOXYGEN__
+#define SNTP_UPDATE_DELAY           3600000
+#endif
+
+/** SNTP macro to get system time, used with SNTP_CHECK_RESPONSE >= 2
+ * to send in request and compare in response.
+ */
+#if !defined SNTP_GET_SYSTEM_TIME || defined __DOXYGEN__
+#define SNTP_GET_SYSTEM_TIME(sec, us)     do { (sec) = 0; (us) = 0; } while(0)
+#endif
+
+/** Default retry timeout (in milliseconds) if the response
+ * received is invalid.
+ * This is doubled with each retry until SNTP_RETRY_TIMEOUT_MAX is reached.
+ */
+#if !defined SNTP_RETRY_TIMEOUT || defined __DOXYGEN__
+#define SNTP_RETRY_TIMEOUT          SNTP_RECV_TIMEOUT
+#endif
+
+/** Maximum retry timeout (in milliseconds). */
+#if !defined SNTP_RETRY_TIMEOUT_MAX || defined __DOXYGEN__
+#define SNTP_RETRY_TIMEOUT_MAX      (SNTP_RETRY_TIMEOUT * 10)
+#endif
+
+/** Increase retry timeout with every retry sent
+ * Default is on to conform to RFC.
+ */
+#if !defined SNTP_RETRY_TIMEOUT_EXP || defined __DOXYGEN__
+#define SNTP_RETRY_TIMEOUT_EXP      1
+#endif
+
+/**
+ * @}
+ */
+
+#endif /* LWIP_HDR_APPS_SNTP_OPTS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/tftp_opts.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/tftp_opts.h
new file mode 100644
index 000000000..6968a803b
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/tftp_opts.h
@@ -0,0 +1,105 @@
+/****************************************************************//**
+ *
+ * @file tftp_opts.h
+ *
+ * @author   Logan Gunthorpe <logang@deltatee.com>
+ *
+ * @brief    Trivial File Transfer Protocol (RFC 1350) implementation options
+ *
+ * Copyright (c) Deltatee Enterprises Ltd. 2013
+ * All rights reserved.
+ *
+ ********************************************************************/
+
+/* 
+ * Redistribution and use in source and binary forms, with or without
+ * modification,are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Author: Logan Gunthorpe <logang@deltatee.com>
+ *
+ */
+
+#ifndef LWIP_HDR_APPS_TFTP_OPTS_H
+#define LWIP_HDR_APPS_TFTP_OPTS_H
+
+#include "lwip/opt.h"
+
+/**
+ * @defgroup tftp_opts Options
+ * @ingroup tftp
+ * @{
+ */
+
+/**
+ * Enable TFTP debug messages
+ */
+#if !defined TFTP_DEBUG || defined __DOXYGEN__
+#define TFTP_DEBUG            LWIP_DBG_ON
+#endif
+
+/**
+ * TFTP server port
+ */
+#if !defined TFTP_PORT || defined __DOXYGEN__
+#define TFTP_PORT             69
+#endif
+
+/**
+ * TFTP timeout
+ */
+#if !defined TFTP_TIMEOUT_MSECS || defined __DOXYGEN__
+#define TFTP_TIMEOUT_MSECS    10000
+#endif
+
+/**
+ * Max. number of retries when a file is read from server
+ */
+#if !defined TFTP_MAX_RETRIES || defined __DOXYGEN__
+#define TFTP_MAX_RETRIES      5
+#endif
+
+/**
+ * TFTP timer cyclic interval
+ */
+#if !defined TFTP_TIMER_MSECS || defined __DOXYGEN__
+#define TFTP_TIMER_MSECS      50
+#endif
+
+/**
+ * Max. length of TFTP filename
+ */
+#if !defined TFTP_MAX_FILENAME_LEN || defined __DOXYGEN__
+#define TFTP_MAX_FILENAME_LEN 20
+#endif
+
+/**
+ * Max. length of TFTP mode
+ */
+#if !defined TFTP_MAX_MODE_LEN || defined __DOXYGEN__
+#define TFTP_MAX_MODE_LEN     7
+#endif
+
+/**
+ * @}
+ */
+
+#endif /* LWIP_HDR_APPS_TFTP_OPTS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/tftp_server.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/tftp_server.h
new file mode 100644
index 000000000..3fbe701e0
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/apps/tftp_server.h
@@ -0,0 +1,94 @@
+/****************************************************************//**
+ *
+ * @file tftp_server.h
+ *
+ * @author   Logan Gunthorpe <logang@deltatee.com>
+ *
+ * @brief    Trivial File Transfer Protocol (RFC 1350)
+ *
+ * Copyright (c) Deltatee Enterprises Ltd. 2013
+ * All rights reserved.
+ *
+ ********************************************************************/
+
+/* 
+ * Redistribution and use in source and binary forms, with or without
+ * modification,are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Author: Logan Gunthorpe <logang@deltatee.com>
+ *
+ */
+
+#ifndef LWIP_HDR_APPS_TFTP_SERVER_H
+#define LWIP_HDR_APPS_TFTP_SERVER_H
+
+#include "lwip/apps/tftp_opts.h"
+#include "lwip/err.h"
+#include "lwip/pbuf.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @ingroup tftp
+ * TFTP context containing callback functions for TFTP transfers
+ */
+struct tftp_context {
+  /**
+   * Open file for read/write.
+   * @param fname Filename
+   * @param mode Mode string from TFTP RFC 1350 (netascii, octet, mail)
+   * @param write Flag indicating read (0) or write (!= 0) access
+   * @returns File handle supplied to other functions
+   */
+  void* (*open)(const char* fname, const char* mode, u8_t write);
+  /**
+   * Close file handle
+   * @param handle File handle returned by open()
+   */
+  void (*close)(void* handle);
+  /**
+   * Read from file 
+   * @param handle File handle returned by open()
+   * @param buf Target buffer to copy read data to
+   * @param bytes Number of bytes to copy to buf
+   * @returns &gt;= 0: Success; &lt; 0: Error
+   */
+  int (*read)(void* handle, void* buf, int bytes);
+  /**
+   * Write to file
+   * @param handle File handle returned by open()
+   * @param pbuf PBUF adjusted such that payload pointer points
+   *             to the beginning of write data. In other words,
+   *             TFTP headers are stripped off.
+   * @returns &gt;= 0: Success; &lt; 0: Error
+   */
+  int (*write)(void* handle, struct pbuf* p);
+};
+
+err_t tftp_init(const struct tftp_context* ctx);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_APPS_TFTP_SERVER_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/arch.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/arch.h
new file mode 100644
index 000000000..1ab171ba6
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/arch.h
@@ -0,0 +1,323 @@
+/**
+ * @file
+ * Support for different processor and compiler architectures
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_ARCH_H
+#define LWIP_HDR_ARCH_H
+
+#if CHIP_HAVE_CONFIG_H
+#include <lwip/lwip_buildconfig.h>
+#endif
+
+#ifndef LITTLE_ENDIAN
+#define LITTLE_ENDIAN 1234
+#endif
+
+#ifndef BIG_ENDIAN
+#define BIG_ENDIAN 4321
+#endif
+
+#include "arch/cc.h"
+
+/**
+ * @defgroup compiler_abstraction Compiler/platform abstraction
+ * @ingroup sys_layer
+ * All defines related to this section must not be placed in lwipopts.h,
+ * but in arch/cc.h!
+ * These options cannot be \#defined in lwipopts.h since they are not options
+ * of lwIP itself, but options of the lwIP port to your system.
+ * @{
+ */
+
+/** Define the byte order of the system.
+ * Needed for conversion of network data to host byte order.
+ * Allowed values: LITTLE_ENDIAN and BIG_ENDIAN
+ */
+#ifndef BYTE_ORDER
+#define BYTE_ORDER LITTLE_ENDIAN
+#endif
+
+/** Define random number generator function of your system */
+#ifdef __DOXYGEN__
+#define LWIP_RAND() ((u32_t)rand())
+#endif
+
+/** Platform specific diagnostic output.\n
+ * Note the default implementation pulls in printf, which may
+ * in turn pull in a lot of standard libary code. In resource-constrained 
+ * systems, this should be defined to something less resource-consuming.
+ */
+#ifndef LWIP_PLATFORM_DIAG
+#define LWIP_PLATFORM_DIAG(x) do {printf x;} while(0)
+#include <stdio.h>
+#include <stdlib.h>
+#endif
+
+/** Platform specific assertion handling.\n
+ * Note the default implementation pulls in printf, fflush and abort, which may
+ * in turn pull in a lot of standard libary code. In resource-constrained 
+ * systems, this should be defined to something less resource-consuming.
+ */
+#ifndef LWIP_PLATFORM_ASSERT
+#define LWIP_PLATFORM_ASSERT(x) do {printf("Assertion \"%s\" failed at line %d in %s\n", \
+                                     x, __LINE__, __FILE__); fflush(NULL); abort();} while(0)
+#include <stdio.h>
+#include <stdlib.h>
+#endif
+
+/** Define this to 1 in arch/cc.h of your port if you do not want to
+ * include stddef.h header to get size_t. You need to typedef size_t
+ * by yourself in this case.
+ */
+#ifndef LWIP_NO_STDDEF_H
+#define LWIP_NO_STDDEF_H 0
+#endif
+
+#if !LWIP_NO_STDDEF_H
+#include <stddef.h> /* for size_t */
+#endif
+
+/** Define this to 1 in arch/cc.h of your port if your compiler does not provide
+ * the stdint.h header. You need to typedef the generic types listed in
+ * lwip/arch.h yourself in this case (u8_t, u16_t...).
+ */
+#ifndef LWIP_NO_STDINT_H
+#define LWIP_NO_STDINT_H 0
+#endif
+
+/* Define generic types used in lwIP */
+#if !LWIP_NO_STDINT_H
+#include <stdint.h>
+typedef uint8_t   u8_t;
+typedef int8_t    s8_t;
+typedef uint16_t  u16_t;
+typedef int16_t   s16_t;
+typedef uint32_t  u32_t;
+typedef int32_t   s32_t;
+typedef uintptr_t mem_ptr_t;
+#endif
+
+/** Define this to 1 in arch/cc.h of your port if your compiler does not provide
+ * the inttypes.h header. You need to define the format strings listed in
+ * lwip/arch.h yourself in this case (X8_F, U16_F...).
+ */
+#ifndef LWIP_NO_INTTYPES_H
+#define LWIP_NO_INTTYPES_H 0
+#endif
+
+/* Define (sn)printf formatters for these lwIP types */
+#if !LWIP_NO_INTTYPES_H
+#include <inttypes.h>
+#ifndef X8_F
+#define X8_F  "02" PRIx8
+#endif
+#ifndef U16_F
+#define U16_F PRIu16
+#endif
+#ifndef S16_F
+#define S16_F PRId16
+#endif
+#ifndef X16_F
+#define X16_F PRIx16
+#endif
+#ifndef U32_F
+#define U32_F PRIu32
+#endif
+#ifndef S32_F
+#define S32_F PRId32
+#endif
+#ifndef X32_F
+#define X32_F PRIx32
+#endif
+#ifndef SZT_F
+#define SZT_F PRIuPTR
+#endif
+#endif
+
+/** Define this to 1 in arch/cc.h of your port if your compiler does not provide
+ * the limits.h header. You need to define the type limits yourself in this case
+ * (e.g. INT_MAX).
+ */
+#ifndef LWIP_NO_LIMITS_H
+#define LWIP_NO_LIMITS_H 0
+#endif
+
+/* Include limits.h? */
+#if !LWIP_NO_LIMITS_H
+#include <limits.h>
+#endif
+
+/** C++ const_cast<target_type>(val) equivalent to remove constness from a value (GCC -Wcast-qual) */
+#ifndef LWIP_CONST_CAST
+#define LWIP_CONST_CAST(target_type, val) ((target_type)((ptrdiff_t)val))
+#endif
+
+/** Get rid of alignment cast warnings (GCC -Wcast-align) */
+#ifndef LWIP_ALIGNMENT_CAST
+#define LWIP_ALIGNMENT_CAST(target_type, val) LWIP_CONST_CAST(target_type, val)
+#endif
+
+/** Get rid of warnings related to pointer-to-numeric and vice-versa casts,
+ * e.g. "conversion from 'u8_t' to 'void *' of greater size"
+ */
+#ifndef LWIP_PTR_NUMERIC_CAST
+#define LWIP_PTR_NUMERIC_CAST(target_type, val) LWIP_CONST_CAST(target_type, val)
+#endif
+
+/** Allocates a memory buffer of specified size that is of sufficient size to align
+ * its start address using LWIP_MEM_ALIGN.
+ * You can declare your own version here e.g. to enforce alignment without adding
+ * trailing padding bytes (see LWIP_MEM_ALIGN_BUFFER) or your own section placement
+ * requirements.\n
+ * e.g. if you use gcc and need 32 bit alignment:\n
+ * \#define LWIP_DECLARE_MEMORY_ALIGNED(variable_name, size) u8_t variable_name[size] \_\_attribute\_\_((aligned(4)))\n
+ * or more portable:\n
+ * \#define LWIP_DECLARE_MEMORY_ALIGNED(variable_name, size) u32_t variable_name[(size + sizeof(u32_t) - 1) / sizeof(u32_t)]
+ */
+#ifndef LWIP_DECLARE_MEMORY_ALIGNED
+#define LWIP_DECLARE_MEMORY_ALIGNED(variable_name, size) u8_t variable_name[LWIP_MEM_ALIGN_BUFFER(size)]
+#endif
+
+/** Calculate memory size for an aligned buffer - returns the next highest
+ * multiple of MEM_ALIGNMENT (e.g. LWIP_MEM_ALIGN_SIZE(3) and
+ * LWIP_MEM_ALIGN_SIZE(4) will both yield 4 for MEM_ALIGNMENT == 4).
+ */
+#ifndef LWIP_MEM_ALIGN_SIZE
+#define LWIP_MEM_ALIGN_SIZE(size) (((size) + MEM_ALIGNMENT - 1U) & ~(MEM_ALIGNMENT-1U))
+#endif
+
+/** Calculate safe memory size for an aligned buffer when using an unaligned
+ * type as storage. This includes a safety-margin on (MEM_ALIGNMENT - 1) at the
+ * start (e.g. if buffer is u8_t[] and actual data will be u32_t*)
+ */
+#ifndef LWIP_MEM_ALIGN_BUFFER
+#define LWIP_MEM_ALIGN_BUFFER(size) (((size) + MEM_ALIGNMENT - 1U))
+#endif
+
+/** Align a memory pointer to the alignment defined by MEM_ALIGNMENT
+ * so that ADDR % MEM_ALIGNMENT == 0
+ */
+#ifndef LWIP_MEM_ALIGN
+#define LWIP_MEM_ALIGN(addr) ((void *)(((mem_ptr_t)(addr) + MEM_ALIGNMENT - 1) & ~(mem_ptr_t)(MEM_ALIGNMENT-1)))
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** Packed structs support.
+  * Placed BEFORE declaration of a packed struct.\n
+  * For examples of packed struct declarations, see include/lwip/prot/ subfolder.\n
+  * A port to GCC/clang is included in lwIP, if you use these compilers there is nothing to do here.
+  */
+#ifndef PACK_STRUCT_BEGIN
+#define PACK_STRUCT_BEGIN
+#endif /* PACK_STRUCT_BEGIN */
+
+/** Packed structs support.
+  * Placed AFTER declaration of a packed struct.\n
+  * For examples of packed struct declarations, see include/lwip/prot/ subfolder.\n
+  * A port to GCC/clang is included in lwIP, if you use these compilers there is nothing to do here.
+  */
+#ifndef PACK_STRUCT_END
+#define PACK_STRUCT_END
+#endif /* PACK_STRUCT_END */
+
+/** Packed structs support.
+  * Placed between end of declaration of a packed struct and trailing semicolon.\n
+  * For examples of packed struct declarations, see include/lwip/prot/ subfolder.\n
+  * A port to GCC/clang is included in lwIP, if you use these compilers there is nothing to do here.
+  */
+#ifndef PACK_STRUCT_STRUCT
+#if defined(__GNUC__) || defined(__clang__)
+#define PACK_STRUCT_STRUCT __attribute__((packed))
+#else
+#define PACK_STRUCT_STRUCT
+#endif
+#endif /* PACK_STRUCT_STRUCT */
+
+/** Packed structs support.
+  * Wraps u32_t and u16_t members.\n
+  * For examples of packed struct declarations, see include/lwip/prot/ subfolder.\n
+  * A port to GCC/clang is included in lwIP, if you use these compilers there is nothing to do here.
+  */
+#ifndef PACK_STRUCT_FIELD
+#define PACK_STRUCT_FIELD(x) x
+#endif /* PACK_STRUCT_FIELD */
+
+/** Packed structs support.
+  * Wraps u8_t members, where some compilers warn that packing is not necessary.\n
+  * For examples of packed struct declarations, see include/lwip/prot/ subfolder.\n
+  * A port to GCC/clang is included in lwIP, if you use these compilers there is nothing to do here.
+  */
+#ifndef PACK_STRUCT_FLD_8
+#define PACK_STRUCT_FLD_8(x) PACK_STRUCT_FIELD(x)
+#endif /* PACK_STRUCT_FLD_8 */
+
+/** Packed structs support.
+  * Wraps members that are packed structs themselves, where some compilers warn that packing is not necessary.\n
+  * For examples of packed struct declarations, see include/lwip/prot/ subfolder.\n
+  * A port to GCC/clang is included in lwIP, if you use these compilers there is nothing to do here.
+  */
+#ifndef PACK_STRUCT_FLD_S
+#define PACK_STRUCT_FLD_S(x) PACK_STRUCT_FIELD(x)
+#endif /* PACK_STRUCT_FLD_S */
+
+/** Packed structs support using \#include files before and after struct to be packed.\n
+ * The file included BEFORE the struct is "arch/bpstruct.h".\n
+ * The file included AFTER the struct is "arch/epstruct.h".\n
+ * This can be used to implement struct packing on MS Visual C compilers, see
+ * the Win32 port in the lwIP contrib repository for reference.
+ * For examples of packed struct declarations, see include/lwip/prot/ subfolder.\n
+ * A port to GCC/clang is included in lwIP, if you use these compilers there is nothing to do here.
+ */
+#ifdef __DOXYGEN__
+#define PACK_STRUCT_USE_INCLUDES
+#endif
+
+/** Eliminates compiler warning about unused arguments (GCC -Wextra -Wunused). */
+#ifndef LWIP_UNUSED_ARG
+#define LWIP_UNUSED_ARG(x) (void)x
+#endif /* LWIP_UNUSED_ARG */
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_ARCH_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/autoip.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/autoip.h
new file mode 100644
index 000000000..3a8ca35f8
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/autoip.h
@@ -0,0 +1,99 @@
+/**
+ * @file
+ *
+ * AutoIP Automatic LinkLocal IP Configuration
+ */
+
+/*
+ *
+ * Copyright (c) 2007 Dominik Spies <kontakt@dspies.de>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * Author: Dominik Spies <kontakt@dspies.de>
+ *
+ * This is a AutoIP implementation for the lwIP TCP/IP stack. It aims to conform
+ * with RFC 3927.
+ *
+ */
+
+#ifndef LWIP_HDR_AUTOIP_H
+#define LWIP_HDR_AUTOIP_H
+
+#include "lwip/opt.h"
+
+#if LWIP_IPV4 && LWIP_AUTOIP /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/netif.h"
+/* #include "lwip/udp.h" */
+#include "lwip/etharp.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** AutoIP Timing */
+#define AUTOIP_TMR_INTERVAL      100
+#define AUTOIP_TICKS_PER_SECOND (1000 / AUTOIP_TMR_INTERVAL)
+
+/** AutoIP state information per netif */
+struct autoip
+{
+  /** the currently selected, probed, announced or used LL IP-Address */
+  ip4_addr_t llipaddr;
+  /** current AutoIP state machine state */
+  u8_t state;
+  /** sent number of probes or announces, dependent on state */
+  u8_t sent_num;
+  /** ticks to wait, tick is AUTOIP_TMR_INTERVAL long */
+  u16_t ttw;
+  /** ticks until a conflict can be solved by defending */
+  u8_t lastconflict;
+  /** total number of probed/used Link Local IP-Addresses */
+  u8_t tried_llipaddr;
+};
+
+
+void autoip_set_struct(struct netif *netif, struct autoip *autoip);
+/** Remove a struct autoip previously set to the netif using autoip_set_struct() */
+#define autoip_remove_struct(netif) netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_AUTOIP, NULL)
+err_t autoip_start(struct netif *netif);
+err_t autoip_stop(struct netif *netif);
+void autoip_arp_reply(struct netif *netif, struct etharp_hdr *hdr);
+void autoip_tmr(void);
+void autoip_network_changed(struct netif *netif);
+u8_t autoip_supplied_address(const struct netif *netif);
+
+/* for lwIP internal use by ip4.c */
+u8_t autoip_accept_packet(struct netif *netif, const ip4_addr_t *addr);
+
+#define netif_autoip_data(netif) ((struct autoip*)netif_get_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_AUTOIP))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_IPV4 && LWIP_AUTOIP */
+
+#endif /* LWIP_HDR_AUTOIP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/debug.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/debug.h
new file mode 100644
index 000000000..a142f1cff
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/debug.h
@@ -0,0 +1,167 @@
+/**
+ * @file
+ * Debug messages infrastructure
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_DEBUG_H
+#define LWIP_HDR_DEBUG_H
+
+#include "lwip/arch.h"
+#include "lwip/opt.h"
+
+/**
+ * @defgroup debugging_levels LWIP_DBG_MIN_LEVEL and LWIP_DBG_TYPES_ON values
+ * @ingroup lwip_opts_debugmsg
+ * @{
+ */
+
+/** @name Debug level (LWIP_DBG_MIN_LEVEL)
+ * @{
+ */
+/** Debug level: ALL messages*/
+#define LWIP_DBG_LEVEL_ALL     0x00
+/** Debug level: Warnings. bad checksums, dropped packets, ... */
+#define LWIP_DBG_LEVEL_WARNING 0x01
+/** Debug level: Serious. memory allocation failures, ... */
+#define LWIP_DBG_LEVEL_SERIOUS 0x02
+/** Debug level: Severe */
+#define LWIP_DBG_LEVEL_SEVERE  0x03
+/**
+ * @}
+ */
+
+#define LWIP_DBG_MASK_LEVEL    0x03
+/* compatibility define only */
+#define LWIP_DBG_LEVEL_OFF     LWIP_DBG_LEVEL_ALL
+
+/** @name Enable/disable debug messages completely (LWIP_DBG_TYPES_ON)
+ * @{
+ */
+/** flag for LWIP_DEBUGF to enable that debug message */
+#define LWIP_DBG_ON            0x80U
+/** flag for LWIP_DEBUGF to disable that debug message */
+#define LWIP_DBG_OFF           0x00U
+/**
+ * @}
+ */
+
+/** @name Debug message types (LWIP_DBG_TYPES_ON)
+ * @{
+ */
+/** flag for LWIP_DEBUGF indicating a tracing message (to follow program flow) */
+#define LWIP_DBG_TRACE         0x40U
+/** flag for LWIP_DEBUGF indicating a state debug message (to follow module states) */
+#define LWIP_DBG_STATE         0x20U
+/** flag for LWIP_DEBUGF indicating newly added code, not thoroughly tested yet */
+#define LWIP_DBG_FRESH         0x10U
+/** flag for LWIP_DEBUGF to halt after printing this debug message */
+#define LWIP_DBG_HALT          0x08U
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+/**
+ * @defgroup lwip_assertions Assertion handling
+ * @ingroup lwip_opts_debug
+ * @{
+ */
+/**
+ * LWIP_NOASSERT: Disable LWIP_ASSERT checks:
+ * To disable assertions define LWIP_NOASSERT in arch/cc.h.
+ */
+#ifdef __DOXYGEN__
+#define LWIP_NOASSERT
+#undef LWIP_NOASSERT
+#endif
+/**
+ * @}
+ */
+
+#ifndef LWIP_NOASSERT
+#define LWIP_ASSERT(message, assertion) do { if (!(assertion)) { \
+  LWIP_PLATFORM_ASSERT(message); }} while(0)
+#ifndef LWIP_PLATFORM_ASSERT
+#error "If you want to use LWIP_ASSERT, LWIP_PLATFORM_ASSERT(message) needs to be defined in your arch/cc.h"
+#endif
+#else  /* LWIP_NOASSERT */
+#define LWIP_ASSERT(message, assertion)
+#endif /* LWIP_NOASSERT */
+
+#ifndef LWIP_ERROR
+#ifndef LWIP_NOASSERT
+#define LWIP_PLATFORM_ERROR(message) LWIP_PLATFORM_ASSERT(message)
+#elif defined LWIP_DEBUG
+#define LWIP_PLATFORM_ERROR(message) LWIP_PLATFORM_DIAG((message))
+#else
+#define LWIP_PLATFORM_ERROR(message)
+#endif
+
+/* if "expression" isn't true, then print "message" and execute "handler" expression */
+#define LWIP_ERROR(message, expression, handler) do { if (!(expression)) { \
+  LWIP_PLATFORM_ERROR(message); handler;}} while(0)
+#endif /* LWIP_ERROR */
+
+/** Enable debug message printing, but only if debug message type is enabled
+ *  AND is of correct type AND is at least LWIP_DBG_LEVEL.
+ */
+#ifdef __DOXYGEN__
+#define LWIP_DEBUG
+#undef LWIP_DEBUG
+#endif
+
+#ifdef LWIP_DEBUG
+#ifndef LWIP_PLATFORM_DIAG
+#error "If you want to use LWIP_DEBUG, LWIP_PLATFORM_DIAG(message) needs to be defined in your arch/cc.h"
+#endif
+#define LWIP_DEBUGF(debug, message) do { \
+                               if ( \
+                                   ((debug) & LWIP_DBG_ON) && \
+                                   ((debug) & LWIP_DBG_TYPES_ON) && \
+                                   ((s16_t)((debug) & LWIP_DBG_MASK_LEVEL) >= LWIP_DBG_MIN_LEVEL)) { \
+                                 LWIP_PLATFORM_DIAG(message); \
+                                 if ((debug) & LWIP_DBG_HALT) { \
+                                   while(1); \
+                                 } \
+                               } \
+                             } while(0)
+
+#else  /* LWIP_DEBUG */
+#define LWIP_DEBUGF(debug, message)
+#endif /* LWIP_DEBUG */
+
+#endif /* LWIP_HDR_DEBUG_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/def.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/def.h
new file mode 100644
index 000000000..82a9d896f
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/def.h
@@ -0,0 +1,141 @@
+/**
+ * @file
+ * various utility macros
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_DEF_H
+#define LWIP_HDR_DEF_H
+
+/* arch.h might define NULL already */
+#include "lwip/arch.h"
+#include "lwip/opt.h"
+#if LWIP_PERF
+#include "arch/perf.h"
+#else /* LWIP_PERF */
+#define PERF_START    /* null definition */
+#define PERF_STOP(x)  /* null definition */
+#endif /* LWIP_PERF */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define LWIP_MAX(x , y)  (((x) > (y)) ? (x) : (y))
+#define LWIP_MIN(x , y)  (((x) < (y)) ? (x) : (y))
+
+/* Get the number of entries in an array ('x' must NOT be a pointer!) */
+#define LWIP_ARRAYSIZE(x) (sizeof(x)/sizeof((x)[0]))
+
+/** Create u32_t value from bytes */
+#define LWIP_MAKEU32(a,b,c,d) (((u32_t)((a) & 0xff) << 24) | \
+                               ((u32_t)((b) & 0xff) << 16) | \
+                               ((u32_t)((c) & 0xff) << 8)  | \
+                                (u32_t)((d) & 0xff))
+
+#ifndef NULL
+#ifdef __cplusplus
+#define NULL 0
+#else
+#define NULL ((void *)0)
+#endif
+#endif
+
+#if BYTE_ORDER == BIG_ENDIAN
+#define lwip_htons(x) (x)
+#define lwip_ntohs(x) (x)
+#define lwip_htonl(x) (x)
+#define lwip_ntohl(x) (x)
+#define PP_HTONS(x) (x)
+#define PP_NTOHS(x) (x)
+#define PP_HTONL(x) (x)
+#define PP_NTOHL(x) (x)
+#else /* BYTE_ORDER != BIG_ENDIAN */
+#ifndef lwip_htons
+u16_t lwip_htons(u16_t x);
+#endif
+#define lwip_ntohs(x) lwip_htons(x)
+
+#ifndef lwip_htonl
+u32_t lwip_htonl(u32_t x);
+#endif
+#define lwip_ntohl(x) lwip_htonl(x)
+
+/* These macros should be calculated by the preprocessor and are used
+   with compile-time constants only (so that there is no little-endian
+   overhead at runtime). */
+#define PP_HTONS(x) ((((x) & 0x00ffUL) << 8) | (((x) & 0xff00UL) >> 8))
+#define PP_NTOHS(x) PP_HTONS(x)
+#define PP_HTONL(x) ((((x) & 0x000000ffUL) << 24) | \
+                     (((x) & 0x0000ff00UL) <<  8) | \
+                     (((x) & 0x00ff0000UL) >>  8) | \
+                     (((x) & 0xff000000UL) >> 24))
+#define PP_NTOHL(x) PP_HTONL(x)
+#endif /* BYTE_ORDER == BIG_ENDIAN */
+
+/* Provide usual function names as macros for users, but this can be turned off */
+#ifndef LWIP_DONT_PROVIDE_BYTEORDER_FUNCTIONS
+#define htons(x) lwip_htons(x)
+#define ntohs(x) lwip_ntohs(x)
+#define htonl(x) lwip_htonl(x)
+#define ntohl(x) lwip_ntohl(x)
+#endif
+
+/* Functions that are not available as standard implementations.
+ * In cc.h, you can #define these to implementations available on
+ * your platform to save some code bytes if you use these functions
+ * in your application, too.
+ */
+
+#ifndef lwip_itoa
+/* This can be #defined to itoa() or snprintf(result, bufsize, "%d", number) depending on your platform */
+void  lwip_itoa(char* result, size_t bufsize, int number);
+#endif
+#ifndef lwip_strnicmp
+/* This can be #defined to strnicmp() or strncasecmp() depending on your platform */
+int   lwip_strnicmp(const char* str1, const char* str2, size_t len);
+#endif
+#ifndef lwip_stricmp
+/* This can be #defined to stricmp() or strcasecmp() depending on your platform */
+int   lwip_stricmp(const char* str1, const char* str2);
+#endif
+#ifndef lwip_strnstr
+/* This can be #defined to strnstr() depending on your platform */
+char* lwip_strnstr(const char* buffer, const char* token, size_t n);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_DEF_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/dhcp.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/dhcp.h
new file mode 100644
index 000000000..df932afb5
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/dhcp.h
@@ -0,0 +1,143 @@
+/**
+ * @file
+ * DHCP client API
+ */
+
+/*
+ * Copyright (c) 2001-2004 Leon Woestenberg <leon.woestenberg@gmx.net>
+ * Copyright (c) 2001-2004 Axon Digital Design B.V., The Netherlands.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Leon Woestenberg <leon.woestenberg@gmx.net>
+ *
+ */
+#ifndef LWIP_HDR_DHCP_H
+#define LWIP_HDR_DHCP_H
+
+#include "lwip/opt.h"
+
+#if LWIP_DHCP /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/netif.h"
+#include "lwip/udp.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** period (in seconds) of the application calling dhcp_coarse_tmr() */
+#define DHCP_COARSE_TIMER_SECS  60
+/** period (in milliseconds) of the application calling dhcp_coarse_tmr() */
+#define DHCP_COARSE_TIMER_MSECS (DHCP_COARSE_TIMER_SECS * 1000UL)
+/** period (in milliseconds) of the application calling dhcp_fine_tmr() */
+#define DHCP_FINE_TIMER_MSECS   500
+
+#define DHCP_BOOT_FILE_LEN      128U
+
+/* AutoIP cooperation flags (struct dhcp.autoip_coop_state) */
+typedef enum {
+  DHCP_AUTOIP_COOP_STATE_OFF  = 0,
+  DHCP_AUTOIP_COOP_STATE_ON   = 1
+} dhcp_autoip_coop_state_enum_t;
+
+struct dhcp
+{
+  /** transaction identifier of last sent request */
+  u32_t xid;
+  /** incoming msg */
+  struct dhcp_msg *msg_in;
+  /** track PCB allocation state */
+  u8_t pcb_allocated;
+  /** current DHCP state machine state */
+  u8_t state;
+  /** retries of current request */
+  u8_t tries;
+#if LWIP_DHCP_AUTOIP_COOP
+  u8_t autoip_coop_state;
+#endif
+  u8_t subnet_mask_given;
+
+  struct pbuf *p_out; /* pbuf of outcoming msg */
+  struct dhcp_msg *msg_out; /* outgoing msg */
+  u16_t options_out_len; /* outgoing msg options length */
+  u16_t request_timeout; /* #ticks with period DHCP_FINE_TIMER_SECS for request timeout */
+  u16_t t1_timeout;  /* #ticks with period DHCP_COARSE_TIMER_SECS for renewal time */
+  u16_t t2_timeout;  /* #ticks with period DHCP_COARSE_TIMER_SECS for rebind time */
+  u16_t t1_renew_time;  /* #ticks with period DHCP_COARSE_TIMER_SECS until next renew try */
+  u16_t t2_rebind_time; /* #ticks with period DHCP_COARSE_TIMER_SECS until next rebind try */
+  u16_t lease_used; /* #ticks with period DHCP_COARSE_TIMER_SECS since last received DHCP ack */
+  u16_t t0_timeout; /* #ticks with period DHCP_COARSE_TIMER_SECS for lease time */
+  ip_addr_t server_ip_addr; /* dhcp server address that offered this lease (ip_addr_t because passed to UDP) */
+  ip4_addr_t offered_ip_addr;
+  ip4_addr_t offered_sn_mask;
+  ip4_addr_t offered_gw_addr;
+
+  u32_t offered_t0_lease; /* lease period (in seconds) */
+  u32_t offered_t1_renew; /* recommended renew time (usually 50% of lease period) */
+  u32_t offered_t2_rebind; /* recommended rebind time (usually 87.5 of lease period)  */
+#if LWIP_DHCP_BOOTP_FILE
+  ip4_addr_t offered_si_addr;
+  char boot_file_name[DHCP_BOOT_FILE_LEN];
+#endif /* LWIP_DHCP_BOOTPFILE */
+};
+
+
+void dhcp_set_struct(struct netif *netif, struct dhcp *dhcp);
+/** Remove a struct dhcp previously set to the netif using dhcp_set_struct() */
+#define dhcp_remove_struct(netif) netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_DHCP, NULL)
+void dhcp_cleanup(struct netif *netif);
+err_t dhcp_start(struct netif *netif);
+err_t dhcp_renew(struct netif *netif);
+err_t dhcp_release(struct netif *netif);
+void dhcp_stop(struct netif *netif);
+void dhcp_inform(struct netif *netif);
+void dhcp_network_changed(struct netif *netif);
+#if DHCP_DOES_ARP_CHECK
+void dhcp_arp_reply(struct netif *netif, const ip4_addr_t *addr);
+#endif
+u8_t dhcp_supplied_address(const struct netif *netif);
+/* to be called every minute */
+void dhcp_coarse_tmr(void);
+/* to be called every half second */
+void dhcp_fine_tmr(void);
+
+#if LWIP_DHCP_GET_NTP_SRV
+/** This function must exist, in other to add offered NTP servers to
+ * the NTP (or SNTP) engine.
+ * See LWIP_DHCP_MAX_NTP_SERVERS */
+extern void dhcp_set_ntp_servers(u8_t num_ntp_servers, const ip4_addr_t* ntp_server_addrs);
+#endif /* LWIP_DHCP_GET_NTP_SRV */
+
+#define netif_dhcp_data(netif) ((struct dhcp*)netif_get_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_DHCP))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_DHCP */
+
+#endif /*LWIP_HDR_DHCP_H*/
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/dhcp6.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/dhcp6.h
new file mode 100644
index 000000000..455336d37
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/dhcp6.h
@@ -0,0 +1,58 @@
+/**
+ * @file
+ *
+ * IPv6 address autoconfiguration as per RFC 4862.
+ */
+
+/*
+ * Copyright (c) 2010 Inico Technologies Ltd.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Ivan Delamer <delamer@inicotech.com>
+ *
+ * IPv6 address autoconfiguration as per RFC 4862.
+ *
+ * Please coordinate changes and requests with Ivan Delamer
+ * <delamer@inicotech.com>
+ */
+
+#ifndef LWIP_HDR_IP6_DHCP6_H
+#define LWIP_HDR_IP6_DHCP6_H
+
+#include "lwip/opt.h"
+
+#if LWIP_IPV6_DHCP6  /* don't build if not configured for use in lwipopts.h */
+
+
+struct dhcp6
+{
+  /*@todo: implement DHCP6*/
+};
+
+#endif /* LWIP_IPV6_DHCP6 */
+
+#endif /* LWIP_HDR_IP6_DHCP6_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/dns.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/dns.h
new file mode 100644
index 000000000..96d417b05
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/dns.h
@@ -0,0 +1,169 @@
+/**
+ * @file
+ * DNS API
+ */
+
+/**
+ * lwip DNS resolver header file.
+
+ * Author: Jim Pettinato
+ *   April 2007
+
+ * ported from uIP resolv.c Copyright (c) 2002-2003, Adam Dunkels.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef LWIP_HDR_DNS_H
+#define LWIP_HDR_DNS_H
+
+#include "lwip/opt.h"
+
+#if LWIP_DNS
+
+#include "lwip/ip_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** DNS timer period */
+#define DNS_TMR_INTERVAL          1000
+
+/* DNS resolve types: */
+#define LWIP_DNS_ADDRTYPE_IPV4      0
+#define LWIP_DNS_ADDRTYPE_IPV6      1
+#define LWIP_DNS_ADDRTYPE_IPV4_IPV6 2 /* try to resolve IPv4 first, try IPv6 if IPv4 fails only */
+#define LWIP_DNS_ADDRTYPE_IPV6_IPV4 3 /* try to resolve IPv6 first, try IPv4 if IPv6 fails only */
+#if LWIP_IPV4 && LWIP_IPV6
+#ifndef LWIP_DNS_ADDRTYPE_DEFAULT
+#define LWIP_DNS_ADDRTYPE_DEFAULT   LWIP_DNS_ADDRTYPE_IPV4_IPV6
+#endif
+#elif LWIP_IPV4
+#define LWIP_DNS_ADDRTYPE_DEFAULT   LWIP_DNS_ADDRTYPE_IPV4
+#else
+#define LWIP_DNS_ADDRTYPE_DEFAULT   LWIP_DNS_ADDRTYPE_IPV6
+#endif
+
+#if DNS_LOCAL_HOSTLIST
+/** struct used for local host-list */
+struct local_hostlist_entry {
+  /** static hostname */
+  const char *name;
+  /** static host address in network byteorder */
+  ip_addr_t addr;
+  struct local_hostlist_entry *next;
+};
+#define DNS_LOCAL_HOSTLIST_ELEM(name, addr_init) {name, addr_init, NULL}
+#if DNS_LOCAL_HOSTLIST_IS_DYNAMIC
+#ifndef DNS_LOCAL_HOSTLIST_MAX_NAMELEN
+#define DNS_LOCAL_HOSTLIST_MAX_NAMELEN  DNS_MAX_NAME_LENGTH
+#endif
+#define LOCALHOSTLIST_ELEM_SIZE ((sizeof(struct local_hostlist_entry) + DNS_LOCAL_HOSTLIST_MAX_NAMELEN + 1))
+#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
+#endif /* DNS_LOCAL_HOSTLIST */
+
+#if LWIP_IPV4
+extern const ip_addr_t dns_mquery_v4group;
+#endif /* LWIP_IPV4 */
+#if LWIP_IPV6
+extern const ip_addr_t dns_mquery_v6group;
+#endif /* LWIP_IPV6 */
+
+/** Callback which is invoked when a hostname is found.
+ * A function of this type must be implemented by the application using the DNS resolver.
+ * There is support for two types of callbacks, invoked when a hostname is found.
+ * @note dns_found_callbackX type is used as a catch-all type, that needs to be cast
+ * to either dns_found_callback or dns_found_callback_multi.
+ *
+ * dns_found_callback returns at most a single IP address, even if the DNS server response contained several addresses
+ *   (this callback is used to maintain backward compatibility with dns_gethostbyname)
+ * @param name pointer to the name that was looked up.
+ * @param ipaddr pointer to an ip_addr_t containing the IP address of the hostname,
+ *        or NULL if the name could not be found (or on any other error).
+ * @param callback_arg a user-specified callback argument passed to dns_gethostbyname.
+ *
+ * dns_found_callback_multi returns up to numipaddrs of all the IP addresses returned by the DSN server
+ *   (this callback is invoked by calling dns_gethostbyname_multi)
+ * @param name pointer to the name that was looked up.
+ * @param ipaddrs pointer to an ip_addr_t array containing the IP addresses of the hostname
+ * @note This pointer is never NULL, instead numipaddrs is set to zero.
+ * @param numipaddrs size of the ipaddrs array.
+ * @param callback_arg a user-specified callback argument passed to dns_gethostbyname_multi.
+*/
+
+typedef void (*dns_found_callback)(const char *name, const ip_addr_t *ipaddr, void *callback_arg);
+
+#if DNS_MAX_ADDRS_PER_NAME > 1
+typedef void (*dns_found_callbackX)(void);
+typedef void (*dns_found_callback_multi)(const char *name, const ip_addr_t *ipaddrs, u8_t numipaddrs, void *callback_arg);
+#define LWIP_DNS_FOUND_CALLBACK_TYPE    dns_found_callbackX
+#else // DNS_MAX_ADDRS_PER_NAME <= 1
+#define LWIP_DNS_FOUND_CALLBACK_TYPE    dns_found_callback
+#endif // DNS_MAX_ADDRS_PER_NAME <= 1
+
+void             dns_init(void);
+void             dns_tmr(void);
+void             dns_setserver(u8_t numdns, const ip_addr_t *dnsserver);
+const ip_addr_t* dns_getserver(u8_t numdns);
+err_t            dns_gethostbyname(const char *hostname, ip_addr_t *addr,
+                                   LWIP_DNS_FOUND_CALLBACK_TYPE found, void *callback_arg);
+err_t            dns_gethostbyname_addrtype(const char *hostname, ip_addr_t *addr,
+                                   LWIP_DNS_FOUND_CALLBACK_TYPE found, void *callback_arg,
+                                   u8_t dns_addrtype);
+
+#if DNS_LOCAL_HOSTLIST
+size_t         dns_local_iterate(dns_found_callback iterator_fn, void *iterator_arg);
+err_t          dns_local_lookup(const char *hostname, ip_addr_t *addr, u8_t dns_addrtype);
+#if DNS_LOCAL_HOSTLIST_IS_DYNAMIC
+
+void           dns_init(void);
+void           dns_tmr(void);
+void           dns_setserver(u8_t numdns, ip_addr_t *dnsserver);
+ip_addr_t      dns_getserver(u8_t numdns);
+
+#if DNS_MAX_ADDRS_PER_NAME > 1
+err_t          dns_gethostbyname_multi(const char *hostname, ip_addr_t *ipaddrs, u8_t *numipaddrs,
+                                 dns_found_callback_multi found, void *callback_arg);
+#endif // DNS_MAX_ADDRS_PER_NAME > 1
+
+int            dns_local_removehost(const char *hostname, const ip_addr_t *addr);
+err_t          dns_local_addhost(const char *hostname, const ip_addr_t *addr);
+#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
+#endif /* DNS_LOCAL_HOSTLIST */
+
+u8_t           dns_cancel(LWIP_DNS_FOUND_CALLBACK_TYPE found, void *callback_arg);
+
+#if LWIP_TEST_CODE
+u8_t           dns_expire_asking_entries(void);
+u8_t           dns_flush_cache(void);
+#endif // LWIP_TEST_CODE
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_DNS */
+#endif /* LWIP_HDR_DNS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/err.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/err.h
new file mode 100644
index 000000000..84e528d1e
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/err.h
@@ -0,0 +1,119 @@
+/**
+ * @file
+ * lwIP Error codes
+ */
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_ERR_H
+#define LWIP_HDR_ERR_H
+
+#include "lwip/opt.h"
+#include "lwip/arch.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @defgroup infrastructure_errors Error codes
+ * @ingroup infrastructure
+ * @{
+ */
+
+/** Define LWIP_ERR_T in cc.h if you want to use
+ *  a different type for your platform (must be signed). */
+#ifdef LWIP_ERR_T
+typedef LWIP_ERR_T err_t;
+#else /* LWIP_ERR_T */
+typedef s8_t err_t;
+#endif /* LWIP_ERR_T*/
+
+/** Definitions for error constants. */
+typedef enum {
+/** No error, everything OK. */
+  ERR_OK         = 0,
+/** Out of memory error.     */
+  ERR_MEM        = -1,
+/** Buffer error.            */
+  ERR_BUF        = -2,
+/** Timeout.                 */
+  ERR_TIMEOUT    = -3,
+/** Routing problem.         */
+  ERR_RTE        = -4,
+/** Operation in progress    */
+  ERR_INPROGRESS = -5,
+/** Illegal value.           */
+  ERR_VAL        = -6,
+/** Operation would block.   */
+  ERR_WOULDBLOCK = -7,
+/** Address in use.          */
+  ERR_USE        = -8,
+/** Already connecting.      */
+  ERR_ALREADY    = -9,
+/** Conn already established.*/
+  ERR_ISCONN     = -10,
+/** Not connected.           */
+  ERR_CONN       = -11,
+/** Low-level netif error    */
+  ERR_IF         = -12,
+
+/** Connection aborted.      */
+  ERR_ABRT       = -13,
+/** Connection reset.        */
+  ERR_RST        = -14,
+/** Connection closed.       */
+  ERR_CLSD       = -15,
+/** Illegal argument.        */
+  ERR_ARG        = -16
+} err_enum_t;
+
+#define ERR_IS_FATAL(e) ((e) <= ERR_ABRT)
+
+/**
+ * @}
+ */
+
+#ifdef LWIP_DEBUG
+extern const char *lwip_strerr(err_t err);
+#else
+#define lwip_strerr(x) ""
+#endif /* LWIP_DEBUG */
+
+#if !NO_SYS
+int err_to_errno(err_t err);
+#endif /* !NO_SYS */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_ERR_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/errno.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/errno.h
new file mode 100644
index 000000000..641cffb09
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/errno.h
@@ -0,0 +1,193 @@
+/**
+ * @file
+ * Posix Errno defines
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_ERRNO_H
+#define LWIP_HDR_ERRNO_H
+
+#include "lwip/opt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef LWIP_PROVIDE_ERRNO
+
+#define  EPERM            1  /* Operation not permitted */
+#define  ENOENT           2  /* No such file or directory */
+#define  ESRCH            3  /* No such process */
+#define  EINTR            4  /* Interrupted system call */
+#define  EIO              5  /* I/O error */
+#define  ENXIO            6  /* No such device or address */
+#define  E2BIG            7  /* Arg list too long */
+#define  ENOEXEC          8  /* Exec format error */
+#define  EBADF            9  /* Bad file number */
+#define  ECHILD          10  /* No child processes */
+#define  EAGAIN          11  /* Try again */
+#define  ENOMEM          12  /* Out of memory */
+#define  EACCES          13  /* Permission denied */
+#define  EFAULT          14  /* Bad address */
+#define  ENOTBLK         15  /* Block device required */
+#define  EBUSY           16  /* Device or resource busy */
+#define  EEXIST          17  /* File exists */
+#define  EXDEV           18  /* Cross-device link */
+#define  ENODEV          19  /* No such device */
+#define  ENOTDIR         20  /* Not a directory */
+#define  EISDIR          21  /* Is a directory */
+#define  EINVAL          22  /* Invalid argument */
+#define  ENFILE          23  /* File table overflow */
+#define  EMFILE          24  /* Too many open files */
+#define  ENOTTY          25  /* Not a typewriter */
+#define  ETXTBSY         26  /* Text file busy */
+#define  EFBIG           27  /* File too large */
+#define  ENOSPC          28  /* No space left on device */
+#define  ESPIPE          29  /* Illegal seek */
+#define  EROFS           30  /* Read-only file system */
+#define  EMLINK          31  /* Too many links */
+#define  EPIPE           32  /* Broken pipe */
+#define  EDOM            33  /* Math argument out of domain of func */
+#define  ERANGE          34  /* Math result not representable */
+#define  EDEADLK         35  /* Resource deadlock would occur */
+#define  ENAMETOOLONG    36  /* File name too long */
+#define  ENOLCK          37  /* No record locks available */
+#define  ENOSYS          38  /* Function not implemented */
+#define  ENOTEMPTY       39  /* Directory not empty */
+#define  ELOOP           40  /* Too many symbolic links encountered */
+#define  EWOULDBLOCK     EAGAIN  /* Operation would block */
+#define  ENOMSG          42  /* No message of desired type */
+#define  EIDRM           43  /* Identifier removed */
+#define  ECHRNG          44  /* Channel number out of range */
+#define  EL2NSYNC        45  /* Level 2 not synchronized */
+#define  EL3HLT          46  /* Level 3 halted */
+#define  EL3RST          47  /* Level 3 reset */
+#define  ELNRNG          48  /* Link number out of range */
+#define  EUNATCH         49  /* Protocol driver not attached */
+#define  ENOCSI          50  /* No CSI structure available */
+#define  EL2HLT          51  /* Level 2 halted */
+#define  EBADE           52  /* Invalid exchange */
+#define  EBADR           53  /* Invalid request descriptor */
+#define  EXFULL          54  /* Exchange full */
+#define  ENOANO          55  /* No anode */
+#define  EBADRQC         56  /* Invalid request code */
+#define  EBADSLT         57  /* Invalid slot */
+
+#define  EDEADLOCK       EDEADLK
+
+#define  EBFONT          59  /* Bad font file format */
+#define  ENOSTR          60  /* Device not a stream */
+#define  ENODATA         61  /* No data available */
+#define  ETIME           62  /* Timer expired */
+#define  ENOSR           63  /* Out of streams resources */
+#define  ENONET          64  /* Machine is not on the network */
+#define  ENOPKG          65  /* Package not installed */
+#define  EREMOTE         66  /* Object is remote */
+#define  ENOLINK         67  /* Link has been severed */
+#define  EADV            68  /* Advertise error */
+#define  ESRMNT          69  /* Srmount error */
+#define  ECOMM           70  /* Communication error on send */
+#define  EPROTO          71  /* Protocol error */
+#define  EMULTIHOP       72  /* Multihop attempted */
+#define  EDOTDOT         73  /* RFS specific error */
+#define  EBADMSG         74  /* Not a data message */
+#define  EOVERFLOW       75  /* Value too large for defined data type */
+#define  ENOTUNIQ        76  /* Name not unique on network */
+#define  EBADFD          77  /* File descriptor in bad state */
+#define  EREMCHG         78  /* Remote address changed */
+#define  ELIBACC         79  /* Can not access a needed shared library */
+#define  ELIBBAD         80  /* Accessing a corrupted shared library */
+#define  ELIBSCN         81  /* .lib section in a.out corrupted */
+#define  ELIBMAX         82  /* Attempting to link in too many shared libraries */
+#define  ELIBEXEC        83  /* Cannot exec a shared library directly */
+#define  EILSEQ          84  /* Illegal byte sequence */
+#define  ERESTART        85  /* Interrupted system call should be restarted */
+#define  ESTRPIPE        86  /* Streams pipe error */
+#define  EUSERS          87  /* Too many users */
+#define  ENOTSOCK        88  /* Socket operation on non-socket */
+#define  EDESTADDRREQ    89  /* Destination address required */
+#define  EMSGSIZE        90  /* Message too long */
+#define  EPROTOTYPE      91  /* Protocol wrong type for socket */
+#define  ENOPROTOOPT     92  /* Protocol not available */
+#define  EPROTONOSUPPORT 93  /* Protocol not supported */
+#define  ESOCKTNOSUPPORT 94  /* Socket type not supported */
+#define  EOPNOTSUPP      95  /* Operation not supported on transport endpoint */
+#define  EPFNOSUPPORT    96  /* Protocol family not supported */
+#define  EAFNOSUPPORT    97  /* Address family not supported by protocol */
+#define  EADDRINUSE      98  /* Address already in use */
+#define  EADDRNOTAVAIL   99  /* Cannot assign requested address */
+#define  ENETDOWN       100  /* Network is down */
+#define  ENETUNREACH    101  /* Network is unreachable */
+#define  ENETRESET      102  /* Network dropped connection because of reset */
+#define  ECONNABORTED   103  /* Software caused connection abort */
+#define  ECONNRESET     104  /* Connection reset by peer */
+#define  ENOBUFS        105  /* No buffer space available */
+#define  EISCONN        106  /* Transport endpoint is already connected */
+#define  ENOTCONN       107  /* Transport endpoint is not connected */
+#define  ESHUTDOWN      108  /* Cannot send after transport endpoint shutdown */
+#define  ETOOMANYREFS   109  /* Too many references: cannot splice */
+#define  ETIMEDOUT      110  /* Connection timed out */
+#define  ECONNREFUSED   111  /* Connection refused */
+#define  EHOSTDOWN      112  /* Host is down */
+#define  EHOSTUNREACH   113  /* No route to host */
+#define  EALREADY       114  /* Operation already in progress */
+#define  EINPROGRESS    115  /* Operation now in progress */
+#define  ESTALE         116  /* Stale NFS file handle */
+#define  EUCLEAN        117  /* Structure needs cleaning */
+#define  ENOTNAM        118  /* Not a XENIX named type file */
+#define  ENAVAIL        119  /* No XENIX semaphores available */
+#define  EISNAM         120  /* Is a named type file */
+#define  EREMOTEIO      121  /* Remote I/O error */
+#define  EDQUOT         122  /* Quota exceeded */
+
+#define  ENOMEDIUM      123  /* No medium found */
+#define  EMEDIUMTYPE    124  /* Wrong medium type */
+
+#ifndef errno
+extern int errno;
+#endif
+
+#else /* LWIP_PROVIDE_ERRNO */
+
+/* Define LWIP_ERRNO_INCLUDE to <errno.h> to include the error defines here */
+#ifdef LWIP_ERRNO_INCLUDE
+#include LWIP_ERRNO_INCLUDE
+#endif /* LWIP_ERRNO_INCLUDE */
+
+#endif /* LWIP_PROVIDE_ERRNO */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_ERRNO_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/etharp.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/etharp.h
new file mode 100644
index 000000000..7080a19d0
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/etharp.h
@@ -0,0 +1,106 @@
+/**
+ * @file
+ * Ethernet output function - handles OUTGOING ethernet level traffic, implements
+ * ARP resolving.
+ * To be used in most low-level netif implementations
+ */
+
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * Copyright (c) 2003-2004 Leon Woestenberg <leon.woestenberg@axon.tv>
+ * Copyright (c) 2003-2004 Axon Digital Design B.V., The Netherlands.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+#ifndef LWIP_HDR_NETIF_ETHARP_H
+#define LWIP_HDR_NETIF_ETHARP_H
+
+#include "lwip/opt.h"
+
+#if LWIP_ARP || LWIP_ETHERNET /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/pbuf.h"
+#include "lwip/ip4_addr.h"
+#include "lwip/netif.h"
+#include "lwip/ip4.h"
+#include "lwip/prot/ethernet.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_IPV4 && LWIP_ARP /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/prot/etharp.h"
+
+/** 1 seconds period */
+#define ARP_TMR_INTERVAL 1000
+
+#if ARP_QUEUEING
+/** struct for queueing outgoing packets for unknown address
+  * defined here to be accessed by memp.h
+  */
+struct etharp_q_entry {
+  struct etharp_q_entry *next;
+  struct pbuf *p;
+};
+#endif /* ARP_QUEUEING */
+
+#define etharp_init() /* Compatibility define, no init needed. */
+void etharp_tmr(void);
+s8_t etharp_find_addr(struct netif *netif, const ip4_addr_t *ipaddr,
+         struct eth_addr **eth_ret, const ip4_addr_t **ip_ret);
+u8_t etharp_get_entry(u8_t i, ip4_addr_t **ipaddr, struct netif **netif, struct eth_addr **eth_ret);
+err_t etharp_output(struct netif *netif, struct pbuf *q, const ip4_addr_t *ipaddr);
+err_t etharp_query(struct netif *netif, const ip4_addr_t *ipaddr, struct pbuf *q);
+err_t etharp_request(struct netif *netif, const ip4_addr_t *ipaddr);
+/** For Ethernet network interfaces, we might want to send "gratuitous ARP";
+ *  this is an ARP packet sent by a node in order to spontaneously cause other
+ *  nodes to update an entry in their ARP cache.
+ *  From RFC 3220 "IP Mobility Support for IPv4" section 4.6. */
+#define etharp_gratuitous(netif) etharp_request((netif), netif_ip4_addr(netif))
+void etharp_cleanup_netif(struct netif *netif);
+
+#if ETHARP_SUPPORT_STATIC_ENTRIES
+err_t etharp_add_static_entry(const ip4_addr_t *ipaddr, struct eth_addr *ethaddr);
+err_t etharp_remove_static_entry(const ip4_addr_t *ipaddr);
+#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
+
+#endif /* LWIP_IPV4 && LWIP_ARP */
+
+void etharp_input(struct pbuf *p, struct netif *netif);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_ARP || LWIP_ETHERNET */
+
+#endif /* LWIP_HDR_NETIF_ETHARP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/ethip6.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/ethip6.h
new file mode 100644
index 000000000..5e88dffd0
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/ethip6.h
@@ -0,0 +1,68 @@
+/**
+ * @file
+ *
+ * Ethernet output for IPv6. Uses ND tables for link-layer addressing.
+ */
+
+/*
+ * Copyright (c) 2010 Inico Technologies Ltd.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Ivan Delamer <delamer@inicotech.com>
+ *
+ *
+ * Please coordinate changes and requests with Ivan Delamer
+ * <delamer@inicotech.com>
+ */
+
+#ifndef LWIP_HDR_ETHIP6_H
+#define LWIP_HDR_ETHIP6_H
+
+#include "lwip/opt.h"
+
+#if LWIP_IPV6 && LWIP_ETHERNET /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/pbuf.h"
+#include "lwip/ip6.h"
+#include "lwip/ip6_addr.h"
+#include "lwip/netif.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+err_t ethip6_output(struct netif *netif, struct pbuf *q, const ip6_addr_t *ip6addr);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_IPV6 && LWIP_ETHERNET */
+
+#endif /* LWIP_HDR_ETHIP6_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/icmp.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/icmp.h
new file mode 100644
index 000000000..f5a31fd4c
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/icmp.h
@@ -0,0 +1,110 @@
+/**
+ * @file
+ * ICMP API
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_ICMP_H
+#define LWIP_HDR_ICMP_H
+
+#include "lwip/opt.h"
+#include "lwip/pbuf.h"
+#include "lwip/ip_addr.h"
+#include "lwip/netif.h"
+#include "lwip/prot/icmp.h"
+
+#if LWIP_IPV6 && LWIP_ICMP6
+#include "lwip/icmp6.h"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** ICMP destination unreachable codes */
+enum icmp_dur_type {
+  /** net unreachable */
+  ICMP_DUR_NET   = 0,
+  /** host unreachable */
+  ICMP_DUR_HOST  = 1,
+  /** protocol unreachable */
+  ICMP_DUR_PROTO = 2,
+  /** port unreachable */
+  ICMP_DUR_PORT  = 3,
+  /** fragmentation needed and DF set */
+  ICMP_DUR_FRAG  = 4,
+  /** source route failed */
+  ICMP_DUR_SR    = 5
+};
+
+/** ICMP time exceeded codes */
+enum icmp_te_type {
+  /** time to live exceeded in transit */
+  ICMP_TE_TTL  = 0,
+  /** fragment reassembly time exceeded */
+  ICMP_TE_FRAG = 1
+};
+
+#if LWIP_IPV4 && LWIP_ICMP /* don't build if not configured for use in lwipopts.h */
+
+void icmp_input(struct pbuf *p, struct netif *inp);
+void icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t);
+void icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t);
+
+#endif /* LWIP_IPV4 && LWIP_ICMP */
+
+#if LWIP_IPV4 && LWIP_IPV6
+#if LWIP_ICMP && LWIP_ICMP6
+#define icmp_port_unreach(isipv6, pbuf) ((isipv6) ? \
+                                         icmp6_dest_unreach(pbuf, ICMP6_DUR_PORT) : \
+                                         icmp_dest_unreach(pbuf, ICMP_DUR_PORT))
+#elif LWIP_ICMP
+#define icmp_port_unreach(isipv6, pbuf) do{ if(!(isipv6)) { icmp_dest_unreach(pbuf, ICMP_DUR_PORT);}}while(0)
+#elif LWIP_ICMP6
+#define icmp_port_unreach(isipv6, pbuf) do{ if(isipv6) { icmp6_dest_unreach(pbuf, ICMP6_DUR_PORT);}}while(0)
+#else
+#define icmp_port_unreach(isipv6, pbuf)
+#endif
+#elif LWIP_IPV6 && LWIP_ICMP6
+#define icmp_port_unreach(isipv6, pbuf) icmp6_dest_unreach(pbuf, ICMP6_DUR_PORT)
+#elif LWIP_IPV4 && LWIP_ICMP
+#define icmp_port_unreach(isipv6, pbuf) icmp_dest_unreach(pbuf, ICMP_DUR_PORT)
+#else /* (LWIP_IPV6 && LWIP_ICMP6) || (LWIP_IPV4 && LWIP_ICMP) */
+#define icmp_port_unreach(isipv6, pbuf)
+#endif /* (LWIP_IPV6 && LWIP_ICMP6) || (LWIP_IPV4 && LWIP_ICMP) LWIP_IPV4*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_ICMP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/icmp6.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/icmp6.h
new file mode 100644
index 000000000..a29dc8c1c
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/icmp6.h
@@ -0,0 +1,70 @@
+/**
+ * @file
+ *
+ * IPv6 version of ICMP, as per RFC 4443.
+ */
+
+/*
+ * Copyright (c) 2010 Inico Technologies Ltd.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Ivan Delamer <delamer@inicotech.com>
+ *
+ *
+ * Please coordinate changes and requests with Ivan Delamer
+ * <delamer@inicotech.com>
+ */
+#ifndef LWIP_HDR_ICMP6_H
+#define LWIP_HDR_ICMP6_H
+
+#include "lwip/opt.h"
+#include "lwip/pbuf.h"
+#include "lwip/ip6_addr.h"
+#include "lwip/netif.h"
+#include "lwip/prot/icmp6.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_ICMP6 && LWIP_IPV6 /* don't build if not configured for use in lwipopts.h */
+
+void icmp6_input(struct pbuf *p, struct netif *inp);
+void icmp6_dest_unreach(struct pbuf *p, enum icmp6_dur_code c);
+void icmp6_packet_too_big(struct pbuf *p, u32_t mtu);
+void icmp6_time_exceeded(struct pbuf *p, enum icmp6_te_code c);
+void icmp6_param_problem(struct pbuf *p, enum icmp6_pp_code c, u32_t pointer);
+
+#endif /* LWIP_ICMP6 && LWIP_IPV6 */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* LWIP_HDR_ICMP6_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/if.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/if.h
new file mode 100644
index 000000000..5600479d8
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/if.h
@@ -0,0 +1,59 @@
+/**
+ * @file
+ * Interface Identification APIs from:
+ *              RFC 3493: Basic Socket Interface Extensions for IPv6
+ *                  Section 4: Interface Identification
+ */
+
+/*
+ * Copyright (c) 2017 Joel Cunningham <joel.cunningham@me.com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modificat
+ion,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO E
+VENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREM
+ENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARIS
+ING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILI
+TY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Joel Cunningham <joel.cunningham@me.com>
+ *
+ */
+#ifndef LWIP_HDR_IF_H
+#define LWIP_HDR_IF_H
+
+#include "lwip/opt.h"
+
+#define IF_NAMESIZE 6 /* 2 chars, 3 nums, 1 \0 */
+
+char * lwip_if_indextoname(unsigned ifindex, char *ifname);
+unsigned int lwip_if_nametoindex(const char *ifname);
+
+#if LWIP_COMPAT_SOCKETS
+#define if_indextoname(ifindex, ifname)  lwip_if_indextoname(ifindex,ifname)
+#define if_nametoindex(ifname)           lwip_if_nametoindex(ifname)
+#endif /* LWIP_COMPAT_SOCKETS */
+
+#endif /* LWIP_HDR_IF_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/igmp.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/igmp.h
new file mode 100644
index 000000000..9e3cb36c3
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/igmp.h
@@ -0,0 +1,118 @@
+/**
+ * @file
+ * IGMP API
+ */
+
+/*
+ * Copyright (c) 2002 CITEL Technologies Ltd.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of CITEL Technologies Ltd nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY CITEL TECHNOLOGIES AND CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL CITEL TECHNOLOGIES OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * This file is a contribution to the lwIP TCP/IP stack.
+ * The Swedish Institute of Computer Science and Adam Dunkels
+ * are specifically granted permission to redistribute this
+ * source code.
+*/
+
+#ifndef LWIP_HDR_IGMP_H
+#define LWIP_HDR_IGMP_H
+
+#include "lwip/opt.h"
+#include "lwip/ip_addr.h"
+#include "lwip/netif.h"
+#include "lwip/pbuf.h"
+
+#if LWIP_IPV4 && LWIP_IGMP /* don't build if not configured for use in lwipopts.h */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* IGMP timer */
+#define IGMP_TMR_INTERVAL              100 /* Milliseconds */
+#define IGMP_V1_DELAYING_MEMBER_TMR   (1000/IGMP_TMR_INTERVAL)
+#define IGMP_JOIN_DELAYING_MEMBER_TMR (500 /IGMP_TMR_INTERVAL)
+
+/* Compatibility defines (don't use for new code) */
+#define IGMP_DEL_MAC_FILTER            NETIF_DEL_MAC_FILTER
+#define IGMP_ADD_MAC_FILTER            NETIF_ADD_MAC_FILTER
+
+/**
+ * igmp group structure - there is
+ * a list of groups for each interface
+ * these should really be linked from the interface, but
+ * if we keep them separate we will not affect the lwip original code
+ * too much
+ *
+ * There will be a group for the all systems group address but this
+ * will not run the state machine as it is used to kick off reports
+ * from all the other groups
+ */
+struct igmp_group {
+  /** next link */
+  struct igmp_group *next;
+  /** multicast address */
+  ip4_addr_t         group_address;
+  /** signifies we were the last person to report */
+  u8_t               last_reporter_flag;
+  /** current state of the group */
+  u8_t               group_state;
+  /** timer for reporting, negative is OFF */
+  u16_t              timer;
+  /** counter of simultaneous uses */
+  u8_t               use;
+};
+
+/*  Prototypes */
+void   igmp_init(void);
+#ifdef LWIP_DEBUG
+void   igmp_dump_group_list(void);
+#endif
+err_t  igmp_start(struct netif *netif);
+err_t  igmp_stop(struct netif *netif);
+void   igmp_report_groups(struct netif *netif);
+struct igmp_group *igmp_lookfor_group(struct netif *ifp, const ip4_addr_t *addr);
+void   igmp_input(struct pbuf *p, struct netif *inp, const ip4_addr_t *dest);
+err_t  igmp_joingroup(const ip4_addr_t *ifaddr, const ip4_addr_t *groupaddr);
+err_t  igmp_joingroup_netif(struct netif *netif, const ip4_addr_t *groupaddr);
+err_t  igmp_leavegroup(const ip4_addr_t *ifaddr, const ip4_addr_t *groupaddr);
+err_t  igmp_leavegroup_netif(struct netif *netif, const ip4_addr_t *groupaddr);
+void   igmp_tmr(void);
+
+/** @ingroup igmp 
+ * Get list head of IGMP groups for netif.
+ * Note: The allsystems group IP is contained in the list as first entry.
+ * @see @ref netif_set_igmp_mac_filter()
+ */
+#define netif_igmp_data(netif) ((struct igmp_group *)netif_get_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_IGMP))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_IPV4 && LWIP_IGMP */
+
+#endif /* LWIP_HDR_IGMP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/inet.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/inet.h
new file mode 100644
index 000000000..4a34f0265
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/inet.h
@@ -0,0 +1,172 @@
+/**
+ * @file
+ * This file (together with sockets.h) aims to provide structs and functions from
+ * - arpa/inet.h
+ * - netinet/in.h
+ *
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_INET_H
+#define LWIP_HDR_INET_H
+
+#include "lwip/opt.h"
+#include "lwip/def.h"
+#include "lwip/ip_addr.h"
+#include "lwip/ip6_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* If your port already typedef's in_addr_t, define IN_ADDR_T_DEFINED
+   to prevent this code from redefining it. */
+#if !defined(in_addr_t) && !defined(IN_ADDR_T_DEFINED)
+typedef u32_t in_addr_t;
+#endif
+
+struct in_addr {
+  in_addr_t s_addr;
+};
+
+struct in6_addr {
+  union {
+    u32_t u32_addr[4];
+    u8_t  u8_addr[16];
+  } un;
+#define s6_addr  un.u8_addr
+};
+
+/** 255.255.255.255 */
+#define INADDR_NONE         IPADDR_NONE
+/** 127.0.0.1 */
+#define INADDR_LOOPBACK     IPADDR_LOOPBACK
+/** 0.0.0.0 */
+#define INADDR_ANY          IPADDR_ANY
+/** 255.255.255.255 */
+#define INADDR_BROADCAST    IPADDR_BROADCAST
+
+/** This macro can be used to initialize a variable of type struct in6_addr
+    to the IPv6 wildcard address. */
+#define IN6ADDR_ANY_INIT {{{0,0,0,0}}}
+/** This macro can be used to initialize a variable of type struct in6_addr
+    to the IPv6 loopback address. */
+#define IN6ADDR_LOOPBACK_INIT {{{0,0,0,PP_HTONL(1)}}}
+/** This variable is initialized by the system to contain the wildcard IPv6 address. */
+extern const struct in6_addr in6addr_any;
+
+/* Definitions of the bits in an (IPv4) Internet address integer.
+
+   On subnets, host and network parts are found according to
+   the subnet mask, not these masks.  */
+#define IN_CLASSA(a)        IP_CLASSA(a)
+#define IN_CLASSA_NET       IP_CLASSA_NET
+#define IN_CLASSA_NSHIFT    IP_CLASSA_NSHIFT
+#define IN_CLASSA_HOST      IP_CLASSA_HOST
+#define IN_CLASSA_MAX       IP_CLASSA_MAX
+
+#define IN_CLASSB(b)        IP_CLASSB(b)
+#define IN_CLASSB_NET       IP_CLASSB_NET
+#define IN_CLASSB_NSHIFT    IP_CLASSB_NSHIFT
+#define IN_CLASSB_HOST      IP_CLASSB_HOST
+#define IN_CLASSB_MAX       IP_CLASSB_MAX
+
+#define IN_CLASSC(c)        IP_CLASSC(c)
+#define IN_CLASSC_NET       IP_CLASSC_NET
+#define IN_CLASSC_NSHIFT    IP_CLASSC_NSHIFT
+#define IN_CLASSC_HOST      IP_CLASSC_HOST
+#define IN_CLASSC_MAX       IP_CLASSC_MAX
+
+#define IN_CLASSD(d)        IP_CLASSD(d)
+#define IN_CLASSD_NET       IP_CLASSD_NET     /* These ones aren't really */
+#define IN_CLASSD_NSHIFT    IP_CLASSD_NSHIFT  /*   net and host fields, but */
+#define IN_CLASSD_HOST      IP_CLASSD_HOST    /*   routing needn't know. */
+#define IN_CLASSD_MAX       IP_CLASSD_MAX
+
+#define IN_MULTICAST(a)     IP_MULTICAST(a)
+
+#define IN_EXPERIMENTAL(a)  IP_EXPERIMENTAL(a)
+#define IN_BADCLASS(a)      IP_BADCLASS(a)
+
+#define IN_LOOPBACKNET      IP_LOOPBACKNET
+
+
+#ifndef INET_ADDRSTRLEN
+#define INET_ADDRSTRLEN     IP4ADDR_STRLEN_MAX
+#endif
+#if LWIP_IPV6
+#ifndef INET6_ADDRSTRLEN
+#define INET6_ADDRSTRLEN    IP6ADDR_STRLEN_MAX
+#endif
+#endif
+
+#if LWIP_IPV4
+
+#define inet_addr_from_ip4addr(target_inaddr, source_ipaddr) ((target_inaddr)->s_addr = ip4_addr_get_u32(source_ipaddr))
+#define inet_addr_to_ip4addr(target_ipaddr, source_inaddr)   (ip4_addr_set_u32(target_ipaddr, (source_inaddr)->s_addr))
+/* ATTENTION: the next define only works because both s_addr and ip4_addr_t are an u32_t effectively! */
+#define inet_addr_to_ip4addr_p(target_ip4addr_p, source_inaddr)   ((target_ip4addr_p) = (ip4_addr_t*)&((source_inaddr)->s_addr))
+
+/* directly map this to the lwip internal functions */
+#define inet_addr(cp)                   ipaddr_addr(cp)
+#define inet_aton(cp, addr)             ip4addr_aton(cp, (ip4_addr_t*)addr)
+#define inet_ntoa(addr)                 ip4addr_ntoa((const ip4_addr_t*)&(addr))
+#define inet_ntoa_r(addr, buf, buflen)  ip4addr_ntoa_r((const ip4_addr_t*)&(addr), buf, buflen)
+
+#endif /* LWIP_IPV4 */
+
+#if LWIP_IPV6
+#define inet6_addr_from_ip6addr(target_in6addr, source_ip6addr) {(target_in6addr)->un.u32_addr[0] = (source_ip6addr)->addr[0]; \
+                                                                 (target_in6addr)->un.u32_addr[1] = (source_ip6addr)->addr[1]; \
+                                                                 (target_in6addr)->un.u32_addr[2] = (source_ip6addr)->addr[2]; \
+                                                                 (target_in6addr)->un.u32_addr[3] = (source_ip6addr)->addr[3];}
+#define inet6_addr_to_ip6addr(target_ip6addr, source_in6addr)   {(target_ip6addr)->addr[0] = (source_in6addr)->un.u32_addr[0]; \
+                                                                 (target_ip6addr)->addr[1] = (source_in6addr)->un.u32_addr[1]; \
+                                                                 (target_ip6addr)->addr[2] = (source_in6addr)->un.u32_addr[2]; \
+                                                                 (target_ip6addr)->addr[3] = (source_in6addr)->un.u32_addr[3];}
+/* ATTENTION: the next define only works because both in6_addr and ip6_addr_t are an u32_t[4] effectively! */
+#define inet6_addr_to_ip6addr_p(target_ip6addr_p, source_in6addr)   ((target_ip6addr_p) = (ip6_addr_t*)(source_in6addr))
+
+/* directly map this to the lwip internal functions */
+#define inet6_aton(cp, addr)            ip6addr_aton(cp, (ip6_addr_t*)addr)
+#define inet6_ntoa(addr)                ip6addr_ntoa((const ip6_addr_t*)&(addr))
+#define inet6_ntoa_r(addr, buf, buflen) ip6addr_ntoa_r((const ip6_addr_t*)&(addr), buf, buflen)
+
+#endif /* LWIP_IPV6 */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_INET_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/inet_chksum.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/inet_chksum.h
new file mode 100644
index 000000000..4e23d7f19
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/inet_chksum.h
@@ -0,0 +1,105 @@
+/**
+ * @file
+ * IP checksum calculation functions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_INET_CHKSUM_H
+#define LWIP_HDR_INET_CHKSUM_H
+
+#include "lwip/opt.h"
+
+#include "lwip/pbuf.h"
+#include "lwip/ip_addr.h"
+
+/** Swap the bytes in an u16_t: much like lwip_htons() for little-endian */
+#ifndef SWAP_BYTES_IN_WORD
+#define SWAP_BYTES_IN_WORD(w) (((w) & 0xff) << 8) | (((w) & 0xff00) >> 8)
+#endif /* SWAP_BYTES_IN_WORD */
+
+/** Split an u32_t in two u16_ts and add them up */
+#ifndef FOLD_U32T
+#define FOLD_U32T(u)          (((u) >> 16) + ((u) & 0x0000ffffUL))
+#endif
+
+#if LWIP_CHECKSUM_ON_COPY
+/** Function-like macro: same as MEMCPY but returns the checksum of copied data
+    as u16_t */
+# ifndef LWIP_CHKSUM_COPY
+#  define LWIP_CHKSUM_COPY(dst, src, len) lwip_chksum_copy(dst, src, len)
+#  ifndef LWIP_CHKSUM_COPY_ALGORITHM
+#   define LWIP_CHKSUM_COPY_ALGORITHM 1
+#  endif /* LWIP_CHKSUM_COPY_ALGORITHM */
+# else /* LWIP_CHKSUM_COPY */
+#  define LWIP_CHKSUM_COPY_ALGORITHM 0
+# endif /* LWIP_CHKSUM_COPY */
+#else /* LWIP_CHECKSUM_ON_COPY */
+# define LWIP_CHKSUM_COPY_ALGORITHM 0
+#endif /* LWIP_CHECKSUM_ON_COPY */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+u16_t inet_chksum(const void *dataptr, u16_t len);
+u16_t inet_chksum_pbuf(struct pbuf *p);
+#if LWIP_CHKSUM_COPY_ALGORITHM
+u16_t lwip_chksum_copy(void *dst, const void *src, u16_t len);
+#endif /* LWIP_CHKSUM_COPY_ALGORITHM */
+
+#if LWIP_IPV4
+u16_t inet_chksum_pseudo(struct pbuf *p, u8_t proto, u16_t proto_len,
+       const ip4_addr_t *src, const ip4_addr_t *dest);
+u16_t inet_chksum_pseudo_partial(struct pbuf *p, u8_t proto,
+       u16_t proto_len, u16_t chksum_len, const ip4_addr_t *src, const ip4_addr_t *dest);
+#endif /* LWIP_IPV4 */
+
+#if LWIP_IPV6
+u16_t ip6_chksum_pseudo(struct pbuf *p, u8_t proto, u16_t proto_len,
+       const ip6_addr_t *src, const ip6_addr_t *dest);
+u16_t ip6_chksum_pseudo_partial(struct pbuf *p, u8_t proto, u16_t proto_len,
+       u16_t chksum_len, const ip6_addr_t *src, const ip6_addr_t *dest);
+#endif /* LWIP_IPV6 */
+
+
+u16_t ip_chksum_pseudo(struct pbuf *p, u8_t proto, u16_t proto_len,
+       const ip_addr_t *src, const ip_addr_t *dest);
+u16_t ip_chksum_pseudo_partial(struct pbuf *p, u8_t proto, u16_t proto_len,
+       u16_t chksum_len, const ip_addr_t *src, const ip_addr_t *dest);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_INET_H */
+
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/init.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/init.h
new file mode 100644
index 000000000..3c234cb58
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/init.h
@@ -0,0 +1,100 @@
+/**
+ * @file
+ * lwIP initialization API
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_INIT_H
+#define LWIP_HDR_INIT_H
+
+#include "lwip/opt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @defgroup lwip_version Version
+ * @ingroup lwip
+ * @{
+ */
+
+/** X.x.x: Major version of the stack */
+#define LWIP_VERSION_MAJOR      2
+/** x.X.x: Minor version of the stack */
+#define LWIP_VERSION_MINOR      0
+/** x.x.X: Revision of the stack */
+#define LWIP_VERSION_REVISION   3
+/** For release candidates, this is set to 1..254
+  * For official releases, this is set to 255 (LWIP_RC_RELEASE)
+  * For development versions (Git), this is set to 0 (LWIP_RC_DEVELOPMENT) */
+#define LWIP_VERSION_RC         LWIP_RC_RELEASE
+
+/** LWIP_VERSION_RC is set to LWIP_RC_RELEASE for official releases */
+#define LWIP_RC_RELEASE         255
+/** LWIP_VERSION_RC is set to LWIP_RC_DEVELOPMENT for Git versions */
+#define LWIP_RC_DEVELOPMENT     0
+
+#define LWIP_VERSION_IS_RELEASE     (LWIP_VERSION_RC == LWIP_RC_RELEASE)
+#define LWIP_VERSION_IS_DEVELOPMENT (LWIP_VERSION_RC == LWIP_RC_DEVELOPMENT)
+#define LWIP_VERSION_IS_RC          ((LWIP_VERSION_RC != LWIP_RC_RELEASE) && (LWIP_VERSION_RC != LWIP_RC_DEVELOPMENT))
+
+/* Some helper defines to get a version string */
+#define LWIP_VERSTR2(x) #x
+#define LWIP_VERSTR(x) LWIP_VERSTR2(x)
+#if LWIP_VERSION_IS_RELEASE
+#define LWIP_VERSION_STRING_SUFFIX ""
+#elif LWIP_VERSION_IS_DEVELOPMENT
+#define LWIP_VERSION_STRING_SUFFIX "d"
+#else
+#define LWIP_VERSION_STRING_SUFFIX "rc" LWIP_VERSTR(LWIP_VERSION_RC)
+#endif
+
+/** Provides the version of the stack */
+#define LWIP_VERSION   (((u32_t)LWIP_VERSION_MAJOR) << 24   | ((u32_t)LWIP_VERSION_MINOR) << 16 | \
+                        ((u32_t)LWIP_VERSION_REVISION) << 8 | ((u32_t)LWIP_VERSION_RC))
+/** Provides the version of the stack as string */
+#define LWIP_VERSION_STRING     LWIP_VERSTR(LWIP_VERSION_MAJOR) "." LWIP_VERSTR(LWIP_VERSION_MINOR) "." LWIP_VERSTR(LWIP_VERSION_REVISION) LWIP_VERSION_STRING_SUFFIX
+
+/**
+ * @}
+ */
+
+/* Modules initialization */
+void lwip_init(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_INIT_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/ip.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/ip.h
new file mode 100644
index 000000000..0413d541f
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/ip.h
@@ -0,0 +1,325 @@
+/**
+ * @file
+ * IP API
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_IP_H
+#define LWIP_HDR_IP_H
+
+#include "lwip/opt.h"
+
+#include "lwip/def.h"
+#include "lwip/pbuf.h"
+#include "lwip/ip_addr.h"
+#include "lwip/err.h"
+#include "lwip/netif.h"
+#include "lwip/ip4.h"
+#include "lwip/ip6.h"
+#include "lwip/prot/ip.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* This is passed as the destination address to ip_output_if (not
+   to ip_output), meaning that an IP header already is constructed
+   in the pbuf. This is used when TCP retransmits. */
+#define LWIP_IP_HDRINCL  NULL
+
+/** pbufs passed to IP must have a ref-count of 1 as their payload pointer
+    gets altered as the packet is passed down the stack */
+#ifndef LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX
+#define LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p) LWIP_ASSERT("p->ref == 1", (p)->ref == 1)
+#endif
+
+#if LWIP_NETIF_HWADDRHINT
+#define IP_PCB_ADDRHINT ;u8_t addr_hint
+#else
+#define IP_PCB_ADDRHINT
+#endif /* LWIP_NETIF_HWADDRHINT */
+
+/** This is the common part of all PCB types. It needs to be at the
+   beginning of a PCB type definition. It is located here so that
+   changes to this common part are made in one location instead of
+   having to change all PCB structs. */
+#define IP_PCB \
+  /* ip addresses in network byte order */ \
+  ip_addr_t local_ip; \
+  ip_addr_t remote_ip; \
+  /* Bound netif index */                  \
+  u8_t netif_idx;                          \
+  /* Socket options */                     \
+  u8_t so_options;      \
+   /* Type Of Service */ \
+  u8_t tos;              \
+  /* Time To Live */     \
+  u8_t ttl               \
+  /* link layer address resolution hint */ \
+  IP_PCB_ADDRHINT
+
+struct ip_pcb {
+/* Common members of all PCB types */
+  IP_PCB;
+};
+
+/*
+ * Option flags per-socket. These are the same like SO_XXX in sockets.h
+ */
+#define SOF_REUSEADDR     0x04U  /* allow local address reuse */
+#define SOF_KEEPALIVE     0x08U  /* keep connections alive */
+#define SOF_BROADCAST     0x20U  /* permit to send and to receive broadcast messages (see IP_SOF_BROADCAST option) */
+
+#if LWIP_MANAGEMENT_CHANNEL
+#define SOF_MANAGEMENT    0x40U  /* Indicates this socket is for management channel. */
+#endif
+
+/* These flags are inherited (e.g. from a listen-pcb to a connection-pcb): */
+#define SOF_INHERITED   (SOF_REUSEADDR|SOF_KEEPALIVE)
+
+/** Global variables of this module, kept in a struct for efficient access using base+index. */
+struct ip_globals
+{
+  /** The interface that accepted the packet for the current callback invocation. */
+  struct netif *current_netif;
+  /** The interface that received the packet for the current callback invocation. */
+  struct netif *current_input_netif;
+#if LWIP_IPV4
+  /** Header of the input packet currently being processed. */
+  struct ip_hdr *current_ip4_header;
+#endif /* LWIP_IPV4 */
+#if LWIP_IPV6
+  /** Header of the input IPv6 packet currently being processed. */
+  struct ip6_hdr *current_ip6_header;
+#endif /* LWIP_IPV6 */
+  /** Total header length of current_ip4/6_header (i.e. after this, the UDP/TCP header starts) */
+  u16_t current_ip_header_tot_len;
+  /** Source IP address of current_header */
+  ip_addr_t current_iphdr_src;
+  /** Destination IP address of current_header */
+  ip_addr_t current_iphdr_dest;
+};
+extern struct ip_globals ip_data;
+
+
+/** Get the interface that accepted the current packet.
+ * This may or may not be the receiving netif, depending on your netif/network setup.
+ * This function must only be called from a receive callback (udp_recv,
+ * raw_recv, tcp_accept). It will return NULL otherwise. */
+#define ip_current_netif()      (ip_data.current_netif)
+/** Get the interface that received the current packet.
+ * This function must only be called from a receive callback (udp_recv,
+ * raw_recv, tcp_accept). It will return NULL otherwise. */
+#define ip_current_input_netif() (ip_data.current_input_netif)
+/** Total header length of ip(6)_current_header() (i.e. after this, the UDP/TCP header starts) */
+#define ip_current_header_tot_len() (ip_data.current_ip_header_tot_len)
+/** Source IP address of current_header */
+#define ip_current_src_addr()   (&ip_data.current_iphdr_src)
+/** Destination IP address of current_header */
+#define ip_current_dest_addr()  (&ip_data.current_iphdr_dest)
+
+#if LWIP_IPV4 && LWIP_IPV6
+/** Get the IPv4 header of the current packet.
+ * This function must only be called from a receive callback (udp_recv,
+ * raw_recv, tcp_accept). It will return NULL otherwise. */
+#define ip4_current_header()     ((const struct ip_hdr*)(ip_data.current_ip4_header))
+/** Get the IPv6 header of the current packet.
+ * This function must only be called from a receive callback (udp_recv,
+ * raw_recv, tcp_accept). It will return NULL otherwise. */
+#define ip6_current_header()      ((const struct ip6_hdr*)(ip_data.current_ip6_header))
+/** Returns TRUE if the current IP input packet is IPv6, FALSE if it is IPv4 */
+#define ip_current_is_v6()        (ip6_current_header() != NULL)
+/** Source IPv6 address of current_header */
+#define ip6_current_src_addr()    (ip_2_ip6(&ip_data.current_iphdr_src))
+/** Destination IPv6 address of current_header */
+#define ip6_current_dest_addr()   (ip_2_ip6(&ip_data.current_iphdr_dest))
+/** Get the transport layer protocol */
+#define ip_current_header_proto() (ip_current_is_v6() ? \
+                                   IP6H_NEXTH(ip6_current_header()) :\
+                                   IPH_PROTO(ip4_current_header()))
+/** Get the transport layer header */
+#define ip_next_header_ptr()     ((const void*)((ip_current_is_v6() ? \
+  (const u8_t*)ip6_current_header() : (const u8_t*)ip4_current_header())  + ip_current_header_tot_len()))
+
+/** Source IP4 address of current_header */
+#define ip4_current_src_addr()     (ip_2_ip4(&ip_data.current_iphdr_src))
+/** Destination IP4 address of current_header */
+#define ip4_current_dest_addr()    (ip_2_ip4(&ip_data.current_iphdr_dest))
+
+#elif LWIP_IPV4 /* LWIP_IPV4 && LWIP_IPV6 */
+
+/** Get the IPv4 header of the current packet.
+ * This function must only be called from a receive callback (udp_recv,
+ * raw_recv, tcp_accept). It will return NULL otherwise. */
+#define ip4_current_header()     ((const struct ip_hdr*)(ip_data.current_ip4_header))
+/** Always returns FALSE when only supporting IPv4 only */
+#define ip_current_is_v6()        0
+/** Get the transport layer protocol */
+#define ip_current_header_proto() IPH_PROTO(ip4_current_header())
+/** Get the transport layer header */
+#define ip_next_header_ptr()     ((const void*)((const u8_t*)ip4_current_header() + ip_current_header_tot_len()))
+/** Source IP4 address of current_header */
+#define ip4_current_src_addr()     (&ip_data.current_iphdr_src)
+/** Destination IP4 address of current_header */
+#define ip4_current_dest_addr()    (&ip_data.current_iphdr_dest)
+
+#elif LWIP_IPV6 /* LWIP_IPV4 && LWIP_IPV6 */
+
+/** Get the IPv6 header of the current packet.
+ * This function must only be called from a receive callback (udp_recv,
+ * raw_recv, tcp_accept). It will return NULL otherwise. */
+#define ip6_current_header()      ((const struct ip6_hdr*)(ip_data.current_ip6_header))
+/** Always returns TRUE when only supporting IPv6 only */
+#define ip_current_is_v6()        1
+/** Get the transport layer protocol */
+#define ip_current_header_proto() IP6H_NEXTH(ip6_current_header())
+/** Get the transport layer header */
+#define ip_next_header_ptr()     ((const void*)((const u8_t*)ip6_current_header()))
+/** Source IP6 address of current_header */
+#define ip6_current_src_addr()    (&ip_data.current_iphdr_src)
+/** Destination IP6 address of current_header */
+#define ip6_current_dest_addr()   (&ip_data.current_iphdr_dest)
+
+#endif /* LWIP_IPV6 */
+
+/** Union source address of current_header */
+#define ip_current_src_addr()    (&ip_data.current_iphdr_src)
+/** Union destination address of current_header */
+#define ip_current_dest_addr()   (&ip_data.current_iphdr_dest)
+
+/** Gets an IP pcb option (SOF_* flags) */
+#define ip_get_option(pcb, opt)   ((pcb)->so_options & (opt))
+/** Sets an IP pcb option (SOF_* flags) */
+#define ip_set_option(pcb, opt)   ((pcb)->so_options |= (opt))
+/** Resets an IP pcb option (SOF_* flags) */
+#define ip_reset_option(pcb, opt) ((pcb)->so_options &= ~(opt))
+
+#if LWIP_IPV4 && LWIP_IPV6
+/**
+ * @ingroup ip
+ * Output IP packet, netif is selected by source address
+ */
+#define ip_output(p, src, dest, ttl, tos, proto, pcb) \
+        (IP_IS_V6(dest) ? \
+        ip6_output(p, ip_2_ip6(src), ip_2_ip6(dest), ttl, tos, proto, pcb) : \
+        ip4_output(p, ip_2_ip4(src), ip_2_ip4(dest), ttl, tos, proto, pcb))
+/**
+ * @ingroup ip
+ * Output IP packet to specified interface
+ */
+#define ip_output_if(p, src, dest, ttl, tos, proto, netif) \
+        (IP_IS_V6(dest) ? \
+        ip6_output_if(p, ip_2_ip6(src), ip_2_ip6(dest), ttl, tos, proto, netif) : \
+        ip4_output_if(p, ip_2_ip4(src), ip_2_ip4(dest), ttl, tos, proto, netif))
+/**
+ * @ingroup ip
+ * Output IP packet to interface specifying source address
+ */
+#define ip_output_if_src(p, src, dest, ttl, tos, proto, netif) \
+        (IP_IS_V6(dest) ? \
+        ip6_output_if_src(p, ip_2_ip6(src), ip_2_ip6(dest), ttl, tos, proto, netif) : \
+        ip4_output_if_src(p, ip_2_ip4(src), ip_2_ip4(dest), ttl, tos, proto, netif))
+/** Output IP packet with addr_hint */
+#define ip_output_hinted(p, src, dest, ttl, tos, proto, addr_hint) \
+        (IP_IS_V6(dest) ? \
+        ip6_output_hinted(p, ip_2_ip6(src), ip_2_ip6(dest), ttl, tos, proto, addr_hint) : \
+        ip4_output_hinted(p, ip_2_ip4(src), ip_2_ip4(dest), ttl, tos, proto, addr_hint))
+/**
+ * @ingroup ip
+ * Get netif for address combination. See \ref ip6_route and \ref ip4_route
+ */
+#define ip_route(src, dest) \
+        (IP_IS_V6(dest) ? \
+        ip6_route(ip_2_ip6(src), ip_2_ip6(dest)) : \
+        ip4_route_src(ip_2_ip4(dest), ip_2_ip4(src)))
+/**
+ * @ingroup ip
+ * Get netif for IP.
+ */
+#define ip_netif_get_local_ip(netif, dest) (IP_IS_V6(dest) ? \
+        ip6_netif_get_local_ip(netif, ip_2_ip6(dest)) : \
+        ip4_netif_get_local_ip(netif))
+#define ip_debug_print(is_ipv6, p) ((is_ipv6) ? ip6_debug_print(p) : ip4_debug_print(p))
+
+err_t ip_input(struct pbuf *p, struct netif *inp);
+
+#elif LWIP_IPV4 /* LWIP_IPV4 && LWIP_IPV6 */
+
+#define ip_output(p, src, dest, ttl, tos, proto, pcb) \
+        ip4_output(p, src, dest, ttl, tos, proto, pcb)
+#define ip_output_if(p, src, dest, ttl, tos, proto, netif) \
+        ip4_output_if(p, src, dest, ttl, tos, proto, netif)
+#define ip_output_if_src(p, src, dest, ttl, tos, proto, netif) \
+        ip4_output_if_src(p, src, dest, ttl, tos, proto, netif)
+#define ip_output_hinted(p, src, dest, ttl, tos, proto, addr_hint) \
+        ip4_output_hinted(p, src, dest, ttl, tos, proto, addr_hint)
+#define ip_route(src, dest) \
+        ip4_route_src(dest, src)
+#define ip_netif_get_local_ip(netif, dest) \
+        ip4_netif_get_local_ip(netif)
+#define ip_debug_print(is_ipv6, p) ip4_debug_print(p)
+
+#define ip_input ip4_input
+
+#elif LWIP_IPV6 /* LWIP_IPV4 && LWIP_IPV6 */
+
+#define ip_output(p, src, dest, ttl, tos, proto, pcb) \
+        ip6_output(p, src, dest, ttl, tos, proto, pcb)
+#define ip_output_if(p, src, dest, ttl, tos, proto, netif) \
+        ip6_output_if(p, src, dest, ttl, tos, proto, netif)
+#define ip_output_if_src(p, src, dest, ttl, tos, proto, netif) \
+        ip6_output_if_src(p, src, dest, ttl, tos, proto, netif)
+#define ip_output_hinted(p, src, dest, ttl, tos, proto, addr_hint) \
+        ip6_output_hinted(p, src, dest, ttl, tos, proto, addr_hint)
+#define ip_route(src, dest) \
+        ip6_route(src, dest)
+#define ip_netif_get_local_ip(netif, dest) \
+        ip6_netif_get_local_ip(netif, dest)
+#define ip_debug_print(is_ipv6, p) ip6_debug_print(p)
+
+#define ip_input ip6_input
+
+#endif /* LWIP_IPV6 */
+
+#define ip_route_get_local_ip(src, dest, netif, ipaddr) do { \
+  (netif) = ip_route(src, dest); \
+  (ipaddr) = ip_netif_get_local_ip(netif, dest); \
+}while(0)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_IP_H */
+
+
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/ip4.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/ip4.h
new file mode 100644
index 000000000..d7f84aafb
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/ip4.h
@@ -0,0 +1,111 @@
+/**
+ * @file
+ * IPv4 API
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_IP4_H
+#define LWIP_HDR_IP4_H
+
+#include "lwip/opt.h"
+
+#if LWIP_IPV4
+
+#include "lwip/def.h"
+#include "lwip/pbuf.h"
+#include "lwip/ip4_addr.h"
+#include "lwip/err.h"
+#include "lwip/netif.h"
+#include "lwip/prot/ip4.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef LWIP_HOOK_IP4_ROUTE_SRC
+#define LWIP_IPV4_SRC_ROUTING   1
+#else
+#define LWIP_IPV4_SRC_ROUTING   0
+#endif
+
+/** Currently, the function ip_output_if_opt() is only used with IGMP */
+#define IP_OPTIONS_SEND   (LWIP_IPV4 && LWIP_IGMP)
+
+#define ip_init() /* Compatibility define, no init needed. */
+struct netif *ip4_route(const ip4_addr_t *dest);
+#if LWIP_IPV4_SRC_ROUTING
+struct netif *ip4_route_src(const ip4_addr_t *dest, const ip4_addr_t *src);
+#else /* LWIP_IPV4_SRC_ROUTING */
+#define ip4_route_src(dest, src) ip4_route(dest)
+#endif /* LWIP_IPV4_SRC_ROUTING */
+err_t ip4_input(struct pbuf *p, struct netif *inp);
+err_t ip4_output(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
+       u8_t ttl, u8_t tos, u8_t proto, struct ip_pcb *pcb);
+err_t ip4_output_if(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
+       u8_t ttl, u8_t tos, u8_t proto, struct netif *netif);
+err_t ip4_output_if_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
+       u8_t ttl, u8_t tos, u8_t proto, struct netif *netif);
+#if LWIP_NETIF_HWADDRHINT
+err_t ip4_output_hinted(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
+       u8_t ttl, u8_t tos, u8_t proto, u8_t *addr_hint);
+#endif /* LWIP_NETIF_HWADDRHINT */
+#if IP_OPTIONS_SEND
+err_t ip4_output_if_opt(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
+       u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
+       u16_t optlen);
+err_t ip4_output_if_opt_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
+       u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
+       u16_t optlen);
+#endif /* IP_OPTIONS_SEND */
+
+#if LWIP_MULTICAST_TX_OPTIONS
+void  ip4_set_default_multicast_netif(struct netif* default_multicast_netif);
+#endif /* LWIP_MULTICAST_TX_OPTIONS */
+
+#define ip4_netif_get_local_ip(netif) (((netif) != NULL) ? netif_ip_addr4(netif) : NULL)
+
+#if IP_DEBUG
+void ip4_debug_print(struct pbuf *p);
+#else
+#define ip4_debug_print(p)
+#endif /* IP_DEBUG */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_IPV4 */
+
+#endif /* LWIP_HDR_IP_H */
+
+
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/ip4_addr.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/ip4_addr.h
new file mode 100644
index 000000000..51b46b8d4
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/ip4_addr.h
@@ -0,0 +1,227 @@
+/**
+ * @file
+ * IPv4 address API
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_IP4_ADDR_H
+#define LWIP_HDR_IP4_ADDR_H
+
+#include "lwip/opt.h"
+#include "lwip/def.h"
+
+#if LWIP_IPV4
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** This is the aligned version of ip4_addr_t,
+   used as local variable, on the stack, etc. */
+struct ip4_addr {
+  u32_t addr;
+};
+
+/** ip4_addr_t uses a struct for convenience only, so that the same defines can
+ * operate both on ip4_addr_t as well as on ip4_addr_p_t. */
+typedef struct ip4_addr ip4_addr_t;
+
+/**
+ * struct ipaddr2 is used in the definition of the ARP packet format in
+ * order to support compilers that don't have structure packing.
+ */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct ip4_addr2 {
+  PACK_STRUCT_FIELD(u16_t addrw[2]);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/* Forward declaration to not include netif.h */
+struct netif;
+
+/** 255.255.255.255 */
+#define IPADDR_NONE         ((u32_t)0xffffffffUL)
+/** 127.0.0.1 */
+#define IPADDR_LOOPBACK     ((u32_t)0x7f000001UL)
+/** 0.0.0.0 */
+#define IPADDR_ANY          ((u32_t)0x00000000UL)
+/** 255.255.255.255 */
+#define IPADDR_BROADCAST    ((u32_t)0xffffffffUL)
+
+/* Definitions of the bits in an Internet address integer.
+
+   On subnets, host and network parts are found according to
+   the subnet mask, not these masks.  */
+#define IP_CLASSA(a)        ((((u32_t)(a)) & 0x80000000UL) == 0)
+#define IP_CLASSA_NET       0xff000000
+#define IP_CLASSA_NSHIFT    24
+#define IP_CLASSA_HOST      (0xffffffff & ~IP_CLASSA_NET)
+#define IP_CLASSA_MAX       128
+
+#define IP_CLASSB(a)        ((((u32_t)(a)) & 0xc0000000UL) == 0x80000000UL)
+#define IP_CLASSB_NET       0xffff0000
+#define IP_CLASSB_NSHIFT    16
+#define IP_CLASSB_HOST      (0xffffffff & ~IP_CLASSB_NET)
+#define IP_CLASSB_MAX       65536
+
+#define IP_CLASSC(a)        ((((u32_t)(a)) & 0xe0000000UL) == 0xc0000000UL)
+#define IP_CLASSC_NET       0xffffff00
+#define IP_CLASSC_NSHIFT    8
+#define IP_CLASSC_HOST      (0xffffffff & ~IP_CLASSC_NET)
+
+#define IP_CLASSD(a)        (((u32_t)(a) & 0xf0000000UL) == 0xe0000000UL)
+#define IP_CLASSD_NET       0xf0000000          /* These ones aren't really */
+#define IP_CLASSD_NSHIFT    28                  /*   net and host fields, but */
+#define IP_CLASSD_HOST      0x0fffffff          /*   routing needn't know. */
+#define IP_MULTICAST(a)     IP_CLASSD(a)
+
+#define IP_EXPERIMENTAL(a)  (((u32_t)(a) & 0xf0000000UL) == 0xf0000000UL)
+#define IP_BADCLASS(a)      (((u32_t)(a) & 0xf0000000UL) == 0xf0000000UL)
+
+#define IP_LOOPBACKNET      127                 /* official! */
+
+/** Set an IP address given by the four byte-parts */
+#define IP4_ADDR(ipaddr, a,b,c,d)  (ipaddr)->addr = PP_HTONL(LWIP_MAKEU32(a,b,c,d))
+
+/** MEMCPY-like copying of IP addresses where addresses are known to be
+ * 16-bit-aligned if the port is correctly configured (so a port could define
+ * this to copying 2 u16_t's) - no NULL-pointer-checking needed. */
+#ifndef IPADDR2_COPY
+#define IPADDR2_COPY(dest, src) SMEMCPY(dest, src, sizeof(ip4_addr_t))
+#endif
+
+/** Copy IP address - faster than ip4_addr_set: no NULL check */
+#define ip4_addr_copy(dest, src) ((dest).addr = (src).addr)
+/** Safely copy one IP address to another (src may be NULL) */
+#define ip4_addr_set(dest, src) ((dest)->addr = \
+                                    ((src) == NULL ? 0 : \
+                                    (src)->addr))
+/** Set complete address to zero */
+#define ip4_addr_set_zero(ipaddr)     ((ipaddr)->addr = 0)
+/** Set address to IPADDR_ANY (no need for lwip_htonl()) */
+#define ip4_addr_set_any(ipaddr)      ((ipaddr)->addr = IPADDR_ANY)
+/** Set address to loopback address */
+#define ip4_addr_set_loopback(ipaddr) ((ipaddr)->addr = PP_HTONL(IPADDR_LOOPBACK))
+/** Check if an address is in the loopback region */
+#define ip4_addr_isloopback(ipaddr)    (((ipaddr)->addr & PP_HTONL(IP_CLASSA_NET)) == PP_HTONL(((u32_t)IP_LOOPBACKNET) << 24))
+/** Safely copy one IP address to another and change byte order
+ * from host- to network-order. */
+#define ip4_addr_set_hton(dest, src) ((dest)->addr = \
+                               ((src) == NULL ? 0:\
+                               lwip_htonl((src)->addr)))
+/** IPv4 only: set the IP address given as an u32_t */
+#define ip4_addr_set_u32(dest_ipaddr, src_u32) ((dest_ipaddr)->addr = (src_u32))
+/** IPv4 only: get the IP address as an u32_t */
+#define ip4_addr_get_u32(src_ipaddr) ((src_ipaddr)->addr)
+
+/** Get the network address by combining host address with netmask */
+#define ip4_addr_get_network(target, host, netmask) do { ((target)->addr = ((host)->addr) & ((netmask)->addr)); } while(0)
+
+/**
+ * Determine if two address are on the same network.
+ *
+ * @arg addr1 IP address 1
+ * @arg addr2 IP address 2
+ * @arg mask network identifier mask
+ * @return !0 if the network identifiers of both address match
+ */
+#define ip4_addr_netcmp(addr1, addr2, mask) (((addr1)->addr & \
+                                              (mask)->addr) == \
+                                             ((addr2)->addr & \
+                                              (mask)->addr))
+#define ip4_addr_cmp(addr1, addr2) ((addr1)->addr == (addr2)->addr)
+
+#define ip4_addr_isany_val(addr1)   ((addr1).addr == IPADDR_ANY)
+#define ip4_addr_isany(addr1) ((addr1) == NULL || ip4_addr_isany_val(*(addr1)))
+
+#define ip4_addr_isbroadcast(addr1, netif) ip4_addr_isbroadcast_u32((addr1)->addr, netif)
+u8_t ip4_addr_isbroadcast_u32(u32_t addr, const struct netif *netif);
+
+#define ip_addr_netmask_valid(netmask) ip4_addr_netmask_valid((netmask)->addr)
+u8_t ip4_addr_netmask_valid(u32_t netmask);
+
+#define ip4_addr_ismulticast(addr1) (((addr1)->addr & PP_HTONL(0xf0000000UL)) == PP_HTONL(0xe0000000UL))
+
+#define ip4_addr_islinklocal(addr1) (((addr1)->addr & PP_HTONL(0xffff0000UL)) == PP_HTONL(0xa9fe0000UL))
+
+#define ip4_addr_debug_print_parts(debug, a, b, c, d) \
+  LWIP_DEBUGF(debug, ("%" U16_F ".%" U16_F ".%" U16_F ".%" U16_F, a, b, c, d))
+#define ip4_addr_debug_print(debug, ipaddr) \
+  ip4_addr_debug_print_parts(debug, \
+                      (u16_t)((ipaddr) != NULL ? ip4_addr1_16(ipaddr) : 0),       \
+                      (u16_t)((ipaddr) != NULL ? ip4_addr2_16(ipaddr) : 0),       \
+                      (u16_t)((ipaddr) != NULL ? ip4_addr3_16(ipaddr) : 0),       \
+                      (u16_t)((ipaddr) != NULL ? ip4_addr4_16(ipaddr) : 0))
+#define ip4_addr_debug_print_val(debug, ipaddr) \
+  ip4_addr_debug_print_parts(debug, \
+                      ip4_addr1_16(&(ipaddr)),       \
+                      ip4_addr2_16(&(ipaddr)),       \
+                      ip4_addr3_16(&(ipaddr)),       \
+                      ip4_addr4_16(&(ipaddr)))
+
+/* Get one byte from the 4-byte address */
+#define ip4_addr1(ipaddr) (((const u8_t*)(&(ipaddr)->addr))[0])
+#define ip4_addr2(ipaddr) (((const u8_t*)(&(ipaddr)->addr))[1])
+#define ip4_addr3(ipaddr) (((const u8_t*)(&(ipaddr)->addr))[2])
+#define ip4_addr4(ipaddr) (((const u8_t*)(&(ipaddr)->addr))[3])
+/* These are cast to u16_t, with the intent that they are often arguments
+ * to printf using the U16_F format from cc.h. */
+#define ip4_addr1_16(ipaddr) ((u16_t)ip4_addr1(ipaddr))
+#define ip4_addr2_16(ipaddr) ((u16_t)ip4_addr2(ipaddr))
+#define ip4_addr3_16(ipaddr) ((u16_t)ip4_addr3(ipaddr))
+#define ip4_addr4_16(ipaddr) ((u16_t)ip4_addr4(ipaddr))
+
+#define IP4ADDR_STRLEN_MAX  16
+
+/** For backwards compatibility */
+#define ip_ntoa(ipaddr)  ipaddr_ntoa(ipaddr)
+
+u32_t ipaddr_addr(const char *cp);
+int ip4addr_aton(const char *cp, ip4_addr_t *addr);
+/** returns ptr to static buffer; not reentrant! */
+char *ip4addr_ntoa(const ip4_addr_t *addr);
+char *ip4addr_ntoa_r(const ip4_addr_t *addr, char *buf, int buflen);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_IPV4 */
+
+#endif /* LWIP_HDR_IP_ADDR_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/ip4_frag.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/ip4_frag.h
new file mode 100644
index 000000000..ed5bf14a3
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/ip4_frag.h
@@ -0,0 +1,100 @@
+/**
+ * @file
+ * IP fragmentation/reassembly
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Jani Monoses <jani@iv.ro>
+ *
+ */
+
+#ifndef LWIP_HDR_IP4_FRAG_H
+#define LWIP_HDR_IP4_FRAG_H
+
+#include "lwip/opt.h"
+#include "lwip/err.h"
+#include "lwip/pbuf.h"
+#include "lwip/netif.h"
+#include "lwip/ip_addr.h"
+#include "lwip/ip.h"
+
+#if LWIP_IPV4
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if IP_REASSEMBLY
+/* The IP reassembly timer interval in milliseconds. */
+#define IP_TMR_INTERVAL 1000
+
+/** IP reassembly helper struct.
+ * This is exported because memp needs to know the size.
+ */
+struct ip_reassdata {
+  struct ip_reassdata *next;
+  struct pbuf *p;
+  struct ip_hdr iphdr;
+  u16_t datagram_len;
+  u8_t flags;
+  u8_t timer;
+};
+
+void ip_reass_init(void);
+void ip_reass_tmr(void);
+struct pbuf * ip4_reass(struct pbuf *p);
+#endif /* IP_REASSEMBLY */
+
+#if IP_FRAG
+#if !LWIP_NETIF_TX_SINGLE_PBUF
+#ifndef LWIP_PBUF_CUSTOM_REF_DEFINED
+#define LWIP_PBUF_CUSTOM_REF_DEFINED
+/** A custom pbuf that holds a reference to another pbuf, which is freed
+ * when this custom pbuf is freed. This is used to create a custom PBUF_REF
+ * that points into the original pbuf. */
+struct pbuf_custom_ref {
+  /** 'base class' */
+  struct pbuf_custom pc;
+  /** pointer to the original pbuf that is referenced */
+  struct pbuf *original;
+};
+#endif /* LWIP_PBUF_CUSTOM_REF_DEFINED */
+#endif /* !LWIP_NETIF_TX_SINGLE_PBUF */
+
+err_t ip4_frag(struct pbuf *p, struct netif *netif, const ip4_addr_t *dest);
+#endif /* IP_FRAG */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_IPV4 */
+
+#endif /* LWIP_HDR_IP4_FRAG_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/ip6.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/ip6.h
new file mode 100644
index 000000000..9cadabe44
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/ip6.h
@@ -0,0 +1,93 @@
+/**
+ * @file
+ *
+ * IPv6 layer.
+ */
+
+/*
+ * Copyright (c) 2010 Inico Technologies Ltd.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Ivan Delamer <delamer@inicotech.com>
+ *
+ *
+ * Please coordinate changes and requests with Ivan Delamer
+ * <delamer@inicotech.com>
+ */
+#ifndef LWIP_HDR_IP6_H
+#define LWIP_HDR_IP6_H
+
+#include "lwip/opt.h"
+
+#if LWIP_IPV6  /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/ip6_addr.h"
+#include "lwip/prot/ip6.h"
+#include "lwip/def.h"
+#include "lwip/pbuf.h"
+#include "lwip/netif.h"
+
+#include "lwip/err.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct netif *ip6_route(const ip6_addr_t *src, const ip6_addr_t *dest);
+const ip_addr_t *ip6_select_source_address(struct netif *netif, const ip6_addr_t * dest);
+err_t         ip6_input(struct pbuf *p, struct netif *inp);
+err_t         ip6_output(struct pbuf *p, const ip6_addr_t *src, const ip6_addr_t *dest,
+                         u8_t hl, u8_t tc, u8_t nexth, struct ip_pcb *pcb);
+err_t         ip6_output_if(struct pbuf *p, const ip6_addr_t *src, const ip6_addr_t *dest,
+                            u8_t hl, u8_t tc, u8_t nexth, struct netif *netif);
+err_t         ip6_output_if_src(struct pbuf *p, const ip6_addr_t *src, const ip6_addr_t *dest,
+                            u8_t hl, u8_t tc, u8_t nexth, struct netif *netif);
+#if LWIP_NETIF_HWADDRHINT
+err_t         ip6_output_hinted(struct pbuf *p, const ip6_addr_t *src, const ip6_addr_t *dest,
+                                u8_t hl, u8_t tc, u8_t nexth, u8_t *addr_hint);
+#endif /* LWIP_NETIF_HWADDRHINT */
+#if LWIP_IPV6_MLD
+err_t         ip6_options_add_hbh_ra(struct pbuf * p, u8_t nexth, u8_t value);
+#endif /* LWIP_IPV6_MLD */
+
+#define ip6_netif_get_local_ip(netif, dest) (((netif) != NULL) ? \
+  ip6_select_source_address(netif, dest) : NULL)
+
+#if IP6_DEBUG
+void ip6_debug_print(struct pbuf *p);
+#else
+#define ip6_debug_print(p)
+#endif /* IP6_DEBUG */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_IPV6 */
+
+#endif /* LWIP_HDR_IP6_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/ip6_addr.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/ip6_addr.h
new file mode 100644
index 000000000..017502200
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/ip6_addr.h
@@ -0,0 +1,306 @@
+/**
+ * @file
+ *
+ * IPv6 addresses.
+ */
+
+/*
+ * Copyright (c) 2010 Inico Technologies Ltd.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Ivan Delamer <delamer@inicotech.com>
+ *
+ * Structs and macros for handling IPv6 addresses.
+ *
+ * Please coordinate changes and requests with Ivan Delamer
+ * <delamer@inicotech.com>
+ */
+#ifndef LWIP_HDR_IP6_ADDR_H
+#define LWIP_HDR_IP6_ADDR_H
+
+#include "lwip/opt.h"
+#include "def.h"
+
+#if LWIP_IPV6  /* don't build if not configured for use in lwipopts.h */
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/** This is the aligned version of ip6_addr_t,
+    used as local variable, on the stack, etc. */
+struct ip6_addr {
+  u32_t addr[4];
+};
+
+/** IPv6 address */
+typedef struct ip6_addr ip6_addr_t;
+
+/** Set an IPv6 partial address given by byte-parts */
+#define IP6_ADDR_PART(ip6addr, index, a,b,c,d) \
+  (ip6addr)->addr[index] = PP_HTONL(LWIP_MAKEU32(a,b,c,d))
+
+/** Set a full IPv6 address by passing the 4 u32_t indices in network byte order
+    (use PP_HTONL() for constants) */
+#define IP6_ADDR(ip6addr, idx0, idx1, idx2, idx3) do { \
+  (ip6addr)->addr[0] = idx0; \
+  (ip6addr)->addr[1] = idx1; \
+  (ip6addr)->addr[2] = idx2; \
+  (ip6addr)->addr[3] = idx3; } while(0)
+
+/** Access address in 16-bit block */
+#define IP6_ADDR_BLOCK1(ip6addr) ((u16_t)((lwip_htonl((ip6addr)->addr[0]) >> 16) & 0xffff))
+/** Access address in 16-bit block */
+#define IP6_ADDR_BLOCK2(ip6addr) ((u16_t)((lwip_htonl((ip6addr)->addr[0])) & 0xffff))
+/** Access address in 16-bit block */
+#define IP6_ADDR_BLOCK3(ip6addr) ((u16_t)((lwip_htonl((ip6addr)->addr[1]) >> 16) & 0xffff))
+/** Access address in 16-bit block */
+#define IP6_ADDR_BLOCK4(ip6addr) ((u16_t)((lwip_htonl((ip6addr)->addr[1])) & 0xffff))
+/** Access address in 16-bit block */
+#define IP6_ADDR_BLOCK5(ip6addr) ((u16_t)((lwip_htonl((ip6addr)->addr[2]) >> 16) & 0xffff))
+/** Access address in 16-bit block */
+#define IP6_ADDR_BLOCK6(ip6addr) ((u16_t)((lwip_htonl((ip6addr)->addr[2])) & 0xffff))
+/** Access address in 16-bit block */
+#define IP6_ADDR_BLOCK7(ip6addr) ((u16_t)((lwip_htonl((ip6addr)->addr[3]) >> 16) & 0xffff))
+/** Access address in 16-bit block */
+#define IP6_ADDR_BLOCK8(ip6addr) ((u16_t)((lwip_htonl((ip6addr)->addr[3])) & 0xffff))
+
+/** Copy IPv6 address - faster than ip6_addr_set: no NULL check */
+#define ip6_addr_copy(dest, src) do{(dest).addr[0] = (src).addr[0]; \
+                                    (dest).addr[1] = (src).addr[1]; \
+                                    (dest).addr[2] = (src).addr[2]; \
+                                    (dest).addr[3] = (src).addr[3];}while(0)
+/** Safely copy one IPv6 address to another (src may be NULL) */
+#define ip6_addr_set(dest, src) do{(dest)->addr[0] = (src) == NULL ? 0 : (src)->addr[0]; \
+                                   (dest)->addr[1] = (src) == NULL ? 0 : (src)->addr[1]; \
+                                   (dest)->addr[2] = (src) == NULL ? 0 : (src)->addr[2]; \
+                                   (dest)->addr[3] = (src) == NULL ? 0 : (src)->addr[3];}while(0)
+
+/** Set complete address to zero */
+#define ip6_addr_set_zero(ip6addr)    do{(ip6addr)->addr[0] = 0; \
+                                         (ip6addr)->addr[1] = 0; \
+                                         (ip6addr)->addr[2] = 0; \
+                                         (ip6addr)->addr[3] = 0;}while(0)
+
+/** Set address to ipv6 'any' (no need for lwip_htonl()) */
+#define ip6_addr_set_any(ip6addr)       ip6_addr_set_zero(ip6addr)
+/** Set address to ipv6 loopback address */
+#define ip6_addr_set_loopback(ip6addr) do{(ip6addr)->addr[0] = 0; \
+                                          (ip6addr)->addr[1] = 0; \
+                                          (ip6addr)->addr[2] = 0; \
+                                          (ip6addr)->addr[3] = PP_HTONL(0x00000001UL);}while(0)
+/** Safely copy one IPv6 address to another and change byte order
+ * from host- to network-order. */
+#define ip6_addr_set_hton(dest, src) do{(dest)->addr[0] = (src) == NULL ? 0 : lwip_htonl((src)->addr[0]); \
+                                        (dest)->addr[1] = (src) == NULL ? 0 : lwip_htonl((src)->addr[1]); \
+                                        (dest)->addr[2] = (src) == NULL ? 0 : lwip_htonl((src)->addr[2]); \
+                                        (dest)->addr[3] = (src) == NULL ? 0 : lwip_htonl((src)->addr[3]);}while(0)
+
+
+/**
+ * Determine if two IPv6 address are on the same network.
+ *
+ * @arg addr1 IPv6 address 1
+ * @arg addr2 IPv6 address 2
+ * @return !0 if the network identifiers of both address match
+ */
+#define ip6_addr_netcmp(addr1, addr2) (((addr1)->addr[0] == (addr2)->addr[0]) && \
+                                       ((addr1)->addr[1] == (addr2)->addr[1]))
+
+#define ip6_addr_net48cmp(addr1, addr2) (((addr1)->addr[0] == (addr2)->addr[0]) && \
+                                         (((addr1)->addr[1] & PP_HTONL(0xffff0000UL)) == \
+                                          ((addr2)->addr[1] & PP_HTONL(0xffff0000UL))))
+
+/* Exact-host comparison *after* ip6_addr_netcmp() succeeded, for efficiency. */
+#define ip6_addr_nethostcmp(addr1, addr2) (((addr1)->addr[2] == (addr2)->addr[2]) && \
+                                           ((addr1)->addr[3] == (addr2)->addr[3]))
+
+#define ip6_addr_cmp(addr1, addr2) (((addr1)->addr[0] == (addr2)->addr[0]) && \
+                                    ((addr1)->addr[1] == (addr2)->addr[1]) && \
+                                    ((addr1)->addr[2] == (addr2)->addr[2]) && \
+                                    ((addr1)->addr[3] == (addr2)->addr[3]))
+
+#define ip6_get_subnet_id(ip6addr)   (lwip_htonl((ip6addr)->addr[1]) & 0x0000ffffUL)
+
+#define ip6_addr_isany_val(ip6addr) (((ip6addr).addr[0] == 0) && \
+                                     ((ip6addr).addr[1] == 0) && \
+                                     ((ip6addr).addr[2] == 0) && \
+                                     ((ip6addr).addr[3] == 0))
+#define ip6_addr_isany(ip6addr) (((ip6addr) == NULL) || ip6_addr_isany_val(*(ip6addr)))
+
+#define ip6_addr_isloopback(ip6addr) (((ip6addr)->addr[0] == 0UL) && \
+                                      ((ip6addr)->addr[1] == 0UL) && \
+                                      ((ip6addr)->addr[2] == 0UL) && \
+                                      ((ip6addr)->addr[3] == PP_HTONL(0x00000001UL)))
+
+#define ip6_addr_isglobal(ip6addr) (((ip6addr)->addr[0] & PP_HTONL(0xe0000000UL)) == PP_HTONL(0x20000000UL))
+
+#define ip6_addr_islinklocal(ip6addr) (((ip6addr)->addr[0] & PP_HTONL(0xffc00000UL)) == PP_HTONL(0xfe800000UL))
+
+#define ip6_addr_issitelocal(ip6addr) (((ip6addr)->addr[0] & PP_HTONL(0xffc00000UL)) == PP_HTONL(0xfec00000UL))
+
+#define ip6_addr_isuniquelocal(ip6addr) (((ip6addr)->addr[0] & PP_HTONL(0xfe000000UL)) == PP_HTONL(0xfc000000UL))
+
+#define ip6_addr_isipv4mappedipv6(ip6addr) (((ip6addr)->addr[0] == 0) && ((ip6addr)->addr[1] == 0) && (((ip6addr)->addr[2]) == PP_HTONL(0x0000FFFFUL)))
+
+#define ip6_addr_ismulticast(ip6addr) (((ip6addr)->addr[0] & PP_HTONL(0xff000000UL)) == PP_HTONL(0xff000000UL))
+#define ip6_addr_multicast_transient_flag(ip6addr)  ((ip6addr)->addr[0] & PP_HTONL(0x00100000UL))
+#define ip6_addr_multicast_prefix_flag(ip6addr)     ((ip6addr)->addr[0] & PP_HTONL(0x00200000UL))
+#define ip6_addr_multicast_rendezvous_flag(ip6addr) ((ip6addr)->addr[0] & PP_HTONL(0x00400000UL))
+#define ip6_addr_multicast_scope(ip6addr) ((lwip_htonl((ip6addr)->addr[0]) >> 16) & 0xf)
+#define IP6_MULTICAST_SCOPE_RESERVED            0x0
+#define IP6_MULTICAST_SCOPE_RESERVED0           0x0
+#define IP6_MULTICAST_SCOPE_INTERFACE_LOCAL     0x1
+#define IP6_MULTICAST_SCOPE_LINK_LOCAL          0x2
+#define IP6_MULTICAST_SCOPE_RESERVED3           0x3
+#define IP6_MULTICAST_SCOPE_ADMIN_LOCAL         0x4
+#define IP6_MULTICAST_SCOPE_SITE_LOCAL          0x5
+#define IP6_MULTICAST_SCOPE_ORGANIZATION_LOCAL  0x8
+#define IP6_MULTICAST_SCOPE_GLOBAL              0xe
+#define IP6_MULTICAST_SCOPE_RESERVEDF           0xf
+#define ip6_addr_ismulticast_iflocal(ip6addr) (((ip6addr)->addr[0] & PP_HTONL(0xff8f0000UL)) == PP_HTONL(0xff010000UL))
+#define ip6_addr_ismulticast_linklocal(ip6addr) (((ip6addr)->addr[0] & PP_HTONL(0xff8f0000UL)) == PP_HTONL(0xff020000UL))
+#define ip6_addr_ismulticast_adminlocal(ip6addr) (((ip6addr)->addr[0] & PP_HTONL(0xff8f0000UL)) == PP_HTONL(0xff040000UL))
+#define ip6_addr_ismulticast_sitelocal(ip6addr) (((ip6addr)->addr[0] & PP_HTONL(0xff8f0000UL)) == PP_HTONL(0xff050000UL))
+#define ip6_addr_ismulticast_orglocal(ip6addr) (((ip6addr)->addr[0] & PP_HTONL(0xff8f0000UL)) == PP_HTONL(0xff080000UL))
+#define ip6_addr_ismulticast_global(ip6addr) (((ip6addr)->addr[0] & PP_HTONL(0xff8f0000UL)) == PP_HTONL(0xff0e0000UL))
+
+/* @todo define get/set for well-know multicast addresses, e.g. ff02::1 */
+#define ip6_addr_isallnodes_iflocal(ip6addr) (((ip6addr)->addr[0] == PP_HTONL(0xff010000UL)) && \
+    ((ip6addr)->addr[1] == 0UL) && \
+    ((ip6addr)->addr[2] == 0UL) && \
+    ((ip6addr)->addr[3] == PP_HTONL(0x00000001UL)))
+
+#define ip6_addr_isallnodes_linklocal(ip6addr) (((ip6addr)->addr[0] == PP_HTONL(0xff020000UL)) && \
+    ((ip6addr)->addr[1] == 0UL) && \
+    ((ip6addr)->addr[2] == 0UL) && \
+    ((ip6addr)->addr[3] == PP_HTONL(0x00000001UL)))
+#define ip6_addr_isallnodes_networklocal(ip6addr) (((ip6addr)->addr[0] == PP_HTONL(0xff030000UL)) && \
+    ((ip6addr)->addr[1] == 0UL) && \
+    ((ip6addr)->addr[2] == 0UL) && \
+    ((ip6addr)->addr[3] == PP_HTONL(0x00000001UL)))
+#define ip6_addr_set_allnodes_linklocal(ip6addr) do{(ip6addr)->addr[0] = PP_HTONL(0xff020000UL); \
+                (ip6addr)->addr[1] = 0; \
+                (ip6addr)->addr[2] = 0; \
+                (ip6addr)->addr[3] = PP_HTONL(0x00000001UL);}while(0)
+
+#define ip6_addr_isallrouters_linklocal(ip6addr) (((ip6addr)->addr[0] == PP_HTONL(0xff020000UL)) && \
+    ((ip6addr)->addr[1] == 0UL) && \
+    ((ip6addr)->addr[2] == 0UL) && \
+    ((ip6addr)->addr[3] == PP_HTONL(0x00000002UL)))
+#define ip6_addr_set_allrouters_linklocal(ip6addr) do{(ip6addr)->addr[0] = PP_HTONL(0xff020000UL); \
+                (ip6addr)->addr[1] = 0; \
+                (ip6addr)->addr[2] = 0; \
+                (ip6addr)->addr[3] = PP_HTONL(0x00000002UL);}while(0)
+
+#define ip6_addr_issolicitednode(ip6addr) ( ((ip6addr)->addr[0] == PP_HTONL(0xff020000UL)) && \
+        ((ip6addr)->addr[2] == PP_HTONL(0x00000001UL)) && \
+        (((ip6addr)->addr[3] & PP_HTONL(0xff000000UL)) == PP_HTONL(0xff000000UL)) )
+
+#define ip6_addr_set_solicitednode(ip6addr, if_id) do{(ip6addr)->addr[0] = PP_HTONL(0xff020000UL); \
+                (ip6addr)->addr[1] = 0; \
+                (ip6addr)->addr[2] = PP_HTONL(0x00000001UL); \
+                (ip6addr)->addr[3] = (PP_HTONL(0xff000000UL) | (if_id));}while(0)
+
+#define ip6_addr_cmp_solicitednode(ip6addr, sn_addr) (((ip6addr)->addr[0] == PP_HTONL(0xff020000UL)) && \
+                                    ((ip6addr)->addr[1] == 0) && \
+                                    ((ip6addr)->addr[2] == PP_HTONL(0x00000001UL)) && \
+                                    ((ip6addr)->addr[3] == (PP_HTONL(0xff000000UL) | (sn_addr)->addr[3])))
+
+/* IPv6 address states. */
+#define IP6_ADDR_INVALID      0x00
+#define IP6_ADDR_TENTATIVE    0x08
+#define IP6_ADDR_TENTATIVE_1  0x09 /* 1 probe sent */
+#define IP6_ADDR_TENTATIVE_2  0x0a /* 2 probes sent */
+#define IP6_ADDR_TENTATIVE_3  0x0b /* 3 probes sent */
+#define IP6_ADDR_TENTATIVE_4  0x0c /* 4 probes sent */
+#define IP6_ADDR_TENTATIVE_5  0x0d /* 5 probes sent */
+#define IP6_ADDR_TENTATIVE_6  0x0e /* 6 probes sent */
+#define IP6_ADDR_TENTATIVE_7  0x0f /* 7 probes sent */
+#define IP6_ADDR_VALID        0x10 /* This bit marks an address as valid (preferred or deprecated) */
+#define IP6_ADDR_PREFERRED    0x30
+#define IP6_ADDR_DEPRECATED   0x10 /* Same as VALID (valid but not preferred) */
+#define IP6_ADDR_DUPLICATED   0x40 /* Failed DAD test, not valid */
+
+#define IP6_ADDR_TENTATIVE_COUNT_MASK 0x07 /* 1-7 probes sent */
+
+#define ip6_addr_isinvalid(addr_state) (addr_state == IP6_ADDR_INVALID)
+#define ip6_addr_istentative(addr_state) (addr_state & IP6_ADDR_TENTATIVE)
+#define ip6_addr_isvalid(addr_state) (addr_state & IP6_ADDR_VALID) /* Include valid, preferred, and deprecated. */
+#define ip6_addr_ispreferred(addr_state) (addr_state == IP6_ADDR_PREFERRED)
+#define ip6_addr_isdeprecated(addr_state) (addr_state == IP6_ADDR_DEPRECATED)
+#define ip6_addr_isduplicated(addr_state) (addr_state == IP6_ADDR_DUPLICATED)
+
+#if LWIP_IPV6_ADDRESS_LIFETIMES
+#define IP6_ADDR_LIFE_STATIC   (0)
+#define IP6_ADDR_LIFE_INFINITE (0xffffffffUL)
+#define ip6_addr_life_isstatic(addr_life) ((addr_life) == IP6_ADDR_LIFE_STATIC)
+#define ip6_addr_life_isinfinite(addr_life) ((addr_life) == IP6_ADDR_LIFE_INFINITE)
+#endif /* LWIP_IPV6_ADDRESS_LIFETIMES */
+
+#define ip6_addr_debug_print_parts(debug, a, b, c, d, e, f, g, h) \
+  LWIP_DEBUGF(debug, ("%" X16_F ":%" X16_F ":%" X16_F ":%" X16_F ":%" X16_F ":%" X16_F ":%" X16_F ":%" X16_F, \
+                      a, b, c, d, e, f, g, h))
+#define ip6_addr_debug_print(debug, ipaddr) \
+  ip6_addr_debug_print_parts(debug, \
+                      (u16_t)((ipaddr) != NULL ? IP6_ADDR_BLOCK1(ipaddr) : 0),    \
+                      (u16_t)((ipaddr) != NULL ? IP6_ADDR_BLOCK2(ipaddr) : 0),    \
+                      (u16_t)((ipaddr) != NULL ? IP6_ADDR_BLOCK3(ipaddr) : 0),    \
+                      (u16_t)((ipaddr) != NULL ? IP6_ADDR_BLOCK4(ipaddr) : 0),    \
+                      (u16_t)((ipaddr) != NULL ? IP6_ADDR_BLOCK5(ipaddr) : 0),    \
+                      (u16_t)((ipaddr) != NULL ? IP6_ADDR_BLOCK6(ipaddr) : 0),    \
+                      (u16_t)((ipaddr) != NULL ? IP6_ADDR_BLOCK7(ipaddr) : 0),    \
+                      (u16_t)((ipaddr) != NULL ? IP6_ADDR_BLOCK8(ipaddr) : 0))
+#define ip6_addr_debug_print_val(debug, ipaddr) \
+  ip6_addr_debug_print_parts(debug, \
+                      IP6_ADDR_BLOCK1(&(ipaddr)),    \
+                      IP6_ADDR_BLOCK2(&(ipaddr)),    \
+                      IP6_ADDR_BLOCK3(&(ipaddr)),    \
+                      IP6_ADDR_BLOCK4(&(ipaddr)),    \
+                      IP6_ADDR_BLOCK5(&(ipaddr)),    \
+                      IP6_ADDR_BLOCK6(&(ipaddr)),    \
+                      IP6_ADDR_BLOCK7(&(ipaddr)),    \
+                      IP6_ADDR_BLOCK8(&(ipaddr)))
+
+#define IP6ADDR_STRLEN_MAX    46
+
+int ip6addr_aton(const char *cp, ip6_addr_t *addr);
+/** returns ptr to static buffer; not reentrant! */
+char *ip6addr_ntoa(const ip6_addr_t *addr);
+char *ip6addr_ntoa_r(const ip6_addr_t *addr, char *buf, int buflen);
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_IPV6 */
+
+#endif /* LWIP_HDR_IP6_ADDR_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/ip6_frag.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/ip6_frag.h
new file mode 100644
index 000000000..6be274734
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/ip6_frag.h
@@ -0,0 +1,120 @@
+/**
+ * @file
+ *
+ * IPv6 fragmentation and reassembly.
+ */
+
+/*
+ * Copyright (c) 2010 Inico Technologies Ltd.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Ivan Delamer <delamer@inicotech.com>
+ *
+ *
+ * Please coordinate changes and requests with Ivan Delamer
+ * <delamer@inicotech.com>
+ */
+#ifndef LWIP_HDR_IP6_FRAG_H
+#define LWIP_HDR_IP6_FRAG_H
+
+#include "lwip/opt.h"
+#include "lwip/pbuf.h"
+#include "lwip/ip6_addr.h"
+#include "lwip/ip6.h"
+#include "lwip/netif.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#if LWIP_IPV6 && LWIP_IPV6_REASS  /* don't build if not configured for use in lwipopts.h */
+
+/** IP6_FRAG_COPYHEADER==1: for platforms where sizeof(void*) > 4, this needs to
+ * be enabled (to not overwrite part of the data). When enabled, the IPv6 header
+ * is copied instead of referencing it, which gives more room for struct ip6_reass_helper */
+#ifndef IPV6_FRAG_COPYHEADER
+#define IPV6_FRAG_COPYHEADER   0
+#endif
+
+/** The IPv6 reassembly timer interval in milliseconds. */
+#define IP6_REASS_TMR_INTERVAL 1000
+
+/* Copy the complete header of the first fragment to struct ip6_reassdata
+   or just point to its original location in the first pbuf? */
+#if IPV6_FRAG_COPYHEADER
+#define IPV6_FRAG_HDRPTR
+#define IPV6_FRAG_HDRREF(hdr) (&(hdr))
+#else /* IPV6_FRAG_COPYHEADER */
+#define IPV6_FRAG_HDRPTR *
+#define IPV6_FRAG_HDRREF(hdr) (hdr)
+#endif /* IPV6_FRAG_COPYHEADER */
+
+/** IPv6 reassembly helper struct.
+ * This is exported because memp needs to know the size.
+ */
+struct ip6_reassdata {
+  struct ip6_reassdata *next;
+  struct pbuf *p;
+  struct ip6_hdr IPV6_FRAG_HDRPTR iphdr;
+  u32_t identification;
+  u16_t datagram_len;
+  u8_t nexth;
+  u8_t timer;
+};
+
+#define ip6_reass_init() /* Compatibility define */
+void ip6_reass_tmr(void);
+struct pbuf *ip6_reass(struct pbuf *p);
+
+#endif /* LWIP_IPV6 && LWIP_IPV6_REASS */
+
+#if LWIP_IPV6 && LWIP_IPV6_FRAG  /* don't build if not configured for use in lwipopts.h */
+
+#ifndef LWIP_PBUF_CUSTOM_REF_DEFINED
+#define LWIP_PBUF_CUSTOM_REF_DEFINED
+/** A custom pbuf that holds a reference to another pbuf, which is freed
+ * when this custom pbuf is freed. This is used to create a custom PBUF_REF
+ * that points into the original pbuf. */
+struct pbuf_custom_ref {
+  /** 'base class' */
+  struct pbuf_custom pc;
+  /** pointer to the original pbuf that is referenced */
+  struct pbuf *original;
+};
+#endif /* LWIP_PBUF_CUSTOM_REF_DEFINED */
+
+err_t ip6_frag(struct pbuf *p, struct netif *netif, const ip6_addr_t *dest);
+
+#endif /* LWIP_IPV6 && LWIP_IPV6_FRAG */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_IP6_FRAG_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/ip6_route_table.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/ip6_route_table.h
new file mode 100644
index 000000000..c11b54344
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/ip6_route_table.h
@@ -0,0 +1,90 @@
+/**
+ * @file
+ *
+ * IPv6 static route table.
+ */
+
+/*
+ * Copyright (c) 2015 Nest Labs, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * Author: Pradip De <pde@nestlabs.com>
+ *
+ *
+ * Please coordinate changes and requests with Pradip De
+ * <pde@nestlabs.com>
+ */
+
+#ifndef __LWIP_IP6_ROUTE_TABLE_H__
+#define __LWIP_IP6_ROUTE_TABLE_H__
+
+#include "lwip/opt.h"
+
+#if LWIP_IPV6  /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/ip.h"
+#include "lwip/ip6_addr.h"
+#include "lwip/def.h"
+#include "lwip/netif.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_IPV6_ROUTE_TABLE_SUPPORT
+
+#define IP6_MAX_PREFIX_LEN                  (128)
+#define IP6_PREFIX_ALLOWED_GRANULARITY      (8)
+/* Prefix length cannot be greater than 128 bits and needs to be at a byte boundary */
+#define ip6_prefix_valid(prefix_len)        (((prefix_len) <= IP6_MAX_PREFIX_LEN) &&                 \
+                                             (((prefix_len) % IP6_PREFIX_ALLOWED_GRANULARITY) == 0))
+
+struct ip6_prefix {
+  ip6_addr_t addr;
+  u8_t prefix_len; /* prefix length in bits at byte boundaries */
+};
+
+struct ip6_route_entry {
+  struct ip6_prefix prefix;
+  struct netif *netif;
+  ip6_addr_t *gateway;
+};
+
+err_t ip6_add_route_entry(struct ip6_prefix *ip6_prefix, struct netif *netif, 
+                         ip6_addr_t *gateway, s8_t *index);
+void ip6_remove_route_entry(struct ip6_prefix *ip6_prefix);
+s8_t ip6_find_route_entry(const ip6_addr_t *ip6_dest_addr);
+struct netif *ip6_static_route(const ip6_addr_t *src, const ip6_addr_t *dest);
+ip6_addr_t *ip6_get_gateway(struct netif *netif, const ip6_addr_t *dest);
+struct ip6_route_entry *ip6_get_route_table(void);
+#endif /* LWIP_IPV6_ROUTE_TABLE_SUPPORT */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_IPV6 */
+
+#endif /* __LWIP_IP6_ROUTE_TABLE_H__ */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/ip_addr.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/ip_addr.h
new file mode 100644
index 000000000..11f65d25b
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/ip_addr.h
@@ -0,0 +1,407 @@
+/**
+ * @file
+ * IP address API (common IPv4 and IPv6)
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_IP_ADDR_H
+#define LWIP_HDR_IP_ADDR_H
+
+#include "lwip/opt.h"
+#include "lwip/def.h"
+
+#include "lwip/ip4_addr.h"
+#include "lwip/ip6_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @ingroup ipaddr
+ * IP address types for use in ip_addr_t.type member.
+ * @see tcp_new_ip_type(), udp_new_ip_type(), raw_new_ip_type().
+ */
+enum lwip_ip_addr_type {
+  /** IPv4 */
+  IPADDR_TYPE_V4 =   0U,
+  /** IPv6 */
+  IPADDR_TYPE_V6 =   6U,
+  /** IPv4+IPv6 ("dual-stack") */
+  IPADDR_TYPE_ANY = 46U
+};
+
+#if LWIP_IPV4 && LWIP_IPV6
+/**
+ * @ingroup ipaddr
+ * A union struct for both IP version's addresses.
+ * ATTENTION: watch out for its size when adding IPv6 address scope!
+ */
+typedef struct ip_addr {
+  union {
+    ip6_addr_t ip6;
+    ip4_addr_t ip4;
+  } u_addr;
+  /** @ref lwip_ip_addr_type */
+  u8_t type;
+} ip_addr_t;
+
+extern const ip_addr_t ip_addr_any_type;
+
+/** @ingroup ip4addr */
+#define IPADDR4_INIT(u32val)          { { { { u32val, 0ul, 0ul, 0ul } } }, IPADDR_TYPE_V4 }
+/** @ingroup ip4addr */
+#define IPADDR4_INIT_BYTES(a,b,c,d)   IPADDR4_INIT(PP_HTONL(LWIP_MAKEU32(a,b,c,d)))
+/** @ingroup ip6addr */
+#define IPADDR6_INIT(a, b, c, d)      { { { { a, b, c, d } } }, IPADDR_TYPE_V6 }
+/** @ingroup ip6addr */
+#define IPADDR6_INIT_HOST(a, b, c, d) { { { { PP_HTONL(a), PP_HTONL(b), PP_HTONL(c), PP_HTONL(d) } } }, IPADDR_TYPE_V6 }
+
+/** @ingroup ipaddr */
+#define IP_IS_ANY_TYPE_VAL(ipaddr)    (IP_GET_TYPE(&ipaddr) == IPADDR_TYPE_ANY)
+/** @ingroup ipaddr */
+#define IPADDR_ANY_TYPE_INIT          { { { { 0ul, 0ul, 0ul, 0ul } } }, IPADDR_TYPE_ANY }
+
+/** @ingroup ip4addr */
+#define IP_IS_V4_VAL(ipaddr)          (IP_GET_TYPE(&ipaddr) == IPADDR_TYPE_V4)
+/** @ingroup ip6addr */
+#define IP_IS_V6_VAL(ipaddr)          (IP_GET_TYPE(&ipaddr) == IPADDR_TYPE_V6)
+/** @ingroup ip4addr */
+#define IP_IS_V4(ipaddr)              (((ipaddr) == NULL) || IP_IS_V4_VAL(*(ipaddr)))
+/** @ingroup ip6addr */
+#define IP_IS_V6(ipaddr)              (((ipaddr) != NULL) && IP_IS_V6_VAL(*(ipaddr)))
+
+#define IP_SET_TYPE_VAL(ipaddr, iptype) do { (ipaddr).type = (iptype); }while(0)
+#define IP_SET_TYPE(ipaddr, iptype)     do { if((ipaddr) != NULL) { IP_SET_TYPE_VAL(*(ipaddr), iptype); }}while(0)
+#define IP_GET_TYPE(ipaddr)           ((ipaddr)->type)
+
+#define IP_ADDR_PCB_VERSION_MATCH_EXACT(pcb, ipaddr) (IP_GET_TYPE(&pcb->local_ip) == IP_GET_TYPE(ipaddr))
+#define IP_ADDR_PCB_VERSION_MATCH(pcb, ipaddr) (IP_IS_ANY_TYPE_VAL(pcb->local_ip) || IP_ADDR_PCB_VERSION_MATCH_EXACT(pcb, ipaddr))
+
+/** @ingroup ip6addr
+ * Convert generic ip address to specific protocol version
+ */
+#define ip_2_ip6(ipaddr)   (&((ipaddr)->u_addr.ip6))
+/** @ingroup ip4addr
+ * Convert generic ip address to specific protocol version
+ */
+#define ip_2_ip4(ipaddr)   (&((ipaddr)->u_addr.ip4))
+
+/** @ingroup ip4addr */
+#define IP_ADDR4(ipaddr,a,b,c,d)      do { IP4_ADDR(ip_2_ip4(ipaddr),a,b,c,d); \
+                                           IP_SET_TYPE_VAL(*(ipaddr), IPADDR_TYPE_V4); } while(0)
+/** @ingroup ip6addr */
+#define IP_ADDR6(ipaddr,i0,i1,i2,i3)  do { IP6_ADDR(ip_2_ip6(ipaddr),i0,i1,i2,i3); \
+                                           IP_SET_TYPE_VAL(*(ipaddr), IPADDR_TYPE_V6); } while(0)
+/** @ingroup ip6addr */
+#define IP_ADDR6_HOST(ipaddr,i0,i1,i2,i3)  IP_ADDR6(ipaddr,PP_HTONL(i0),PP_HTONL(i1),PP_HTONL(i2),PP_HTONL(i3))
+
+/** @ingroup ipaddr */
+#define ip_addr_copy(dest, src)      do{ IP_SET_TYPE_VAL(dest, IP_GET_TYPE(&src)); if(IP_IS_V6_VAL(src)){ \
+  ip6_addr_copy(*ip_2_ip6(&(dest)), *ip_2_ip6(&(src))); }else{ \
+  ip4_addr_copy(*ip_2_ip4(&(dest)), *ip_2_ip4(&(src))); }}while(0)
+/** @ingroup ip6addr */
+#define ip_addr_copy_from_ip6(dest, src)      do{ \
+  ip6_addr_copy(*ip_2_ip6(&(dest)), src); IP_SET_TYPE_VAL(dest, IPADDR_TYPE_V6); }while(0)
+/** @ingroup ip4addr */
+#define ip_addr_copy_from_ip4(dest, src)      do{ \
+  ip4_addr_copy(*ip_2_ip4(&(dest)), src); IP_SET_TYPE_VAL(dest, IPADDR_TYPE_V4); }while(0)
+/** @ingroup ip4addr */
+#define ip_addr_set_ip4_u32(ipaddr, val)  do{if(ipaddr){ip4_addr_set_u32(ip_2_ip4(ipaddr), val); \
+  IP_SET_TYPE(ipaddr, IPADDR_TYPE_V4); }}while(0)
+/** @ingroup ip4addr */
+#define ip_addr_get_ip4_u32(ipaddr)  (((ipaddr) && IP_IS_V4(ipaddr)) ? \
+  ip4_addr_get_u32(ip_2_ip4(ipaddr)) : 0)
+/** @ingroup ipaddr */
+#define ip_addr_set(dest, src) do{ IP_SET_TYPE(dest, IP_GET_TYPE(src)); if(IP_IS_V6(src)){ \
+  ip6_addr_set(ip_2_ip6(dest), ip_2_ip6(src)); }else{ \
+  ip4_addr_set(ip_2_ip4(dest), ip_2_ip4(src)); }}while(0)
+/** @ingroup ipaddr */
+#define ip_addr_set_ipaddr(dest, src) ip_addr_set(dest, src)
+/** @ingroup ipaddr */
+#define ip_addr_set_zero(ipaddr)     do{ \
+  ip6_addr_set_zero(ip_2_ip6(ipaddr)); IP_SET_TYPE(ipaddr, 0); }while(0)
+/** @ingroup ip5addr */
+#define ip_addr_set_zero_ip4(ipaddr)     do{ \
+  ip6_addr_set_zero(ip_2_ip6(ipaddr)); IP_SET_TYPE(ipaddr, IPADDR_TYPE_V4); }while(0)
+/** @ingroup ip6addr */
+#define ip_addr_set_zero_ip6(ipaddr)     do{ \
+  ip6_addr_set_zero(ip_2_ip6(ipaddr)); IP_SET_TYPE(ipaddr, IPADDR_TYPE_V6); }while(0)
+/** @ingroup ipaddr */
+#define ip_addr_set_any(is_ipv6, ipaddr)      do{if(is_ipv6){ \
+  ip6_addr_set_any(ip_2_ip6(ipaddr)); IP_SET_TYPE(ipaddr, IPADDR_TYPE_V6); }else{ \
+  ip4_addr_set_any(ip_2_ip4(ipaddr)); IP_SET_TYPE(ipaddr, IPADDR_TYPE_V4); }}while(0)
+/** @ingroup ipaddr */
+#define ip_addr_set_loopback(is_ipv6, ipaddr) do{if(is_ipv6){ \
+  ip6_addr_set_loopback(ip_2_ip6(ipaddr)); IP_SET_TYPE(ipaddr, IPADDR_TYPE_V6); }else{ \
+  ip4_addr_set_loopback(ip_2_ip4(ipaddr)); IP_SET_TYPE(ipaddr, IPADDR_TYPE_V4); }}while(0)
+/** @ingroup ipaddr */
+#define ip_addr_set_hton(dest, src)  do{if(IP_IS_V6(src)){ \
+  ip6_addr_set_hton(ip_2_ip6(ipaddr), (src)); IP_SET_TYPE(dest, IPADDR_TYPE_V6); }else{ \
+  ip4_addr_set_hton(ip_2_ip4(ipaddr), (src)); IP_SET_TYPE(dest, IPADDR_TYPE_V4); }}while(0)
+/** @ingroup ipaddr */
+#define ip_addr_get_network(target, host, netmask) do{if(IP_IS_V6(host)){ \
+  ip4_addr_set_zero(ip_2_ip4(target)); IP_SET_TYPE(target, IPADDR_TYPE_V6); } else { \
+  ip4_addr_get_network(ip_2_ip4(target), ip_2_ip4(host), ip_2_ip4(netmask)); IP_SET_TYPE(target, IPADDR_TYPE_V4); }}while(0)
+/** @ingroup ipaddr */
+#define ip_addr_netcmp(addr1, addr2, mask) ((IP_IS_V6(addr1) && IP_IS_V6(addr2)) ? \
+  0 : \
+  ip4_addr_netcmp(ip_2_ip4(addr1), ip_2_ip4(addr2), mask))
+/** @ingroup ipaddr */
+#define ip_addr_cmp(addr1, addr2)    ((IP_GET_TYPE(addr1) != IP_GET_TYPE(addr2)) ? 0 : (IP_IS_V6_VAL(*(addr1)) ? \
+  ip6_addr_cmp(ip_2_ip6(addr1), ip_2_ip6(addr2)) : \
+  ip4_addr_cmp(ip_2_ip4(addr1), ip_2_ip4(addr2))))
+/** @ingroup ipaddr */
+#define ip_addr_isany(ipaddr)        ((IP_IS_V6(ipaddr)) ? \
+  ip6_addr_isany(ip_2_ip6(ipaddr)) : \
+  ip4_addr_isany(ip_2_ip4(ipaddr)))
+/** @ingroup ipaddr */
+#define ip_addr_isany_val(ipaddr)        ((IP_IS_V6_VAL(ipaddr)) ? \
+  ip6_addr_isany_val(*ip_2_ip6(&(ipaddr))) : \
+  ip4_addr_isany_val(*ip_2_ip4(&(ipaddr))))
+/** @ingroup ipaddr */
+#define ip_addr_isbroadcast(ipaddr, netif) ((IP_IS_V6(ipaddr)) ? \
+  0 : \
+  ip4_addr_isbroadcast(ip_2_ip4(ipaddr), netif))
+/** @ingroup ipaddr */
+#define ip_addr_ismulticast(ipaddr)  ((IP_IS_V6(ipaddr)) ? \
+  ip6_addr_ismulticast(ip_2_ip6(ipaddr)) : \
+  ip4_addr_ismulticast(ip_2_ip4(ipaddr)))
+/** @ingroup ipaddr */
+#define ip_addr_isloopback(ipaddr)  ((IP_IS_V6(ipaddr)) ? \
+  ip6_addr_isloopback(ip_2_ip6(ipaddr)) : \
+  ip4_addr_isloopback(ip_2_ip4(ipaddr)))
+/** @ingroup ipaddr */
+#define ip_addr_islinklocal(ipaddr)  ((IP_IS_V6(ipaddr)) ? \
+  ip6_addr_islinklocal(ip_2_ip6(ipaddr)) : \
+  ip4_addr_islinklocal(ip_2_ip4(ipaddr)))
+#define ip_addr_debug_print(debug, ipaddr) do { if(IP_IS_V6(ipaddr)) { \
+  ip6_addr_debug_print(debug, ip_2_ip6(ipaddr)); } else { \
+  ip4_addr_debug_print(debug, ip_2_ip4(ipaddr)); }}while(0)
+#define ip_addr_debug_print_val(debug, ipaddr) do { if(IP_IS_V6_VAL(ipaddr)) { \
+  ip6_addr_debug_print_val(debug, *ip_2_ip6(&(ipaddr))); } else { \
+  ip4_addr_debug_print_val(debug, *ip_2_ip4(&(ipaddr))); }}while(0)
+/** @ingroup ipaddr */
+#define ipaddr_ntoa(addr)   (((addr) == NULL) ? "NULL" : \
+  ((IP_IS_V6(addr)) ? ip6addr_ntoa(ip_2_ip6(addr)) : ip4addr_ntoa(ip_2_ip4(addr))))
+/** @ingroup ipaddr */
+#define ipaddr_ntoa_r(addr, buf, buflen)   (((addr) == NULL) ? "NULL" : \
+  ((IP_IS_V6(addr)) ? ip6addr_ntoa_r(ip_2_ip6(addr), buf, buflen) : ip4addr_ntoa_r(ip_2_ip4(addr), buf, buflen)))
+int ipaddr_aton(const char *cp, ip_addr_t *addr);
+
+/** @ingroup ipaddr */
+#define IPADDR_STRLEN_MAX   IP6ADDR_STRLEN_MAX
+
+/** @ingroup ipaddr */
+#define ip4_2_ipv4_mapped_ipv6(ip6addr, ip4addr) do { \
+  (ip6addr)->addr[3] = (ip4addr)->addr; \
+  (ip6addr)->addr[2] = PP_HTONL(0x0000FFFFUL); \
+  (ip6addr)->addr[1] = 0; \
+  (ip6addr)->addr[0] = 0; } while(0);
+
+/** @ingroup ipaddr */
+#define unmap_ipv4_mapped_ipv6(ip4addr, ip6addr) \
+  (ip4addr)->addr = (ip6addr)->addr[3];
+
+#define IP46_ADDR_ANY(type) (((type) == IPADDR_TYPE_V6)? IP6_ADDR_ANY : IP4_ADDR_ANY)
+
+#else /* LWIP_IPV4 && LWIP_IPV6 */
+
+#define IP_ADDR_PCB_VERSION_MATCH(addr, pcb)         1
+#define IP_ADDR_PCB_VERSION_MATCH_EXACT(pcb, ipaddr) 1
+
+#if LWIP_IPV4
+
+typedef ip4_addr_t ip_addr_t;
+#define IPADDR4_INIT(u32val)                    { u32val }
+#define IPADDR4_INIT_BYTES(a,b,c,d)             IPADDR4_INIT(PP_HTONL(LWIP_MAKEU32(a,b,c,d)))
+#define IP_IS_V4_VAL(ipaddr)                    1
+#define IP_IS_V6_VAL(ipaddr)                    0
+#define IP_IS_V4(ipaddr)                        1
+#define IP_IS_V6(ipaddr)                        0
+#define IP_IS_ANY_TYPE_VAL(ipaddr)              0
+#define IP_SET_TYPE_VAL(ipaddr, iptype)
+#define IP_SET_TYPE(ipaddr, iptype)
+#define IP_GET_TYPE(ipaddr)                     IPADDR_TYPE_V4
+#define ip_2_ip4(ipaddr)                        (ipaddr)
+#define IP_ADDR4(ipaddr,a,b,c,d)                IP4_ADDR(ipaddr,a,b,c,d)
+
+#define ip_addr_copy(dest, src)                 ip4_addr_copy(dest, src)
+#define ip_addr_copy_from_ip4(dest, src)        ip4_addr_copy(dest, src)
+#define ip_addr_set_ip4_u32(ipaddr, val)        ip4_addr_set_u32(ip_2_ip4(ipaddr), val)
+#define ip_addr_get_ip4_u32(ipaddr)             ip4_addr_get_u32(ip_2_ip4(ipaddr))
+#define ip_addr_set(dest, src)                  ip4_addr_set(dest, src)
+#define ip_addr_set_ipaddr(dest, src)           ip4_addr_set(dest, src)
+#define ip_addr_set_zero(ipaddr)                ip4_addr_set_zero(ipaddr)
+#define ip_addr_set_zero_ip4(ipaddr)            ip4_addr_set_zero(ipaddr)
+#define ip_addr_set_any(is_ipv6, ipaddr)        ip4_addr_set_any(ipaddr)
+#define ip_addr_set_loopback(is_ipv6, ipaddr)   ip4_addr_set_loopback(ipaddr)
+#define ip_addr_set_hton(dest, src)             ip4_addr_set_hton(dest, src)
+#define ip_addr_get_network(target, host, mask) ip4_addr_get_network(target, host, mask)
+#define ip_addr_netcmp(addr1, addr2, mask)      ip4_addr_netcmp(addr1, addr2, mask)
+#define ip_addr_cmp(addr1, addr2)               ip4_addr_cmp(addr1, addr2)
+#define ip_addr_isany(ipaddr)                   ip4_addr_isany(ipaddr)
+#define ip_addr_isany_val(ipaddr)               ip4_addr_isany_val(ipaddr)
+#define ip_addr_isloopback(ipaddr)              ip4_addr_isloopback(ipaddr)
+#define ip_addr_islinklocal(ipaddr)             ip4_addr_islinklocal(ipaddr)
+#define ip_addr_isbroadcast(addr, netif)        ip4_addr_isbroadcast(addr, netif)
+#define ip_addr_ismulticast(ipaddr)             ip4_addr_ismulticast(ipaddr)
+#define ip_addr_debug_print(debug, ipaddr)      ip4_addr_debug_print(debug, ipaddr)
+#define ip_addr_debug_print_val(debug, ipaddr)  ip4_addr_debug_print_val(debug, ipaddr)
+#define ipaddr_ntoa(ipaddr)                     ip4addr_ntoa(ipaddr)
+#define ipaddr_ntoa_r(ipaddr, buf, buflen)      ip4addr_ntoa_r(ipaddr, buf, buflen)
+#define ipaddr_aton(cp, addr)                   ip4addr_aton(cp, addr)
+
+#define IPADDR_STRLEN_MAX   IP4ADDR_STRLEN_MAX
+
+#define IP46_ADDR_ANY(type) (IP4_ADDR_ANY)
+
+#else /* LWIP_IPV4 */
+
+typedef ip6_addr_t ip_addr_t;
+#define IPADDR6_INIT(a, b, c, d)                { { a, b, c, d } }
+#define IPADDR6_INIT_HOST(a, b, c, d)           { { PP_HTONL(a), PP_HTONL(b), PP_HTONL(c), PP_HTONL(d) } }
+#define IP_IS_V4_VAL(ipaddr)                    0
+#define IP_IS_V6_VAL(ipaddr)                    1
+#define IP_IS_V4(ipaddr)                        0
+#define IP_IS_V6(ipaddr)                        1
+#define IP_IS_ANY_TYPE_VAL(ipaddr)              0
+#define IP_SET_TYPE_VAL(ipaddr, iptype)
+#define IP_SET_TYPE(ipaddr, iptype)
+#define IP_GET_TYPE(ipaddr)                     IPADDR_TYPE_V6
+#define ip_2_ip6(ipaddr)                        (ipaddr)
+#define IP_ADDR6(ipaddr,i0,i1,i2,i3)            IP6_ADDR(ipaddr,i0,i1,i2,i3)
+#define IP_ADDR6_HOST(ipaddr,i0,i1,i2,i3)       IP_ADDR6(ipaddr,PP_HTONL(i0),PP_HTONL(i1),PP_HTONL(i2),PP_HTONL(i3))
+
+#define ip_addr_copy(dest, src)                 ip6_addr_copy(dest, src)
+#define ip_addr_copy_from_ip6(dest, src)        ip6_addr_copy(dest, src)
+#define ip_addr_set(dest, src)                  ip6_addr_set(dest, src)
+#define ip_addr_set_ipaddr(dest, src)           ip6_addr_set(dest, src)
+#define ip_addr_set_zero(ipaddr)                ip6_addr_set_zero(ipaddr)
+#define ip_addr_set_zero_ip6(ipaddr)            ip6_addr_set_zero(ipaddr)
+#define ip_addr_set_any(is_ipv6, ipaddr)        ip6_addr_set_any(ipaddr)
+#define ip_addr_set_loopback(is_ipv6, ipaddr)   ip6_addr_set_loopback(ipaddr)
+#define ip_addr_set_hton(dest, src)             ip6_addr_set_hton(dest, src)
+#define ip_addr_get_network(target, host, mask) ip6_addr_set_zero(target)
+#define ip_addr_netcmp(addr1, addr2, mask)      0
+#define ip_addr_cmp(addr1, addr2)               ip6_addr_cmp(addr1, addr2)
+#define ip_addr_isany(ipaddr)                   ip6_addr_isany(ipaddr)
+#define ip_addr_isany_val(ipaddr)               ip6_addr_isany_val(ipaddr)
+#define ip_addr_isloopback(ipaddr)              ip6_addr_isloopback(ipaddr)
+#define ip_addr_islinklocal(ipaddr)             ip6_addr_islinklocal(ipaddr)
+#define ip_addr_isbroadcast(addr, netif)        0
+#define ip_addr_ismulticast(ipaddr)             ip6_addr_ismulticast(ipaddr)
+#define ip_addr_debug_print(debug, ipaddr)      ip6_addr_debug_print(debug, ipaddr)
+#define ip_addr_debug_print_val(debug, ipaddr)  ip6_addr_debug_print_val(debug, ipaddr)
+#define ipaddr_ntoa(ipaddr)                     ip6addr_ntoa(ipaddr)
+#define ipaddr_ntoa_r(ipaddr, buf, buflen)      ip6addr_ntoa_r(ipaddr, buf, buflen)
+#define ipaddr_aton(cp, addr)                   ip6addr_aton(cp, addr)
+
+#define IPADDR_STRLEN_MAX   IP6ADDR_STRLEN_MAX
+
+#define IP46_ADDR_ANY(type) (IP6_ADDR_ANY)
+
+#endif /* LWIP_IPV4 */
+#endif /* LWIP_IPV4 && LWIP_IPV6 */
+
+#if LWIP_IPV4
+
+extern const ip_addr_t ip_addr_any;
+extern const ip_addr_t ip_addr_broadcast;
+
+/**
+ * @ingroup ip4addr
+ * Can be used as a fixed/const ip_addr_t
+ * for the IP wildcard.
+ * Defined to @ref IP4_ADDR_ANY when IPv4 is enabled.
+ * Defined to @ref IP6_ADDR_ANY in IPv6 only systems.
+ * Use this if you can handle IPv4 _AND_ IPv6 addresses.
+ * Use @ref IP4_ADDR_ANY or @ref IP6_ADDR_ANY when the IP
+ * type matters.
+ */
+#define IP_ADDR_ANY         IP4_ADDR_ANY
+/**
+ * @ingroup ip4addr
+ * Can be used as a fixed/const ip_addr_t
+ * for the IPv4 wildcard and the broadcast address
+ */
+#define IP4_ADDR_ANY        (&ip_addr_any)
+/**
+ * @ingroup ip4addr
+ * Can be used as a fixed/const ip4_addr_t
+ * for the wildcard and the broadcast address
+ */
+#define IP4_ADDR_ANY4       (ip_2_ip4(&ip_addr_any))
+
+/** @ingroup ip4addr */
+#define IP_ADDR_BROADCAST   (&ip_addr_broadcast)
+/** @ingroup ip4addr */
+#define IP4_ADDR_BROADCAST  (ip_2_ip4(&ip_addr_broadcast))
+
+#endif /* LWIP_IPV4*/
+
+#if LWIP_IPV6
+
+extern const ip_addr_t ip6_addr_any;
+
+/** 
+ * @ingroup ip6addr
+ * IP6_ADDR_ANY can be used as a fixed ip_addr_t
+ * for the IPv6 wildcard address
+ */
+#define IP6_ADDR_ANY   (&ip6_addr_any)
+/**
+ * @ingroup ip6addr
+ * IP6_ADDR_ANY6 can be used as a fixed ip6_addr_t
+ * for the IPv6 wildcard address
+ */
+#define IP6_ADDR_ANY6  (ip_2_ip6(&ip6_addr_any))
+
+#if !LWIP_IPV4
+/** IPv6-only configurations */
+#define IP_ADDR_ANY IP6_ADDR_ANY
+#endif /* !LWIP_IPV4 */
+
+#endif
+
+#if LWIP_IPV4 && LWIP_IPV6
+/** @ingroup ipaddr */
+#define IP_ANY_TYPE    (&ip_addr_any_type)
+#else
+#define IP_ANY_TYPE    IP_ADDR_ANY
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_IP_ADDR_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/lwip_buildconfig.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/lwip_buildconfig.h
new file mode 100644
index 000000000..a075e230a
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/lwip_buildconfig.h
@@ -0,0 +1,10 @@
+// Generated by write_buildconfig_header.py
+// From "//third_party/connectedhomeip/src/lwip:gen_lwip_buildconfig"
+
+#ifndef LWIP_LWIP_BUILDCONFIG_H_
+#define LWIP_LWIP_BUILDCONFIG_H_
+
+#define HAVE_LWIP_UDP_BIND_NETIF 1
+#define LWIP_DEBUG 1
+
+#endif  // LWIP_LWIP_BUILDCONFIG_H_
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/mem.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/mem.h
new file mode 100644
index 000000000..ff208d25c
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/mem.h
@@ -0,0 +1,82 @@
+/**
+ * @file
+ * Heap API
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_MEM_H
+#define LWIP_HDR_MEM_H
+
+#include "lwip/opt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if MEM_LIBC_MALLOC
+
+#include "lwip/arch.h"
+
+typedef size_t mem_size_t;
+#define MEM_SIZE_F SZT_F
+
+#elif MEM_USE_POOLS
+
+typedef u16_t mem_size_t;
+#define MEM_SIZE_F U16_F
+
+#else
+
+/* MEM_SIZE would have to be aligned, but using 64000 here instead of
+ * 65535 leaves some room for alignment...
+ */
+#if MEM_SIZE > 64000L
+typedef u32_t mem_size_t;
+#define MEM_SIZE_F U32_F
+#else
+typedef u16_t mem_size_t;
+#define MEM_SIZE_F U16_F
+#endif /* MEM_SIZE > 64000 */
+#endif
+
+void  mem_init(void);
+void *mem_trim(void *mem, mem_size_t size);
+void *mem_malloc(mem_size_t size);
+void *mem_calloc(mem_size_t count, mem_size_t size);
+void  mem_free(void *mem);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_MEM_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/memp.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/memp.h
new file mode 100644
index 000000000..cd30996de
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/memp.h
@@ -0,0 +1,164 @@
+/**
+ * @file
+ * Memory pool API
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+#ifndef LWIP_HDR_MEMP_H
+#define LWIP_HDR_MEMP_H
+
+#include "lwip/opt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* run once with empty definition to handle all custom includes in lwippools.h */
+#define LWIP_MEMPOOL(name,num,size,desc)
+#include "lwip/priv/memp_std.h"
+
+/** Create the list of all memory pools managed by memp. MEMP_MAX represents a NULL pool at the end */
+typedef enum {
+#define LWIP_MEMPOOL(name,num,size,desc)  MEMP_##name,
+#include "lwip/priv/memp_std.h"
+  MEMP_MAX
+} memp_t;
+
+#include "lwip/priv/memp_priv.h"
+#include "lwip/stats.h"
+
+extern const struct memp_desc* const memp_pools[MEMP_MAX];
+
+#if MEMP_MEM_MALLOC || MEM_USE_POOLS || LWIP_PBUF_FROM_CUSTOM_POOLS
+extern const u16_t memp_sizes[MEMP_MAX];
+#endif /* MEMP_MEM_MALLOC || MEM_USE_POOLS */
+
+/**
+ * @ingroup mempool
+ * Declare prototype for private memory pool if it is used in multiple files
+ */
+#define LWIP_MEMPOOL_PROTOTYPE(name) extern const struct memp_desc memp_ ## name
+
+#if MEMP_MEM_MALLOC
+
+#define LWIP_MEMPOOL_DECLARE(name,num,size,desc) \
+  LWIP_MEMPOOL_DECLARE_STATS_INSTANCE(memp_stats_ ## name) \
+  const struct memp_desc memp_ ## name = { \
+    DECLARE_LWIP_MEMPOOL_DESC(desc) \
+    LWIP_MEMPOOL_DECLARE_STATS_REFERENCE(memp_stats_ ## name) \
+    LWIP_MEM_ALIGN_SIZE(size) \
+  };
+
+#else /* MEMP_MEM_MALLOC */
+
+/**
+ * @ingroup mempool
+ * Declare a private memory pool
+ * Private mempools example:
+ * .h: only when pool is used in multiple .c files: LWIP_MEMPOOL_PROTOTYPE(my_private_pool);
+ * .c:
+ *   - in global variables section: LWIP_MEMPOOL_DECLARE(my_private_pool, 10, sizeof(foo), "Some description")
+ *   - call ONCE before using pool (e.g. in some init() function): LWIP_MEMPOOL_INIT(my_private_pool);
+ *   - allocate: void* my_new_mem = LWIP_MEMPOOL_ALLOC(my_private_pool);
+ *   - free: LWIP_MEMPOOL_FREE(my_private_pool, my_new_mem);
+ *
+ * To relocate a pool, declare it as extern in cc.h. Example for GCC:
+ *   extern u8_t __attribute__((section(".onchip_mem"))) memp_memory_my_private_pool[];
+ */
+#define LWIP_MEMPOOL_DECLARE(name,num,size,desc) \
+  LWIP_DECLARE_MEMORY_ALIGNED(memp_memory_ ## name ## _base, ((num) * (MEMP_SIZE + MEMP_ALIGN_SIZE(size)))); \
+    \
+  LWIP_MEMPOOL_DECLARE_STATS_INSTANCE(memp_stats_ ## name) \
+    \
+  static struct memp *memp_tab_ ## name; \
+    \
+  const struct memp_desc memp_ ## name = { \
+    DECLARE_LWIP_MEMPOOL_DESC(desc) \
+    LWIP_MEMPOOL_DECLARE_STATS_REFERENCE(memp_stats_ ## name) \
+    LWIP_MEM_ALIGN_SIZE(size), \
+    (num), \
+    memp_memory_ ## name ## _base, \
+    &memp_tab_ ## name \
+  };
+
+#endif /* MEMP_MEM_MALLOC */
+
+/**
+ * @ingroup mempool
+ * Initialize a private memory pool
+ */
+#define LWIP_MEMPOOL_INIT(name)    memp_init_pool(&memp_ ## name)
+/**
+ * @ingroup mempool
+ * Allocate from a private memory pool
+ */
+#define LWIP_MEMPOOL_ALLOC(name)   memp_malloc_pool(&memp_ ## name)
+/**
+ * @ingroup mempool
+ * Free element from a private memory pool
+ */
+#define LWIP_MEMPOOL_FREE(name, x) memp_free_pool(&memp_ ## name, (x))
+
+#if MEM_USE_POOLS
+/** This structure is used to save the pool one element came from.
+ * This has to be defined here as it is required for pool size calculation. */
+struct memp_malloc_helper
+{
+   memp_t poolnr;
+#if MEMP_OVERFLOW_CHECK || (LWIP_STATS && MEM_STATS)
+   u16_t size;
+#endif /* MEMP_OVERFLOW_CHECK || (LWIP_STATS && MEM_STATS) */
+};
+#endif /* MEM_USE_POOLS */
+
+void  memp_init(void);
+
+#if MEMP_OVERFLOW_CHECK
+void *memp_malloc_fn(memp_t type, const char* file, const int line);
+#define memp_malloc(t) memp_malloc_fn((t), __FILE__, __LINE__)
+#else
+void *memp_malloc(memp_t type);
+#endif
+void  memp_free(memp_t type, void *mem);
+#if MEMP_SEPARATE_POOLS
+u16_t memp_pbuf_index(memp_t type, const void *mem);
+u16_t memp_num_pbufs(memp_t type);
+#endif
+u8_t memp_is_not_empty (memp_t type);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_MEMP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/mld6.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/mld6.h
new file mode 100644
index 000000000..7219beb6f
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/mld6.h
@@ -0,0 +1,97 @@
+/**
+ * @file
+ *
+ * Multicast listener discovery for IPv6. Aims to be compliant with RFC 2710.
+ * No support for MLDv2.
+ */
+
+/*
+ * Copyright (c) 2010 Inico Technologies Ltd.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Ivan Delamer <delamer@inicotech.com>
+ *
+ *
+ * Please coordinate changes and requests with Ivan Delamer
+ * <delamer@inicotech.com>
+ */
+
+#ifndef LWIP_HDR_MLD6_H
+#define LWIP_HDR_MLD6_H
+
+#include "lwip/opt.h"
+
+ /* don't build if not configured for use in lwipopts.h */
+ #if LWIP_IPV6_MLD && LWIP_IPV6_ND && LWIP_IPV6 
+
+#include "lwip/pbuf.h"
+#include "lwip/netif.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** MLD group */
+struct mld_group {
+  /** next link */
+  struct mld_group *next;
+  /** multicast address */
+  ip6_addr_t         group_address;
+  /** signifies we were the last person to report */
+  u8_t               last_reporter_flag;
+  /** current state of the group */
+  u8_t               group_state;
+  /** timer for reporting */
+  u16_t              timer;
+  /** counter of simultaneous uses */
+  u8_t               use;
+};
+
+err_t  mld6_stop(struct netif *netif);
+void   mld6_report_groups(struct netif *netif);
+struct mld_group *mld6_lookfor_group(struct netif *ifp, const ip6_addr_t *addr);
+void   mld6_input(struct pbuf *p, struct netif *inp);
+err_t  mld6_joingroup(const ip6_addr_t *srcaddr, const ip6_addr_t *groupaddr);
+err_t  mld6_joingroup_netif(struct netif *netif, const ip6_addr_t *groupaddr);
+err_t  mld6_leavegroup(const ip6_addr_t *srcaddr, const ip6_addr_t *groupaddr);
+err_t  mld6_leavegroup_netif(struct netif *netif, const ip6_addr_t *groupaddr);
+
+/** @ingroup mld6
+ * Get list head of MLD6 groups for netif.
+ * Note: The allnodes group IP is NOT in the list, since it must always 
+ * be received for correct IPv6 operation.
+ * @see @ref netif_set_mld_mac_filter()
+ */
+#define netif_mld6_data(netif) ((struct mld_group *)netif_get_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_MLD6))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_IPV6_MLD && LWIP_IPV6_ND && LWIP_IPV6 */
+
+#endif /* LWIP_HDR_MLD6_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/nd6.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/nd6.h
new file mode 100644
index 000000000..e68eb3573
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/nd6.h
@@ -0,0 +1,85 @@
+/**
+ * @file
+ *
+ * Neighbor discovery and stateless address autoconfiguration for IPv6.
+ * Aims to be compliant with RFC 4861 (Neighbor discovery) and RFC 4862
+ * (Address autoconfiguration).
+ */
+
+/*
+ * Copyright (c) 2010 Inico Technologies Ltd.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Ivan Delamer <delamer@inicotech.com>
+ *
+ *
+ * Please coordinate changes and requests with Ivan Delamer
+ * <delamer@inicotech.com>
+ */
+
+#ifndef LWIP_HDR_ND6_H
+#define LWIP_HDR_ND6_H
+
+#include "lwip/opt.h"
+
+/* don't build if not configured for use in lwipopts.h */
+#if LWIP_IPV6 && LWIP_IPV6_ND
+
+#include "lwip/ip6_addr.h"
+#include "lwip/err.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** 1 second period */
+#define ND6_TMR_INTERVAL 1000
+
+struct pbuf;
+struct netif;
+
+void nd6_tmr(void);
+void nd6_input(struct pbuf *p, struct netif *inp);
+void nd6_clear_destination_cache(void);
+struct netif *nd6_find_route(const ip6_addr_t *ip6addr);
+err_t nd6_get_next_hop_addr_or_queue(struct netif *netif, struct pbuf *q, const ip6_addr_t *ip6addr, const u8_t **hwaddrp);
+u16_t nd6_get_destination_mtu(const ip6_addr_t *ip6addr, struct netif *netif);
+#if LWIP_ND6_TCP_REACHABILITY_HINTS
+void nd6_reachability_hint(const ip6_addr_t *ip6addr);
+#endif /* LWIP_ND6_TCP_REACHABILITY_HINTS */
+void nd6_cleanup_netif(struct netif *netif);
+#if LWIP_IPV6_MLD
+void nd6_adjust_mld_membership(struct netif *netif, s8_t addr_idx, u8_t new_state);
+#endif /* LWIP_IPV6_MLD */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_IPV6 && LWIP_IPV6_ND */
+
+#endif /* LWIP_HDR_ND6_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/netbuf.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/netbuf.h
new file mode 100644
index 000000000..e6865f80f
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/netbuf.h
@@ -0,0 +1,118 @@
+/**
+ * @file
+ * netbuf API (for netconn API)
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_NETBUF_H
+#define LWIP_HDR_NETBUF_H
+
+#include "lwip/opt.h"
+
+#if LWIP_NETCONN || LWIP_SOCKET /* don't build if not configured for use in lwipopts.h */
+/* Note: Netconn API is always available when sockets are enabled -
+ * sockets are implemented on top of them */
+
+#include "lwip/pbuf.h"
+#include "lwip/ip_addr.h"
+#include "lwip/ip6_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** This netbuf has dest-addr/port set */
+#define NETBUF_FLAG_DESTADDR    0x01
+/** This netbuf includes a checksum */
+#define NETBUF_FLAG_CHKSUM      0x02
+
+/** "Network buffer" - contains data and addressing info */
+struct netbuf {
+  struct pbuf *p, *ptr;
+  ip_addr_t addr;
+  u16_t port;
+#if LWIP_NETBUF_RECVINFO || LWIP_CHECKSUM_ON_COPY
+#if LWIP_CHECKSUM_ON_COPY
+  u8_t flags;
+#endif /* LWIP_CHECKSUM_ON_COPY */
+  u16_t toport_chksum;
+#if LWIP_NETBUF_RECVINFO
+  ip_addr_t toaddr;
+#endif /* LWIP_NETBUF_RECVINFO */
+#endif /* LWIP_NETBUF_RECVINFO || LWIP_CHECKSUM_ON_COPY */
+};
+
+/* Network buffer functions: */
+struct netbuf *   netbuf_new      (void);
+void              netbuf_delete   (struct netbuf *buf);
+void *            netbuf_alloc    (struct netbuf *buf, u16_t size);
+void              netbuf_free     (struct netbuf *buf);
+err_t             netbuf_ref      (struct netbuf *buf,
+                                   const void *dataptr, u16_t size);
+void              netbuf_chain    (struct netbuf *head, struct netbuf *tail);
+
+err_t             netbuf_data     (struct netbuf *buf,
+                                   void **dataptr, u16_t *len);
+s8_t              netbuf_next     (struct netbuf *buf);
+void              netbuf_first    (struct netbuf *buf);
+
+
+#define netbuf_copy_partial(buf, dataptr, len, offset) \
+  pbuf_copy_partial((buf)->p, (dataptr), (len), (offset))
+#define netbuf_copy(buf,dataptr,len) netbuf_copy_partial(buf, dataptr, len, 0)
+#define netbuf_take(buf, dataptr, len) pbuf_take((buf)->p, dataptr, len)
+#define netbuf_len(buf)              ((buf)->p->tot_len)
+#define netbuf_fromaddr(buf)         (&((buf)->addr))
+#define netbuf_set_fromaddr(buf, fromaddr) ip_addr_set(&((buf)->addr), fromaddr)
+#define netbuf_fromport(buf)         ((buf)->port)
+#if LWIP_NETBUF_RECVINFO
+#define netbuf_destaddr(buf)         (&((buf)->toaddr))
+#define netbuf_set_destaddr(buf, destaddr) ip_addr_set(&((buf)->toaddr), destaddr)
+#if LWIP_CHECKSUM_ON_COPY
+#define netbuf_destport(buf)         (((buf)->flags & NETBUF_FLAG_DESTADDR) ? (buf)->toport_chksum : 0)
+#else /* LWIP_CHECKSUM_ON_COPY */
+#define netbuf_destport(buf)         ((buf)->toport_chksum)
+#endif /* LWIP_CHECKSUM_ON_COPY */
+#endif /* LWIP_NETBUF_RECVINFO */
+#if LWIP_CHECKSUM_ON_COPY
+#define netbuf_set_chksum(buf, chksum) do { (buf)->flags = NETBUF_FLAG_CHKSUM; \
+                                            (buf)->toport_chksum = chksum; } while(0)
+#endif /* LWIP_CHECKSUM_ON_COPY */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_NETCONN || LWIP_SOCKET */
+
+#endif /* LWIP_HDR_NETBUF_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/netdb.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/netdb.h
new file mode 100644
index 000000000..d3d15dfac
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/netdb.h
@@ -0,0 +1,150 @@
+/**
+ * @file
+ * NETDB API (sockets)
+ */
+
+/*
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Simon Goldschmidt
+ *
+ */
+#ifndef LWIP_HDR_NETDB_H
+#define LWIP_HDR_NETDB_H
+
+#include "lwip/opt.h"
+
+#if LWIP_DNS && LWIP_SOCKET
+
+#include "lwip/arch.h"
+#include "lwip/inet.h"
+#include "lwip/sockets.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* some rarely used options */
+#ifndef LWIP_DNS_API_DECLARE_H_ERRNO
+#define LWIP_DNS_API_DECLARE_H_ERRNO  1
+#endif
+
+#ifndef LWIP_DNS_API_DEFINE_ERRORS
+#define LWIP_DNS_API_DEFINE_ERRORS    1
+#endif
+
+#ifndef LWIP_DNS_API_DEFINE_FLAGS
+#define LWIP_DNS_API_DEFINE_FLAGS     1
+#endif
+
+#ifndef LWIP_DNS_API_DECLARE_STRUCTS
+#define LWIP_DNS_API_DECLARE_STRUCTS  1
+#endif
+
+#if LWIP_DNS_API_DEFINE_ERRORS
+/** Errors used by the DNS API functions, h_errno can be one of them */
+#define EAI_NONAME      200
+#define EAI_SERVICE     201
+#define EAI_FAIL        202
+#define EAI_MEMORY      203
+#define EAI_FAMILY      204
+
+#define HOST_NOT_FOUND  210
+#define NO_DATA         211
+#define NO_RECOVERY     212
+#define TRY_AGAIN       213
+#endif /* LWIP_DNS_API_DEFINE_ERRORS */
+
+#if LWIP_DNS_API_DEFINE_FLAGS
+/* input flags for struct addrinfo */
+#define AI_PASSIVE      0x01
+#define AI_CANONNAME    0x02
+#define AI_NUMERICHOST  0x04
+#define AI_NUMERICSERV  0x08
+#define AI_V4MAPPED     0x10
+#define AI_ALL          0x20
+#define AI_ADDRCONFIG   0x40
+#endif /* LWIP_DNS_API_DEFINE_FLAGS */
+
+#if LWIP_DNS_API_DECLARE_STRUCTS
+struct hostent {
+    char  *h_name;      /* Official name of the host. */
+    char **h_aliases;   /* A pointer to an array of pointers to alternative host names,
+                           terminated by a null pointer. */
+    int    h_addrtype;  /* Address type. */
+    int    h_length;    /* The length, in bytes, of the address. */
+    char **h_addr_list; /* A pointer to an array of pointers to network addresses (in
+                           network byte order) for the host, terminated by a null pointer. */
+#define h_addr h_addr_list[0] /* for backward compatibility */
+};
+
+struct addrinfo {
+    int               ai_flags;      /* Input flags. */
+    int               ai_family;     /* Address family of socket. */
+    int               ai_socktype;   /* Socket type. */
+    int               ai_protocol;   /* Protocol of socket. */
+    socklen_t         ai_addrlen;    /* Length of socket address. */
+    struct sockaddr  *ai_addr;       /* Socket address of socket. */
+    char             *ai_canonname;  /* Canonical name of service location. */
+    struct addrinfo  *ai_next;       /* Pointer to next in list. */
+};
+#endif /* LWIP_DNS_API_DECLARE_STRUCTS */
+
+#define NETDB_ELEM_SIZE           (sizeof(struct addrinfo) + sizeof(struct sockaddr_storage) + DNS_MAX_NAME_LENGTH + 1)
+
+#if LWIP_DNS_API_DECLARE_H_ERRNO
+/* application accessible error code set by the DNS API functions */
+extern int h_errno;
+#endif /* LWIP_DNS_API_DECLARE_H_ERRNO*/
+
+struct hostent *lwip_gethostbyname(const char *name);
+int lwip_gethostbyname_r(const char *name, struct hostent *ret, char *buf,
+                size_t buflen, struct hostent **result, int *h_errnop);
+void lwip_freeaddrinfo(struct addrinfo *ai);
+int lwip_getaddrinfo(const char *nodename,
+       const char *servname,
+       const struct addrinfo *hints,
+       struct addrinfo **res);
+
+#if LWIP_COMPAT_SOCKETS
+/** @ingroup netdbapi */
+#define gethostbyname(name) lwip_gethostbyname(name)
+/** @ingroup netdbapi */
+#define gethostbyname_r(name, ret, buf, buflen, result, h_errnop) \
+       lwip_gethostbyname_r(name, ret, buf, buflen, result, h_errnop)
+/** @ingroup netdbapi */
+#define freeaddrinfo(addrinfo) lwip_freeaddrinfo(addrinfo)
+/** @ingroup netdbapi */
+#define getaddrinfo(nodname, servname, hints, res) \
+       lwip_getaddrinfo(nodname, servname, hints, res)
+#endif /* LWIP_COMPAT_SOCKETS */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_DNS && LWIP_SOCKET */
+
+#endif /* LWIP_HDR_NETDB_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/netif.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/netif.h
new file mode 100644
index 000000000..9f4ee1ff2
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/netif.h
@@ -0,0 +1,515 @@
+/**
+ * @file
+ * netif API (to be used from TCPIP thread)
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_NETIF_H
+#define LWIP_HDR_NETIF_H
+
+#include "lwip/opt.h"
+
+#define ENABLE_LOOPBACK (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF)
+
+#include "lwip/err.h"
+
+#include "lwip/ip_addr.h"
+
+#include "lwip/def.h"
+#include "lwip/pbuf.h"
+#include "lwip/stats.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Throughout this file, IP addresses are expected to be in
+ * the same byte order as in IP_PCB. */
+
+/** Must be the maximum of all used hardware address lengths
+    across all types of interfaces in use.
+    This does not have to be changed, normally. */
+#ifndef NETIF_MAX_HWADDR_LEN
+#define NETIF_MAX_HWADDR_LEN 6U
+#endif
+
+/**
+ * @defgroup netif_flags Flags
+ * @ingroup netif
+ * @{
+ */
+
+/** Whether the network interface is 'up'. This is
+ * a software flag used to control whether this network
+ * interface is enabled and processes traffic.
+ * It must be set by the startup code before this netif can be used
+ * (also for dhcp/autoip).
+ */
+#define NETIF_FLAG_UP           0x01U
+/** If set, the netif has broadcast capability.
+ * Set by the netif driver in its init function. */
+#define NETIF_FLAG_BROADCAST    0x02U
+/** If set, the interface has an active link
+ *  (set by the network interface driver).
+ * Either set by the netif driver in its init function (if the link
+ * is up at that time) or at a later point once the link comes up
+ * (if link detection is supported by the hardware). */
+#define NETIF_FLAG_LINK_UP      0x04U
+/** If set, the netif is an ethernet device using ARP.
+ * Set by the netif driver in its init function.
+ * Used to check input packet types and use of DHCP. */
+#define NETIF_FLAG_ETHARP       0x08U
+/** If set, the netif is an ethernet device. It might not use
+ * ARP or TCP/IP if it is used for PPPoE only.
+ */
+#define NETIF_FLAG_ETHERNET     0x10U
+/** If set, the netif has IGMP capability.
+ * Set by the netif driver in its init function. */
+#define NETIF_FLAG_IGMP         0x20U
+/** If set, the netif has MLD6 capability.
+ * Set by the netif driver in its init function. */
+#define NETIF_FLAG_MLD6         0x40U
+
+/**
+ * @}
+ */
+
+enum lwip_internal_netif_client_data_index
+{
+#if LWIP_DHCP
+   LWIP_NETIF_CLIENT_DATA_INDEX_DHCP,
+#endif
+#if LWIP_AUTOIP
+   LWIP_NETIF_CLIENT_DATA_INDEX_AUTOIP,
+#endif
+#if LWIP_IGMP
+   LWIP_NETIF_CLIENT_DATA_INDEX_IGMP,
+#endif
+#if LWIP_IPV6_MLD
+   LWIP_NETIF_CLIENT_DATA_INDEX_MLD6,
+#endif
+   LWIP_NETIF_CLIENT_DATA_INDEX_MAX
+};
+
+#if LWIP_CHECKSUM_CTRL_PER_NETIF
+#define NETIF_CHECKSUM_GEN_IP       0x0001
+#define NETIF_CHECKSUM_GEN_UDP      0x0002
+#define NETIF_CHECKSUM_GEN_TCP      0x0004
+#define NETIF_CHECKSUM_GEN_ICMP     0x0008
+#define NETIF_CHECKSUM_GEN_ICMP6    0x0010
+#define NETIF_CHECKSUM_CHECK_IP     0x0100
+#define NETIF_CHECKSUM_CHECK_UDP    0x0200
+#define NETIF_CHECKSUM_CHECK_TCP    0x0400
+#define NETIF_CHECKSUM_CHECK_ICMP   0x0800
+#define NETIF_CHECKSUM_CHECK_ICMP6  0x1000
+#define NETIF_CHECKSUM_ENABLE_ALL   0xFFFF
+#define NETIF_CHECKSUM_DISABLE_ALL  0x0000
+#endif /* LWIP_CHECKSUM_CTRL_PER_NETIF */
+
+struct netif;
+
+/** MAC Filter Actions, these are passed to a netif's igmp_mac_filter or
+ * mld_mac_filter callback function. */
+enum netif_mac_filter_action {
+  /** Delete a filter entry */
+  NETIF_DEL_MAC_FILTER = 0,
+  /** Add a filter entry */
+  NETIF_ADD_MAC_FILTER = 1
+};
+
+/** Function prototype for netif init functions. Set up flags and output/linkoutput
+ * callback functions in this function.
+ *
+ * @param netif The netif to initialize
+ */
+typedef err_t (*netif_init_fn)(struct netif *netif);
+/** Function prototype for netif->input functions. This function is saved as 'input'
+ * callback function in the netif struct. Call it when a packet has been received.
+ *
+ * @param p The received packet, copied into a pbuf
+ * @param inp The netif which received the packet
+ */
+typedef err_t (*netif_input_fn)(struct pbuf *p, struct netif *inp);
+
+#if LWIP_IPV4
+/** Function prototype for netif->output functions. Called by lwIP when a packet
+ * shall be sent. For ethernet netif, set this to 'etharp_output' and set
+ * 'linkoutput'.
+ *
+ * @param netif The netif which shall send a packet
+ * @param p The packet to send (p->payload points to IP header)
+ * @param ipaddr The IP address to which the packet shall be sent
+ */
+typedef err_t (*netif_output_fn)(struct netif *netif, struct pbuf *p,
+       const ip4_addr_t *ipaddr);
+#endif /* LWIP_IPV4*/
+
+#if LWIP_IPV6
+/** Function prototype for netif->output_ip6 functions. Called by lwIP when a packet
+ * shall be sent. For ethernet netif, set this to 'ethip6_output' and set
+ * 'linkoutput'.
+ *
+ * @param netif The netif which shall send a packet
+ * @param p The packet to send (p->payload points to IP header)
+ * @param ipaddr The IPv6 address to which the packet shall be sent
+ */
+typedef err_t (*netif_output_ip6_fn)(struct netif *netif, struct pbuf *p,
+       const ip6_addr_t *ipaddr);
+#endif /* LWIP_IPV6 */
+
+/** Function prototype for netif->linkoutput functions. Only used for ethernet
+ * netifs. This function is called by ARP when a packet shall be sent.
+ *
+ * @param netif The netif which shall send a packet
+ * @param p The packet to send (raw ethernet packet)
+ */
+typedef err_t (*netif_linkoutput_fn)(struct netif *netif, struct pbuf *p);
+/** Function prototype for netif status- or link-callback functions. */
+typedef void (*netif_status_callback_fn)(struct netif *netif);
+#if LWIP_IPV4 && LWIP_IGMP
+/** Function prototype for netif igmp_mac_filter functions */
+typedef err_t (*netif_igmp_mac_filter_fn)(struct netif *netif,
+       const ip4_addr_t *group, enum netif_mac_filter_action action);
+#endif /* LWIP_IPV4 && LWIP_IGMP */
+#if LWIP_IPV6 && LWIP_IPV6_MLD
+/** Function prototype for netif mld_mac_filter functions */
+typedef err_t (*netif_mld_mac_filter_fn)(struct netif *netif,
+       const ip6_addr_t *group, enum netif_mac_filter_action action);
+#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
+
+#if LWIP_DHCP || LWIP_AUTOIP || LWIP_IGMP || LWIP_IPV6_MLD || (LWIP_NUM_NETIF_CLIENT_DATA > 0)
+u8_t netif_alloc_client_data_id(void);
+/** @ingroup netif_cd
+ * Set client data. Obtain ID from netif_alloc_client_data_id().
+ */
+#define netif_set_client_data(netif, id, data) netif_get_client_data(netif, id) = (data)
+/** @ingroup netif_cd
+ * Get client data. Obtain ID from netif_alloc_client_data_id().
+ */
+#define netif_get_client_data(netif, id)       (netif)->client_data[(id)]
+#endif /* LWIP_DHCP || LWIP_AUTOIP || (LWIP_NUM_NETIF_CLIENT_DATA > 0) */
+
+/** Generic data structure used for all lwIP network interfaces.
+ *  The following fields should be filled in by the initialization
+ *  function for the device driver: hwaddr_len, hwaddr[], mtu, flags */
+struct netif {
+  /** pointer to next in linked list */
+  struct netif *next;
+
+#if LWIP_IPV4
+  /** IP address configuration in network byte order */
+  ip_addr_t ip_addr;
+  ip_addr_t netmask;
+  ip_addr_t gw;
+#endif /* LWIP_IPV4 */
+#if LWIP_IPV6
+  /** Array of IPv6 addresses for this netif. */
+  ip_addr_t ip6_addr[LWIP_IPV6_NUM_ADDRESSES];
+  /** The state of each IPv6 address (Tentative, Preferred, etc).
+   * @see ip6_addr.h */
+  u8_t ip6_addr_state[LWIP_IPV6_NUM_ADDRESSES];
+#if LWIP_IPV6_ADDRESS_LIFETIMES
+  /** Remaining valid and preferred lifetime of each IPv6 address, in seconds.
+   * For valid lifetimes, the special value of IP6_ADDR_LIFE_STATIC (0)
+   * indicates the address is static and has no lifetimes. */
+  u32_t ip6_addr_valid_life[LWIP_IPV6_NUM_ADDRESSES];
+  u32_t ip6_addr_pref_life[LWIP_IPV6_NUM_ADDRESSES];
+#endif /* LWIP_IPV6_ADDRESS_LIFETIMES */
+#endif /* LWIP_IPV6 */
+  /** This function is called by the network device driver
+   *  to pass a packet up the TCP/IP stack. */
+  netif_input_fn input;
+#if LWIP_IPV4
+  /** This function is called by the IP module when it wants
+   *  to send a packet on the interface. This function typically
+   *  first resolves the hardware address, then sends the packet.
+   *  For ethernet physical layer, this is usually etharp_output() */
+  netif_output_fn output;
+#endif /* LWIP_IPV4 */
+  /** This function is called by ethernet_output() when it wants
+   *  to send a packet on the interface. This function outputs
+   *  the pbuf as-is on the link medium. */
+  netif_linkoutput_fn linkoutput;
+#if LWIP_IPV6
+  /** This function is called by the IPv6 module when it wants
+   *  to send a packet on the interface. This function typically
+   *  first resolves the hardware address, then sends the packet.
+   *  For ethernet physical layer, this is usually ethip6_output() */
+  netif_output_ip6_fn output_ip6;
+#endif /* LWIP_IPV6 */
+#if LWIP_NETIF_STATUS_CALLBACK
+  /** This function is called when the netif state is set to up or down
+   */
+  netif_status_callback_fn status_callback;
+#endif /* LWIP_NETIF_STATUS_CALLBACK */
+#if LWIP_NETIF_LINK_CALLBACK
+  /** This function is called when the netif link is set to up or down
+   */
+  netif_status_callback_fn link_callback;
+#endif /* LWIP_NETIF_LINK_CALLBACK */
+#if LWIP_NETIF_REMOVE_CALLBACK
+  /** This function is called when the netif has been removed */
+  netif_status_callback_fn remove_callback;
+#endif /* LWIP_NETIF_REMOVE_CALLBACK */
+  /** This field can be set by the device driver and could point
+   *  to state information for the device. */
+  void *state;
+#ifdef netif_get_client_data
+  void* client_data[LWIP_NETIF_CLIENT_DATA_INDEX_MAX + LWIP_NUM_NETIF_CLIENT_DATA];
+#endif
+#if LWIP_IPV6_AUTOCONFIG
+  /** is this netif enabled for IPv6 autoconfiguration */
+  u8_t ip6_autoconfig_enabled;
+#endif /* LWIP_IPV6_AUTOCONFIG */
+#if LWIP_IPV6_SEND_ROUTER_SOLICIT
+  /** Number of Router Solicitation messages that remain to be sent. */
+  u8_t rs_count;
+#endif /* LWIP_IPV6_SEND_ROUTER_SOLICIT */
+#if LWIP_NETIF_HOSTNAME
+  /* the hostname for this netif, NULL is a valid value */
+  const char*  hostname;
+#endif /* LWIP_NETIF_HOSTNAME */
+#if LWIP_CHECKSUM_CTRL_PER_NETIF
+  u16_t chksum_flags;
+#endif /* LWIP_CHECKSUM_CTRL_PER_NETIF*/
+  /** maximum transfer unit (in bytes) */
+  u16_t mtu;
+  /** number of bytes used in hwaddr */
+  u8_t hwaddr_len;
+  /** link level hardware address of this interface */
+  u8_t hwaddr[NETIF_MAX_HWADDR_LEN];
+  /** flags (@see @ref netif_flags) */
+  u8_t flags;
+#if LWIP_MANAGEMENT_CHANNEL
+  u8_t using_management_channel:1;
+#endif
+  /** descriptive abbreviation */
+  char name[2];
+  /** number of this interface */
+  u8_t num;
+#if MIB2_STATS
+  /** link type (from "snmp_ifType" enum from snmp_mib2.h) */
+  u8_t link_type;
+  /** (estimate) link speed */
+  u32_t link_speed;
+  /** timestamp at last change made (up/down) */
+  u32_t ts;
+  /** counters */
+  struct stats_mib2_netif_ctrs mib2_counters;
+#endif /* MIB2_STATS */
+#if LWIP_IPV4 && LWIP_IGMP
+  /** This function could be called to add or delete an entry in the multicast
+      filter table of the ethernet MAC.*/
+  netif_igmp_mac_filter_fn igmp_mac_filter;
+#endif /* LWIP_IPV4 && LWIP_IGMP */
+#if LWIP_IPV6 && LWIP_IPV6_MLD
+  /** This function could be called to add or delete an entry in the IPv6 multicast
+      filter table of the ethernet MAC. */
+  netif_mld_mac_filter_fn mld_mac_filter;
+#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
+#if LWIP_NETIF_HWADDRHINT
+  u8_t *addr_hint;
+#endif /* LWIP_NETIF_HWADDRHINT */
+#if ENABLE_LOOPBACK
+  /* List of packets to be queued for ourselves. */
+  struct pbuf *loop_first;
+  struct pbuf *loop_last;
+#if LWIP_LOOPBACK_MAX_PBUFS
+  u16_t loop_cnt_current;
+#endif /* LWIP_LOOPBACK_MAX_PBUFS */
+#endif /* ENABLE_LOOPBACK */
+};
+
+#if LWIP_CHECKSUM_CTRL_PER_NETIF
+#define NETIF_SET_CHECKSUM_CTRL(netif, chksumflags) do { \
+  (netif)->chksum_flags = chksumflags; } while(0)
+#define IF__NETIF_CHECKSUM_ENABLED(netif, chksumflag) if (((netif) == NULL) || (((netif)->chksum_flags & (chksumflag)) != 0))
+#else /* LWIP_CHECKSUM_CTRL_PER_NETIF */
+#define NETIF_SET_CHECKSUM_CTRL(netif, chksumflags)
+#define IF__NETIF_CHECKSUM_ENABLED(netif, chksumflag)
+#endif /* LWIP_CHECKSUM_CTRL_PER_NETIF */
+
+/** The list of network interfaces. */
+extern struct netif *netif_list;
+/** The default network interface. */
+extern struct netif *netif_default;
+
+void netif_init(void);
+
+struct ip_pcb;
+
+void netif_apply_pcb(struct netif *netif, struct ip_pcb *pcb);
+
+struct netif *netif_add(struct netif *netif,
+#if LWIP_IPV4
+                        const ip4_addr_t *ipaddr, const ip4_addr_t *netmask, const ip4_addr_t *gw,
+#endif /* LWIP_IPV4 */
+                        void *state, netif_init_fn init, netif_input_fn input);
+#if LWIP_IPV4
+void netif_set_addr(struct netif *netif, const ip4_addr_t *ipaddr, const ip4_addr_t *netmask,
+                    const ip4_addr_t *gw);
+#endif /* LWIP_IPV4 */
+void netif_remove(struct netif * netif);
+
+/* Returns a network interface given its name. The name is of the form
+   "et0", where the first two letters are the "name" field in the
+   netif structure, and the digit is in the num field in the same
+   structure. */
+struct netif *netif_find(const char *name);
+
+void netif_set_default(struct netif *netif);
+
+#if LWIP_IPV4
+void netif_set_ipaddr(struct netif *netif, const ip4_addr_t *ipaddr);
+void netif_set_netmask(struct netif *netif, const ip4_addr_t *netmask);
+void netif_set_gw(struct netif *netif, const ip4_addr_t *gw);
+/** @ingroup netif_ip4 */
+#define netif_ip4_addr(netif)    ((const ip4_addr_t*)ip_2_ip4(&((netif)->ip_addr)))
+/** @ingroup netif_ip4 */
+#define netif_ip4_netmask(netif) ((const ip4_addr_t*)ip_2_ip4(&((netif)->netmask)))
+/** @ingroup netif_ip4 */
+#define netif_ip4_gw(netif)      ((const ip4_addr_t*)ip_2_ip4(&((netif)->gw)))
+/** @ingroup netif_ip4 */
+#define netif_ip_addr4(netif)    ((const ip_addr_t*)&((netif)->ip_addr))
+/** @ingroup netif_ip4 */
+#define netif_ip_netmask4(netif) ((const ip_addr_t*)&((netif)->netmask))
+/** @ingroup netif_ip4 */
+#define netif_ip_gw4(netif)      ((const ip_addr_t*)&((netif)->gw))
+#endif /* LWIP_IPV4 */
+
+void netif_set_up(struct netif *netif);
+void netif_set_down(struct netif *netif);
+/** @ingroup netif
+ * Ask if an interface is up
+ */
+#define netif_is_up(netif) (((netif)->flags & NETIF_FLAG_UP) ? (u8_t)1 : (u8_t)0)
+
+#if LWIP_NETIF_STATUS_CALLBACK
+void netif_set_status_callback(struct netif *netif, netif_status_callback_fn status_callback);
+#endif /* LWIP_NETIF_STATUS_CALLBACK */
+#if LWIP_NETIF_REMOVE_CALLBACK
+void netif_set_remove_callback(struct netif *netif, netif_status_callback_fn remove_callback);
+#endif /* LWIP_NETIF_REMOVE_CALLBACK */
+
+void netif_set_link_up(struct netif *netif);
+void netif_set_link_down(struct netif *netif);
+/** Ask if a link is up */
+#define netif_is_link_up(netif) (((netif)->flags & NETIF_FLAG_LINK_UP) ? (u8_t)1 : (u8_t)0)
+
+#if LWIP_NETIF_LINK_CALLBACK
+void netif_set_link_callback(struct netif *netif, netif_status_callback_fn link_callback);
+#endif /* LWIP_NETIF_LINK_CALLBACK */
+
+#if LWIP_NETIF_HOSTNAME
+/** @ingroup netif */
+#define netif_set_hostname(netif, name) do { if((netif) != NULL) { (netif)->hostname = name; }}while(0)
+/** @ingroup netif */
+#define netif_get_hostname(netif) (((netif) != NULL) ? ((netif)->hostname) : NULL)
+#endif /* LWIP_NETIF_HOSTNAME */
+
+#if LWIP_IGMP
+/** @ingroup netif */
+#define netif_set_igmp_mac_filter(netif, function) do { if((netif) != NULL) { (netif)->igmp_mac_filter = function; }}while(0)
+#define netif_get_igmp_mac_filter(netif) (((netif) != NULL) ? ((netif)->igmp_mac_filter) : NULL)
+#endif /* LWIP_IGMP */
+
+#if LWIP_IPV6 && LWIP_IPV6_MLD
+/** @ingroup netif */
+#define netif_set_mld_mac_filter(netif, function) do { if((netif) != NULL) { (netif)->mld_mac_filter = function; }}while(0)
+#define netif_get_mld_mac_filter(netif) (((netif) != NULL) ? ((netif)->mld_mac_filter) : NULL)
+#define netif_mld_mac_filter(netif, addr, action) do { if((netif) && (netif)->mld_mac_filter) { (netif)->mld_mac_filter((netif), (addr), (action)); }}while(0)
+#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
+
+#if ENABLE_LOOPBACK
+err_t netif_loop_output(struct netif *netif, struct pbuf *p);
+void netif_poll(struct netif *netif);
+#if !LWIP_NETIF_LOOPBACK_MULTITHREADING
+void netif_poll_all(void);
+#endif /* !LWIP_NETIF_LOOPBACK_MULTITHREADING */
+#endif /* ENABLE_LOOPBACK */
+
+err_t netif_input(struct pbuf *p, struct netif *inp);
+
+#if LWIP_IPV6
+/** @ingroup netif_ip6 */
+#define netif_ip_addr6(netif, i)  ((const ip_addr_t*)(&((netif)->ip6_addr[i])))
+/** @ingroup netif_ip6 */
+#define netif_ip6_addr(netif, i)  ((const ip6_addr_t*)ip_2_ip6(&((netif)->ip6_addr[i])))
+void netif_ip6_addr_set(struct netif *netif, s8_t addr_idx, const ip6_addr_t *addr6);
+void netif_ip6_addr_set_parts(struct netif *netif, s8_t addr_idx, u32_t i0, u32_t i1, u32_t i2, u32_t i3);
+#define netif_ip6_addr_state(netif, i)  ((netif)->ip6_addr_state[i])
+void netif_ip6_addr_set_state(struct netif* netif, s8_t addr_idx, u8_t state);
+s8_t netif_get_ip6_addr_match(struct netif *netif, const ip6_addr_t *ip6addr);
+void netif_create_ip6_linklocal_address(struct netif *netif, u8_t from_mac_48bit);
+err_t netif_add_ip6_address(struct netif *netif, const ip6_addr_t *ip6addr, s8_t *chosen_idx);
+err_t netif_add_ip6_address_with_route(struct netif *netif, ip6_addr_t *ip6addr, 
+                                       u8_t prefix_len, s8_t *chosen_idx);
+err_t netif_remove_ip6_address(struct netif *netif, ip6_addr_t *ip6addr);
+err_t netif_remove_ip6_address_with_route(struct netif *netif, ip6_addr_t *ip6addr, 
+                                          u8_t prefix_len);
+#define netif_set_ip6_autoconfig_enabled(netif, action) do { if(netif) { (netif)->ip6_autoconfig_enabled = (action); }}while(0)
+#if LWIP_IPV6_ADDRESS_LIFETIMES
+#define netif_ip6_addr_valid_life(netif, i)  \
+    (((netif) != NULL) ? ((netif)->ip6_addr_valid_life[i]) : IP6_ADDR_LIFE_STATIC)
+#define netif_ip6_addr_set_valid_life(netif, i, secs) \
+    do { if (netif != NULL) { (netif)->ip6_addr_valid_life[i] = (secs); }} while (0)
+#define netif_ip6_addr_pref_life(netif, i)  \
+    (((netif) != NULL) ? ((netif)->ip6_addr_pref_life[i]) : IP6_ADDR_LIFE_STATIC)
+#define netif_ip6_addr_set_pref_life(netif, i, secs) \
+    do { if (netif != NULL) { (netif)->ip6_addr_pref_life[i] = (secs); }} while (0)
+#define netif_ip6_addr_isstatic(netif, i)  \
+    (netif_ip6_addr_valid_life((netif), (i)) == IP6_ADDR_LIFE_STATIC)
+#else /* !LWIP_IPV6_ADDRESS_LIFETIMES */
+#define netif_ip6_addr_isstatic(netif, i)  (1) /* all addresses are static */
+#endif /* !LWIP_IPV6_ADDRESS_LIFETIMES */
+#endif /* LWIP_IPV6 */
+
+#if LWIP_NETIF_HWADDRHINT
+#define NETIF_SET_HWADDRHINT(netif, hint) ((netif)->addr_hint = (hint))
+#else /* LWIP_NETIF_HWADDRHINT */
+#define NETIF_SET_HWADDRHINT(netif, hint)
+#endif /* LWIP_NETIF_HWADDRHINT */
+
+u8_t netif_name_to_index(const char *name);
+char * netif_index_to_name(u8_t idx, char *name);
+struct netif* netif_get_by_index(u8_t index);
+
+/* Interface indexes always start at 1 per RFC 3493, section 4, num starts at 0 */
+#define netif_get_index(netif)      ((netif)->num + 1)
+#define NETIF_NO_INDEX              (0)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_NETIF_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/netifapi.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/netifapi.h
new file mode 100644
index 000000000..79369c281
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/netifapi.h
@@ -0,0 +1,154 @@
+/**
+ * @file
+ * netif API (to be used from non-TCPIP threads)
+ */
+
+/*
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ */
+#ifndef LWIP_HDR_NETIFAPI_H
+#define LWIP_HDR_NETIFAPI_H
+
+#include "lwip/opt.h"
+
+#if LWIP_NETIF_API /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/sys.h"
+#include "lwip/netif.h"
+#include "lwip/dhcp.h"
+#include "lwip/autoip.h"
+#include "lwip/if.h"
+#include "lwip/priv/tcpip_priv.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_MPU_COMPATIBLE
+#define NETIFAPI_IPADDR_DEF(type, m)  type m
+#else /* LWIP_MPU_COMPATIBLE */
+#define NETIFAPI_IPADDR_DEF(type, m)  const type * m
+#endif /* LWIP_MPU_COMPATIBLE */
+
+typedef void (*netifapi_void_fn)(struct netif *netif);
+typedef err_t (*netifapi_errt_fn)(struct netif *netif);
+
+struct netifapi_msg {
+  struct tcpip_api_call_data call;
+  struct netif *netif;
+  union {
+    struct {
+#if LWIP_IPV4
+      NETIFAPI_IPADDR_DEF(ip4_addr_t, ipaddr);
+      NETIFAPI_IPADDR_DEF(ip4_addr_t, netmask);
+      NETIFAPI_IPADDR_DEF(ip4_addr_t, gw);
+#endif /* LWIP_IPV4 */
+      void *state;
+      netif_init_fn init;
+      netif_input_fn input;
+    } add;
+    struct {
+      netifapi_void_fn voidfunc;
+      netifapi_errt_fn errtfunc;
+    } common;
+    struct {
+#if LWIP_MPU_COMPATIBLE
+      char name[IF_NAMESIZE];
+#else /* LWIP_MPU_COMPATIBLE */
+      char *name;
+#endif /* LWIP_MPU_COMPATIBLE */
+      u8_t index;
+    } ifs;
+  } msg;
+};
+
+
+/* API for application */
+err_t netifapi_netif_add(struct netif *netif,
+#if LWIP_IPV4
+                         const ip4_addr_t *ipaddr, const ip4_addr_t *netmask, const ip4_addr_t *gw,
+#endif /* LWIP_IPV4 */
+                         void *state, netif_init_fn init, netif_input_fn input);
+
+#if LWIP_IPV4
+err_t netifapi_netif_set_addr(struct netif *netif, const ip4_addr_t *ipaddr,
+                              const ip4_addr_t *netmask, const ip4_addr_t *gw);
+#endif /* LWIP_IPV4*/
+
+err_t netifapi_netif_common(struct netif *netif, netifapi_void_fn voidfunc,
+                            netifapi_errt_fn errtfunc);
+
+/** @ingroup netifapi_netif */
+err_t netifapi_netif_name_to_index(const char *name, u8_t *index);
+/** @ingroup netifapi_netif */
+err_t netifapi_netif_index_to_name(u8_t index, char *name);
+
+/** @ingroup netifapi_netif */
+#define netifapi_netif_remove(n)        netifapi_netif_common(n, netif_remove, NULL)
+/** @ingroup netifapi_netif */
+#define netifapi_netif_set_up(n)        netifapi_netif_common(n, netif_set_up, NULL)
+/** @ingroup netifapi_netif */
+#define netifapi_netif_set_down(n)      netifapi_netif_common(n, netif_set_down, NULL)
+/** @ingroup netifapi_netif */
+#define netifapi_netif_set_default(n)   netifapi_netif_common(n, netif_set_default, NULL)
+/** @ingroup netifapi_netif */
+#define netifapi_netif_set_link_up(n)   netifapi_netif_common(n, netif_set_link_up, NULL)
+/** @ingroup netifapi_netif */
+#define netifapi_netif_set_link_down(n) netifapi_netif_common(n, netif_set_link_down, NULL)
+
+/**
+ * @defgroup netifapi_dhcp4 DHCPv4
+ * @ingroup netifapi
+ * To be called from non-TCPIP threads
+ */
+/** @ingroup netifapi_dhcp4 */
+#define netifapi_dhcp_start(n)        netifapi_netif_common(n, NULL, dhcp_start)
+/** @ingroup netifapi_dhcp4 */
+#define netifapi_dhcp_stop(n)         netifapi_netif_common(n, dhcp_stop, NULL)
+/** @ingroup netifapi_dhcp4 */
+#define netifapi_dhcp_inform(n)       netifapi_netif_common(n, dhcp_inform, NULL)
+/** @ingroup netifapi_dhcp4 */
+#define netifapi_dhcp_renew(n)        netifapi_netif_common(n, NULL, dhcp_renew)
+/** @ingroup netifapi_dhcp4 */
+#define netifapi_dhcp_release(n)      netifapi_netif_common(n, NULL, dhcp_release)
+
+/**
+ * @defgroup netifapi_autoip AUTOIP
+ * @ingroup netifapi
+ * To be called from non-TCPIP threads
+ */
+/** @ingroup netifapi_autoip */
+#define netifapi_autoip_start(n)      netifapi_netif_common(n, NULL, autoip_start)
+/** @ingroup netifapi_autoip */
+#define netifapi_autoip_stop(n)       netifapi_netif_common(n, NULL, autoip_stop)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_NETIF_API */
+
+#endif /* LWIP_HDR_NETIFAPI_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/opt.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/opt.h
new file mode 100644
index 000000000..0c97ebd0c
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/opt.h
@@ -0,0 +1,3014 @@
+/**
+ * @file
+ *
+ * lwIP Options Configuration
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+/*
+ * NOTE: || defined __DOXYGEN__ is a workaround for doxygen bug -
+ * without this, doxygen does not see the actual #define
+ */
+
+#if !defined LWIP_HDR_OPT_H
+#define LWIP_HDR_OPT_H
+
+/*
+ * Include user defined options first. Anything not defined in these files
+ * will be set to standard values. Override anything you don't like!
+ */
+#include "lwipopts.h"
+#include "lwip/debug.h"
+
+/**
+ * @defgroup lwip_opts Options (lwipopts.h)
+ * @ingroup lwip
+ *
+ * @defgroup lwip_opts_debug Debugging
+ * @ingroup lwip_opts
+ *
+ * @defgroup lwip_opts_infrastructure Infrastructure
+ * @ingroup lwip_opts
+ *
+ * @defgroup lwip_opts_callback Callback-style APIs
+ * @ingroup lwip_opts
+ *
+ * @defgroup lwip_opts_threadsafe_apis Thread-safe APIs
+ * @ingroup lwip_opts
+ */
+
+ /*
+   ------------------------------------
+   -------------- NO SYS --------------
+   ------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_nosys NO_SYS
+ * @ingroup lwip_opts_infrastructure
+ * @{
+ */
+/**
+ * NO_SYS==1: Use lwIP without OS-awareness (no thread, semaphores, mutexes or
+ * mboxes). This means threaded APIs cannot be used (socket, netconn,
+ * i.e. everything in the 'api' folder), only the callback-style raw API is
+ * available (and you have to watch out for yourself that you don't access
+ * lwIP functions/structures from more than one context at a time!)
+ */
+#if !defined NO_SYS || defined __DOXYGEN__
+#define NO_SYS                          0
+#endif
+/**
+ * @}
+ */
+
+/**
+ * @defgroup lwip_opts_timers Timers
+ * @ingroup lwip_opts_infrastructure
+ * @{
+ */
+/**
+ * LWIP_TIMERS==0: Drop support for sys_timeout and lwip-internal cyclic timers.
+ * (the array of lwip-internal cyclic timers is still provided)
+ * (check NO_SYS_NO_TIMERS for compatibility to old versions)
+ */
+#if !defined LWIP_TIMERS || defined __DOXYGEN__
+#ifdef NO_SYS_NO_TIMERS
+#define LWIP_TIMERS                     (!NO_SYS || (NO_SYS && !NO_SYS_NO_TIMERS))
+#else
+#define LWIP_TIMERS                     1
+#endif
+#endif
+
+/**
+ * LWIP_TIMERS_CUSTOM==1: Provide your own timer implementation.
+ * Function prototypes in timeouts.h and the array of lwip-internal cyclic timers
+ * are still included, but the implementation is not. The following functions
+ * will be required: sys_timeouts_init(), sys_timeout(), sys_untimeout(),
+ *                   sys_timeouts_mbox_fetch()
+ */
+#if !defined LWIP_TIMERS_CUSTOM || defined __DOXYGEN__
+#define LWIP_TIMERS_CUSTOM              0
+#endif
+/**
+ * @}
+ */
+
+/**
+ * @defgroup lwip_opts_memcpy memcpy
+ * @ingroup lwip_opts_infrastructure
+ * @{
+ */
+/**
+ * MEMCPY: override this if you have a faster implementation at hand than the
+ * one included in your C library
+ */
+#if !defined MEMCPY || defined __DOXYGEN__
+#define MEMCPY(dst,src,len)             memcpy(dst,src,len)
+#endif
+
+/**
+ * SMEMCPY: override this with care! Some compilers (e.g. gcc) can inline a
+ * call to memcpy() if the length is known at compile time and is small.
+ */
+#if !defined SMEMCPY || defined __DOXYGEN__
+#define SMEMCPY(dst,src,len)            memcpy(dst,src,len)
+#endif
+/**
+ * @}
+ */
+
+/*
+   ------------------------------------
+   ----------- Core locking -----------
+   ------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_lock Core locking and MPU
+ * @ingroup lwip_opts_infrastructure
+ * @{
+ */
+/**
+ * LWIP_MPU_COMPATIBLE: enables special memory management mechanism
+ * which makes lwip able to work on MPU (Memory Protection Unit) system
+ * by not passing stack-pointers to other threads
+ * (this decreases performance as memory is allocated from pools instead
+ * of keeping it on the stack)
+ */
+#if !defined LWIP_MPU_COMPATIBLE || defined __DOXYGEN__
+#define LWIP_MPU_COMPATIBLE             0
+#endif
+
+/**
+ * LWIP_TCPIP_CORE_LOCKING
+ * Creates a global mutex that is held during TCPIP thread operations.
+ * Can be locked by client code to perform lwIP operations without changing
+ * into TCPIP thread using callbacks. See LOCK_TCPIP_CORE() and
+ * UNLOCK_TCPIP_CORE().
+ * Your system should provide mutexes supporting priority inversion to use this.
+ */
+#if !defined LWIP_TCPIP_CORE_LOCKING || defined __DOXYGEN__
+#define LWIP_TCPIP_CORE_LOCKING         1
+#endif
+
+/**
+ * LWIP_TCPIP_CORE_LOCKING_INPUT: when LWIP_TCPIP_CORE_LOCKING is enabled,
+ * this lets tcpip_input() grab the mutex for input packets as well,
+ * instead of allocating a message and passing it to tcpip_thread.
+ *
+ * ATTENTION: this does not work when tcpip_input() is called from
+ * interrupt context!
+ */
+#if !defined LWIP_TCPIP_CORE_LOCKING_INPUT || defined __DOXYGEN__
+#define LWIP_TCPIP_CORE_LOCKING_INPUT   0
+#endif
+
+/**
+ * SYS_LIGHTWEIGHT_PROT==1: enable inter-task protection (and task-vs-interrupt
+ * protection) for certain critical regions during buffer allocation, deallocation
+ * and memory allocation and deallocation.
+ * ATTENTION: This is required when using lwIP from more than one context! If
+ * you disable this, you must be sure what you are doing!
+ */
+#if !defined SYS_LIGHTWEIGHT_PROT || defined __DOXYGEN__
+#define SYS_LIGHTWEIGHT_PROT            1
+#endif
+
+/**
+ * LWIP_ASSERT_CORE_LOCKED: Macro to check whether lwIP's threading/locking
+ * requirements are satisfied during current function call.
+ * This macro usually calls a function that is implemented in the OS-dependent
+ * sys layer and performs the following checks:
+ * - Not in ISR
+ * - If LWIP_TCPIP_CORE_LOCKING=1: TCPIP core lock is held
+ * - If LWIP_TCPIP_CORE_LOCKING=0: function is called from TCPIP thread
+ */
+#if !defined LWIP_ASSERT_CORE_LOCKED || defined __DOXYGEN__
+#define LWIP_ASSERT_CORE_LOCKED()
+#endif
+
+/**
+ * Called as first thing in the lwIP TCPIP thread. Can be used in conjunction
+ * with LWIP_ASSERT_CORE_LOCKED to check core locking.
+ */
+#if !defined LWIP_MARK_TCPIP_THREAD || defined __DOXYGEN__
+#define LWIP_MARK_TCPIP_THREAD()
+#endif
+/**
+ * @}
+ */
+
+/*
+   ------------------------------------
+   ---------- Memory options ----------
+   ------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_mem Heap and memory pools
+ * @ingroup lwip_opts_infrastructure
+ * @{
+ */
+/**
+ * MEM_LIBC_MALLOC==1: Use malloc/free/realloc provided by your C-library
+ * instead of the lwip internal allocator. Can save code size if you
+ * already use it.
+ */
+#if !defined MEM_LIBC_MALLOC || defined __DOXYGEN__
+#define MEM_LIBC_MALLOC                 0
+#endif
+
+/**
+ * MEMP_MEM_MALLOC==1: Use mem_malloc/mem_free instead of the lwip pool allocator.
+ * Especially useful with MEM_LIBC_MALLOC but handle with care regarding execution
+ * speed (heap alloc can be much slower than pool alloc) and usage from interrupts
+ * (especially if your netif driver allocates PBUF_POOL pbufs for received frames
+ * from interrupt)!
+ * ATTENTION: Currently, this uses the heap for ALL pools (also for private pools,
+ * not only for internal pools defined in memp_std.h)!
+ */
+#if !defined MEMP_MEM_MALLOC || defined __DOXYGEN__
+#define MEMP_MEM_MALLOC                 0
+#endif
+
+/**
+ * MEM_ALIGNMENT: should be set to the alignment of the CPU
+ *    4 byte alignment -> \#define MEM_ALIGNMENT 4
+ *    2 byte alignment -> \#define MEM_ALIGNMENT 2
+ */
+#if !defined MEM_ALIGNMENT || defined __DOXYGEN__
+#define MEM_ALIGNMENT                   1
+#endif
+
+/**
+ * MEM_SIZE: the size of the heap memory. If the application will send
+ * a lot of data that needs to be copied, this should be set high.
+ */
+#if !defined MEM_SIZE || defined __DOXYGEN__
+#define MEM_SIZE                        1600
+#endif
+
+/**
+ * MEMP_OVERFLOW_CHECK: memp overflow protection reserves a configurable
+ * amount of bytes before and after each memp element in every pool and fills
+ * it with a prominent default value.
+ *    MEMP_OVERFLOW_CHECK == 0 no checking
+ *    MEMP_OVERFLOW_CHECK == 1 checks each element when it is freed
+ *    MEMP_OVERFLOW_CHECK >= 2 checks each element in every pool every time
+ *      memp_malloc() or memp_free() is called (useful but slow!)
+ */
+#if !defined MEMP_OVERFLOW_CHECK || defined __DOXYGEN__
+#define MEMP_OVERFLOW_CHECK             0
+#endif
+
+/**
+ * MEMP_SANITY_CHECK==1: run a sanity check after each memp_free() to make
+ * sure that there are no cycles in the linked lists.
+ */
+#if !defined MEMP_SANITY_CHECK || defined __DOXYGEN__
+#define MEMP_SANITY_CHECK               0
+#endif
+
+/**
+ * MEM_USE_POOLS==1: Use an alternative to malloc() by allocating from a set
+ * of memory pools of various sizes. When mem_malloc is called, an element of
+ * the smallest pool that can provide the length needed is returned.
+ * To use this, MEMP_USE_CUSTOM_POOLS also has to be enabled.
+ */
+#if !defined MEM_USE_POOLS || defined __DOXYGEN__
+#define MEM_USE_POOLS                   0
+#endif
+
+/**
+ * MEM_USE_POOLS_TRY_BIGGER_POOL==1: if one malloc-pool is empty, try the next
+ * bigger pool - WARNING: THIS MIGHT WASTE MEMORY but it can make a system more
+ * reliable. */
+#if !defined MEM_USE_POOLS_TRY_BIGGER_POOL || defined __DOXYGEN__
+#define MEM_USE_POOLS_TRY_BIGGER_POOL   0
+#endif
+
+/**
+ * MEMP_USE_CUSTOM_POOLS==1: whether to include a user file lwippools.h
+ * that defines additional pools beyond the "standard" ones required
+ * by lwIP. If you set this to 1, you must have lwippools.h in your
+ * include path somewhere.
+ */
+#if !defined MEMP_USE_CUSTOM_POOLS || defined __DOXYGEN__
+#define MEMP_USE_CUSTOM_POOLS           0
+#endif
+
+/**
+ * Set this to 1 if you want to free PBUF_RAM pbufs (or call mem_free()) from
+ * interrupt context (or another context that doesn't allow waiting for a
+ * semaphore).
+ * If set to 1, mem_malloc will be protected by a semaphore and SYS_ARCH_PROTECT,
+ * while mem_free will only use SYS_ARCH_PROTECT. mem_malloc SYS_ARCH_UNPROTECTs
+ * with each loop so that mem_free can run.
+ *
+ * ATTENTION: As you can see from the above description, this leads to dis-/
+ * enabling interrupts often, which can be slow! Also, on low memory, mem_malloc
+ * can need longer.
+ *
+ * If you don't want that, at least for NO_SYS=0, you can still use the following
+ * functions to enqueue a deallocation call which then runs in the tcpip_thread
+ * context:
+ * - pbuf_free_callback(p);
+ * - mem_free_callback(m);
+ */
+#if !defined LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT || defined __DOXYGEN__
+#define LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT 0
+#endif
+/**
+ * @}
+ */
+
+/*
+   ------------------------------------------------
+   ---------- Internal Memory Pool Sizes ----------
+   ------------------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_memp Internal memory pools
+ * @ingroup lwip_opts_infrastructure
+ * @{
+ */
+/**
+ * MEMP_NUM_PBUF: the number of memp struct pbufs (used for PBUF_ROM and PBUF_REF).
+ * If the application sends a lot of data out of ROM (or other static memory),
+ * this should be set high.
+ */
+#if !defined MEMP_NUM_PBUF || defined __DOXYGEN__
+#define MEMP_NUM_PBUF                   16
+#endif
+
+/**
+ * MEMP_NUM_RAW_PCB: Number of raw connection PCBs
+ * (requires the LWIP_RAW option)
+ */
+#if !defined MEMP_NUM_RAW_PCB || defined __DOXYGEN__
+#define MEMP_NUM_RAW_PCB                4
+#endif
+
+/**
+ * MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
+ * per active UDP "connection".
+ * (requires the LWIP_UDP option)
+ */
+#if !defined MEMP_NUM_UDP_PCB || defined __DOXYGEN__
+#define MEMP_NUM_UDP_PCB                4
+#endif
+
+/**
+ * MEMP_NUM_TCP_PCB: the number of simultaneously active TCP connections.
+ * (requires the LWIP_TCP option)
+ */
+#if !defined MEMP_NUM_TCP_PCB || defined __DOXYGEN__
+#define MEMP_NUM_TCP_PCB                5
+#endif
+
+/**
+ * MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP connections.
+ * (requires the LWIP_TCP option)
+ */
+#if !defined MEMP_NUM_TCP_PCB_LISTEN || defined __DOXYGEN__
+#define MEMP_NUM_TCP_PCB_LISTEN         8
+#endif
+
+/**
+ * MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP segments.
+ * (requires the LWIP_TCP option)
+ */
+#if !defined MEMP_NUM_TCP_SEG || defined __DOXYGEN__
+#define MEMP_NUM_TCP_SEG                16
+#endif
+
+/**
+ * MEMP_NUM_REASSDATA: the number of IP packets simultaneously queued for
+ * reassembly (whole packets, not fragments!)
+ */
+#if !defined MEMP_NUM_REASSDATA || defined __DOXYGEN__
+#define MEMP_NUM_REASSDATA              5
+#endif
+
+/**
+ * MEMP_NUM_FRAG_PBUF: the number of IP fragments simultaneously sent
+ * (fragments, not whole packets!).
+ * This is only used with LWIP_NETIF_TX_SINGLE_PBUF==0 and only has to be > 1
+ * with DMA-enabled MACs where the packet is not yet sent when netif->output
+ * returns.
+ */
+#if !defined MEMP_NUM_FRAG_PBUF || defined __DOXYGEN__
+#define MEMP_NUM_FRAG_PBUF              15
+#endif
+
+/**
+ * MEMP_NUM_ARP_QUEUE: the number of simultaneously queued outgoing
+ * packets (pbufs) that are waiting for an ARP request (to resolve
+ * their destination address) to finish.
+ * (requires the ARP_QUEUEING option)
+ */
+#if !defined MEMP_NUM_ARP_QUEUE || defined __DOXYGEN__
+#define MEMP_NUM_ARP_QUEUE              30
+#endif
+
+/**
+ * MEMP_NUM_IGMP_GROUP: The number of multicast groups whose network interfaces
+ * can be members at the same time (one per netif - allsystems group -, plus one
+ * per netif membership).
+ * (requires the LWIP_IGMP option)
+ */
+#if !defined MEMP_NUM_IGMP_GROUP || defined __DOXYGEN__
+#define MEMP_NUM_IGMP_GROUP             8
+#endif
+
+/**
+ * MEMP_NUM_SYS_TIMEOUT: the number of simultaneously active timeouts.
+ * The default number of timeouts is calculated here for all enabled modules.
+ * The formula expects settings to be either '0' or '1'.
+ */
+#if !defined MEMP_NUM_SYS_TIMEOUT || defined __DOXYGEN__
+#define MEMP_NUM_SYS_TIMEOUT            (LWIP_TCP + IP_REASSEMBLY + LWIP_ARP + (2*LWIP_DHCP) + LWIP_AUTOIP + LWIP_IGMP + LWIP_DNS + (PPP_SUPPORT*6*MEMP_NUM_PPP_PCB) + (LWIP_IPV6 ? (1 + LWIP_IPV6_REASS + LWIP_IPV6_MLD) : 0))
+#endif
+
+/**
+ * MEMP_NUM_NETBUF: the number of struct netbufs.
+ * (only needed if you use the sequential API, like api_lib.c)
+ */
+#if !defined MEMP_NUM_NETBUF || defined __DOXYGEN__
+#define MEMP_NUM_NETBUF                 2
+#endif
+
+/**
+ * MEMP_NUM_NETCONN: the number of struct netconns.
+ * (only needed if you use the sequential API, like api_lib.c)
+ */
+#if !defined MEMP_NUM_NETCONN || defined __DOXYGEN__
+#define MEMP_NUM_NETCONN                4
+#endif
+
+/**
+ * MEMP_NUM_TCPIP_MSG_API: the number of struct tcpip_msg, which are used
+ * for callback/timeout API communication.
+ * (only needed if you use tcpip.c)
+ */
+#if !defined MEMP_NUM_TCPIP_MSG_API || defined __DOXYGEN__
+#define MEMP_NUM_TCPIP_MSG_API          8
+#endif
+
+/**
+ * MEMP_NUM_TCPIP_MSG_INPKT: the number of struct tcpip_msg, which are used
+ * for incoming packets.
+ * (only needed if you use tcpip.c)
+ */
+#if !defined MEMP_NUM_TCPIP_MSG_INPKT || defined __DOXYGEN__
+#define MEMP_NUM_TCPIP_MSG_INPKT        8
+#endif
+
+/**
+ * MEMP_NUM_NETDB: the number of concurrently running lwip_addrinfo() calls
+ * (before freeing the corresponding memory using lwip_freeaddrinfo()).
+ */
+#if !defined MEMP_NUM_NETDB || defined __DOXYGEN__
+#define MEMP_NUM_NETDB                  1
+#endif
+
+/**
+ * MEMP_NUM_LOCALHOSTLIST: the number of host entries in the local host list
+ * if DNS_LOCAL_HOSTLIST_IS_DYNAMIC==1.
+ */
+#if !defined MEMP_NUM_LOCALHOSTLIST || defined __DOXYGEN__
+#define MEMP_NUM_LOCALHOSTLIST          1
+#endif
+
+/**
+ * PBUF_POOL_SIZE: the number of buffers in the pbuf pool.
+ */
+#if !defined PBUF_POOL_SIZE || defined __DOXYGEN__
+#define PBUF_POOL_SIZE                  16
+#endif
+
+/** MEMP_NUM_API_MSG: the number of concurrently active calls to various
+ * socket, netconn, and tcpip functions
+ */
+#if !defined MEMP_NUM_API_MSG || defined __DOXYGEN__
+#define MEMP_NUM_API_MSG                MEMP_NUM_TCPIP_MSG_API
+#endif
+
+/** MEMP_NUM_DNS_API_MSG: the number of concurrently active calls to netconn_gethostbyname
+ */
+#if !defined MEMP_NUM_DNS_API_MSG || defined __DOXYGEN__
+#define MEMP_NUM_DNS_API_MSG            MEMP_NUM_TCPIP_MSG_API
+#endif
+
+/** MEMP_NUM_SOCKET_SETGETSOCKOPT_DATA: the number of concurrently active calls
+ * to getsockopt/setsockopt
+ */
+#if !defined MEMP_NUM_SOCKET_SETGETSOCKOPT_DATA || defined __DOXYGEN__
+#define MEMP_NUM_SOCKET_SETGETSOCKOPT_DATA MEMP_NUM_TCPIP_MSG_API
+#endif
+
+/** MEMP_NUM_NETIFAPI_MSG: the number of concurrently active calls to the
+ * netifapi functions
+ */
+#if !defined MEMP_NUM_NETIFAPI_MSG || defined __DOXYGEN__
+#define MEMP_NUM_NETIFAPI_MSG           MEMP_NUM_TCPIP_MSG_API
+#endif
+/**
+ * @}
+ */
+
+/*
+   ---------------------------------
+   ---------- ARP options ----------
+   ---------------------------------
+*/
+/**
+ * @defgroup lwip_opts_arp ARP
+ * @ingroup lwip_opts_ipv4
+ * @{
+ */
+/**
+ * LWIP_ARP==1: Enable ARP functionality.
+ */
+#if !defined LWIP_ARP || defined __DOXYGEN__
+#define LWIP_ARP                        1
+#endif
+
+/**
+ * ARP_TABLE_SIZE: Number of active MAC-IP address pairs cached.
+ */
+#if !defined ARP_TABLE_SIZE || defined __DOXYGEN__
+#define ARP_TABLE_SIZE                  10
+#endif
+
+/** the time an ARP entry stays valid after its last update,
+ *  for ARP_TMR_INTERVAL = 1000, this is
+ *  (60 * 5) seconds = 5 minutes.
+ */
+#if !defined ARP_MAXAGE || defined __DOXYGEN__
+#define ARP_MAXAGE                      300
+#endif
+
+/**
+ * ARP_QUEUEING==1: Multiple outgoing packets are queued during hardware address
+ * resolution. By default, only the most recent packet is queued per IP address.
+ * This is sufficient for most protocols and mainly reduces TCP connection
+ * startup time. Set this to 1 if you know your application sends more than one
+ * packet in a row to an IP address that is not in the ARP cache.
+ */
+#if !defined ARP_QUEUEING || defined __DOXYGEN__
+#define ARP_QUEUEING                    0
+#endif
+
+/** The maximum number of packets which may be queued for each
+ *  unresolved address by other network layers. Defaults to 3, 0 means disabled.
+ *  Old packets are dropped, new packets are queued.
+ */
+#if !defined ARP_QUEUE_LEN || defined __DOXYGEN__
+#define ARP_QUEUE_LEN                   3
+#endif
+
+/**
+ * ETHARP_SUPPORT_VLAN==1: support receiving and sending ethernet packets with
+ * VLAN header. See the description of LWIP_HOOK_VLAN_CHECK and
+ * LWIP_HOOK_VLAN_SET hooks to check/set VLAN headers.
+ * Additionally, you can define ETHARP_VLAN_CHECK to an u16_t VLAN ID to check.
+ * If ETHARP_VLAN_CHECK is defined, only VLAN-traffic for this VLAN is accepted.
+ * If ETHARP_VLAN_CHECK is not defined, all traffic is accepted.
+ * Alternatively, define a function/define ETHARP_VLAN_CHECK_FN(eth_hdr, vlan)
+ * that returns 1 to accept a packet or 0 to drop a packet.
+ */
+#if !defined ETHARP_SUPPORT_VLAN || defined __DOXYGEN__
+#define ETHARP_SUPPORT_VLAN             0
+#endif
+
+/** LWIP_ETHERNET==1: enable ethernet support even though ARP might be disabled
+ */
+#if !defined LWIP_ETHERNET || defined __DOXYGEN__
+#define LWIP_ETHERNET                   LWIP_ARP
+#endif
+
+/** ETH_PAD_SIZE: number of bytes added before the ethernet header to ensure
+ * alignment of payload after that header. Since the header is 14 bytes long,
+ * without this padding e.g. addresses in the IP header will not be aligned
+ * on a 32-bit boundary, so setting this to 2 can speed up 32-bit-platforms.
+ */
+#if !defined ETH_PAD_SIZE || defined __DOXYGEN__
+#define ETH_PAD_SIZE                    0
+#endif
+
+/** ETHARP_SUPPORT_STATIC_ENTRIES==1: enable code to support static ARP table
+ * entries (using etharp_add_static_entry/etharp_remove_static_entry).
+ */
+#if !defined ETHARP_SUPPORT_STATIC_ENTRIES || defined __DOXYGEN__
+#define ETHARP_SUPPORT_STATIC_ENTRIES   0
+#endif
+
+/** ETHARP_TABLE_MATCH_NETIF==1: Match netif for ARP table entries.
+ * If disabled, duplicate IP address on multiple netifs are not supported
+ * (but this should only occur for AutoIP).
+ */
+#if !defined ETHARP_TABLE_MATCH_NETIF || defined __DOXYGEN__
+#define ETHARP_TABLE_MATCH_NETIF        0
+#endif
+/**
+ * @}
+ */
+
+/*
+   --------------------------------
+   ---------- IP options ----------
+   --------------------------------
+*/
+/**
+ * @defgroup lwip_opts_ipv4 IPv4
+ * @ingroup lwip_opts
+ * @{
+ */
+/**
+ * LWIP_IPV4==1: Enable IPv4
+ */
+#if !defined LWIP_IPV4 || defined __DOXYGEN__
+#define LWIP_IPV4                       1
+#endif
+
+/**
+ * IP_FORWARD==1: Enables the ability to forward IP packets across network
+ * interfaces. If you are going to run lwIP on a device with only one network
+ * interface, define this to 0.
+ */
+#if !defined IP_FORWARD || defined __DOXYGEN__
+#define IP_FORWARD                      0
+#endif
+
+/**
+ * IP_REASSEMBLY==1: Reassemble incoming fragmented IP packets. Note that
+ * this option does not affect outgoing packet sizes, which can be controlled
+ * via IP_FRAG.
+ */
+#if !defined IP_REASSEMBLY || defined __DOXYGEN__
+#define IP_REASSEMBLY                   1
+#endif
+
+/**
+ * IP_FRAG==1: Fragment outgoing IP packets if their size exceeds MTU. Note
+ * that this option does not affect incoming packet sizes, which can be
+ * controlled via IP_REASSEMBLY.
+ */
+#if !defined IP_FRAG || defined __DOXYGEN__
+#define IP_FRAG                         1
+#endif
+
+#if !LWIP_IPV4
+/* disable IPv4 extensions when IPv4 is disabled */
+#undef IP_FORWARD
+#define IP_FORWARD                      0
+#undef IP_REASSEMBLY
+#define IP_REASSEMBLY                   0
+#undef IP_FRAG
+#define IP_FRAG                         0
+#endif /* !LWIP_IPV4 */
+
+/**
+ * IP_OPTIONS_ALLOWED: Defines the behavior for IP options.
+ *      IP_OPTIONS_ALLOWED==0: All packets with IP options are dropped.
+ *      IP_OPTIONS_ALLOWED==1: IP options are allowed (but not parsed).
+ */
+#if !defined IP_OPTIONS_ALLOWED || defined __DOXYGEN__
+#define IP_OPTIONS_ALLOWED              1
+#endif
+
+/**
+ * IP_REASS_MAXAGE: Maximum time (in multiples of IP_TMR_INTERVAL - so seconds, normally)
+ * a fragmented IP packet waits for all fragments to arrive. If not all fragments arrived
+ * in this time, the whole packet is discarded.
+ */
+#if !defined IP_REASS_MAXAGE || defined __DOXYGEN__
+#define IP_REASS_MAXAGE                 3
+#endif
+
+/**
+ * IP_REASS_MAX_PBUFS: Total maximum amount of pbufs waiting to be reassembled.
+ * Since the received pbufs are enqueued, be sure to configure
+ * PBUF_POOL_SIZE > IP_REASS_MAX_PBUFS so that the stack is still able to receive
+ * packets even if the maximum amount of fragments is enqueued for reassembly!
+ */
+#if !defined IP_REASS_MAX_PBUFS || defined __DOXYGEN__
+#define IP_REASS_MAX_PBUFS              10
+#endif
+
+/**
+ * IP_DEFAULT_TTL: Default value for Time-To-Live used by transport layers.
+ */
+#if !defined IP_DEFAULT_TTL || defined __DOXYGEN__
+#define IP_DEFAULT_TTL                  255
+#endif
+
+/**
+ * IP_SOF_BROADCAST=1: Use the SOF_BROADCAST field to enable broadcast
+ * filter per pcb on udp and raw send operations. To enable broadcast filter
+ * on recv operations, you also have to set IP_SOF_BROADCAST_RECV=1.
+ */
+#if !defined IP_SOF_BROADCAST || defined __DOXYGEN__
+#define IP_SOF_BROADCAST                0
+#endif
+
+/**
+ * IP_SOF_BROADCAST_RECV (requires IP_SOF_BROADCAST=1) enable the broadcast
+ * filter on recv operations.
+ */
+#if !defined IP_SOF_BROADCAST_RECV || defined __DOXYGEN__
+#define IP_SOF_BROADCAST_RECV           0
+#endif
+
+/**
+ * IP_FORWARD_ALLOW_TX_ON_RX_NETIF==1: allow ip_forward() to send packets back
+ * out on the netif where it was received. This should only be used for
+ * wireless networks.
+ * ATTENTION: When this is 1, make sure your netif driver correctly marks incoming
+ * link-layer-broadcast/multicast packets as such using the corresponding pbuf flags!
+ */
+#if !defined IP_FORWARD_ALLOW_TX_ON_RX_NETIF || defined __DOXYGEN__
+#define IP_FORWARD_ALLOW_TX_ON_RX_NETIF 0
+#endif
+
+/**
+ * LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS==1: randomize the local port for the first
+ * local TCP/UDP pcb (default==0). This can prevent creating predictable port
+ * numbers after booting a device.
+ */
+#if !defined LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS || defined __DOXYGEN__
+#define LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS 0
+#endif
+/**
+ * @}
+ */
+
+/*
+   ----------------------------------
+   ---------- ICMP options ----------
+   ----------------------------------
+*/
+/**
+ * @defgroup lwip_opts_icmp ICMP
+ * @ingroup lwip_opts_ipv4
+ * @{
+ */
+/**
+ * LWIP_ICMP==1: Enable ICMP module inside the IP stack.
+ * Be careful, disable that make your product non-compliant to RFC1122
+ */
+#if !defined LWIP_ICMP || defined __DOXYGEN__
+#define LWIP_ICMP                       1
+#endif
+
+/**
+ * ICMP_TTL: Default value for Time-To-Live used by ICMP packets.
+ */
+#if !defined ICMP_TTL || defined __DOXYGEN__
+#define ICMP_TTL                       (IP_DEFAULT_TTL)
+#endif
+
+/**
+ * LWIP_BROADCAST_PING==1: respond to broadcast pings (default is unicast only)
+ */
+#if !defined LWIP_BROADCAST_PING || defined __DOXYGEN__
+#define LWIP_BROADCAST_PING             0
+#endif
+
+/**
+ * LWIP_MULTICAST_PING==1: respond to multicast pings (default is unicast only)
+ */
+#if !defined LWIP_MULTICAST_PING || defined __DOXYGEN__
+#define LWIP_MULTICAST_PING             0
+#endif
+/**
+ * @}
+ */
+
+/*
+   ---------------------------------
+   ---------- RAW options ----------
+   ---------------------------------
+*/
+/**
+ * @defgroup lwip_opts_raw RAW
+ * @ingroup lwip_opts_callback
+ * @{
+ */
+/**
+ * LWIP_RAW==1: Enable application layer to hook into the IP layer itself.
+ */
+#if !defined LWIP_RAW || defined __DOXYGEN__
+#define LWIP_RAW                        0
+#endif
+
+/**
+ * LWIP_RAW==1: Enable application layer to hook into the IP layer itself.
+ */
+#if !defined RAW_TTL || defined __DOXYGEN__
+#define RAW_TTL                        (IP_DEFAULT_TTL)
+#endif
+/**
+ * @}
+ */
+
+/*
+   ----------------------------------
+   ---------- DHCP options ----------
+   ----------------------------------
+*/
+/**
+ * @defgroup lwip_opts_dhcp DHCP
+ * @ingroup lwip_opts_ipv4
+ * @{
+ */
+/**
+ * LWIP_DHCP==1: Enable DHCP module.
+ */
+#if !defined LWIP_DHCP || defined __DOXYGEN__
+#define LWIP_DHCP                       0
+#endif
+#if !LWIP_IPV4
+/* disable DHCP when IPv4 is disabled */
+#undef LWIP_DHCP
+#define LWIP_DHCP                       0
+#endif /* !LWIP_IPV4 */
+
+/**
+ * DHCP_DOES_ARP_CHECK==1: Do an ARP check on the offered address.
+ */
+#if !defined DHCP_DOES_ARP_CHECK || defined __DOXYGEN__
+#define DHCP_DOES_ARP_CHECK             ((LWIP_DHCP) && (LWIP_ARP))
+#endif
+
+/**
+ * LWIP_DHCP_CHECK_LINK_UP==1: dhcp_start() only really starts if the netif has
+ * NETIF_FLAG_LINK_UP set in its flags. As this is only an optimization and
+ * netif drivers might not set this flag, the default is off. If enabled,
+ * netif_set_link_up() must be called to continue dhcp starting.
+ */
+#if !defined LWIP_DHCP_CHECK_LINK_UP
+#define LWIP_DHCP_CHECK_LINK_UP         0
+#endif
+
+/**
+ * LWIP_DHCP_BOOTP_FILE==1: Store offered_si_addr and boot_file_name.
+ */
+#if !defined LWIP_DHCP_BOOTP_FILE || defined __DOXYGEN__
+#define LWIP_DHCP_BOOTP_FILE            0
+#endif
+
+/**
+ * LWIP_DHCP_GETS_NTP==1: Request NTP servers with discover/select. For each
+ * response packet, an callback is called, which has to be provided by the port:
+ * void dhcp_set_ntp_servers(u8_t num_ntp_servers, ip_addr_t* ntp_server_addrs);
+*/
+#if !defined LWIP_DHCP_GET_NTP_SRV || defined __DOXYGEN__
+#define LWIP_DHCP_GET_NTP_SRV           0
+#endif
+
+/**
+ * The maximum of NTP servers requested
+ */
+#if !defined LWIP_DHCP_MAX_NTP_SERVERS || defined __DOXYGEN__
+#define LWIP_DHCP_MAX_NTP_SERVERS       1
+#endif
+
+/**
+ * LWIP_DHCP_MAX_DNS_SERVERS > 0: Request DNS servers with discover/select.
+ * DHCP servers received in the response are passed to DNS via @ref dns_setserver()
+ * (up to the maximum limit defined here).
+ */
+#if !defined LWIP_DHCP_MAX_DNS_SERVERS || defined __DOXYGEN__
+#define LWIP_DHCP_MAX_DNS_SERVERS       DNS_MAX_SERVERS
+#endif
+/**
+ * @}
+ */
+
+/*
+   ------------------------------------
+   ---------- AUTOIP options ----------
+   ------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_autoip AUTOIP
+ * @ingroup lwip_opts_ipv4
+ * @{
+ */
+/**
+ * LWIP_AUTOIP==1: Enable AUTOIP module.
+ */
+#if !defined LWIP_AUTOIP || defined __DOXYGEN__
+#define LWIP_AUTOIP                     0
+#endif
+#if !LWIP_IPV4
+/* disable AUTOIP when IPv4 is disabled */
+#undef LWIP_AUTOIP
+#define LWIP_AUTOIP                     0
+#endif /* !LWIP_IPV4 */
+
+/**
+ * LWIP_DHCP_AUTOIP_COOP==1: Allow DHCP and AUTOIP to be both enabled on
+ * the same interface at the same time.
+ */
+#if !defined LWIP_DHCP_AUTOIP_COOP || defined __DOXYGEN__
+#define LWIP_DHCP_AUTOIP_COOP           0
+#endif
+
+/**
+ * LWIP_DHCP_AUTOIP_COOP_TRIES: Set to the number of DHCP DISCOVER probes
+ * that should be sent before falling back on AUTOIP (the DHCP client keeps
+ * running in this case). This can be set as low as 1 to get an AutoIP address
+ * very  quickly, but you should be prepared to handle a changing IP address
+ * when DHCP overrides AutoIP.
+ */
+#if !defined LWIP_DHCP_AUTOIP_COOP_TRIES || defined __DOXYGEN__
+#define LWIP_DHCP_AUTOIP_COOP_TRIES     9
+#endif
+/**
+ * @}
+ */
+
+/*
+   ----------------------------------
+   ----- SNMP MIB2 support      -----
+   ----------------------------------
+*/
+/**
+ * @defgroup lwip_opts_mib2 SNMP MIB2 callbacks
+ * @ingroup lwip_opts_infrastructure
+ * @{
+ */
+/**
+ * LWIP_MIB2_CALLBACKS==1: Turn on SNMP MIB2 callbacks.
+ * Turn this on to get callbacks needed to implement MIB2.
+ * Usually MIB2_STATS should be enabled, too.
+ */
+#if !defined LWIP_MIB2_CALLBACKS || defined __DOXYGEN__
+#define LWIP_MIB2_CALLBACKS             0
+#endif
+/**
+ * @}
+ */
+
+/*
+   ----------------------------------
+   -------- Multicast options -------
+   ----------------------------------
+*/
+/**
+ * @defgroup lwip_opts_multicast Multicast
+ * @ingroup lwip_opts_infrastructure
+ * @{
+ */
+/**
+ * LWIP_MULTICAST_TX_OPTIONS==1: Enable multicast TX support like the socket options
+ * IP_MULTICAST_TTL/IP_MULTICAST_IF/IP_MULTICAST_LOOP, as well as (currently only)
+ * core support for the corresponding IPv6 options.
+ */
+#if !defined LWIP_MULTICAST_TX_OPTIONS || defined __DOXYGEN__
+#define LWIP_MULTICAST_TX_OPTIONS       ((LWIP_IGMP || LWIP_IPV6_MLD) && (LWIP_UDP || LWIP_RAW))
+#endif
+/**
+ * @}
+ */
+
+/*
+   ----------------------------------
+   ---------- IGMP options ----------
+   ----------------------------------
+*/
+/**
+ * @defgroup lwip_opts_igmp IGMP
+ * @ingroup lwip_opts_ipv4
+ * @{
+ */
+/**
+ * LWIP_IGMP==1: Turn on IGMP module.
+ */
+#if !defined LWIP_IGMP || defined __DOXYGEN__
+#define LWIP_IGMP                       0
+#endif
+#if !LWIP_IPV4
+#undef LWIP_IGMP
+#define LWIP_IGMP                       0
+#endif
+/**
+ * @}
+ */
+
+/*
+   ----------------------------------
+   ---------- DNS options -----------
+   ----------------------------------
+*/
+/**
+ * @defgroup lwip_opts_dns DNS
+ * @ingroup lwip_opts_callback
+ * @{
+ */
+/**
+ * LWIP_DNS==1: Turn on DNS module. UDP must be available for DNS
+ * transport.
+ */
+#if !defined LWIP_DNS || defined __DOXYGEN__
+#define LWIP_DNS                        0
+#endif
+
+/**
+ * LWIP_DNS_RAND_ID==1: Runs on the fix for CVE-2014-4883
+ * Randomizes the id of dns requests.
+ * This should be on for security purposes
+ */
+#ifndef LWIP_DNS_RAND_ID
+#define LWIP_DNS_RAND_ID                1
+#endif
+
+/** DNS maximum number of entries to maintain locally. */
+#if !defined DNS_TABLE_SIZE || defined __DOXYGEN__
+#define DNS_TABLE_SIZE                  4
+#endif
+
+/** DNS maximum host name length supported in the name table. */
+#if !defined DNS_MAX_NAME_LENGTH || defined __DOXYGEN__
+#define DNS_MAX_NAME_LENGTH             256
+#endif
+
+/** The maximum of DNS servers
+ * The first server can be initialized automatically by defining
+ * DNS_SERVER_ADDRESS(ipaddr), where 'ipaddr' is an 'ip_addr_t*'
+ */
+#if !defined DNS_MAX_SERVERS || defined __DOXYGEN__
+#define DNS_MAX_SERVERS                 2
+#endif
+
+/** DNS do a name checking between the query and the response. */
+#if !defined DNS_DOES_NAME_CHECK || defined __DOXYGEN__
+#define DNS_DOES_NAME_CHECK             1
+#endif
+
+/** LWIP_DNS_SECURE: controls the security level of the DNS implementation
+ * Use all DNS security features by default.
+ * This is overridable but should only be needed by very small targets
+ * or when using against non standard DNS servers. */
+#if !defined LWIP_DNS_SECURE || defined __DOXYGEN__
+#define LWIP_DNS_SECURE (LWIP_DNS_SECURE_RAND_XID | LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING | LWIP_DNS_SECURE_RAND_SRC_PORT)
+#endif
+
+/* A list of DNS security features follows */
+#define LWIP_DNS_SECURE_RAND_XID                1
+#define LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING 2
+#define LWIP_DNS_SECURE_RAND_SRC_PORT           4
+
+/** DNS_LOCAL_HOSTLIST: Implements a local host-to-address list. If enabled, you have to define an initializer:
+ *  \#define DNS_LOCAL_HOSTLIST_INIT {DNS_LOCAL_HOSTLIST_ELEM("host_ip4", IPADDR4_INIT_BYTES(1,2,3,4)), \
+ *                                    DNS_LOCAL_HOSTLIST_ELEM("host_ip6", IPADDR6_INIT_HOST(123, 234, 345, 456)}
+ *
+ *  Instead, you can also use an external function:
+ *  \#define DNS_LOOKUP_LOCAL_EXTERN(x) extern err_t my_lookup_function(const char *name, ip_addr_t *addr, u8_t dns_addrtype)
+ *  that looks up the IP address and returns ERR_OK if found (LWIP_DNS_ADDRTYPE_xxx is passed in dns_addrtype).
+ */
+#if !defined DNS_LOCAL_HOSTLIST || defined __DOXYGEN__
+#define DNS_LOCAL_HOSTLIST              0
+#endif /* DNS_LOCAL_HOSTLIST */
+
+/** If this is turned on, the local host-list can be dynamically changed
+ *  at runtime. */
+#if !defined DNS_LOCAL_HOSTLIST_IS_DYNAMIC || defined __DOXYGEN__
+#define DNS_LOCAL_HOSTLIST_IS_DYNAMIC   0
+#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
+
+/** Set this to 1 to enable querying ".local" names via mDNS
+ *  using a One-Shot Multicast DNS Query */
+#if !defined LWIP_DNS_SUPPORT_MDNS_QUERIES || defined __DOXYGEN__
+#define LWIP_DNS_SUPPORT_MDNS_QUERIES  0
+#endif
+
+/** DNS message max. size. Default value is RFC compliant. */
+#ifndef DNS_MSG_SIZE
+#define DNS_MSG_SIZE                    512
+#endif
+
+/** DNS maximum addresses per host name supported in the name table. */
+#if !defined DNS_MAX_ADDRS_PER_NAME || defined __DOXYGEN__
+#define DNS_MAX_ADDRS_PER_NAME          4
+#endif
+/**
+ * @}
+ */
+
+/*
+   ---------------------------------
+   ---------- UDP options ----------
+   ---------------------------------
+*/
+/**
+ * @defgroup lwip_opts_udp UDP
+ * @ingroup lwip_opts_callback
+ * @{
+ */
+/**
+ * LWIP_UDP==1: Turn on UDP.
+ */
+#if !defined LWIP_UDP || defined __DOXYGEN__
+#define LWIP_UDP                        1
+#endif
+
+/**
+ * LWIP_UDPLITE==1: Turn on UDP-Lite. (Requires LWIP_UDP)
+ */
+#if !defined LWIP_UDPLITE || defined __DOXYGEN__
+#define LWIP_UDPLITE                    0
+#endif
+
+/**
+ * UDP_TTL: Default Time-To-Live value.
+ */
+#if !defined UDP_TTL || defined __DOXYGEN__
+#define UDP_TTL                         (IP_DEFAULT_TTL)
+#endif
+
+/**
+ * LWIP_NETBUF_RECVINFO==1: append destination addr and port to every netbuf.
+ */
+#if !defined LWIP_NETBUF_RECVINFO || defined __DOXYGEN__
+#define LWIP_NETBUF_RECVINFO            0
+#endif
+/**
+ * @}
+ */
+
+/*
+   ---------------------------------
+   ---------- TCP options ----------
+   ---------------------------------
+*/
+/**
+ * @defgroup lwip_opts_tcp TCP
+ * @ingroup lwip_opts_callback
+ * @{
+ */
+/**
+ * LWIP_TCP==1: Turn on TCP.
+ */
+#if !defined LWIP_TCP || defined __DOXYGEN__
+#define LWIP_TCP                        1
+#endif
+
+/**
+ * TCP_TTL: Default Time-To-Live value.
+ */
+#if !defined TCP_TTL || defined __DOXYGEN__
+#define TCP_TTL                         (IP_DEFAULT_TTL)
+#endif
+
+/**
+ * TCP_WND: The size of a TCP window.  This must be at least
+ * (2 * TCP_MSS) for things to work well.
+ * ATTENTION: when using TCP_RCV_SCALE, TCP_WND is the total size
+ * with scaling applied. Maximum window value in the TCP header
+ * will be TCP_WND >> TCP_RCV_SCALE
+ */
+#if !defined TCP_WND || defined __DOXYGEN__
+#define TCP_WND                         (4 * TCP_MSS)
+#endif
+
+/**
+ * TCP_MAXRTX: Maximum number of retransmissions of data segments.
+ */
+#if !defined TCP_MAXRTX || defined __DOXYGEN__
+#define TCP_MAXRTX                      12
+#endif
+
+/**
+ * TCP_SYNMAXRTX: Maximum number of retransmissions of SYN segments.
+ */
+#if !defined TCP_SYNMAXRTX || defined __DOXYGEN__
+#define TCP_SYNMAXRTX                   6
+#endif
+
+/**
+ * TCP_QUEUE_OOSEQ==1: TCP will queue segments that arrive out of order.
+ * Define to 0 if your device is low on memory.
+ */
+#if !defined TCP_QUEUE_OOSEQ || defined __DOXYGEN__
+#define TCP_QUEUE_OOSEQ                 (LWIP_TCP)
+#endif
+
+/**
+ * TCP_MSS: TCP Maximum segment size. (default is 536, a conservative default,
+ * you might want to increase this.)
+ * For the receive side, this MSS is advertised to the remote side
+ * when opening a connection. For the transmit size, this MSS sets
+ * an upper limit on the MSS advertised by the remote host.
+ */
+#if !defined TCP_MSS || defined __DOXYGEN__
+#define TCP_MSS                         536
+#endif
+
+/**
+ * TCP_CALCULATE_EFF_SEND_MSS: "The maximum size of a segment that TCP really
+ * sends, the 'effective send MSS,' MUST be the smaller of the send MSS (which
+ * reflects the available reassembly buffer size at the remote host) and the
+ * largest size permitted by the IP layer" (RFC 1122)
+ * Setting this to 1 enables code that checks TCP_MSS against the MTU of the
+ * netif used for a connection and limits the MSS if it would be too big otherwise.
+ */
+#if !defined TCP_CALCULATE_EFF_SEND_MSS || defined __DOXYGEN__
+#define TCP_CALCULATE_EFF_SEND_MSS      1
+#endif
+
+
+/**
+ * TCP_SND_BUF: TCP sender buffer space (bytes).
+ * To achieve good performance, this should be at least 2 * TCP_MSS.
+ */
+#if !defined TCP_SND_BUF || defined __DOXYGEN__
+#define TCP_SND_BUF                     (2 * TCP_MSS)
+#endif
+
+/**
+ * TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least
+ * as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work.
+ */
+#if !defined TCP_SND_QUEUELEN || defined __DOXYGEN__
+#define TCP_SND_QUEUELEN                ((4 * (TCP_SND_BUF) + (TCP_MSS - 1))/(TCP_MSS))
+#endif
+
+/**
+ * TCP_SNDLOWAT: TCP writable space (bytes). This must be less than
+ * TCP_SND_BUF. It is the amount of space which must be available in the
+ * TCP snd_buf for select to return writable (combined with TCP_SNDQUEUELOWAT).
+ */
+#if !defined TCP_SNDLOWAT || defined __DOXYGEN__
+#define TCP_SNDLOWAT                    LWIP_MIN(LWIP_MAX(((TCP_SND_BUF)/2), (2 * TCP_MSS) + 1), (TCP_SND_BUF) - 1)
+#endif
+
+/**
+ * TCP_SNDQUEUELOWAT: TCP writable bufs (pbuf count). This must be less
+ * than TCP_SND_QUEUELEN. If the number of pbufs queued on a pcb drops below
+ * this number, select returns writable (combined with TCP_SNDLOWAT).
+ */
+#if !defined TCP_SNDQUEUELOWAT || defined __DOXYGEN__
+#define TCP_SNDQUEUELOWAT               LWIP_MAX(((TCP_SND_QUEUELEN)/2), 5)
+#endif
+
+/**
+ * TCP_OOSEQ_MAX_BYTES: The maximum number of bytes queued on ooseq per pcb.
+ * Default is 0 (no limit). Only valid for TCP_QUEUE_OOSEQ==1.
+ */
+#if !defined TCP_OOSEQ_MAX_BYTES || defined __DOXYGEN__
+#define TCP_OOSEQ_MAX_BYTES             0
+#endif
+
+/**
+ * TCP_OOSEQ_MAX_PBUFS: The maximum number of pbufs queued on ooseq per pcb.
+ * Default is 0 (no limit). Only valid for TCP_QUEUE_OOSEQ==1.
+ */
+#if !defined TCP_OOSEQ_MAX_PBUFS || defined __DOXYGEN__
+#define TCP_OOSEQ_MAX_PBUFS             0
+#endif
+
+/**
+ * TCP_LISTEN_BACKLOG: Enable the backlog option for tcp listen pcb.
+ */
+#if !defined TCP_LISTEN_BACKLOG || defined __DOXYGEN__
+#define TCP_LISTEN_BACKLOG              0
+#endif
+
+/**
+ * The maximum allowed backlog for TCP listen netconns.
+ * This backlog is used unless another is explicitly specified.
+ * 0xff is the maximum (u8_t).
+ */
+#if !defined TCP_DEFAULT_LISTEN_BACKLOG || defined __DOXYGEN__
+#define TCP_DEFAULT_LISTEN_BACKLOG      0xff
+#endif
+
+/**
+ * TCP_OVERSIZE: The maximum number of bytes that tcp_write may
+ * allocate ahead of time in an attempt to create shorter pbuf chains
+ * for transmission. The meaningful range is 0 to TCP_MSS. Some
+ * suggested values are:
+ *
+ * 0:         Disable oversized allocation. Each tcp_write() allocates a new
+              pbuf (old behaviour).
+ * 1:         Allocate size-aligned pbufs with minimal excess. Use this if your
+ *            scatter-gather DMA requires aligned fragments.
+ * 128:       Limit the pbuf/memory overhead to 20%.
+ * TCP_MSS:   Try to create unfragmented TCP packets.
+ * TCP_MSS/4: Try to create 4 fragments or less per TCP packet.
+ */
+#if !defined TCP_OVERSIZE || defined __DOXYGEN__
+#define TCP_OVERSIZE                    TCP_MSS
+#endif
+
+/**
+ * LWIP_TCP_TIMESTAMPS==1: support the TCP timestamp option.
+ * The timestamp option is currently only used to help remote hosts, it is not
+ * really used locally. Therefore, it is only enabled when a TS option is
+ * received in the initial SYN packet from a remote host.
+ */
+#if !defined LWIP_TCP_TIMESTAMPS || defined __DOXYGEN__
+#define LWIP_TCP_TIMESTAMPS             0
+#endif
+
+/**
+ * TCP_WND_UPDATE_THRESHOLD: difference in window to trigger an
+ * explicit window update
+ */
+#if !defined TCP_WND_UPDATE_THRESHOLD || defined __DOXYGEN__
+#define TCP_WND_UPDATE_THRESHOLD   LWIP_MIN((TCP_WND / 4), (TCP_MSS * 4))
+#endif
+
+/**
+ * LWIP_EVENT_API and LWIP_CALLBACK_API: Only one of these should be set to 1.
+ *     LWIP_EVENT_API==1: The user defines lwip_tcp_event() to receive all
+ *         events (accept, sent, etc) that happen in the system.
+ *     LWIP_CALLBACK_API==1: The PCB callback function is called directly
+ *         for the event. This is the default.
+ */
+#if !defined(LWIP_EVENT_API) && !defined(LWIP_CALLBACK_API) || defined __DOXYGEN__
+#define LWIP_EVENT_API                  0
+#define LWIP_CALLBACK_API               1
+#else
+#ifndef LWIP_EVENT_API
+#define LWIP_EVENT_API                  0
+#endif
+#ifndef LWIP_CALLBACK_API
+#define LWIP_CALLBACK_API               0
+#endif
+#endif
+
+/**
+ * LWIP_WND_SCALE and TCP_RCV_SCALE:
+ * Set LWIP_WND_SCALE to 1 to enable window scaling.
+ * Set TCP_RCV_SCALE to the desired scaling factor (shift count in the
+ * range of [0..14]).
+ * When LWIP_WND_SCALE is enabled but TCP_RCV_SCALE is 0, we can use a large
+ * send window while having a small receive window only.
+ */
+#if !defined LWIP_WND_SCALE || defined __DOXYGEN__
+#define LWIP_WND_SCALE                  0
+#define TCP_RCV_SCALE                   0
+#endif
+/**
+ * @}
+ */
+
+/*
+   ----------------------------------
+   ---------- Pbuf options ----------
+   ----------------------------------
+*/
+/**
+ * @defgroup lwip_opts_pbuf PBUF
+ * @ingroup lwip_opts
+ * @{
+ */
+/**
+ * PBUF_LINK_HLEN: the number of bytes that should be allocated for a
+ * link level header. The default is 14, the standard value for
+ * Ethernet.
+ */
+#if !defined PBUF_LINK_HLEN || defined __DOXYGEN__
+#if defined LWIP_HOOK_VLAN_SET && !defined __DOXYGEN__
+#define PBUF_LINK_HLEN                  (18 + ETH_PAD_SIZE)
+#else /* LWIP_HOOK_VLAN_SET */
+#define PBUF_LINK_HLEN                  (14 + ETH_PAD_SIZE)
+#endif /* LWIP_HOOK_VLAN_SET */
+#endif
+
+/**
+ * PBUF_LINK_ENCAPSULATION_HLEN: the number of bytes that should be allocated
+ * for an additional encapsulation header before ethernet headers (e.g. 802.11)
+ */
+#if !defined PBUF_LINK_ENCAPSULATION_HLEN || defined __DOXYGEN__
+#define PBUF_LINK_ENCAPSULATION_HLEN    0u
+#endif
+
+/**
+ * PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. The default is
+ * designed to accommodate single full size TCP frame in one pbuf, including
+ * TCP_MSS, IP header, and link header.
+ */
+#if !defined PBUF_POOL_BUFSIZE || defined __DOXYGEN__
+#define PBUF_POOL_BUFSIZE               LWIP_MEM_ALIGN_SIZE(TCP_MSS+40+PBUF_LINK_ENCAPSULATION_HLEN+PBUF_LINK_HLEN)
+#endif
+/**
+ * @}
+ */
+
+/*
+   ------------------------------------------------
+   ---------- Network Interfaces options ----------
+   ------------------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_netif NETIF
+ * @ingroup lwip_opts
+ * @{
+ */
+/**
+ * LWIP_NETIF_HOSTNAME==1: use DHCP_OPTION_HOSTNAME with netif's hostname
+ * field.
+ */
+#if !defined LWIP_NETIF_HOSTNAME || defined __DOXYGEN__
+#define LWIP_NETIF_HOSTNAME             0
+#endif
+
+/**
+ * LWIP_NETIF_API==1: Support netif api (in netifapi.c)
+ */
+#if !defined LWIP_NETIF_API || defined __DOXYGEN__
+#define LWIP_NETIF_API                  0
+#endif
+
+/**
+ * LWIP_NETIF_STATUS_CALLBACK==1: Support a callback function whenever an interface
+ * changes its up/down status (i.e., due to DHCP IP acquisition)
+ */
+#if !defined LWIP_NETIF_STATUS_CALLBACK || defined __DOXYGEN__
+#define LWIP_NETIF_STATUS_CALLBACK      0
+#endif
+
+/**
+ * LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
+ * whenever the link changes (i.e., link down)
+ */
+#if !defined LWIP_NETIF_LINK_CALLBACK || defined __DOXYGEN__
+#define LWIP_NETIF_LINK_CALLBACK        0
+#endif
+
+/**
+ * LWIP_NETIF_REMOVE_CALLBACK==1: Support a callback function that is called
+ * when a netif has been removed
+ */
+#if !defined LWIP_NETIF_REMOVE_CALLBACK || defined __DOXYGEN__
+#define LWIP_NETIF_REMOVE_CALLBACK      0
+#endif
+
+/**
+ * LWIP_NETIF_HWADDRHINT==1: Cache link-layer-address hints (e.g. table
+ * indices) in struct netif. TCP and UDP can make use of this to prevent
+ * scanning the ARP table for every sent packet. While this is faster for big
+ * ARP tables or many concurrent connections, it might be counterproductive
+ * if you have a tiny ARP table or if there never are concurrent connections.
+ */
+#if !defined LWIP_NETIF_HWADDRHINT || defined __DOXYGEN__
+#define LWIP_NETIF_HWADDRHINT           0
+#endif
+
+/**
+ * LWIP_NETIF_TX_SINGLE_PBUF: if this is set to 1, lwIP tries to put all data
+ * to be sent into one single pbuf. This is for compatibility with DMA-enabled
+ * MACs that do not support scatter-gather.
+ * Beware that this might involve CPU-memcpy before transmitting that would not
+ * be needed without this flag! Use this only if you need to!
+ *
+ * @todo: TCP and IP-frag do not work with this, yet:
+ */
+#if !defined LWIP_NETIF_TX_SINGLE_PBUF || defined __DOXYGEN__
+#define LWIP_NETIF_TX_SINGLE_PBUF             0
+#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
+
+/**
+ * LWIP_NUM_NETIF_CLIENT_DATA: Number of clients that may store
+ * data in client_data member array of struct netif.
+ */
+#if !defined LWIP_NUM_NETIF_CLIENT_DATA || defined __DOXYGEN__
+#define LWIP_NUM_NETIF_CLIENT_DATA            0
+#endif
+/**
+ * @}
+ */
+
+#ifndef LWIP_MANAGEMENT_CHANNEL
+#define LWIP_MANAGEMENT_CHANNEL    0
+#endif
+
+/*
+   ------------------------------------
+   ---------- LOOPIF options ----------
+   ------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_loop Loopback interface
+ * @ingroup lwip_opts_netif
+ * @{
+ */
+/**
+ * LWIP_HAVE_LOOPIF==1: Support loop interface (127.0.0.1).
+ * This is only needed when no real netifs are available. If at least one other
+ * netif is available, loopback traffic uses this netif.
+ */
+#if !defined LWIP_HAVE_LOOPIF || defined __DOXYGEN__
+#define LWIP_HAVE_LOOPIF                LWIP_NETIF_LOOPBACK
+#endif
+
+/**
+ * LWIP_LOOPIF_MULTICAST==1: Support multicast/IGMP on loop interface (127.0.0.1).
+ */
+#if !defined LWIP_LOOPIF_MULTICAST || defined __DOXYGEN__
+#define LWIP_LOOPIF_MULTICAST               0
+#endif
+
+/**
+ * LWIP_NETIF_LOOPBACK==1: Support sending packets with a destination IP
+ * address equal to the netif IP address, looping them back up the stack.
+ */
+#if !defined LWIP_NETIF_LOOPBACK || defined __DOXYGEN__
+#define LWIP_NETIF_LOOPBACK             0
+#endif
+
+/**
+ * LWIP_LOOPBACK_MAX_PBUFS: Maximum number of pbufs on queue for loopback
+ * sending for each netif (0 = disabled)
+ */
+#if !defined LWIP_LOOPBACK_MAX_PBUFS || defined __DOXYGEN__
+#define LWIP_LOOPBACK_MAX_PBUFS         0
+#endif
+
+/**
+ * LWIP_NETIF_LOOPBACK_MULTITHREADING: Indicates whether threading is enabled in
+ * the system, as netifs must change how they behave depending on this setting
+ * for the LWIP_NETIF_LOOPBACK option to work.
+ * Setting this is needed to avoid reentering non-reentrant functions like
+ * tcp_input().
+ *    LWIP_NETIF_LOOPBACK_MULTITHREADING==1: Indicates that the user is using a
+ *       multithreaded environment like tcpip.c. In this case, netif->input()
+ *       is called directly.
+ *    LWIP_NETIF_LOOPBACK_MULTITHREADING==0: Indicates a polling (or NO_SYS) setup.
+ *       The packets are put on a list and netif_poll() must be called in
+ *       the main application loop.
+ */
+#if !defined LWIP_NETIF_LOOPBACK_MULTITHREADING || defined __DOXYGEN__
+#define LWIP_NETIF_LOOPBACK_MULTITHREADING    (!NO_SYS)
+#endif
+/**
+ * @}
+ */
+
+/*
+   ------------------------------------
+   ---------- Thread options ----------
+   ------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_thread Threading
+ * @ingroup lwip_opts_infrastructure
+ * @{
+ */
+/**
+ * TCPIP_THREAD_NAME: The name assigned to the main tcpip thread.
+ */
+#if !defined TCPIP_THREAD_NAME || defined __DOXYGEN__
+#define TCPIP_THREAD_NAME              "tcpip_thread"
+#endif
+
+/**
+ * TCPIP_THREAD_STACKSIZE: The stack size used by the main tcpip thread.
+ * The stack size value itself is platform-dependent, but is passed to
+ * sys_thread_new() when the thread is created.
+ */
+#if !defined TCPIP_THREAD_STACKSIZE || defined __DOXYGEN__
+#define TCPIP_THREAD_STACKSIZE          0
+#endif
+
+/**
+ * TCPIP_THREAD_PRIO: The priority assigned to the main tcpip thread.
+ * The priority value itself is platform-dependent, but is passed to
+ * sys_thread_new() when the thread is created.
+ */
+#if !defined TCPIP_THREAD_PRIO || defined __DOXYGEN__
+#define TCPIP_THREAD_PRIO               1
+#endif
+
+/**
+ * TCPIP_MBOX_SIZE: The mailbox size for the tcpip thread messages
+ * The queue size value itself is platform-dependent, but is passed to
+ * sys_mbox_new() when tcpip_init is called.
+ */
+#if !defined TCPIP_MBOX_SIZE || defined __DOXYGEN__
+#define TCPIP_MBOX_SIZE                 0
+#endif
+
+/**
+ * Define this to something that triggers a watchdog. This is called from
+ * tcpip_thread after processing a message.
+ */
+#if !defined LWIP_TCPIP_THREAD_ALIVE || defined __DOXYGEN__
+#define LWIP_TCPIP_THREAD_ALIVE()
+#endif
+
+/**
+ * SLIPIF_THREAD_NAME: The name assigned to the slipif_loop thread.
+ */
+#if !defined SLIPIF_THREAD_NAME || defined __DOXYGEN__
+#define SLIPIF_THREAD_NAME             "slipif_loop"
+#endif
+
+/**
+ * SLIP_THREAD_STACKSIZE: The stack size used by the slipif_loop thread.
+ * The stack size value itself is platform-dependent, but is passed to
+ * sys_thread_new() when the thread is created.
+ */
+#if !defined SLIPIF_THREAD_STACKSIZE || defined __DOXYGEN__
+#define SLIPIF_THREAD_STACKSIZE         0
+#endif
+
+/**
+ * SLIPIF_THREAD_PRIO: The priority assigned to the slipif_loop thread.
+ * The priority value itself is platform-dependent, but is passed to
+ * sys_thread_new() when the thread is created.
+ */
+#if !defined SLIPIF_THREAD_PRIO || defined __DOXYGEN__
+#define SLIPIF_THREAD_PRIO              1
+#endif
+
+/**
+ * DEFAULT_THREAD_NAME: The name assigned to any other lwIP thread.
+ */
+#if !defined DEFAULT_THREAD_NAME || defined __DOXYGEN__
+#define DEFAULT_THREAD_NAME            "lwIP"
+#endif
+
+/**
+ * DEFAULT_THREAD_STACKSIZE: The stack size used by any other lwIP thread.
+ * The stack size value itself is platform-dependent, but is passed to
+ * sys_thread_new() when the thread is created.
+ */
+#if !defined DEFAULT_THREAD_STACKSIZE || defined __DOXYGEN__
+#define DEFAULT_THREAD_STACKSIZE        0
+#endif
+
+/**
+ * DEFAULT_THREAD_PRIO: The priority assigned to any other lwIP thread.
+ * The priority value itself is platform-dependent, but is passed to
+ * sys_thread_new() when the thread is created.
+ */
+#if !defined DEFAULT_THREAD_PRIO || defined __DOXYGEN__
+#define DEFAULT_THREAD_PRIO             1
+#endif
+
+/**
+ * DEFAULT_RAW_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
+ * NETCONN_RAW. The queue size value itself is platform-dependent, but is passed
+ * to sys_mbox_new() when the recvmbox is created.
+ */
+#if !defined DEFAULT_RAW_RECVMBOX_SIZE || defined __DOXYGEN__
+#define DEFAULT_RAW_RECVMBOX_SIZE       0
+#endif
+
+/**
+ * DEFAULT_UDP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
+ * NETCONN_UDP. The queue size value itself is platform-dependent, but is passed
+ * to sys_mbox_new() when the recvmbox is created.
+ */
+#if !defined DEFAULT_UDP_RECVMBOX_SIZE || defined __DOXYGEN__
+#define DEFAULT_UDP_RECVMBOX_SIZE       0
+#endif
+
+/**
+ * DEFAULT_TCP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
+ * NETCONN_TCP. The queue size value itself is platform-dependent, but is passed
+ * to sys_mbox_new() when the recvmbox is created.
+ */
+#if !defined DEFAULT_TCP_RECVMBOX_SIZE || defined __DOXYGEN__
+#define DEFAULT_TCP_RECVMBOX_SIZE       0
+#endif
+
+/**
+ * DEFAULT_ACCEPTMBOX_SIZE: The mailbox size for the incoming connections.
+ * The queue size value itself is platform-dependent, but is passed to
+ * sys_mbox_new() when the acceptmbox is created.
+ */
+#if !defined DEFAULT_ACCEPTMBOX_SIZE || defined __DOXYGEN__
+#define DEFAULT_ACCEPTMBOX_SIZE         0
+#endif
+/**
+ * @}
+ */
+
+/*
+   ----------------------------------------------
+   ---------- Sequential layer options ----------
+   ----------------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_netconn Netconn
+ * @ingroup lwip_opts_threadsafe_apis
+ * @{
+ */
+/**
+ * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
+ */
+#if !defined LWIP_NETCONN || defined __DOXYGEN__
+#define LWIP_NETCONN                    1
+#endif
+
+/** LWIP_TCPIP_TIMEOUT==1: Enable tcpip_timeout/tcpip_untimeout to create
+ * timers running in tcpip_thread from another thread.
+ */
+#if !defined LWIP_TCPIP_TIMEOUT || defined __DOXYGEN__
+#define LWIP_TCPIP_TIMEOUT              0
+#endif
+
+/** LWIP_NETCONN_SEM_PER_THREAD==1: Use one (thread-local) semaphore per
+ * thread calling socket/netconn functions instead of allocating one
+ * semaphore per netconn (and per select etc.)
+ * ATTENTION: a thread-local semaphore for API calls is needed:
+ * - LWIP_NETCONN_THREAD_SEM_GET() returning a sys_sem_t*
+ * - LWIP_NETCONN_THREAD_SEM_ALLOC() creating the semaphore
+ * - LWIP_NETCONN_THREAD_SEM_FREE() freeing the semaphore
+ * The latter 2 can be invoked up by calling netconn_thread_init()/netconn_thread_cleanup().
+ * Ports may call these for threads created with sys_thread_new().
+ */
+#if !defined LWIP_NETCONN_SEM_PER_THREAD || defined __DOXYGEN__
+#define LWIP_NETCONN_SEM_PER_THREAD     0
+#endif
+
+/** LWIP_NETCONN_FULLDUPLEX==1: Enable code that allows reading from one thread,
+ * writing from a 2nd thread and closing from a 3rd thread at the same time.
+ * ATTENTION: This is currently really alpha! Some requirements:
+ * - LWIP_NETCONN_SEM_PER_THREAD==1 is required to use one socket/netconn from
+ *   multiple threads at once
+ * - sys_mbox_free() has to unblock receive tasks waiting on recvmbox/acceptmbox
+ *   and prevent a task pending on this during/after deletion
+ */
+#if !defined LWIP_NETCONN_FULLDUPLEX || defined __DOXYGEN__
+#define LWIP_NETCONN_FULLDUPLEX         0
+#endif
+/**
+ * @}
+ */
+
+/*
+   ------------------------------------
+   ---------- Socket options ----------
+   ------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_socket Sockets
+ * @ingroup lwip_opts_threadsafe_apis
+ * @{
+ */
+/**
+ * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
+ */
+#if !defined LWIP_SOCKET || defined __DOXYGEN__
+#define LWIP_SOCKET                     1
+#endif
+
+/* LWIP_SOCKET_SET_ERRNO==1: Set errno when socket functions cannot complete
+ * successfully, as required by POSIX. Default is POSIX-compliant.
+ */
+#if !defined LWIP_SOCKET_SET_ERRNO || defined __DOXYGEN__
+#define LWIP_SOCKET_SET_ERRNO           1
+#endif
+
+/**
+ * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names through defines.
+ * LWIP_COMPAT_SOCKETS==2: Same as ==1 but correctly named functions are created.
+ * While this helps code completion, it might conflict with existing libraries.
+ * (only used if you use sockets.c)
+ */
+#if !defined LWIP_COMPAT_SOCKETS || defined __DOXYGEN__
+#define LWIP_COMPAT_SOCKETS             1
+#endif
+
+/**
+ * LWIP_POSIX_SOCKETS_IO_NAMES==1: Enable POSIX-style sockets functions names.
+ * Disable this option if you use a POSIX operating system that uses the same
+ * names (read, write & close). (only used if you use sockets.c)
+ */
+#if !defined LWIP_POSIX_SOCKETS_IO_NAMES || defined __DOXYGEN__
+#define LWIP_POSIX_SOCKETS_IO_NAMES     1
+#endif
+
+/**
+ * LWIP_SOCKET_OFFSET==n: Increases the file descriptor number created by LwIP with n.
+ * This can be useful when there are multiple APIs which create file descriptors.
+ * When they all start with a different offset and you won't make them overlap you can
+ * re implement read/write/close/ioctl/fnctl to send the requested action to the right
+ * library (sharing select will need more work though).
+ */
+#if !defined LWIP_SOCKET_OFFSET || defined __DOXYGEN__
+#define LWIP_SOCKET_OFFSET              0
+#endif
+
+/**
+ * LWIP_TCP_KEEPALIVE==1: Enable TCP_KEEPIDLE, TCP_KEEPINTVL and TCP_KEEPCNT
+ * options processing. Note that TCP_KEEPIDLE and TCP_KEEPINTVL have to be set
+ * in seconds. (does not require sockets.c, and will affect tcp.c)
+ */
+#if !defined LWIP_TCP_KEEPALIVE || defined __DOXYGEN__
+#define LWIP_TCP_KEEPALIVE              0
+#endif
+
+/**
+ * LWIP_SO_SNDTIMEO==1: Enable send timeout for sockets/netconns and
+ * SO_SNDTIMEO processing.
+ */
+#if !defined LWIP_SO_SNDTIMEO || defined __DOXYGEN__
+#define LWIP_SO_SNDTIMEO                0
+#endif
+
+/**
+ * LWIP_SO_RCVTIMEO==1: Enable receive timeout for sockets/netconns and
+ * SO_RCVTIMEO processing.
+ */
+#if !defined LWIP_SO_RCVTIMEO || defined __DOXYGEN__
+#define LWIP_SO_RCVTIMEO                0
+#endif
+
+/**
+ * LWIP_SO_SNDRCVTIMEO_NONSTANDARD==1: SO_RCVTIMEO/SO_SNDTIMEO take an int
+ * (milliseconds, much like winsock does) instead of a struct timeval (default).
+ */
+#if !defined LWIP_SO_SNDRCVTIMEO_NONSTANDARD || defined __DOXYGEN__
+#define LWIP_SO_SNDRCVTIMEO_NONSTANDARD 0
+#endif
+
+/**
+ * LWIP_SO_RCVBUF==1: Enable SO_RCVBUF processing.
+ */
+#if !defined LWIP_SO_RCVBUF || defined __DOXYGEN__
+#define LWIP_SO_RCVBUF                  0
+#endif
+
+/**
+ * LWIP_SO_LINGER==1: Enable SO_LINGER processing.
+ */
+#if !defined LWIP_SO_LINGER || defined __DOXYGEN__
+#define LWIP_SO_LINGER                  0
+#endif
+
+/**
+ * If LWIP_SO_RCVBUF is used, this is the default value for recv_bufsize.
+ */
+#if !defined RECV_BUFSIZE_DEFAULT || defined __DOXYGEN__
+#define RECV_BUFSIZE_DEFAULT            INT_MAX
+#endif
+
+/**
+ * By default, TCP socket/netconn close waits 20 seconds max to send the FIN
+ */
+#if !defined LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT || defined __DOXYGEN__
+#define LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT 20000
+#endif
+
+/**
+ * SO_REUSE==1: Enable SO_REUSEADDR option.
+ */
+#if !defined SO_REUSE || defined __DOXYGEN__
+#define SO_REUSE                        0
+#endif
+
+/**
+ * SO_REUSE_RXTOALL==1: Pass a copy of incoming broadcast/multicast packets
+ * to all local matches if SO_REUSEADDR is turned on.
+ * WARNING: Adds a memcpy for every packet if passing to more than one pcb!
+ */
+#if !defined SO_REUSE_RXTOALL || defined __DOXYGEN__
+#define SO_REUSE_RXTOALL                0
+#endif
+
+/**
+ * LWIP_FIONREAD_LINUXMODE==0 (default): ioctl/FIONREAD returns the amount of
+ * pending data in the network buffer. This is the way windows does it. It's
+ * the default for lwIP since it is smaller.
+ * LWIP_FIONREAD_LINUXMODE==1: ioctl/FIONREAD returns the size of the next
+ * pending datagram in bytes. This is the way linux does it. This code is only
+ * here for compatibility.
+ */
+#if !defined LWIP_FIONREAD_LINUXMODE || defined __DOXYGEN__
+#define LWIP_FIONREAD_LINUXMODE         0
+#endif
+/**
+ * @}
+ */
+
+/*
+   ----------------------------------------
+   ---------- Statistics options ----------
+   ----------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_stats Statistics
+ * @ingroup lwip_opts_debug
+ * @{
+ */
+/**
+ * LWIP_STATS==1: Enable statistics collection in lwip_stats.
+ */
+#if !defined LWIP_STATS || defined __DOXYGEN__
+#define LWIP_STATS                      1
+#endif
+
+#if LWIP_STATS
+
+/**
+ * LWIP_STATS_DISPLAY==1: Compile in the statistics output functions.
+ */
+#if !defined LWIP_STATS_DISPLAY || defined __DOXYGEN__
+#define LWIP_STATS_DISPLAY              0
+#endif
+
+/**
+ * LINK_STATS==1: Enable link stats.
+ */
+#if !defined LINK_STATS || defined __DOXYGEN__
+#define LINK_STATS                      1
+#endif
+
+/**
+ * ETHARP_STATS==1: Enable etharp stats.
+ */
+#if !defined ETHARP_STATS || defined __DOXYGEN__
+#define ETHARP_STATS                    (LWIP_ARP)
+#endif
+
+/**
+ * IP_STATS==1: Enable IP stats.
+ */
+#if !defined IP_STATS || defined __DOXYGEN__
+#define IP_STATS                        1
+#endif
+
+/**
+ * IPFRAG_STATS==1: Enable IP fragmentation stats. Default is
+ * on if using either frag or reass.
+ */
+#if !defined IPFRAG_STATS || defined __DOXYGEN__
+#define IPFRAG_STATS                    (IP_REASSEMBLY || IP_FRAG)
+#endif
+
+/**
+ * ICMP_STATS==1: Enable ICMP stats.
+ */
+#if !defined ICMP_STATS || defined __DOXYGEN__
+#define ICMP_STATS                      1
+#endif
+
+/**
+ * IGMP_STATS==1: Enable IGMP stats.
+ */
+#if !defined IGMP_STATS || defined __DOXYGEN__
+#define IGMP_STATS                      (LWIP_IGMP)
+#endif
+
+/**
+ * UDP_STATS==1: Enable UDP stats. Default is on if
+ * UDP enabled, otherwise off.
+ */
+#if !defined UDP_STATS || defined __DOXYGEN__
+#define UDP_STATS                       (LWIP_UDP)
+#endif
+
+/**
+ * TCP_STATS==1: Enable TCP stats. Default is on if TCP
+ * enabled, otherwise off.
+ */
+#if !defined TCP_STATS || defined __DOXYGEN__
+#define TCP_STATS                       (LWIP_TCP)
+#endif
+
+/**
+ * MEM_STATS==1: Enable mem.c stats.
+ */
+#if !defined MEM_STATS || defined __DOXYGEN__
+#define MEM_STATS                       ((MEM_LIBC_MALLOC == 0) && (MEM_USE_POOLS == 0))
+#endif
+
+/**
+ * MEMP_STATS==1: Enable memp.c pool stats.
+ */
+#if !defined MEMP_STATS || defined __DOXYGEN__
+#define MEMP_STATS                      (MEMP_MEM_MALLOC == 0)
+#endif
+
+/**
+ * SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
+ */
+#if !defined SYS_STATS || defined __DOXYGEN__
+#define SYS_STATS                       (NO_SYS == 0)
+#endif
+
+/**
+ * IP6_STATS==1: Enable IPv6 stats.
+ */
+#if !defined IP6_STATS || defined __DOXYGEN__
+#define IP6_STATS                       (LWIP_IPV6)
+#endif
+
+/**
+ * ICMP6_STATS==1: Enable ICMP for IPv6 stats.
+ */
+#if !defined ICMP6_STATS || defined __DOXYGEN__
+#define ICMP6_STATS                     (LWIP_IPV6 && LWIP_ICMP6)
+#endif
+
+/**
+ * IP6_FRAG_STATS==1: Enable IPv6 fragmentation stats.
+ */
+#if !defined IP6_FRAG_STATS || defined __DOXYGEN__
+#define IP6_FRAG_STATS                  (LWIP_IPV6 && (LWIP_IPV6_FRAG || LWIP_IPV6_REASS))
+#endif
+
+/**
+ * MLD6_STATS==1: Enable MLD for IPv6 stats.
+ */
+#if !defined MLD6_STATS || defined __DOXYGEN__
+#define MLD6_STATS                      (LWIP_IPV6 && LWIP_IPV6_MLD)
+#endif
+
+/**
+ * ND6_STATS==1: Enable Neighbor discovery for IPv6 stats.
+ */
+#if !defined ND6_STATS || defined __DOXYGEN__
+#define ND6_STATS                       (LWIP_IPV6_ND)
+#endif
+
+/**
+ * MIB2_STATS==1: Stats for SNMP MIB2.
+ */
+#if !defined MIB2_STATS || defined __DOXYGEN__
+#define MIB2_STATS                      0
+#endif
+
+#else
+
+#define LINK_STATS                      0
+#define ETHARP_STATS                    0
+#define IP_STATS                        0
+#define IPFRAG_STATS                    0
+#define ICMP_STATS                      0
+#define IGMP_STATS                      0
+#define UDP_STATS                       0
+#define TCP_STATS                       0
+#define MEM_STATS                       0
+#define MEMP_STATS                      0
+#define SYS_STATS                       0
+#define LWIP_STATS_DISPLAY              0
+#define IP6_STATS                       0
+#define ICMP6_STATS                     0
+#define IP6_FRAG_STATS                  0
+#define MLD6_STATS                      0
+#define ND6_STATS                       0
+#define MIB2_STATS                      0
+
+#endif /* LWIP_STATS */
+/**
+ * @}
+ */
+
+/*
+   --------------------------------------
+   ---------- Checksum options ----------
+   --------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_checksum Checksum
+ * @ingroup lwip_opts_infrastructure
+ * @{
+ */
+/**
+ * LWIP_CHECKSUM_CTRL_PER_NETIF==1: Checksum generation/check can be enabled/disabled
+ * per netif.
+ * ATTENTION: if enabled, the CHECKSUM_GEN_* and CHECKSUM_CHECK_* defines must be enabled!
+ */
+#if !defined LWIP_CHECKSUM_CTRL_PER_NETIF || defined __DOXYGEN__
+#define LWIP_CHECKSUM_CTRL_PER_NETIF    0
+#endif
+
+/**
+ * CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.
+ */
+#if !defined CHECKSUM_GEN_IP || defined __DOXYGEN__
+#define CHECKSUM_GEN_IP                 1
+#endif
+
+/**
+ * CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.
+ */
+#if !defined CHECKSUM_GEN_UDP || defined __DOXYGEN__
+#define CHECKSUM_GEN_UDP                1
+#endif
+
+/**
+ * CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.
+ */
+#if !defined CHECKSUM_GEN_TCP || defined __DOXYGEN__
+#define CHECKSUM_GEN_TCP                1
+#endif
+
+/**
+ * CHECKSUM_GEN_ICMP==1: Generate checksums in software for outgoing ICMP packets.
+ */
+#if !defined CHECKSUM_GEN_ICMP || defined __DOXYGEN__
+#define CHECKSUM_GEN_ICMP               1
+#endif
+
+/**
+ * CHECKSUM_GEN_ICMP6==1: Generate checksums in software for outgoing ICMP6 packets.
+ */
+#if !defined CHECKSUM_GEN_ICMP6 || defined __DOXYGEN__
+#define CHECKSUM_GEN_ICMP6              1
+#endif
+
+/**
+ * CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.
+ */
+#if !defined CHECKSUM_CHECK_IP || defined __DOXYGEN__
+#define CHECKSUM_CHECK_IP               1
+#endif
+
+/**
+ * CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.
+ */
+#if !defined CHECKSUM_CHECK_UDP || defined __DOXYGEN__
+#define CHECKSUM_CHECK_UDP              1
+#endif
+
+/**
+ * CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.
+ */
+#if !defined CHECKSUM_CHECK_TCP || defined __DOXYGEN__
+#define CHECKSUM_CHECK_TCP              1
+#endif
+
+/**
+ * CHECKSUM_CHECK_ICMP==1: Check checksums in software for incoming ICMP packets.
+ */
+#if !defined CHECKSUM_CHECK_ICMP || defined __DOXYGEN__
+#define CHECKSUM_CHECK_ICMP             1
+#endif
+
+/**
+ * CHECKSUM_CHECK_ICMP6==1: Check checksums in software for incoming ICMPv6 packets
+ */
+#if !defined CHECKSUM_CHECK_ICMP6 || defined __DOXYGEN__
+#define CHECKSUM_CHECK_ICMP6            1
+#endif
+
+/**
+ * LWIP_CHECKSUM_ON_COPY==1: Calculate checksum when copying data from
+ * application buffers to pbufs.
+ */
+#if !defined LWIP_CHECKSUM_ON_COPY || defined __DOXYGEN__
+#define LWIP_CHECKSUM_ON_COPY           0
+#endif
+/**
+ * @}
+ */
+
+/*
+   ---------------------------------------
+   ---------- IPv6 options ---------------
+   ---------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_ipv6 IPv6
+ * @ingroup lwip_opts
+ * @{
+ */
+/**
+ * LWIP_IPV6==1: Enable IPv6
+ */
+#if !defined LWIP_IPV6 || defined __DOXYGEN__
+#define LWIP_IPV6                       0
+#endif
+
+/**
+ * LWIP_IPV6_NUM_ADDRESSES: Number of IPv6 addresses per netif.
+ */
+#if !defined LWIP_IPV6_NUM_ADDRESSES || defined __DOXYGEN__
+#define LWIP_IPV6_NUM_ADDRESSES         3
+#endif
+
+/**
+ * LWIP_IPV6_FORWARD==1: Forward IPv6 packets across netifs
+ */
+#if !defined LWIP_IPV6_FORWARD || defined __DOXYGEN__
+#define LWIP_IPV6_FORWARD               0
+#endif
+
+/**
+ * LWIP_IPV6_FRAG==1: Fragment outgoing IPv6 packets that are too big.
+ */
+#if !defined LWIP_IPV6_FRAG || defined __DOXYGEN__
+#define LWIP_IPV6_FRAG                  0
+#endif
+
+/**
+ * LWIP_IPV6_REASS==1: reassemble incoming IPv6 packets that fragmented
+ */
+#if !defined LWIP_IPV6_REASS || defined __DOXYGEN__
+#define LWIP_IPV6_REASS                 (LWIP_IPV6)
+#endif
+
+/**
+ * LWIP_IPV6_SEND_ROUTER_SOLICIT==1: Send router solicitation messages during
+ * network startup.
+ */
+#if !defined LWIP_IPV6_SEND_ROUTER_SOLICIT || defined __DOXYGEN__
+#define LWIP_IPV6_SEND_ROUTER_SOLICIT   1
+#endif
+
+/**
+ * LWIP_IPV6_ADDRESS_LIFETIMES==1: Keep valid and preferred lifetimes for each
+ * IPv6 address. Required for LWIP_IPV6_AUTOCONFIG. May still be enabled
+ * otherwise, in which case the application may assign address lifetimes with
+ * the appropriate macros. Addresses with no lifetime are assumed to be static.
+ * If this option is disabled, all addresses are assumed to be static.
+ */
+#if !defined LWIP_IPV6_ADDRESS_LIFETIMES || defined __DOXYGEN__
+#define LWIP_IPV6_ADDRESS_LIFETIMES     (LWIP_IPV6_AUTOCONFIG)
+#endif
+
+/**
+ * LWIP_IPV6_DUP_DETECT_ATTEMPTS=[0..7]: Number of duplicate address detection attempts.
+ */
+#if !defined LWIP_IPV6_DUP_DETECT_ATTEMPTS || defined __DOXYGEN__
+#define LWIP_IPV6_DUP_DETECT_ATTEMPTS   1
+#endif
+/**
+ * @}
+ */
+
+/**
+ * @defgroup lwip_opts_icmp6 ICMP6
+ * @ingroup lwip_opts_ipv6
+ * @{
+ */
+/**
+ * LWIP_ICMP6==1: Enable ICMPv6 (mandatory per RFC)
+ */
+#if !defined LWIP_ICMP6 || defined __DOXYGEN__
+#define LWIP_ICMP6                      (LWIP_IPV6)
+#endif
+
+/**
+ * LWIP_ICMP6_DATASIZE: bytes from original packet to send back in
+ * ICMPv6 error messages.
+ */
+#if !defined LWIP_ICMP6_DATASIZE || defined __DOXYGEN__
+#define LWIP_ICMP6_DATASIZE             8
+#endif
+
+/**
+ * LWIP_ICMP6_HL: default hop limit for ICMPv6 messages
+ */
+#if !defined LWIP_ICMP6_HL || defined __DOXYGEN__
+#define LWIP_ICMP6_HL                   255
+#endif
+/**
+ * @}
+ */
+
+/**
+ * @defgroup lwip_opts_nd6 Neighbor discovery
+ * @ingroup lwip_opts_ipv6
+ * @{
+ */
+
+/**
+ * LWIP_IPV6_ND==1: Enable neighbor discovery protocol.
+ * If LWIP_IPV6 is enabled but this setting is disabled, then neighbor and
+ * destination caches, duplicate address detection, neighbor unreachability
+ * detection, multicast listener discovery and router discovery are delegated
+ * entirely to the sub-IP layer.
+ */
+#if !defined LWIP_IPV6_ND || defined __DOXYGEN__
+#define LWIP_IPV6_ND                   (LWIP_IPV6)
+#endif
+
+/**
+ * LWIP_IPV6_AUTOCONFIG==1: Enable stateless address autoconfiguration as per RFC 4862.
+ */
+#if !defined LWIP_IPV6_AUTOCONFIG || defined __DOXYGEN__
+#define LWIP_IPV6_AUTOCONFIG            (LWIP_IPV6_ND)
+#endif
+
+/**
+ * @defgroup lwip_opts_mld6 Multicast listener discovery
+ * @ingroup lwip_opts_ipv6
+ * @{
+ */
+/**
+ * LWIP_IPV6_MLD==1: Enable multicast listener discovery protocol.
+ * If LWIP_IPV6_ND is enabled but this setting is disabled, the MAC layer must
+ * indiscriminately pass all inbound IPv6 multicast traffic to lwIP.
+ */
+#if !defined LWIP_IPV6_MLD || defined __DOXYGEN__
+#define LWIP_IPV6_MLD                   (LWIP_IPV6_ND)
+#endif
+
+/**
+ * MEMP_NUM_MLD6_GROUP: Max number of IPv6 multicast groups that can be joined.
+ * There must be enough groups so that each netif can join the solicited-node
+ * multicast group for each of its local addresses, plus one for MDNS if
+ * applicable, plus any number of groups to be joined on UDP sockets.
+ */
+#if !defined MEMP_NUM_MLD6_GROUP || defined __DOXYGEN__
+#define MEMP_NUM_MLD6_GROUP             4
+#endif
+/**
+ * @}
+ */
+
+/**
+ * @defgroup lwip_opts_nd6 Neighbor discovery
+ * @ingroup lwip_opts_ipv6
+ * @{
+ */
+/**
+ * LWIP_ND6_QUEUEING==1: queue outgoing IPv6 packets while MAC address
+ * is being resolved.
+ */
+#if !defined LWIP_ND6_QUEUEING || defined __DOXYGEN__
+#define LWIP_ND6_QUEUEING               (LWIP_IPV6_ND)
+#endif
+
+/**
+ * MEMP_NUM_ND6_QUEUE: Max number of IPv6 packets to queue during MAC resolution.
+ */
+#if !defined MEMP_NUM_ND6_QUEUE || defined __DOXYGEN__
+#define MEMP_NUM_ND6_QUEUE              20
+#endif
+
+/**
+ * LWIP_ND6_NUM_NEIGHBORS: Number of entries in IPv6 neighbor cache
+ */
+#if !defined LWIP_ND6_NUM_NEIGHBORS || defined __DOXYGEN__
+#define LWIP_ND6_NUM_NEIGHBORS          10
+#endif
+
+/**
+ * LWIP_ND6_NUM_DESTINATIONS: number of entries in IPv6 destination cache
+ */
+#if !defined LWIP_ND6_NUM_DESTINATIONS || defined __DOXYGEN__
+#define LWIP_ND6_NUM_DESTINATIONS       10
+#endif
+
+/**
+ * LWIP_ND6_NUM_PREFIXES: number of entries in IPv6 on-link prefixes cache
+ */
+#if !defined LWIP_ND6_NUM_PREFIXES || defined __DOXYGEN__
+#define LWIP_ND6_NUM_PREFIXES           5
+#endif
+
+/**
+ * LWIP_ND6_NUM_ROUTERS: number of entries in IPv6 default router cache
+ */
+#if !defined LWIP_ND6_NUM_ROUTERS || defined __DOXYGEN__
+#define LWIP_ND6_NUM_ROUTERS            3
+#endif
+
+/**
+ * LWIP_ND6_MAX_MULTICAST_SOLICIT: max number of multicast solicit messages to send
+ * (neighbor solicit and router solicit)
+ */
+#if !defined LWIP_ND6_MAX_MULTICAST_SOLICIT || defined __DOXYGEN__
+#define LWIP_ND6_MAX_MULTICAST_SOLICIT  3
+#endif
+
+/**
+ * LWIP_ND6_MAX_UNICAST_SOLICIT: max number of unicast neighbor solicitation messages
+ * to send during neighbor reachability detection.
+ */
+#if !defined LWIP_ND6_MAX_UNICAST_SOLICIT || defined __DOXYGEN__
+#define LWIP_ND6_MAX_UNICAST_SOLICIT    3
+#endif
+
+/**
+ * Unused: See ND RFC (time in milliseconds).
+ */
+#if !defined LWIP_ND6_MAX_ANYCAST_DELAY_TIME || defined __DOXYGEN__
+#define LWIP_ND6_MAX_ANYCAST_DELAY_TIME 1000
+#endif
+
+/**
+ * Unused: See ND RFC
+ */
+#if !defined LWIP_ND6_MAX_NEIGHBOR_ADVERTISEMENT || defined __DOXYGEN__
+#define LWIP_ND6_MAX_NEIGHBOR_ADVERTISEMENT  3
+#endif
+
+/**
+ * LWIP_ND6_REACHABLE_TIME: default neighbor reachable time (in milliseconds).
+ * May be updated by router advertisement messages.
+ */
+#if !defined LWIP_ND6_REACHABLE_TIME || defined __DOXYGEN__
+#define LWIP_ND6_REACHABLE_TIME         30000
+#endif
+
+/**
+ * LWIP_ND6_RETRANS_TIMER: default retransmission timer for solicitation messages
+ */
+#if !defined LWIP_ND6_RETRANS_TIMER || defined __DOXYGEN__
+#define LWIP_ND6_RETRANS_TIMER          1000
+#endif
+
+/**
+ * LWIP_ND6_DELAY_FIRST_PROBE_TIME: Delay before first unicast neighbor solicitation
+ * message is sent, during neighbor reachability detection.
+ */
+#if !defined LWIP_ND6_DELAY_FIRST_PROBE_TIME || defined __DOXYGEN__
+#define LWIP_ND6_DELAY_FIRST_PROBE_TIME 5000
+#endif
+
+/**
+ * LWIP_ND6_ALLOW_RA_UPDATES==1: Allow Router Advertisement messages to update
+ * Reachable time and retransmission timers, and netif MTU.
+ */
+#if !defined LWIP_ND6_ALLOW_RA_UPDATES || defined __DOXYGEN__
+#define LWIP_ND6_ALLOW_RA_UPDATES       1
+#endif
+
+/**
+ * LWIP_ND6_TCP_REACHABILITY_HINTS==1: Allow TCP to provide Neighbor Discovery
+ * with reachability hints for connected destinations. This helps avoid sending
+ * unicast neighbor solicitation messages.
+ */
+#if !defined LWIP_ND6_TCP_REACHABILITY_HINTS || defined __DOXYGEN__
+#define LWIP_ND6_TCP_REACHABILITY_HINTS 1
+#endif
+
+/**
+ * LWIP_ND6_RDNSS_MAX_DNS_SERVERS > 0: Use IPv6 Router Advertisement Recursive
+ * DNS Server Option (as per RFC 6106) to copy a defined maximum number of DNS
+ * servers to the DNS module.
+ */
+#if !defined LWIP_ND6_RDNSS_MAX_DNS_SERVERS || defined __DOXYGEN__
+#define LWIP_ND6_RDNSS_MAX_DNS_SERVERS  0
+#endif
+/**
+ * @}
+ */
+
+/**
+ * LWIP_IPV6_DHCP6==1: enable DHCPv6 stateful address autoconfiguration.
+ */
+#if !defined LWIP_IPV6_DHCP6 || defined __DOXYGEN__
+#define LWIP_IPV6_DHCP6                 0
+#endif
+
+/**
+ * LWIP_ND6_LISTEN_RA==1: Enable listening and processing incoming Router Advertisements.
+ */
+#ifndef LWIP_ND6_LISTEN_RA
+#define LWIP_ND6_LISTEN_RA              1
+#endif
+
+/**
+ * LWIP_IPV6_ROUTER_SUPPORT==1: Maintain a list of IPV6 routers dynamically discovered via Router Advertisements.
+ */
+#ifndef LWIP_IPV6_ROUTER_SUPPORT
+#define LWIP_IPV6_ROUTER_SUPPORT        1
+#endif
+
+/**
+ * LWIP_IPV6_ROUTE_TABLE_SUPPORT==1: Enable support for adding static routes and referring to these during forwarding.
+ */
+#ifndef LWIP_IPV6_ROUTE_TABLE_SUPPORT
+#define LWIP_IPV6_ROUTE_TABLE_SUPPORT   0
+#endif
+
+/**
+ * LWIP_IPV6_NUM_ROUTES: Number of IPV6 routes that can be kept in the static route table.
+ */
+#ifndef LWIP_IPV6_NUM_ROUTE_ENTRIES
+#define LWIP_IPV6_NUM_ROUTE_ENTRIES     8
+#endif
+
+
+/*
+   ---------------------------------------
+   ---------- Hook options ---------------
+   ---------------------------------------
+*/
+
+/**
+ * @defgroup lwip_opts_hooks Hooks
+ * @ingroup lwip_opts_infrastructure
+ * Hooks are undefined by default, define them to a function if you need them.
+ * @{
+ */
+
+/**
+ * LWIP_HOOK_FILENAME: Custom filename to #include in files that provide hooks.
+ * Declare your hook function prototypes in there, you may also #include all headers
+ * providing data types that are need in this file.
+ */
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_FILENAME "path/to/my/lwip_hooks.h"
+#endif
+
+/**
+ * LWIP_HOOK_TCP_ISN:
+ * Hook for generation of the Initial Sequence Number (ISN) for a new TCP
+ * connection. The default lwIP ISN generation algorithm is very basic and may
+ * allow for TCP spoofing attacks. This hook provides the means to implement
+ * the standardized ISN generation algorithm from RFC 6528 (see contrib/adons/tcp_isn),
+ * or any other desired algorithm as a replacement.
+ * Called from tcp_connect() and tcp_listen_input() when an ISN is needed for
+ * a new TCP connection, if TCP support (@ref LWIP_TCP) is enabled.\n
+ * Signature: u32_t my_hook_tcp_isn(const ip_addr_t* local_ip, u16_t local_port, const ip_addr_t* remote_ip, u16_t remote_port);
+ * - it may be necessary to use "struct ip_addr" (ip4_addr, ip6_addr) instead of "ip_addr_t" in function declarations\n
+ * Arguments:
+ * - local_ip: pointer to the local IP address of the connection
+ * - local_port: local port number of the connection (host-byte order)
+ * - remote_ip: pointer to the remote IP address of the connection
+ * - remote_port: remote port number of the connection (host-byte order)\n
+ * Return value:
+ * - the 32-bit Initial Sequence Number to use for the new TCP connection.
+ */
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_TCP_ISN(local_ip, local_port, remote_ip, remote_port)
+#endif
+
+/**
+ * LWIP_HOOK_IP4_INPUT(pbuf, input_netif):
+ * - called from ip_input() (IPv4)
+ * - pbuf: received struct pbuf passed to ip_input()
+ * - input_netif: struct netif on which the packet has been received
+ * Return values:
+ * - 0: Hook has not consumed the packet, packet is processed as normal
+ * - != 0: Hook has consumed the packet.
+ * If the hook consumed the packet, 'pbuf' is in the responsibility of the hook
+ * (i.e. free it when done).
+ */
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_IP4_INPUT(pbuf, input_netif)
+#endif
+
+/**
+ * LWIP_HOOK_IP4_ROUTE(dest):
+ * - called from ip_route() (IPv4)
+ * - dest: destination IPv4 address
+ * Returns the destination netif or NULL if no destination netif is found. In
+ * that case, ip_route() continues as normal.
+ */
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_IP4_ROUTE()
+#endif
+
+/**
+ * LWIP_HOOK_IP4_ROUTE_SRC(dest, src):
+ * - source-based routing for IPv4 (see LWIP_HOOK_IP4_ROUTE(), src may be NULL)
+ */
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_IP4_ROUTE_SRC(dest, src)
+#endif
+
+/**
+ * LWIP_HOOK_ETHARP_GET_GW(netif, dest):
+ * - called from etharp_output() (IPv4)
+ * - netif: the netif used for sending
+ * - dest: the destination IPv4 address
+ * Returns the IPv4 address of the gateway to handle the specified destination
+ * IPv4 address. If NULL is returned, the netif's default gateway is used.
+ * The returned address MUST be directly reachable on the specified netif!
+ * This function is meant to implement advanced IPv4 routing together with
+ * LWIP_HOOK_IP4_ROUTE(). The actual routing/gateway table implementation is
+ * not part of lwIP but can e.g. be hidden in the netif's state argument.
+*/
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_ETHARP_GET_GW(netif, dest)
+#endif
+
+/**
+ * LWIP_HOOK_IP6_INPUT(pbuf, input_netif):
+ * - called from ip6_input() (IPv6)
+ * - pbuf: received struct pbuf passed to ip6_input()
+ * - input_netif: struct netif on which the packet has been received
+ * Return values:
+ * - 0: Hook has not consumed the packet, packet is processed as normal
+ * - != 0: Hook has consumed the packet.
+ * If the hook consumed the packet, 'pbuf' is in the responsibility of the hook
+ * (i.e. free it when done).
+ */
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_IP6_INPUT(pbuf, input_netif)
+#endif
+
+/**
+ * LWIP_HOOK_IP6_ROUTE(src, dest):
+ * - called from ip6_route() (IPv6)
+ * - src: sourc IPv6 address
+ * - dest: destination IPv6 address
+ * Returns the destination netif or NULL if no destination netif is found. In
+ * that case, ip6_route() continues as normal.
+ */
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_IP6_ROUTE(src, dest)
+#endif
+
+/**
+ * LWIP_HOOK_ND6_GET_GW(netif, dest):
+ * - called from nd6_get_next_hop_entry() (IPv6)
+ * - netif: the netif used for sending
+ * - dest: the destination IPv6 address
+ * Returns the IPv6 address of the next hop to handle the specified destination
+ * IPv6 address. If NULL is returned, a NDP-discovered router is used instead.
+ * The returned address MUST be directly reachable on the specified netif!
+ * This function is meant to implement advanced IPv6 routing together with
+ * LWIP_HOOK_IP6_ROUTE(). The actual routing/gateway table implementation is
+ * not part of lwIP but can e.g. be hidden in the netif's state argument.
+*/
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_ND6_GET_GW(netif, dest)
+#endif
+
+/**
+ * LWIP_HOOK_VLAN_CHECK(netif, eth_hdr, vlan_hdr):
+ * - called from ethernet_input() if VLAN support is enabled
+ * - netif: struct netif on which the packet has been received
+ * - eth_hdr: struct eth_hdr of the packet
+ * - vlan_hdr: struct eth_vlan_hdr of the packet
+ * Return values:
+ * - 0: Packet must be dropped.
+ * - != 0: Packet must be accepted.
+ */
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_VLAN_CHECK(netif, eth_hdr, vlan_hdr)
+#endif
+
+/**
+ * LWIP_HOOK_VLAN_SET:
+ * Hook can be used to set prio_vid field of vlan_hdr. If you need to store data
+ * on per-netif basis to implement this callback, see @ref netif_cd.
+ * Called from ethernet_output() if VLAN support (@ref ETHARP_SUPPORT_VLAN) is enabled.\n
+ * Signature: s32_t my_hook_vlan_set(struct netif* netif, struct pbuf* pbuf, const struct eth_addr* src, const struct eth_addr* dst, u16_t eth_type);\n
+ * Arguments:
+ * - netif: struct netif that the packet will be sent through
+ * - p: struct pbuf packet to be sent
+ * - src: source eth address
+ * - dst: destination eth address
+ * - eth_type: ethernet type to packet to be sent\n
+ * 
+ * 
+ * Return values:
+ * - &lt;0: Packet shall not contain VLAN header.
+ * - 0 &lt;= return value &lt;= 0xFFFF: Packet shall contain VLAN header. Return value is prio_vid in host byte order.
+ */
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_VLAN_SET(netif, p, src, dst, eth_type)
+#endif
+
+/**
+ * LWIP_HOOK_MEMP_AVAILABLE(memp_t_type):
+ * - called from memp_free() when a memp pool was empty and an item is now available
+ */
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_MEMP_AVAILABLE(memp_t_type)
+#endif
+
+/**
+ * LWIP_HOOK_UNKNOWN_ETH_PROTOCOL(pbuf, netif):
+ * Called from ethernet_input() when an unknown eth type is encountered.
+ * Return ERR_OK if packet is accepted, any error code otherwise.
+ * Payload points to ethernet header!
+ */
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_UNKNOWN_ETH_PROTOCOL(pbuf, netif)
+#endif
+/**
+ * @}
+ */
+
+/**
+* LWIP_HOOK_ETHIP6_GET_GW(netif, dest):
+* - called from ethip6_output() (IPv6)
+* - netif: the netif used for sending
+* - dest: the destination IPv6 address
+* Returns the IPv6 address of the gateway to handle the specified destination
+* IPv6 address. If NULL is returned, the netif's default gateway is used.
+* The returned address MUST be reachable on the specified netif!
+*/
+#if LWIP_IPV6_ROUTE_TABLE_SUPPORT
+#define LWIP_HOOK_ETHIP6_GET_GW(netif, dest)         ip6_get_gateway(netif, dest)
+#endif
+
+
+/*
+   ---------------------------------------
+   ---------- Debugging options ----------
+   ---------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_debugmsg Debug messages
+ * @ingroup lwip_opts_debug
+ * @{
+ */
+/**
+ * LWIP_DBG_MIN_LEVEL: After masking, the value of the debug is
+ * compared against this value. If it is smaller, then debugging
+ * messages are written.
+ * @see debugging_levels
+ */
+#if !defined LWIP_DBG_MIN_LEVEL || defined __DOXYGEN__
+#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_ALL
+#endif
+
+/**
+ * LWIP_DBG_TYPES_ON: A mask that can be used to globally enable/disable
+ * debug messages of certain types.
+ * @see debugging_levels
+ */
+#if !defined LWIP_DBG_TYPES_ON || defined __DOXYGEN__
+#define LWIP_DBG_TYPES_ON               LWIP_DBG_ON
+#endif
+
+/**
+ * ETHARP_DEBUG: Enable debugging in etharp.c.
+ */
+#if !defined ETHARP_DEBUG || defined __DOXYGEN__
+#define ETHARP_DEBUG                    LWIP_DBG_OFF
+#endif
+
+/**
+ * NETIF_DEBUG: Enable debugging in netif.c.
+ */
+#if !defined NETIF_DEBUG || defined __DOXYGEN__
+#define NETIF_DEBUG                     LWIP_DBG_OFF
+#endif
+
+/**
+ * PBUF_DEBUG: Enable debugging in pbuf.c.
+ */
+#if !defined PBUF_DEBUG || defined __DOXYGEN__
+#define PBUF_DEBUG                      LWIP_DBG_OFF
+#endif
+
+/**
+ * API_LIB_DEBUG: Enable debugging in api_lib.c.
+ */
+#if !defined API_LIB_DEBUG || defined __DOXYGEN__
+#define API_LIB_DEBUG                   LWIP_DBG_OFF
+#endif
+
+/**
+ * API_MSG_DEBUG: Enable debugging in api_msg.c.
+ */
+#if !defined API_MSG_DEBUG || defined __DOXYGEN__
+#define API_MSG_DEBUG                   LWIP_DBG_OFF
+#endif
+
+/**
+ * SOCKETS_DEBUG: Enable debugging in sockets.c.
+ */
+#if !defined SOCKETS_DEBUG || defined __DOXYGEN__
+#define SOCKETS_DEBUG                   LWIP_DBG_OFF
+#endif
+
+/**
+ * ICMP_DEBUG: Enable debugging in icmp.c.
+ */
+#if !defined ICMP_DEBUG || defined __DOXYGEN__
+#define ICMP_DEBUG                      LWIP_DBG_OFF
+#endif
+
+/**
+ * IGMP_DEBUG: Enable debugging in igmp.c.
+ */
+#if !defined IGMP_DEBUG || defined __DOXYGEN__
+#define IGMP_DEBUG                      LWIP_DBG_OFF
+#endif
+
+/**
+ * INET_DEBUG: Enable debugging in inet.c.
+ */
+#if !defined INET_DEBUG || defined __DOXYGEN__
+#define INET_DEBUG                      LWIP_DBG_OFF
+#endif
+
+/**
+ * IP_DEBUG: Enable debugging for IP.
+ */
+#if !defined IP_DEBUG || defined __DOXYGEN__
+#define IP_DEBUG                        LWIP_DBG_OFF
+#endif
+
+/**
+ * IP_REASS_DEBUG: Enable debugging in ip_frag.c for both frag & reass.
+ */
+#if !defined IP_REASS_DEBUG || defined __DOXYGEN__
+#define IP_REASS_DEBUG                  LWIP_DBG_OFF
+#endif
+
+/**
+ * RAW_DEBUG: Enable debugging in raw.c.
+ */
+#if !defined RAW_DEBUG || defined __DOXYGEN__
+#define RAW_DEBUG                       LWIP_DBG_OFF
+#endif
+
+/**
+ * MEM_DEBUG: Enable debugging in mem.c.
+ */
+#if !defined MEM_DEBUG || defined __DOXYGEN__
+#define MEM_DEBUG                       LWIP_DBG_OFF
+#endif
+
+/**
+ * MEMP_DEBUG: Enable debugging in memp.c.
+ */
+#if !defined MEMP_DEBUG || defined __DOXYGEN__
+#define MEMP_DEBUG                      LWIP_DBG_OFF
+#endif
+
+/**
+ * SYS_DEBUG: Enable debugging in sys.c.
+ */
+#if !defined SYS_DEBUG || defined __DOXYGEN__
+#define SYS_DEBUG                       LWIP_DBG_OFF
+#endif
+
+/**
+ * TIMERS_DEBUG: Enable debugging in timers.c.
+ */
+#if !defined TIMERS_DEBUG || defined __DOXYGEN__
+#define TIMERS_DEBUG                    LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_DEBUG: Enable debugging for TCP.
+ */
+#if !defined TCP_DEBUG || defined __DOXYGEN__
+#define TCP_DEBUG                       LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_INPUT_DEBUG: Enable debugging in tcp_in.c for incoming debug.
+ */
+#if !defined TCP_INPUT_DEBUG || defined __DOXYGEN__
+#define TCP_INPUT_DEBUG                 LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_FR_DEBUG: Enable debugging in tcp_in.c for fast retransmit.
+ */
+#if !defined TCP_FR_DEBUG || defined __DOXYGEN__
+#define TCP_FR_DEBUG                    LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_RTO_DEBUG: Enable debugging in TCP for retransmit
+ * timeout.
+ */
+#if !defined TCP_RTO_DEBUG || defined __DOXYGEN__
+#define TCP_RTO_DEBUG                   LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_CWND_DEBUG: Enable debugging for TCP congestion window.
+ */
+#if !defined TCP_CWND_DEBUG || defined __DOXYGEN__
+#define TCP_CWND_DEBUG                  LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_WND_DEBUG: Enable debugging in tcp_in.c for window updating.
+ */
+#if !defined TCP_WND_DEBUG || defined __DOXYGEN__
+#define TCP_WND_DEBUG                   LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_OUTPUT_DEBUG: Enable debugging in tcp_out.c output functions.
+ */
+#if !defined TCP_OUTPUT_DEBUG || defined __DOXYGEN__
+#define TCP_OUTPUT_DEBUG                LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_RST_DEBUG: Enable debugging for TCP with the RST message.
+ */
+#if !defined TCP_RST_DEBUG || defined __DOXYGEN__
+#define TCP_RST_DEBUG                   LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_QLEN_DEBUG: Enable debugging for TCP queue lengths.
+ */
+#if !defined TCP_QLEN_DEBUG || defined __DOXYGEN__
+#define TCP_QLEN_DEBUG                  LWIP_DBG_OFF
+#endif
+
+/**
+ * UDP_DEBUG: Enable debugging in UDP.
+ */
+#if !defined UDP_DEBUG || defined __DOXYGEN__
+#define UDP_DEBUG                       LWIP_DBG_OFF
+#endif
+
+/**
+ * TCPIP_DEBUG: Enable debugging in tcpip.c.
+ */
+#if !defined TCPIP_DEBUG || defined __DOXYGEN__
+#define TCPIP_DEBUG                     LWIP_DBG_OFF
+#endif
+
+/**
+ * SLIP_DEBUG: Enable debugging in slipif.c.
+ */
+#if !defined SLIP_DEBUG || defined __DOXYGEN__
+#define SLIP_DEBUG                      LWIP_DBG_OFF
+#endif
+
+/**
+ * DHCP_DEBUG: Enable debugging in dhcp.c.
+ */
+#if !defined DHCP_DEBUG || defined __DOXYGEN__
+#define DHCP_DEBUG                      LWIP_DBG_OFF
+#endif
+
+/**
+ * AUTOIP_DEBUG: Enable debugging in autoip.c.
+ */
+#if !defined AUTOIP_DEBUG || defined __DOXYGEN__
+#define AUTOIP_DEBUG                    LWIP_DBG_OFF
+#endif
+
+/**
+ * DNS_DEBUG: Enable debugging for DNS.
+ */
+#if !defined DNS_DEBUG || defined __DOXYGEN__
+#define DNS_DEBUG                       LWIP_DBG_OFF
+#endif
+
+/**
+ * IP6_DEBUG: Enable debugging for IPv6.
+ */
+#if !defined IP6_DEBUG || defined __DOXYGEN__
+#define IP6_DEBUG                       LWIP_DBG_OFF
+#endif
+
+/**
+ * LWIP_IP_DEBUG_TARGET: Enable selective output of IP-level debug for
+ * a particular IP address.
+ */
+#ifndef LWIP_IP_DEBUG_TARGET
+#define LWIP_IP_DEBUG_TARGET            0
+#endif
+
+/**
+ * @}
+ */
+
+/*
+   --------------------------------------------------
+   ---------- Performance tracking options ----------
+   --------------------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_perf Performance
+ * @ingroup lwip_opts_debug
+ * @{
+ */
+/**
+ * LWIP_PERF: Enable performance testing for lwIP
+ * (if enabled, arch/perf.h is included)
+ */
+#if !defined LWIP_PERF || defined __DOXYGEN__
+#define LWIP_PERF                       0
+#endif
+/**
+ * @}
+ */
+
+#endif /* LWIP_HDR_OPT_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/pbuf.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/pbuf.h
new file mode 100644
index 000000000..9996770df
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/pbuf.h
@@ -0,0 +1,269 @@
+/**
+ * @file
+ * pbuf API
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+#ifndef LWIP_HDR_PBUF_H
+#define LWIP_HDR_PBUF_H
+
+#include "lwip/opt.h"
+#include "lwip/err.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** LWIP_SUPPORT_CUSTOM_PBUF==1: Custom pbufs behave much like their pbuf type
+ * but they are allocated by external code (initialised by calling
+ * pbuf_alloced_custom()) and when pbuf_free gives up their last reference, they
+ * are freed by calling pbuf_custom->custom_free_function().
+ * Currently, the pbuf_custom code is only needed for one specific configuration
+ * of IP_FRAG, unless required by external driver/application code. */
+#ifndef LWIP_SUPPORT_CUSTOM_PBUF
+#define LWIP_SUPPORT_CUSTOM_PBUF ((IP_FRAG && !LWIP_NETIF_TX_SINGLE_PBUF) || (LWIP_IPV6 && LWIP_IPV6_FRAG))
+#endif
+
+/* @todo: We need a mechanism to prevent wasting memory in every pbuf
+   (TCP vs. UDP, IPv4 vs. IPv6: UDP/IPv4 packets may waste up to 28 bytes) */
+
+#define PBUF_TRANSPORT_HLEN 20
+#if LWIP_IPV6
+#define PBUF_IP_HLEN        40
+#else
+#define PBUF_IP_HLEN        20
+#endif
+
+/**
+ * @ingroup pbuf
+ * Enumeration of pbuf layers
+ */
+typedef enum {
+  /** Includes spare room for transport layer header, e.g. UDP header.
+   * Use this if you intend to pass the pbuf to functions like udp_send().
+   */
+  PBUF_TRANSPORT,
+  /** Includes spare room for IP header.
+   * Use this if you intend to pass the pbuf to functions like raw_send().
+   */
+  PBUF_IP,
+  /** Includes spare room for link layer header (ethernet header).
+   * Use this if you intend to pass the pbuf to functions like ethernet_output().
+   * @see PBUF_LINK_HLEN
+   */
+  PBUF_LINK,
+  /** Includes spare room for additional encapsulation header before ethernet
+   * headers (e.g. 802.11).
+   * Use this if you intend to pass the pbuf to functions like netif->linkoutput().
+   * @see PBUF_LINK_ENCAPSULATION_HLEN
+   */
+  PBUF_RAW_TX,
+  /** Use this for input packets in a netif driver when calling netif->input()
+   * in the most common case - ethernet-layer netif driver. */
+  PBUF_RAW
+} pbuf_layer;
+
+/**
+ * @ingroup pbuf
+ * Enumeration of pbuf types
+ */
+typedef enum {
+  /** pbuf data is stored in RAM, used for TX mostly, struct pbuf and its payload
+      are allocated in one piece of contiguous memory (so the first payload byte
+      can be calculated from struct pbuf).
+      pbuf_alloc() allocates PBUF_RAM pbufs as unchained pbufs (although that might
+      change in future versions).
+      This should be used for all OUTGOING packets (TX).*/
+  PBUF_RAM,
+  /** pbuf data is stored in ROM, i.e. struct pbuf and its payload are located in
+      totally different memory areas. Since it points to ROM, payload does not
+      have to be copied when queued for transmission. */
+  PBUF_ROM,
+  /** pbuf comes from the pbuf pool. Much like PBUF_ROM but payload might change
+      so it has to be duplicated when queued before transmitting, depending on
+      who has a 'ref' to it. */
+  PBUF_REF,
+  /** pbuf payload refers to RAM. This one comes from a pool and should be used
+      for RX. Payload can be chained (scatter-gather RX) but like PBUF_RAM, struct
+      pbuf and its payload are allocated in one piece of contiguous memory (so
+      the first payload byte can be calculated from struct pbuf).
+      Don't use this for TX, if the pool becomes empty e.g. because of TCP queuing,
+      you are unable to receive TCP acks! */
+  PBUF_POOL
+} pbuf_type;
+
+
+/** indicates this packet's data should be immediately passed to the application */
+#define PBUF_FLAG_PUSH      0x01U
+/** indicates this is a custom pbuf: pbuf_free calls pbuf_custom->custom_free_function()
+    when the last reference is released (plus custom PBUF_RAM cannot be trimmed) */
+#define PBUF_FLAG_IS_CUSTOM 0x02U
+/** indicates this pbuf is UDP multicast to be looped back */
+#define PBUF_FLAG_MCASTLOOP 0x04U
+/** indicates this pbuf was received as link-level broadcast */
+#define PBUF_FLAG_LLBCAST   0x08U
+/** indicates this pbuf was received as link-level multicast */
+#define PBUF_FLAG_LLMCAST   0x10U
+/** indicates this pbuf includes a TCP FIN flag */
+#define PBUF_FLAG_TCP_FIN   0x20U
+
+/** Main packet buffer struct */
+struct pbuf {
+  /** next pbuf in singly linked pbuf chain */
+  struct pbuf *next;
+
+  /** pointer to the actual data in the buffer */
+  void *payload;
+
+  /**
+   * total length of this buffer and all next buffers in chain
+   * belonging to the same packet.
+   *
+   * For non-queue packet chains this is the invariant:
+   * p->tot_len == p->len + (p->next? p->next->tot_len: 0)
+   */
+  u16_t tot_len;
+
+  /** length of this buffer */
+  u16_t len;
+
+  /** pbuf_type as u8_t instead of enum to save space */
+  u8_t /*pbuf_type*/ type;
+
+  /** misc flags */
+  u8_t flags;
+
+  /**
+   * the reference count always equals the number of pointers
+   * that refer to this pbuf. This can be pointers from an application,
+   * the stack itself, or pbuf->next pointers from a chain.
+   */
+  u16_t ref;
+
+#if LWIP_PBUF_FROM_CUSTOM_POOLS
+  /** Pool from which pbuf was allocated */
+  u16_t pool;
+#endif
+};
+
+
+/** Helper struct for const-correctness only.
+ * The only meaning of this one is to provide a const payload pointer
+ * for PBUF_ROM type.
+ */
+struct pbuf_rom {
+  /** next pbuf in singly linked pbuf chain */
+  struct pbuf *next;
+
+  /** pointer to the actual data in the buffer */
+  const void *payload;
+};
+
+#if LWIP_SUPPORT_CUSTOM_PBUF
+/** Prototype for a function to free a custom pbuf */
+typedef void (*pbuf_free_custom_fn)(struct pbuf *p);
+
+/** A custom pbuf: like a pbuf, but following a function pointer to free it. */
+struct pbuf_custom {
+  /** The actual pbuf */
+  struct pbuf pbuf;
+  /** This function is called when pbuf_free deallocates this pbuf(_custom) */
+  pbuf_free_custom_fn custom_free_function;
+};
+#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
+
+/** Define this to 0 to prevent freeing ooseq pbufs when the PBUF_POOL is empty */
+#ifndef PBUF_POOL_FREE_OOSEQ
+#define PBUF_POOL_FREE_OOSEQ 1
+#endif /* PBUF_POOL_FREE_OOSEQ */
+#if LWIP_TCP && TCP_QUEUE_OOSEQ && NO_SYS && PBUF_POOL_FREE_OOSEQ
+extern volatile u8_t pbuf_free_ooseq_pending;
+void pbuf_free_ooseq(void);
+/** When not using sys_check_timeouts(), call PBUF_CHECK_FREE_OOSEQ()
+    at regular intervals from main level to check if ooseq pbufs need to be
+    freed! */
+#define PBUF_CHECK_FREE_OOSEQ() do { if(pbuf_free_ooseq_pending) { \
+  /* pbuf_alloc() reported PBUF_POOL to be empty -> try to free some \
+     ooseq queued pbufs now */ \
+  pbuf_free_ooseq(); }}while(0)
+#else /* LWIP_TCP && TCP_QUEUE_OOSEQ && NO_SYS && PBUF_POOL_FREE_OOSEQ */
+  /* Otherwise declare an empty PBUF_CHECK_FREE_OOSEQ */
+  #define PBUF_CHECK_FREE_OOSEQ()
+#endif /* LWIP_TCP && TCP_QUEUE_OOSEQ && NO_SYS && PBUF_POOL_FREE_OOSEQ*/
+
+/* Initializes the pbuf module. This call is empty for now, but may not be in future. */
+#define pbuf_init()
+
+struct pbuf *pbuf_alloc(pbuf_layer l, u16_t length, pbuf_type type);
+#if LWIP_SUPPORT_CUSTOM_PBUF
+struct pbuf *pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type,
+                                 struct pbuf_custom *p, void *payload_mem,
+                                 u16_t payload_mem_len);
+#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
+struct pbuf *pbuf_rightsize(struct pbuf *p, s16_t offset);
+void pbuf_realloc(struct pbuf *p, u16_t size);
+u8_t pbuf_header(struct pbuf *p, s16_t header_size);
+u8_t pbuf_header_force(struct pbuf *p, s16_t header_size);
+void pbuf_ref(struct pbuf *p);
+u8_t pbuf_free(struct pbuf *p);
+u16_t pbuf_clen(const struct pbuf *p);
+void pbuf_cat(struct pbuf *head, struct pbuf *tail);
+void pbuf_chain(struct pbuf *head, struct pbuf *tail);
+struct pbuf *pbuf_dechain(struct pbuf *p);
+err_t pbuf_copy(struct pbuf *p_to, const struct pbuf *p_from);
+u16_t pbuf_copy_partial(const struct pbuf *p, void *dataptr, u16_t len, u16_t offset);
+err_t pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len);
+err_t pbuf_take_at(struct pbuf *buf, const void *dataptr, u16_t len, u16_t offset);
+struct pbuf *pbuf_skip(struct pbuf* in, u16_t in_offset, u16_t* out_offset);
+struct pbuf *pbuf_coalesce(struct pbuf *p, pbuf_layer layer);
+#if LWIP_CHECKSUM_ON_COPY
+err_t pbuf_fill_chksum(struct pbuf *p, u16_t start_offset, const void *dataptr,
+                       u16_t len, u16_t *chksum);
+#endif /* LWIP_CHECKSUM_ON_COPY */
+#if LWIP_TCP && TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
+void pbuf_split_64k(struct pbuf *p, struct pbuf **rest);
+#endif /* LWIP_TCP && TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
+
+u8_t pbuf_get_at(const struct pbuf* p, u16_t offset);
+int pbuf_try_get_at(const struct pbuf* p, u16_t offset);
+void pbuf_put_at(struct pbuf* p, u16_t offset, u8_t data);
+u16_t pbuf_memcmp(const struct pbuf* p, u16_t offset, const void* s2, u16_t n);
+u16_t pbuf_memfind(const struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset);
+u16_t pbuf_strstr(const struct pbuf* p, const char* substr);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PBUF_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/priv/api_msg.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/priv/api_msg.h
new file mode 100644
index 000000000..f12b8b7d4
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/priv/api_msg.h
@@ -0,0 +1,216 @@
+/**
+ * @file
+ * netconn API lwIP internal implementations (do not use in application code)
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_API_MSG_H
+#define LWIP_HDR_API_MSG_H
+
+#include "lwip/opt.h"
+
+#if LWIP_NETCONN || LWIP_SOCKET /* don't build if not configured for use in lwipopts.h */
+/* Note: Netconn API is always available when sockets are enabled -
+ * sockets are implemented on top of them */
+
+#include "lwip/arch.h"
+#include "lwip/ip_addr.h"
+#include "lwip/err.h"
+#include "lwip/sys.h"
+#include "lwip/igmp.h"
+#include "lwip/api.h"
+#include "lwip/priv/tcpip_priv.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_MPU_COMPATIBLE
+#if LWIP_NETCONN_SEM_PER_THREAD
+#define API_MSG_M_DEF_SEM(m)  *m
+#else
+#define API_MSG_M_DEF_SEM(m)  API_MSG_M_DEF(m)
+#endif
+#else /* LWIP_MPU_COMPATIBLE */
+#define API_MSG_M_DEF_SEM(m)  API_MSG_M_DEF(m)
+#endif /* LWIP_MPU_COMPATIBLE */
+
+/* For the netconn API, these values are use as a bitmask! */
+#define NETCONN_SHUT_RD   1
+#define NETCONN_SHUT_WR   2
+#define NETCONN_SHUT_RDWR (NETCONN_SHUT_RD | NETCONN_SHUT_WR)
+
+/* IP addresses and port numbers are expected to be in
+ * the same byte order as in the corresponding pcb.
+ */
+/** This struct includes everything that is necessary to execute a function
+    for a netconn in another thread context (mainly used to process netconns
+    in the tcpip_thread context to be thread safe). */
+struct api_msg {
+  /** The netconn which to process - always needed: it includes the semaphore
+      which is used to block the application thread until the function finished. */
+  struct netconn *conn;
+  /** The return value of the function executed in tcpip_thread. */
+  err_t err;
+  /** Depending on the executed function, one of these union members is used */
+  union {
+    /** used for lwip_netconn_do_send */
+    struct netbuf *b;
+    /** used for lwip_netconn_do_newconn */
+    struct {
+      u8_t proto;
+    } n;
+    /** used for lwip_netconn_do_bind and lwip_netconn_do_connect */
+    struct {
+      API_MSG_M_DEF_C(ip_addr_t, ipaddr);
+      u16_t port;
+    } bc;
+    /** used for lwip_netconn_do_getaddr */
+    struct {
+      ip_addr_t API_MSG_M_DEF(ipaddr);
+      u16_t API_MSG_M_DEF(port);
+      u8_t local;
+    } ad;
+    /** used for lwip_netconn_do_write */
+    struct {
+      const void *dataptr;
+      size_t len;
+      u8_t apiflags;
+#if LWIP_SO_SNDTIMEO
+      u32_t time_started;
+#endif /* LWIP_SO_SNDTIMEO */
+    } w;
+    /** used for lwip_netconn_do_recv */
+    struct {
+      u32_t len;
+    } r;
+#if LWIP_TCP
+    /** used for lwip_netconn_do_close (/shutdown) */
+    struct {
+      u8_t shut;
+#if LWIP_SO_SNDTIMEO || LWIP_SO_LINGER
+      u32_t time_started;
+#else /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
+      u8_t polls_left;
+#endif /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
+    } sd;
+#endif /* LWIP_TCP */
+#if LWIP_IGMP || (LWIP_IPV6 && LWIP_IPV6_MLD)
+    /** used for lwip_netconn_do_join_leave_group */
+    struct {
+      API_MSG_M_DEF_C(ip_addr_t, multiaddr);
+      API_MSG_M_DEF_C(ip_addr_t, netif_addr);
+      enum netconn_igmp join_or_leave;
+    } jl;
+#endif /* LWIP_IGMP || (LWIP_IPV6 && LWIP_IPV6_MLD) */
+#if TCP_LISTEN_BACKLOG
+    struct {
+      u8_t backlog;
+    } lb;
+#endif /* TCP_LISTEN_BACKLOG */
+  } msg;
+#if LWIP_NETCONN_SEM_PER_THREAD
+  sys_sem_t* op_completed_sem;
+#endif /* LWIP_NETCONN_SEM_PER_THREAD */
+};
+
+#if LWIP_NETCONN_SEM_PER_THREAD
+#define LWIP_API_MSG_SEM(msg)          ((msg)->op_completed_sem)
+#else /* LWIP_NETCONN_SEM_PER_THREAD */
+#define LWIP_API_MSG_SEM(msg)          (&(msg)->conn->op_completed)
+#endif /* LWIP_NETCONN_SEM_PER_THREAD */
+
+
+#if LWIP_DNS
+/** As lwip_netconn_do_gethostbyname requires more arguments but doesn't require a netconn,
+    it has its own struct (to avoid struct api_msg getting bigger than necessary).
+    lwip_netconn_do_gethostbyname must be called using tcpip_callback instead of tcpip_apimsg
+    (see netconn_gethostbyname). */
+struct dns_api_msg {
+  /** Hostname to query or dotted IP address string */
+#if LWIP_MPU_COMPATIBLE
+  char name[DNS_MAX_NAME_LENGTH];
+#else /* LWIP_MPU_COMPATIBLE */
+  const char *name;
+#endif /* LWIP_MPU_COMPATIBLE */
+  /** The resolved address is stored here */
+  ip_addr_t API_MSG_M_DEF(addr);
+#if LWIP_IPV4 && LWIP_IPV6
+  /** Type of resolve call */
+  u8_t dns_addrtype;
+#endif /* LWIP_IPV4 && LWIP_IPV6 */
+  /** This semaphore is posted when the name is resolved, the application thread
+      should wait on it. */
+  sys_sem_t API_MSG_M_DEF_SEM(sem);
+  /** Errors are given back here */
+  err_t API_MSG_M_DEF(err);
+};
+#endif /* LWIP_DNS */
+
+#if LWIP_TCP
+extern u8_t netconn_aborted;
+#endif /* LWIP_TCP */
+
+void lwip_netconn_do_newconn         (void *m);
+void lwip_netconn_do_delconn         (void *m);
+void lwip_netconn_do_bind            (void *m);
+void lwip_netconn_do_connect         (void *m);
+void lwip_netconn_do_disconnect      (void *m);
+void lwip_netconn_do_listen          (void *m);
+void lwip_netconn_do_send            (void *m);
+void lwip_netconn_do_recv            (void *m);
+#if TCP_LISTEN_BACKLOG
+void lwip_netconn_do_accepted        (void *m);
+#endif /* TCP_LISTEN_BACKLOG */
+void lwip_netconn_do_write           (void *m);
+void lwip_netconn_do_getaddr         (void *m);
+void lwip_netconn_do_close           (void *m);
+void lwip_netconn_do_shutdown        (void *m);
+#if LWIP_IGMP || (LWIP_IPV6 && LWIP_IPV6_MLD)
+void lwip_netconn_do_join_leave_group(void *m);
+#endif /* LWIP_IGMP || (LWIP_IPV6 && LWIP_IPV6_MLD) */
+
+#if LWIP_DNS
+void lwip_netconn_do_gethostbyname(void *arg);
+#endif /* LWIP_DNS */
+
+struct netconn* netconn_alloc(enum netconn_type t, netconn_callback callback);
+void netconn_free(struct netconn *conn);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_NETCONN || LWIP_SOCKET */
+
+#endif /* LWIP_HDR_API_MSG_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/priv/memp_priv.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/priv/memp_priv.h
new file mode 100644
index 000000000..f246061da
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/priv/memp_priv.h
@@ -0,0 +1,183 @@
+/**
+ * @file
+ * memory pools lwIP internal implementations (do not use in application code)
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+#ifndef LWIP_HDR_MEMP_PRIV_H
+#define LWIP_HDR_MEMP_PRIV_H
+
+#include "lwip/opt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "lwip/mem.h"
+
+#if MEMP_OVERFLOW_CHECK
+/* if MEMP_OVERFLOW_CHECK is turned on, we reserve some bytes at the beginning
+ * and at the end of each element, initialize them as 0xcd and check
+ * them later. */
+/* If MEMP_OVERFLOW_CHECK is >= 2, on every call to memp_malloc or memp_free,
+ * every single element in each pool is checked!
+ * This is VERY SLOW but also very helpful. */
+/* MEMP_SANITY_REGION_BEFORE and MEMP_SANITY_REGION_AFTER can be overridden in
+ * lwipopts.h to change the amount reserved for checking. */
+#ifndef MEMP_SANITY_REGION_BEFORE
+#define MEMP_SANITY_REGION_BEFORE  16
+#endif /* MEMP_SANITY_REGION_BEFORE*/
+#if MEMP_SANITY_REGION_BEFORE > 0
+#define MEMP_SANITY_REGION_BEFORE_ALIGNED    LWIP_MEM_ALIGN_SIZE(MEMP_SANITY_REGION_BEFORE)
+#else
+#define MEMP_SANITY_REGION_BEFORE_ALIGNED    0
+#endif /* MEMP_SANITY_REGION_BEFORE*/
+#ifndef MEMP_SANITY_REGION_AFTER
+#define MEMP_SANITY_REGION_AFTER   16
+#endif /* MEMP_SANITY_REGION_AFTER*/
+#if MEMP_SANITY_REGION_AFTER > 0
+#define MEMP_SANITY_REGION_AFTER_ALIGNED     LWIP_MEM_ALIGN_SIZE(MEMP_SANITY_REGION_AFTER)
+#else
+#define MEMP_SANITY_REGION_AFTER_ALIGNED     0
+#endif /* MEMP_SANITY_REGION_AFTER*/
+
+/* MEMP_SIZE: save space for struct memp and for sanity check */
+#define MEMP_SIZE          (LWIP_MEM_ALIGN_SIZE(sizeof(struct memp)) + MEMP_SANITY_REGION_BEFORE_ALIGNED)
+#define MEMP_ALIGN_SIZE(x) (LWIP_MEM_ALIGN_SIZE(x) + MEMP_SANITY_REGION_AFTER_ALIGNED)
+
+#else /* MEMP_OVERFLOW_CHECK */
+
+/* No sanity checks
+ * We don't need to preserve the struct memp while not allocated, so we
+ * can save a little space and set MEMP_SIZE to 0.
+ */
+#define MEMP_SIZE           0
+#define MEMP_ALIGN_SIZE(x) (LWIP_MEM_ALIGN_SIZE(x))
+
+#endif /* MEMP_OVERFLOW_CHECK */
+
+#if !MEMP_MEM_MALLOC || MEMP_OVERFLOW_CHECK
+struct memp {
+  struct memp *next;
+#if MEMP_OVERFLOW_CHECK
+  const char *file;
+  int line;
+#endif /* MEMP_OVERFLOW_CHECK */
+};
+#endif /* !MEMP_MEM_MALLOC || MEMP_OVERFLOW_CHECK */
+
+#if MEM_USE_POOLS && MEMP_USE_CUSTOM_POOLS
+/* Use a helper type to get the start and end of the user "memory pools" for mem_malloc */
+typedef enum {
+    /* Get the first (via:
+       MEMP_POOL_HELPER_START = ((u8_t) 1*MEMP_POOL_A + 0*MEMP_POOL_B + 0*MEMP_POOL_C + 0)*/
+    MEMP_POOL_HELPER_FIRST = ((u8_t)
+#define LWIP_MEMPOOL(name,num,size,desc)
+#define LWIP_MALLOC_MEMPOOL_START 1
+#define LWIP_MALLOC_MEMPOOL(num, size) * MEMP_POOL_##size + 0
+#define LWIP_MALLOC_MEMPOOL_END
+#include "lwip/priv/memp_std.h"
+    ) ,
+    /* Get the last (via:
+       MEMP_POOL_HELPER_END = ((u8_t) 0 + MEMP_POOL_A*0 + MEMP_POOL_B*0 + MEMP_POOL_C*1) */
+    MEMP_POOL_HELPER_LAST = ((u8_t)
+#define LWIP_MEMPOOL(name,num,size,desc)
+#define LWIP_MALLOC_MEMPOOL_START
+#define LWIP_MALLOC_MEMPOOL(num, size) 0 + MEMP_POOL_##size *
+#define LWIP_MALLOC_MEMPOOL_END 1
+#include "lwip/priv/memp_std.h"
+    )
+} memp_pool_helper_t;
+
+/* The actual start and stop values are here (cast them over)
+   We use this helper type and these defines so we can avoid using const memp_t values */
+#define MEMP_POOL_FIRST ((memp_t) MEMP_POOL_HELPER_FIRST)
+#define MEMP_POOL_LAST   ((memp_t) MEMP_POOL_HELPER_LAST)
+#endif /* MEM_USE_POOLS && MEMP_USE_CUSTOM_POOLS */
+
+/** Memory pool descriptor */
+struct memp_desc {
+#if defined(LWIP_DEBUG) || MEMP_OVERFLOW_CHECK || LWIP_STATS_DISPLAY
+  /** Textual description */
+  const char *desc;
+#endif /* LWIP_DEBUG || MEMP_OVERFLOW_CHECK || LWIP_STATS_DISPLAY */
+#if MEMP_STATS
+  /** Statistics */
+  struct stats_mem *stats;
+#endif
+
+  /** Element size */
+  u16_t size;
+
+#if !MEMP_MEM_MALLOC
+  /** Number of elements */
+  u16_t num;
+
+  /** Base address */
+  u8_t *base;
+
+  /** First free element of each pool. Elements form a linked list. */
+  struct memp **tab;
+#endif /* MEMP_MEM_MALLOC */
+};
+
+#if defined(LWIP_DEBUG) || MEMP_OVERFLOW_CHECK || LWIP_STATS_DISPLAY
+#define DECLARE_LWIP_MEMPOOL_DESC(desc) (desc),
+#else
+#define DECLARE_LWIP_MEMPOOL_DESC(desc)
+#endif
+
+#if MEMP_STATS
+#define LWIP_MEMPOOL_DECLARE_STATS_INSTANCE(name) static struct stats_mem name;
+#define LWIP_MEMPOOL_DECLARE_STATS_REFERENCE(name) &name,
+#else
+#define LWIP_MEMPOOL_DECLARE_STATS_INSTANCE(name)
+#define LWIP_MEMPOOL_DECLARE_STATS_REFERENCE(name)
+#endif
+
+void memp_init_pool(const struct memp_desc *desc);
+
+#if MEMP_OVERFLOW_CHECK
+void *memp_malloc_pool_fn(const struct memp_desc* desc, const char* file, const int line);
+#define memp_malloc_pool(d) memp_malloc_pool_fn((d), __FILE__, __LINE__)
+#else
+void *memp_malloc_pool(const struct memp_desc *desc);
+#endif
+void  memp_free_pool(const struct memp_desc* desc, void *mem);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_MEMP_PRIV_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/priv/memp_std.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/priv/memp_std.h
new file mode 100644
index 000000000..d39106744
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/priv/memp_std.h
@@ -0,0 +1,146 @@
+/**
+ * @file
+ * lwIP internal memory pools (do not use in application code)
+ * This file is deliberately included multiple times: once with empty
+ * definition of LWIP_MEMPOOL() to handle all includes and multiple times
+ * to build up various lists of mem pools.
+ */
+
+/*
+ * SETUP: Make sure we define everything we will need.
+ *
+ * We have create three types of pools:
+ *   1) MEMPOOL - standard pools
+ *   2) MALLOC_MEMPOOL - to be used by mem_malloc in mem.c
+ *   3) PBUF_MEMPOOL - a mempool of pbuf's, so include space for the pbuf struct
+ *
+ * If the include'r doesn't require any special treatment of each of the types
+ * above, then will declare #2 & #3 to be just standard mempools.
+ */
+#ifndef LWIP_MALLOC_MEMPOOL
+/* This treats "malloc pools" just like any other pool.
+   The pools are a little bigger to provide 'size' as the amount of user data. */
+#define LWIP_MALLOC_MEMPOOL(num, size) LWIP_MEMPOOL(POOL_##size, num, (size + LWIP_MEM_ALIGN_SIZE(sizeof(struct memp_malloc_helper))), "MALLOC_"#size)
+#define LWIP_MALLOC_MEMPOOL_START
+#define LWIP_MALLOC_MEMPOOL_END
+#endif /* LWIP_MALLOC_MEMPOOL */
+
+#ifndef LWIP_PBUF_MEMPOOL
+/* This treats "pbuf pools" just like any other pool.
+ * Allocates buffers for a pbuf struct AND a payload size */
+#define LWIP_PBUF_MEMPOOL(name, num, payload, desc) LWIP_MEMPOOL(name, num, (MEMP_ALIGN_SIZE(sizeof(struct pbuf)) + MEMP_ALIGN_SIZE(payload)), desc)
+#endif /* LWIP_PBUF_MEMPOOL */
+
+
+/*
+ * A list of internal pools used by LWIP.
+ *
+ * LWIP_MEMPOOL(pool_name, number_elements, element_size, pool_description)
+ *     creates a pool name MEMP_pool_name. description is used in stats.c
+ */
+#if LWIP_RAW
+LWIP_MEMPOOL(RAW_PCB,        MEMP_NUM_RAW_PCB,         sizeof(struct raw_pcb),        "RAW_PCB")
+#endif /* LWIP_RAW */
+
+#if LWIP_UDP
+LWIP_MEMPOOL(UDP_PCB,        MEMP_NUM_UDP_PCB,         sizeof(struct udp_pcb),        "UDP_PCB")
+#endif /* LWIP_UDP */
+
+#if LWIP_TCP
+LWIP_MEMPOOL(TCP_PCB,        MEMP_NUM_TCP_PCB,         sizeof(struct tcp_pcb),        "TCP_PCB")
+LWIP_MEMPOOL(TCP_PCB_LISTEN, MEMP_NUM_TCP_PCB_LISTEN,  sizeof(struct tcp_pcb_listen), "TCP_PCB_LISTEN")
+LWIP_MEMPOOL(TCP_SEG,        MEMP_NUM_TCP_SEG,         sizeof(struct tcp_seg),        "TCP_SEG")
+#endif /* LWIP_TCP */
+
+#if LWIP_IPV4 && IP_REASSEMBLY
+LWIP_MEMPOOL(REASSDATA,      MEMP_NUM_REASSDATA,       sizeof(struct ip_reassdata),   "REASSDATA")
+#endif /* LWIP_IPV4 && IP_REASSEMBLY */
+#if (IP_FRAG && !LWIP_NETIF_TX_SINGLE_PBUF) || (LWIP_IPV6 && LWIP_IPV6_FRAG)
+LWIP_MEMPOOL(FRAG_PBUF,      MEMP_NUM_FRAG_PBUF,       sizeof(struct pbuf_custom_ref),"FRAG_PBUF")
+#endif /* IP_FRAG && !LWIP_NETIF_TX_SINGLE_PBUF || (LWIP_IPV6 && LWIP_IPV6_FRAG) */
+
+#if LWIP_NETCONN || LWIP_SOCKET
+LWIP_MEMPOOL(NETBUF,         MEMP_NUM_NETBUF,          sizeof(struct netbuf),         "NETBUF")
+LWIP_MEMPOOL(NETCONN,        MEMP_NUM_NETCONN,         sizeof(struct netconn),        "NETCONN")
+#endif /* LWIP_NETCONN || LWIP_SOCKET */
+
+#if NO_SYS==0
+LWIP_MEMPOOL(TCPIP_MSG_API,  MEMP_NUM_TCPIP_MSG_API,   sizeof(struct tcpip_msg),      "TCPIP_MSG_API")
+#if LWIP_MPU_COMPATIBLE
+LWIP_MEMPOOL(API_MSG,        MEMP_NUM_API_MSG,         sizeof(struct api_msg),        "API_MSG")
+#if LWIP_DNS
+LWIP_MEMPOOL(DNS_API_MSG,    MEMP_NUM_DNS_API_MSG,     sizeof(struct dns_api_msg),    "DNS_API_MSG")
+#endif
+#if LWIP_SOCKET && !LWIP_TCPIP_CORE_LOCKING
+LWIP_MEMPOOL(SOCKET_SETGETSOCKOPT_DATA, MEMP_NUM_SOCKET_SETGETSOCKOPT_DATA, sizeof(struct lwip_setgetsockopt_data), "SOCKET_SETGETSOCKOPT_DATA")
+#endif
+#if LWIP_NETIF_API
+LWIP_MEMPOOL(NETIFAPI_MSG,   MEMP_NUM_NETIFAPI_MSG,    sizeof(struct netifapi_msg),   "NETIFAPI_MSG")
+#endif
+#endif /* LWIP_MPU_COMPATIBLE */
+#if !LWIP_TCPIP_CORE_LOCKING_INPUT
+LWIP_MEMPOOL(TCPIP_MSG_INPKT,MEMP_NUM_TCPIP_MSG_INPKT, sizeof(struct tcpip_msg),      "TCPIP_MSG_INPKT")
+#endif /* !LWIP_TCPIP_CORE_LOCKING_INPUT */
+#endif /* NO_SYS==0 */
+
+#if LWIP_IPV4 && LWIP_ARP && ARP_QUEUEING
+LWIP_MEMPOOL(ARP_QUEUE,      MEMP_NUM_ARP_QUEUE,       sizeof(struct etharp_q_entry), "ARP_QUEUE")
+#endif /* LWIP_IPV4 && LWIP_ARP && ARP_QUEUEING */
+
+#if LWIP_IGMP
+LWIP_MEMPOOL(IGMP_GROUP,     MEMP_NUM_IGMP_GROUP,      sizeof(struct igmp_group),     "IGMP_GROUP")
+#endif /* LWIP_IGMP */
+
+#if LWIP_TIMERS && !LWIP_TIMERS_CUSTOM
+LWIP_MEMPOOL(SYS_TIMEOUT,    MEMP_NUM_SYS_TIMEOUT,     sizeof(struct sys_timeo),      "SYS_TIMEOUT")
+#endif /* LWIP_TIMERS && !LWIP_TIMERS_CUSTOM */
+
+#if LWIP_DNS && LWIP_SOCKET
+LWIP_MEMPOOL(NETDB,          MEMP_NUM_NETDB,           NETDB_ELEM_SIZE,               "NETDB")
+#endif /* LWIP_DNS && LWIP_SOCKET */
+#if LWIP_DNS && DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC
+LWIP_MEMPOOL(LOCALHOSTLIST,  MEMP_NUM_LOCALHOSTLIST,   LOCALHOSTLIST_ELEM_SIZE,       "LOCALHOSTLIST")
+#endif /* LWIP_DNS && DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
+
+#if LWIP_IPV6 && LWIP_ND6_QUEUEING
+LWIP_MEMPOOL(ND6_QUEUE,      MEMP_NUM_ND6_QUEUE,       sizeof(struct nd6_q_entry), "ND6_QUEUE")
+#endif /* LWIP_IPV6 && LWIP_ND6_QUEUEING */
+
+#if LWIP_IPV6 && LWIP_IPV6_REASS
+LWIP_MEMPOOL(IP6_REASSDATA,      MEMP_NUM_REASSDATA,       sizeof(struct ip6_reassdata),   "IP6_REASSDATA")
+#endif /* LWIP_IPV6 && LWIP_IPV6_REASS */
+
+#if LWIP_IPV6 && LWIP_IPV6_ND && LWIP_IPV6_MLD
+LWIP_MEMPOOL(MLD6_GROUP,     MEMP_NUM_MLD6_GROUP,      sizeof(struct mld_group),     "MLD6_GROUP")
+#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
+
+
+/*
+ * A list of pools of pbuf's used by LWIP.
+ *
+ * LWIP_PBUF_MEMPOOL(pool_name, number_elements, pbuf_payload_size, pool_description)
+ *     creates a pool name MEMP_pool_name. description is used in stats.c
+ *     This allocates enough space for the pbuf struct and a payload.
+ *     (Example: pbuf_payload_size=0 allocates only size for the struct)
+ */
+LWIP_PBUF_MEMPOOL(PBUF,      MEMP_NUM_PBUF,            0,                             "PBUF_REF/ROM")
+LWIP_PBUF_MEMPOOL(PBUF_POOL, PBUF_POOL_SIZE,           PBUF_POOL_BUFSIZE,             "PBUF_POOL")
+
+
+/*
+ * Allow for user-defined pools; this must be explicitly set in lwipopts.h
+ * since the default is to NOT look for lwippools.h
+ */
+#if MEMP_USE_CUSTOM_POOLS
+#include "lwippools.h"
+#endif /* MEMP_USE_CUSTOM_POOLS */
+
+/*
+ * REQUIRED CLEANUP: Clear up so we don't get "multiply defined" error later
+ * (#undef is ignored for something that is not defined)
+ */
+#undef LWIP_MEMPOOL
+#undef LWIP_MALLOC_MEMPOOL
+#undef LWIP_MALLOC_MEMPOOL_START
+#undef LWIP_MALLOC_MEMPOOL_END
+#undef LWIP_PBUF_MEMPOOL
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/priv/nd6_priv.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/priv/nd6_priv.h
new file mode 100644
index 000000000..5d7731ca9
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/priv/nd6_priv.h
@@ -0,0 +1,140 @@
+/**
+ * @file
+ *
+ * Neighbor discovery and stateless address autoconfiguration for IPv6.
+ * Aims to be compliant with RFC 4861 (Neighbor discovery) and RFC 4862
+ * (Address autoconfiguration).
+ */
+
+/*
+ * Copyright (c) 2010 Inico Technologies Ltd.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Ivan Delamer <delamer@inicotech.com>
+ *
+ *
+ * Please coordinate changes and requests with Ivan Delamer
+ * <delamer@inicotech.com>
+ */
+
+#ifndef LWIP_HDR_ND6_PRIV_H
+#define LWIP_HDR_ND6_PRIV_H
+
+#include "lwip/opt.h"
+
+#if LWIP_IPV6  /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/pbuf.h"
+#include "lwip/ip6_addr.h"
+#include "lwip/netif.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_ND6_QUEUEING
+/** struct for queueing outgoing packets for unknown address
+  * defined here to be accessed by memp.h
+  */
+struct nd6_q_entry {
+  struct nd6_q_entry *next;
+  struct pbuf *p;
+};
+#endif /* LWIP_ND6_QUEUEING */
+
+/** Struct for tables. */
+struct nd6_neighbor_cache_entry {
+  ip6_addr_t next_hop_address;
+  struct netif *netif;
+  u8_t lladdr[NETIF_MAX_HWADDR_LEN];
+  /*u32_t pmtu;*/
+#if LWIP_ND6_QUEUEING
+  /** Pointer to queue of pending outgoing packets on this entry. */
+  struct nd6_q_entry *q;
+#else /* LWIP_ND6_QUEUEING */
+  /** Pointer to a single pending outgoing packet on this entry. */
+  struct pbuf *q;
+#endif /* LWIP_ND6_QUEUEING */
+  u8_t state;
+  u8_t isrouter;
+  union {
+    u32_t reachable_time; /* in seconds */
+    u32_t delay_time;     /* ticks (ND6_TMR_INTERVAL) */
+    u32_t probes_sent;
+    u32_t stale_time;     /* ticks (ND6_TMR_INTERVAL) */
+  } counter;
+};
+
+struct nd6_destination_cache_entry {
+  ip6_addr_t destination_addr;
+  ip6_addr_t next_hop_addr;
+  u16_t pmtu;
+  u32_t age;
+};
+
+struct nd6_prefix_list_entry {
+  ip6_addr_t prefix;
+  struct netif *netif;
+  u32_t invalidation_timer; /* in seconds */
+};
+
+struct nd6_router_list_entry {
+  struct nd6_neighbor_cache_entry *neighbor_entry;
+  u32_t invalidation_timer; /* in seconds */
+  u8_t flags;
+};
+
+enum nd6_neighbor_cache_entry_state {
+  ND6_NO_ENTRY = 0,
+  ND6_INCOMPLETE,
+  ND6_REACHABLE,
+  ND6_STALE,
+  ND6_DELAY,
+  ND6_PROBE
+};
+
+#define ND6_2HRS 7200 /* two hours, expressed in number of seconds */
+
+/* Router tables. */
+/* @todo make these static? and entries accessible through API? */
+extern struct nd6_neighbor_cache_entry neighbor_cache[];
+extern struct nd6_destination_cache_entry destination_cache[];
+extern struct nd6_prefix_list_entry prefix_list[];
+extern struct nd6_router_list_entry default_router_list[];
+
+/* Default values, can be updated by a RA message. */
+extern u32_t reachable_time;
+extern u32_t retrans_timer;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_IPV6 */
+
+#endif /* LWIP_HDR_ND6_PRIV_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/priv/tcp_priv.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/priv/tcp_priv.h
new file mode 100644
index 000000000..73e8967e4
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/priv/tcp_priv.h
@@ -0,0 +1,507 @@
+/**
+ * @file
+ * TCP internal implementations (do not use in application code)
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_TCP_PRIV_H
+#define LWIP_HDR_TCP_PRIV_H
+
+#include "lwip/opt.h"
+
+#if LWIP_TCP /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/tcp.h"
+#include "lwip/mem.h"
+#include "lwip/pbuf.h"
+#include "lwip/ip.h"
+#include "lwip/icmp.h"
+#include "lwip/err.h"
+#include "lwip/ip6.h"
+#include "lwip/ip6_addr.h"
+#include "lwip/prot/tcp.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Functions for interfacing with TCP: */
+
+/* Lower layer interface to TCP: */
+void             tcp_init    (void);  /* Initialize this module. */
+void             tcp_tmr     (void);  /* Must be called every
+                                         TCP_TMR_INTERVAL
+                                         ms. (Typically 250 ms). */
+/* It is also possible to call these two functions at the right
+   intervals (instead of calling tcp_tmr()). */
+void             tcp_slowtmr (void);
+void             tcp_fasttmr (void);
+
+/* Call this from a netif driver (watch out for threading issues!) that has
+   returned a memory error on transmit and now has free buffers to send more.
+   This iterates all active pcbs that had an error and tries to call
+   tcp_output, so use this with care as it might slow down the system. */
+void             tcp_txnow   (void);
+
+/* Only used by IP to pass a TCP segment to TCP: */
+void             tcp_input   (struct pbuf *p, struct netif *inp);
+/* Used within the TCP code only: */
+struct tcp_pcb * tcp_alloc   (u8_t prio);
+void             tcp_abandon (struct tcp_pcb *pcb, int reset);
+err_t            tcp_send_empty_ack(struct tcp_pcb *pcb);
+void             tcp_rexmit  (struct tcp_pcb *pcb);
+void             tcp_rexmit_rto  (struct tcp_pcb *pcb);
+void             tcp_rexmit_fast (struct tcp_pcb *pcb);
+u32_t            tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb);
+err_t            tcp_process_refused_data(struct tcp_pcb *pcb);
+
+/**
+ * This is the Nagle algorithm: try to combine user data to send as few TCP
+ * segments as possible. Only send if
+ * - no previously transmitted data on the connection remains unacknowledged or
+ * - the TF_NODELAY flag is set (nagle algorithm turned off for this pcb) or
+ * - the only unsent segment is at least pcb->mss bytes long (or there is more
+ *   than one unsent segment - with lwIP, this can happen although unsent->len < mss)
+ * - or if we are in fast-retransmit (TF_INFR)
+ */
+#define tcp_do_output_nagle(tpcb) ((((tpcb)->unacked == NULL) || \
+                            ((tpcb)->flags & (TF_NODELAY | TF_INFR)) || \
+                            (((tpcb)->unsent != NULL) && (((tpcb)->unsent->next != NULL) || \
+                              ((tpcb)->unsent->len >= (tpcb)->mss))) || \
+                            ((tcp_sndbuf(tpcb) == 0) || (tcp_sndqueuelen(tpcb) >= TCP_SND_QUEUELEN)) \
+                            ) ? 1 : 0)
+#define tcp_output_nagle(tpcb) (tcp_do_output_nagle(tpcb) ? tcp_output(tpcb) : ERR_OK)
+
+
+#define TCP_SEQ_LT(a,b)     ((s32_t)((u32_t)(a) - (u32_t)(b)) < 0)
+#define TCP_SEQ_LEQ(a,b)    ((s32_t)((u32_t)(a) - (u32_t)(b)) <= 0)
+#define TCP_SEQ_GT(a,b)     ((s32_t)((u32_t)(a) - (u32_t)(b)) > 0)
+#define TCP_SEQ_GEQ(a,b)    ((s32_t)((u32_t)(a) - (u32_t)(b)) >= 0)
+/* is b<=a<=c? */
+#if 0 /* see bug #10548 */
+#define TCP_SEQ_BETWEEN(a,b,c) ((c)-(b) >= (a)-(b))
+#endif
+#define TCP_SEQ_BETWEEN(a,b,c) (TCP_SEQ_GEQ(a,b) && TCP_SEQ_LEQ(a,c))
+
+#ifndef TCP_TMR_INTERVAL
+#define TCP_TMR_INTERVAL       250  /* The TCP timer interval in milliseconds. */
+#endif /* TCP_TMR_INTERVAL */
+
+#ifndef TCP_FAST_INTERVAL
+#define TCP_FAST_INTERVAL      TCP_TMR_INTERVAL /* the fine grained timeout in milliseconds */
+#endif /* TCP_FAST_INTERVAL */
+
+#ifndef TCP_SLOW_INTERVAL
+#define TCP_SLOW_INTERVAL      (2*TCP_TMR_INTERVAL)  /* the coarse grained timeout in milliseconds */
+#endif /* TCP_SLOW_INTERVAL */
+
+#define TCP_FIN_WAIT_TIMEOUT 20000 /* milliseconds */
+#define TCP_SYN_RCVD_TIMEOUT 20000 /* milliseconds */
+
+#define TCP_OOSEQ_TIMEOUT        6U /* x RTO */
+
+#ifndef TCP_MSL
+#define TCP_MSL 60000UL /* The maximum segment lifetime in milliseconds */
+#endif
+
+/* Keepalive values, compliant with RFC 1122. Don't change this unless you know what you're doing */
+#ifndef  TCP_KEEPIDLE_DEFAULT
+#define  TCP_KEEPIDLE_DEFAULT     7200000UL /* Default KEEPALIVE timer in milliseconds */
+#endif
+
+#ifndef  TCP_KEEPINTVL_DEFAULT
+#define  TCP_KEEPINTVL_DEFAULT    75000UL   /* Default Time between KEEPALIVE probes in milliseconds */
+#endif
+
+#ifndef  TCP_KEEPCNT_DEFAULT
+#define  TCP_KEEPCNT_DEFAULT      9U        /* Default Counter for KEEPALIVE probes */
+#endif
+
+#define  TCP_MAXIDLE              TCP_KEEPCNT_DEFAULT * TCP_KEEPINTVL_DEFAULT  /* Maximum KEEPALIVE probe time */
+
+#define TCP_TCPLEN(seg) ((seg)->len + (((TCPH_FLAGS((seg)->tcphdr) & (TCP_FIN | TCP_SYN)) != 0) ? 1U : 0U))
+
+/** Flags used on input processing, not on pcb->flags
+*/
+#define TF_RESET     (u8_t)0x08U   /* Connection was reset. */
+#define TF_CLOSED    (u8_t)0x10U   /* Connection was successfully closed. */
+#define TF_GOT_FIN   (u8_t)0x20U   /* Connection was closed by the remote end. */
+
+
+#if LWIP_EVENT_API
+
+#define TCP_EVENT_ACCEPT(lpcb,pcb,arg,err,ret) ret = lwip_tcp_event(arg, (pcb),\
+                LWIP_EVENT_ACCEPT, NULL, 0, err)
+#define TCP_EVENT_SENT(pcb,space,ret) ret = lwip_tcp_event((pcb)->callback_arg, (pcb),\
+                   LWIP_EVENT_SENT, NULL, space, ERR_OK)
+#define TCP_EVENT_RECV(pcb,p,err,ret) ret = lwip_tcp_event((pcb)->callback_arg, (pcb),\
+                LWIP_EVENT_RECV, (p), 0, (err))
+#define TCP_EVENT_CLOSED(pcb,ret) ret = lwip_tcp_event((pcb)->callback_arg, (pcb),\
+                LWIP_EVENT_RECV, NULL, 0, ERR_OK)
+#define TCP_EVENT_CONNECTED(pcb,err,ret) ret = lwip_tcp_event((pcb)->callback_arg, (pcb),\
+                LWIP_EVENT_CONNECTED, NULL, 0, (err))
+#define TCP_EVENT_POLL(pcb,ret)       do { if ((pcb)->state != SYN_RCVD) {                          \
+                ret = lwip_tcp_event((pcb)->callback_arg, (pcb), LWIP_EVENT_POLL, NULL, 0, ERR_OK); \
+                } else {                                                                            \
+                ret = ERR_ARG; } } while(0)
+#define TCP_EVENT_ERR(last_state,errf,arg,err)  do { if (last_state != SYN_RCVD) {                \
+                lwip_tcp_event((arg), NULL, LWIP_EVENT_ERR, NULL, 0, (err)); } } while(0)
+
+#else /* LWIP_EVENT_API */
+
+#define TCP_EVENT_ACCEPT(lpcb,pcb,arg,err,ret)                 \
+  do {                                                         \
+    if((lpcb)->accept != NULL)                                 \
+      (ret) = (lpcb)->accept((arg),(pcb),(err));               \
+    else (ret) = ERR_ARG;                                      \
+  } while (0)
+
+#define TCP_EVENT_SENT(pcb,space,ret)                          \
+  do {                                                         \
+    if((pcb)->sent != NULL)                                    \
+      (ret) = (pcb)->sent((pcb)->callback_arg,(pcb),(space));  \
+    else (ret) = ERR_OK;                                       \
+  } while (0)
+
+#define TCP_EVENT_RECV(pcb,p,err,ret)                          \
+  do {                                                         \
+    if((pcb)->recv != NULL) {                                  \
+      (ret) = (pcb)->recv((pcb)->callback_arg,(pcb),(p),(err));\
+    } else {                                                   \
+      (ret) = tcp_recv_null(NULL, (pcb), (p), (err));          \
+    }                                                          \
+  } while (0)
+
+#define TCP_EVENT_CLOSED(pcb,ret)                                \
+  do {                                                           \
+    if(((pcb)->recv != NULL)) {                                  \
+      (ret) = (pcb)->recv((pcb)->callback_arg,(pcb),NULL,ERR_OK);\
+    } else {                                                     \
+      (ret) = ERR_OK;                                            \
+    }                                                            \
+  } while (0)
+
+#define TCP_EVENT_CONNECTED(pcb,err,ret)                         \
+  do {                                                           \
+    if((pcb)->connected != NULL)                                 \
+      (ret) = (pcb)->connected((pcb)->callback_arg,(pcb),(err)); \
+    else (ret) = ERR_OK;                                         \
+  } while (0)
+
+#define TCP_EVENT_POLL(pcb,ret)                                \
+  do {                                                         \
+    if((pcb)->poll != NULL)                                    \
+      (ret) = (pcb)->poll((pcb)->callback_arg,(pcb));          \
+    else (ret) = ERR_OK;                                       \
+  } while (0)
+
+#define TCP_EVENT_ERR(last_state,errf,arg,err)                 \
+  do {                                                         \
+    LWIP_UNUSED_ARG(last_state);                               \
+    if((errf) != NULL)                                         \
+      (errf)((arg),(err));                                     \
+  } while (0)
+
+#endif /* LWIP_EVENT_API */
+
+/** Enabled extra-check for TCP_OVERSIZE if LWIP_DEBUG is enabled */
+#if TCP_OVERSIZE && defined(LWIP_DEBUG)
+#define TCP_OVERSIZE_DBGCHECK 1
+#else
+#define TCP_OVERSIZE_DBGCHECK 0
+#endif
+
+/** Don't generate checksum on copy if CHECKSUM_GEN_TCP is disabled */
+#define TCP_CHECKSUM_ON_COPY  (LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_TCP)
+
+/* This structure represents a TCP segment on the unsent, unacked and ooseq queues */
+struct tcp_seg {
+  struct tcp_seg *next;    /* used when putting segments on a queue */
+  struct pbuf *p;          /* buffer containing data + TCP header */
+  u16_t len;               /* the TCP length of this segment */
+#if TCP_OVERSIZE_DBGCHECK
+  u16_t oversize_left;     /* Extra bytes available at the end of the last
+                              pbuf in unsent (used for asserting vs.
+                              tcp_pcb.unsent_oversize only) */
+#endif /* TCP_OVERSIZE_DBGCHECK */
+#if TCP_CHECKSUM_ON_COPY
+  u16_t chksum;
+  u8_t  chksum_swapped;
+#endif /* TCP_CHECKSUM_ON_COPY */
+  u8_t  flags;
+#define TF_SEG_OPTS_MSS         (u8_t)0x01U /* Include MSS option. */
+#define TF_SEG_OPTS_TS          (u8_t)0x02U /* Include timestamp option. */
+#define TF_SEG_DATA_CHECKSUMMED (u8_t)0x04U /* ALL data (not the header) is
+                                               checksummed into 'chksum' */
+#define TF_SEG_OPTS_WND_SCALE   (u8_t)0x08U /* Include WND SCALE option */
+  struct tcp_hdr *tcphdr;  /* the TCP header */
+};
+
+#define LWIP_TCP_OPT_EOL        0
+#define LWIP_TCP_OPT_NOP        1
+#define LWIP_TCP_OPT_MSS        2
+#define LWIP_TCP_OPT_WS         3
+#define LWIP_TCP_OPT_TS         8
+
+#define LWIP_TCP_OPT_LEN_MSS    4
+#if LWIP_TCP_TIMESTAMPS
+#define LWIP_TCP_OPT_LEN_TS     10
+#define LWIP_TCP_OPT_LEN_TS_OUT 12 /* aligned for output (includes NOP padding) */
+#else
+#define LWIP_TCP_OPT_LEN_TS_OUT 0
+#endif
+#if LWIP_WND_SCALE
+#define LWIP_TCP_OPT_LEN_WS     3
+#define LWIP_TCP_OPT_LEN_WS_OUT 4 /* aligned for output (includes NOP padding) */
+#else
+#define LWIP_TCP_OPT_LEN_WS_OUT 0
+#endif
+
+#define LWIP_TCP_OPT_LENGTH(flags) \
+  (flags & TF_SEG_OPTS_MSS       ? LWIP_TCP_OPT_LEN_MSS    : 0) + \
+  (flags & TF_SEG_OPTS_TS        ? LWIP_TCP_OPT_LEN_TS_OUT : 0) + \
+  (flags & TF_SEG_OPTS_WND_SCALE ? LWIP_TCP_OPT_LEN_WS_OUT : 0)
+
+/** This returns a TCP header option for MSS in an u32_t */
+#define TCP_BUILD_MSS_OPTION(mss) lwip_htonl(0x02040000 | ((mss) & 0xFFFF))
+
+#if LWIP_WND_SCALE
+#define TCPWNDSIZE_F       U32_F
+#define TCPWND_MAX         0xFFFFFFFFU
+#define TCPWND_CHECK16(x)  LWIP_ASSERT("window size > 0xFFFF", (x) <= 0xFFFF)
+#define TCPWND_MIN16(x)    ((u16_t)LWIP_MIN((x), 0xFFFF))
+#else /* LWIP_WND_SCALE */
+#define TCPWNDSIZE_F       U16_F
+#define TCPWND_MAX         0xFFFFU
+#define TCPWND_CHECK16(x)
+#define TCPWND_MIN16(x)    x
+#endif /* LWIP_WND_SCALE */
+
+/* Global variables: */
+extern struct tcp_pcb *tcp_input_pcb;
+extern u32_t tcp_ticks;
+extern u8_t tcp_active_pcbs_changed;
+
+/* The TCP PCB lists. */
+union tcp_listen_pcbs_t { /* List of all TCP PCBs in LISTEN state. */
+  struct tcp_pcb_listen *listen_pcbs;
+  struct tcp_pcb *pcbs;
+};
+extern struct tcp_pcb *tcp_bound_pcbs;
+extern union tcp_listen_pcbs_t tcp_listen_pcbs;
+extern struct tcp_pcb *tcp_active_pcbs;  /* List of all TCP PCBs that are in a
+              state in which they accept or send
+              data. */
+extern struct tcp_pcb *tcp_tw_pcbs;      /* List of all TCP PCBs in TIME-WAIT. */
+
+#define NUM_TCP_PCB_LISTS_NO_TIME_WAIT  3
+#define NUM_TCP_PCB_LISTS               4
+extern struct tcp_pcb ** const tcp_pcb_lists[NUM_TCP_PCB_LISTS];
+
+/* Axioms about the above lists:
+   1) Every TCP PCB that is not CLOSED is in one of the lists.
+   2) A PCB is only in one of the lists.
+   3) All PCBs in the tcp_listen_pcbs list is in LISTEN state.
+   4) All PCBs in the tcp_tw_pcbs list is in TIME-WAIT state.
+*/
+/* Define two macros, TCP_REG and TCP_RMV that registers a TCP PCB
+   with a PCB list or removes a PCB from a list, respectively. */
+#ifndef TCP_DEBUG_PCB_LISTS
+#define TCP_DEBUG_PCB_LISTS 0
+#endif
+#if TCP_DEBUG_PCB_LISTS
+#define TCP_REG(pcbs, npcb) do {\
+                            struct tcp_pcb *tcp_tmp_pcb; \
+                            LWIP_DEBUGF(TCP_DEBUG, ("TCP_REG %p local port %d\n", (npcb), (npcb)->local_port)); \
+                            for (tcp_tmp_pcb = *(pcbs); \
+          tcp_tmp_pcb != NULL; \
+        tcp_tmp_pcb = tcp_tmp_pcb->next) { \
+                                LWIP_ASSERT("TCP_REG: already registered\n", tcp_tmp_pcb != (npcb)); \
+                            } \
+                            LWIP_ASSERT("TCP_REG: pcb->state != CLOSED", ((pcbs) == &tcp_bound_pcbs) || ((npcb)->state != CLOSED)); \
+                            (npcb)->next = *(pcbs); \
+                            LWIP_ASSERT("TCP_REG: npcb->next != npcb", (npcb)->next != (npcb)); \
+                            *(pcbs) = (npcb); \
+                            LWIP_ASSERT("TCP_RMV: tcp_pcbs sane", tcp_pcbs_sane()); \
+              tcp_timer_needed(); \
+                            } while(0)
+#define TCP_RMV(pcbs, npcb) do { \
+                            struct tcp_pcb *tcp_tmp_pcb; \
+                            LWIP_ASSERT("TCP_RMV: pcbs != NULL", *(pcbs) != NULL); \
+                            LWIP_DEBUGF(TCP_DEBUG, ("TCP_RMV: removing %p from %p\n", (npcb), *(pcbs))); \
+                            if(*(pcbs) == (npcb)) { \
+                               *(pcbs) = (*pcbs)->next; \
+                            } else for (tcp_tmp_pcb = *(pcbs); tcp_tmp_pcb != NULL; tcp_tmp_pcb = tcp_tmp_pcb->next) { \
+                               if(tcp_tmp_pcb->next == (npcb)) { \
+                                  tcp_tmp_pcb->next = (npcb)->next; \
+                                  break; \
+                               } \
+                            } \
+                            (npcb)->next = NULL; \
+                            LWIP_ASSERT("TCP_RMV: tcp_pcbs sane", tcp_pcbs_sane()); \
+                            LWIP_DEBUGF(TCP_DEBUG, ("TCP_RMV: removed %p from %p\n", (npcb), *(pcbs))); \
+                            } while(0)
+
+#else /* LWIP_DEBUG */
+
+#define TCP_REG(pcbs, npcb)                        \
+  do {                                             \
+    (npcb)->next = *pcbs;                          \
+    *(pcbs) = (npcb);                              \
+    tcp_timer_needed();                            \
+  } while (0)
+
+#define TCP_RMV(pcbs, npcb)                        \
+  do {                                             \
+    if(*(pcbs) == (npcb)) {                        \
+      (*(pcbs)) = (*pcbs)->next;                   \
+    }                                              \
+    else {                                         \
+      struct tcp_pcb *tcp_tmp_pcb;                 \
+      for (tcp_tmp_pcb = *pcbs;                    \
+          tcp_tmp_pcb != NULL;                     \
+          tcp_tmp_pcb = tcp_tmp_pcb->next) {       \
+        if(tcp_tmp_pcb->next == (npcb)) {          \
+          tcp_tmp_pcb->next = (npcb)->next;        \
+          break;                                   \
+        }                                          \
+      }                                            \
+    }                                              \
+    (npcb)->next = NULL;                           \
+  } while(0)
+
+#endif /* LWIP_DEBUG */
+
+#define TCP_REG_ACTIVE(npcb)                       \
+  do {                                             \
+    TCP_REG(&tcp_active_pcbs, npcb);               \
+    tcp_active_pcbs_changed = 1;                   \
+  } while (0)
+
+#define TCP_RMV_ACTIVE(npcb)                       \
+  do {                                             \
+    TCP_RMV(&tcp_active_pcbs, npcb);               \
+    tcp_active_pcbs_changed = 1;                   \
+  } while (0)
+
+#define TCP_PCB_REMOVE_ACTIVE(pcb)                 \
+  do {                                             \
+    tcp_pcb_remove(&tcp_active_pcbs, pcb);         \
+    tcp_active_pcbs_changed = 1;                   \
+  } while (0)
+
+
+/* Internal functions: */
+struct tcp_pcb *tcp_pcb_copy(struct tcp_pcb *pcb);
+void tcp_pcb_purge(struct tcp_pcb *pcb);
+void tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb);
+
+void tcp_segs_free(struct tcp_seg *seg);
+void tcp_seg_free(struct tcp_seg *seg);
+struct tcp_seg *tcp_seg_copy(struct tcp_seg *seg);
+
+#define tcp_ack(pcb)                               \
+  do {                                             \
+    if((pcb)->flags & TF_ACK_DELAY) {              \
+      (pcb)->flags &= ~TF_ACK_DELAY;               \
+      (pcb)->flags |= TF_ACK_NOW;                  \
+    }                                              \
+    else {                                         \
+      (pcb)->flags |= TF_ACK_DELAY;                \
+    }                                              \
+  } while (0)
+
+#define tcp_ack_now(pcb)                           \
+  do {                                             \
+    (pcb)->flags |= TF_ACK_NOW;                    \
+  } while (0)
+
+err_t tcp_send_fin(struct tcp_pcb *pcb);
+err_t tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags);
+
+void tcp_rexmit_seg(struct tcp_pcb *pcb, struct tcp_seg *seg);
+
+void tcp_rst(u32_t seqno, u32_t ackno,
+       const ip_addr_t *local_ip, const ip_addr_t *remote_ip,
+       u16_t local_port, u16_t remote_port);
+
+u32_t tcp_next_iss(struct tcp_pcb *pcb);
+
+err_t tcp_keepalive(struct tcp_pcb *pcb);
+err_t tcp_zero_window_probe(struct tcp_pcb *pcb);
+void  tcp_trigger_input_pcb_close(void);
+
+#if TCP_CALCULATE_EFF_SEND_MSS
+u16_t tcp_eff_send_mss_impl(u16_t sendmss, const ip_addr_t *dest
+#if LWIP_IPV6 || LWIP_IPV4_SRC_ROUTING
+                           , const ip_addr_t *src
+#endif /* LWIP_IPV6 || LWIP_IPV4_SRC_ROUTING */
+                           );
+#if LWIP_IPV6 || LWIP_IPV4_SRC_ROUTING
+#define tcp_eff_send_mss(sendmss, src, dest) tcp_eff_send_mss_impl(sendmss, dest, src)
+#else /* LWIP_IPV6 || LWIP_IPV4_SRC_ROUTING */
+#define tcp_eff_send_mss(sendmss, src, dest) tcp_eff_send_mss_impl(sendmss, dest)
+#endif /* LWIP_IPV6 || LWIP_IPV4_SRC_ROUTING */
+#endif /* TCP_CALCULATE_EFF_SEND_MSS */
+
+#if LWIP_CALLBACK_API
+err_t tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err);
+#endif /* LWIP_CALLBACK_API */
+
+#if TCP_DEBUG || TCP_INPUT_DEBUG || TCP_OUTPUT_DEBUG
+void tcp_debug_print(struct tcp_hdr *tcphdr);
+void tcp_debug_print_flags(u8_t flags);
+void tcp_debug_print_state(enum tcp_state s);
+void tcp_debug_print_pcbs(void);
+s16_t tcp_pcbs_sane(void);
+#else
+#  define tcp_debug_print(tcphdr)
+#  define tcp_debug_print_flags(flags)
+#  define tcp_debug_print_state(s)
+#  define tcp_debug_print_pcbs()
+#  define tcp_pcbs_sane() 1
+#endif /* TCP_DEBUG */
+
+/** External function (implemented in timers.c), called when TCP detects
+ * that a timer is needed (i.e. active- or time-wait-pcb found). */
+void tcp_timer_needed(void);
+
+void tcp_netif_ip_addr_changed(const ip_addr_t* old_addr, const ip_addr_t* new_addr);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_TCP */
+
+#endif /* LWIP_HDR_TCP_PRIV_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/priv/tcpip_priv.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/priv/tcpip_priv.h
new file mode 100644
index 000000000..127eae542
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/priv/tcpip_priv.h
@@ -0,0 +1,161 @@
+/**
+ * @file
+ * TCPIP API internal implementations (do not use in application code)
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_TCPIP_PRIV_H
+#define LWIP_HDR_TCPIP_PRIV_H
+
+#include "lwip/opt.h"
+
+#if !NO_SYS /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/tcpip.h"
+#include "lwip/sys.h"
+#include "lwip/timeouts.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct pbuf;
+struct netif;
+
+#if LWIP_MPU_COMPATIBLE
+#define API_VAR_REF(name)               (*(name))
+#define API_VAR_DECLARE(type, name)     type * name
+#define API_VAR_ALLOC(type, pool, name, errorval) do { \
+                                          name = (type *)memp_malloc(pool); \
+                                          if (name == NULL) { \
+                                            return errorval; \
+                                          } \
+                                        } while(0)
+#define API_VAR_ALLOC_POOL(type, pool, name, errorval) do { \
+                                          name = (type *)LWIP_MEMPOOL_ALLOC(pool); \
+                                          if (name == NULL) { \
+                                            return errorval; \
+                                          } \
+                                        } while(0)
+#define API_VAR_FREE(pool, name)        memp_free(pool, name)
+#define API_VAR_FREE_POOL(pool, name)   LWIP_MEMPOOL_FREE(pool, name)
+#define API_EXPR_REF(expr)              (&(expr))
+#if LWIP_NETCONN_SEM_PER_THREAD
+#define API_EXPR_REF_SEM(expr)          (expr)
+#else
+#define API_EXPR_REF_SEM(expr)          API_EXPR_REF(expr)
+#endif
+#define API_EXPR_DEREF(expr)            expr
+#define API_MSG_M_DEF(m)                m
+#define API_MSG_M_DEF_C(t, m)           t m
+#else /* LWIP_MPU_COMPATIBLE */
+#define API_VAR_REF(name)               name
+#define API_VAR_DECLARE(type, name)     type name
+#define API_VAR_ALLOC(type, pool, name, errorval)
+#define API_VAR_ALLOC_POOL(type, pool, name, errorval)
+#define API_VAR_FREE(pool, name)
+#define API_VAR_FREE_POOL(pool, name)
+#define API_EXPR_REF(expr)              expr
+#define API_EXPR_REF_SEM(expr)          API_EXPR_REF(expr)
+#define API_EXPR_DEREF(expr)            (*(expr))
+#define API_MSG_M_DEF(m)                *m
+#define API_MSG_M_DEF_C(t, m)           const t * m
+#endif /* LWIP_MPU_COMPATIBLE */
+
+err_t tcpip_send_msg_wait_sem(tcpip_callback_fn fn, void *apimsg, sys_sem_t* sem);
+
+struct tcpip_api_call_data
+{
+#if !LWIP_TCPIP_CORE_LOCKING
+  err_t err;
+#if !LWIP_NETCONN_SEM_PER_THREAD
+  sys_sem_t sem;
+#endif /* LWIP_NETCONN_SEM_PER_THREAD */
+#else /* !LWIP_TCPIP_CORE_LOCKING */
+  u8_t dummy; /* avoid empty struct :-( */
+#endif /* !LWIP_TCPIP_CORE_LOCKING */
+};
+typedef err_t (*tcpip_api_call_fn)(struct tcpip_api_call_data* call);
+err_t tcpip_api_call(tcpip_api_call_fn fn, struct tcpip_api_call_data *call);
+
+enum tcpip_msg_type {
+  TCPIP_MSG_API,
+  TCPIP_MSG_API_CALL,
+  TCPIP_MSG_INPKT,
+#if LWIP_TCPIP_TIMEOUT && LWIP_TIMERS
+  TCPIP_MSG_TIMEOUT,
+  TCPIP_MSG_UNTIMEOUT,
+#endif /* LWIP_TCPIP_TIMEOUT && LWIP_TIMERS */
+  TCPIP_MSG_CALLBACK,
+  TCPIP_MSG_CALLBACK_STATIC,
+  TCPIP_MSG_FINISH
+};
+
+struct tcpip_msg {
+  enum tcpip_msg_type type;
+  union {
+    struct {
+      tcpip_callback_fn function;
+      void* msg;
+    } api_msg;
+    struct {
+      tcpip_api_call_fn function;
+      struct tcpip_api_call_data *arg;
+      sys_sem_t *sem;
+    } api_call;
+    struct {
+      struct pbuf *p;
+      struct netif *netif;
+      netif_input_fn input_fn;
+    } inp;
+    struct {
+      tcpip_callback_fn function;
+      void *ctx;
+    } cb;
+#if LWIP_TCPIP_TIMEOUT && LWIP_TIMERS
+    struct {
+      u32_t msecs;
+      sys_timeout_handler h;
+      void *arg;
+    } tmo;
+#endif /* LWIP_TCPIP_TIMEOUT && LWIP_TIMERS */
+  } msg;
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !NO_SYS */
+
+#endif /* LWIP_HDR_TCPIP_PRIV_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/autoip.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/autoip.h
new file mode 100644
index 000000000..fd3af8a9f
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/autoip.h
@@ -0,0 +1,78 @@
+/**
+ * @file
+ * AutoIP protocol definitions
+ */
+
+/*
+ *
+ * Copyright (c) 2007 Dominik Spies <kontakt@dspies.de>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * Author: Dominik Spies <kontakt@dspies.de>
+ *
+ * This is a AutoIP implementation for the lwIP TCP/IP stack. It aims to conform
+ * with RFC 3927.
+ *
+ */
+
+#ifndef LWIP_HDR_PROT_AUTOIP_H
+#define LWIP_HDR_PROT_AUTOIP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* 169.254.0.0 */
+#define AUTOIP_NET              0xA9FE0000
+/* 169.254.1.0 */
+#define AUTOIP_RANGE_START      (AUTOIP_NET | 0x0100)
+/* 169.254.254.255 */
+#define AUTOIP_RANGE_END        (AUTOIP_NET | 0xFEFF)
+
+/* RFC 3927 Constants */
+#define PROBE_WAIT              1   /* second   (initial random delay)                 */
+#define PROBE_MIN               1   /* second   (minimum delay till repeated probe)    */
+#define PROBE_MAX               2   /* seconds  (maximum delay till repeated probe)    */
+#define PROBE_NUM               3   /*          (number of probe packets)              */
+#define ANNOUNCE_NUM            2   /*          (number of announcement packets)       */
+#define ANNOUNCE_INTERVAL       2   /* seconds  (time between announcement packets)    */
+#define ANNOUNCE_WAIT           2   /* seconds  (delay before announcing)              */
+#define MAX_CONFLICTS           10  /*          (max conflicts before rate limiting)   */
+#define RATE_LIMIT_INTERVAL     60  /* seconds  (delay between successive attempts)    */
+#define DEFEND_INTERVAL         10  /* seconds  (min. wait between defensive ARPs)     */
+
+/* AutoIP client states */
+typedef enum {
+  AUTOIP_STATE_OFF        = 0,
+  AUTOIP_STATE_PROBING    = 1,
+  AUTOIP_STATE_ANNOUNCING = 2,
+  AUTOIP_STATE_BOUND      = 3
+} autoip_state_enum_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_AUTOIP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/dhcp.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/dhcp.h
new file mode 100644
index 000000000..112953cb8
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/dhcp.h
@@ -0,0 +1,183 @@
+/**
+ * @file
+ * DHCP protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Leon Woestenberg <leon.woestenberg@gmx.net>
+ * Copyright (c) 2001-2004 Axon Digital Design B.V., The Netherlands.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Leon Woestenberg <leon.woestenberg@gmx.net>
+ *
+ */
+#ifndef LWIP_HDR_PROT_DHCP_H
+#define LWIP_HDR_PROT_DHCP_H
+
+#include "lwip/opt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define DHCP_CLIENT_PORT  68
+#define DHCP_SERVER_PORT  67
+
+
+ /* DHCP message item offsets and length */
+#define DHCP_CHADDR_LEN   16U
+#define DHCP_SNAME_OFS    44U
+#define DHCP_SNAME_LEN    64U
+#define DHCP_FILE_OFS     108U
+#define DHCP_FILE_LEN     128U
+#define DHCP_MSG_LEN      236U
+#define DHCP_OPTIONS_OFS  (DHCP_MSG_LEN + 4U) /* 4 byte: cookie */
+
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+/** minimum set of fields of any DHCP message */
+struct dhcp_msg
+{
+  PACK_STRUCT_FLD_8(u8_t op);
+  PACK_STRUCT_FLD_8(u8_t htype);
+  PACK_STRUCT_FLD_8(u8_t hlen);
+  PACK_STRUCT_FLD_8(u8_t hops);
+  PACK_STRUCT_FIELD(u32_t xid);
+  PACK_STRUCT_FIELD(u16_t secs);
+  PACK_STRUCT_FIELD(u16_t flags);
+  PACK_STRUCT_FLD_S(ip4_addr_p_t ciaddr);
+  PACK_STRUCT_FLD_S(ip4_addr_p_t yiaddr);
+  PACK_STRUCT_FLD_S(ip4_addr_p_t siaddr);
+  PACK_STRUCT_FLD_S(ip4_addr_p_t giaddr);
+  PACK_STRUCT_FLD_8(u8_t chaddr[DHCP_CHADDR_LEN]);
+  PACK_STRUCT_FLD_8(u8_t sname[DHCP_SNAME_LEN]);
+  PACK_STRUCT_FLD_8(u8_t file[DHCP_FILE_LEN]);
+  PACK_STRUCT_FIELD(u32_t cookie);
+#define DHCP_MIN_OPTIONS_LEN 68U
+/** make sure user does not configure this too small */
+#if ((defined(DHCP_OPTIONS_LEN)) && (DHCP_OPTIONS_LEN < DHCP_MIN_OPTIONS_LEN))
+#  undef DHCP_OPTIONS_LEN
+#endif
+/** allow this to be configured in lwipopts.h, but not too small */
+#if (!defined(DHCP_OPTIONS_LEN))
+/** set this to be sufficient for your options in outgoing DHCP msgs */
+#  define DHCP_OPTIONS_LEN DHCP_MIN_OPTIONS_LEN
+#endif
+  PACK_STRUCT_FLD_8(u8_t options[DHCP_OPTIONS_LEN]);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+
+/* DHCP client states */
+typedef enum {
+  DHCP_STATE_OFF             = 0,
+  DHCP_STATE_REQUESTING      = 1,
+  DHCP_STATE_INIT            = 2,
+  DHCP_STATE_REBOOTING       = 3,
+  DHCP_STATE_REBINDING       = 4,
+  DHCP_STATE_RENEWING        = 5,
+  DHCP_STATE_SELECTING       = 6,
+  DHCP_STATE_INFORMING       = 7,
+  DHCP_STATE_CHECKING        = 8,
+  DHCP_STATE_PERMANENT       = 9,  /* not yet implemented */
+  DHCP_STATE_BOUND           = 10,
+  DHCP_STATE_RELEASING       = 11, /* not yet implemented */
+  DHCP_STATE_BACKING_OFF     = 12
+} dhcp_state_enum_t;
+
+/* DHCP op codes */
+#define DHCP_BOOTREQUEST            1
+#define DHCP_BOOTREPLY              2
+
+/* DHCP message types */
+#define DHCP_DISCOVER               1
+#define DHCP_OFFER                  2
+#define DHCP_REQUEST                3
+#define DHCP_DECLINE                4
+#define DHCP_ACK                    5
+#define DHCP_NAK                    6
+#define DHCP_RELEASE                7
+#define DHCP_INFORM                 8
+
+/** DHCP hardware type, currently only ethernet is supported */
+#define DHCP_HTYPE_ETH              1
+
+#define DHCP_MAGIC_COOKIE           0x63825363UL
+
+/* This is a list of options for BOOTP and DHCP, see RFC 2132 for descriptions */
+
+/* BootP options */
+#define DHCP_OPTION_PAD             0
+#define DHCP_OPTION_SUBNET_MASK     1 /* RFC 2132 3.3 */
+#define DHCP_OPTION_ROUTER          3
+#define DHCP_OPTION_DNS_SERVER      6
+#define DHCP_OPTION_HOSTNAME        12
+#define DHCP_OPTION_IP_TTL          23
+#define DHCP_OPTION_MTU             26
+#define DHCP_OPTION_BROADCAST       28
+#define DHCP_OPTION_TCP_TTL         37
+#define DHCP_OPTION_NTP             42
+#define DHCP_OPTION_END             255
+
+/* DHCP options */
+#define DHCP_OPTION_REQUESTED_IP    50 /* RFC 2132 9.1, requested IP address */
+#define DHCP_OPTION_LEASE_TIME      51 /* RFC 2132 9.2, time in seconds, in 4 bytes */
+#define DHCP_OPTION_OVERLOAD        52 /* RFC2132 9.3, use file and/or sname field for options */
+
+#define DHCP_OPTION_MESSAGE_TYPE    53 /* RFC 2132 9.6, important for DHCP */
+#define DHCP_OPTION_MESSAGE_TYPE_LEN 1
+
+#define DHCP_OPTION_SERVER_ID       54 /* RFC 2132 9.7, server IP address */
+#define DHCP_OPTION_PARAMETER_REQUEST_LIST  55 /* RFC 2132 9.8, requested option types */
+
+#define DHCP_OPTION_MAX_MSG_SIZE    57 /* RFC 2132 9.10, message size accepted >= 576 */
+#define DHCP_OPTION_MAX_MSG_SIZE_LEN 2
+
+#define DHCP_OPTION_T1              58 /* T1 renewal time */
+#define DHCP_OPTION_T2              59 /* T2 rebinding time */
+#define DHCP_OPTION_US              60
+#define DHCP_OPTION_CLIENT_ID       61
+#define DHCP_OPTION_TFTP_SERVERNAME 66
+#define DHCP_OPTION_BOOTFILE        67
+
+/* possible combinations of overloading the file and sname fields with options */
+#define DHCP_OVERLOAD_NONE          0
+#define DHCP_OVERLOAD_FILE          1
+#define DHCP_OVERLOAD_SNAME         2
+#define DHCP_OVERLOAD_SNAME_FILE    3
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*LWIP_HDR_PROT_DHCP_H*/
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/dns.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/dns.h
new file mode 100644
index 000000000..94782d6e9
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/dns.h
@@ -0,0 +1,140 @@
+/**
+ * @file
+ * DNS - host name to IP address resolver.
+ */
+
+/*
+ * Port to lwIP from uIP
+ * by Jim Pettinato April 2007
+ *
+ * security fixes and more by Simon Goldschmidt
+ *
+ * uIP version Copyright (c) 2002-2003, Adam Dunkels.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef LWIP_HDR_PROT_DNS_H
+#define LWIP_HDR_PROT_DNS_H
+
+#include "lwip/arch.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** DNS server port address */
+#ifndef DNS_SERVER_PORT
+#define DNS_SERVER_PORT           53
+#endif
+
+/* DNS field TYPE used for "Resource Records" */
+#define DNS_RRTYPE_A              1     /* a host address */
+#define DNS_RRTYPE_NS             2     /* an authoritative name server */
+#define DNS_RRTYPE_MD             3     /* a mail destination (Obsolete - use MX) */
+#define DNS_RRTYPE_MF             4     /* a mail forwarder (Obsolete - use MX) */
+#define DNS_RRTYPE_CNAME          5     /* the canonical name for an alias */
+#define DNS_RRTYPE_SOA            6     /* marks the start of a zone of authority */
+#define DNS_RRTYPE_MB             7     /* a mailbox domain name (EXPERIMENTAL) */
+#define DNS_RRTYPE_MG             8     /* a mail group member (EXPERIMENTAL) */
+#define DNS_RRTYPE_MR             9     /* a mail rename domain name (EXPERIMENTAL) */
+#define DNS_RRTYPE_NULL           10    /* a null RR (EXPERIMENTAL) */
+#define DNS_RRTYPE_WKS            11    /* a well known service description */
+#define DNS_RRTYPE_PTR            12    /* a domain name pointer */
+#define DNS_RRTYPE_HINFO          13    /* host information */
+#define DNS_RRTYPE_MINFO          14    /* mailbox or mail list information */
+#define DNS_RRTYPE_MX             15    /* mail exchange */
+#define DNS_RRTYPE_TXT            16    /* text strings */
+#define DNS_RRTYPE_AAAA           28    /* IPv6 address */
+#define DNS_RRTYPE_SRV            33    /* service location */
+#define DNS_RRTYPE_ANY            255   /* any type */
+
+/* DNS field CLASS used for "Resource Records" */
+#define DNS_RRCLASS_IN            1     /* the Internet */
+#define DNS_RRCLASS_CS            2     /* the CSNET class (Obsolete - used only for examples in some obsolete RFCs) */
+#define DNS_RRCLASS_CH            3     /* the CHAOS class */
+#define DNS_RRCLASS_HS            4     /* Hesiod [Dyer 87] */
+#define DNS_RRCLASS_ANY           255   /* any class */
+#define DNS_RRCLASS_FLUSH         0x800 /* Flush bit */
+
+/* DNS protocol flags */
+#define DNS_FLAG1_RESPONSE        0x80
+#define DNS_FLAG1_OPCODE_STATUS   0x10
+#define DNS_FLAG1_OPCODE_INVERSE  0x08
+#define DNS_FLAG1_OPCODE_STANDARD 0x00
+#define DNS_FLAG1_AUTHORATIVE     0x04
+#define DNS_FLAG1_TRUNC           0x02
+#define DNS_FLAG1_RD              0x01
+#define DNS_FLAG2_RA              0x80
+#define DNS_FLAG2_ERR_MASK        0x0f
+#define DNS_FLAG2_ERR_NONE        0x00
+#define DNS_FLAG2_ERR_NAME        0x03
+
+#define DNS_HDR_GET_OPCODE(hdr) ((((hdr)->flags1) >> 3) & 0xF)
+
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+/** DNS message header */
+struct dns_hdr {
+  PACK_STRUCT_FIELD(u16_t id);
+  PACK_STRUCT_FLD_8(u8_t flags1);
+  PACK_STRUCT_FLD_8(u8_t flags2);
+  PACK_STRUCT_FIELD(u16_t numquestions);
+  PACK_STRUCT_FIELD(u16_t numanswers);
+  PACK_STRUCT_FIELD(u16_t numauthrr);
+  PACK_STRUCT_FIELD(u16_t numextrarr);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+#define SIZEOF_DNS_HDR 12
+
+
+/* Multicast DNS definitions */
+
+/** UDP port for multicast DNS queries */
+#ifndef DNS_MQUERY_PORT
+#define DNS_MQUERY_PORT             5353
+#endif
+
+/* IPv4 group for multicast DNS queries: 224.0.0.251 */
+#ifndef DNS_MQUERY_IPV4_GROUP_INIT
+#define DNS_MQUERY_IPV4_GROUP_INIT  IPADDR4_INIT_BYTES(224,0,0,251)
+#endif
+
+/* IPv6 group for multicast DNS queries: FF02::FB */
+#ifndef DNS_MQUERY_IPV6_GROUP_INIT
+#define DNS_MQUERY_IPV6_GROUP_INIT  IPADDR6_INIT_HOST(0xFF020000,0,0,0xFB)
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_DNS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/etharp.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/etharp.h
new file mode 100644
index 000000000..ec78305b8
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/etharp.h
@@ -0,0 +1,91 @@
+/**
+ * @file
+ * ARP protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_PROT_ETHARP_H
+#define LWIP_HDR_PROT_ETHARP_H
+
+#include "lwip/arch.h"
+#include "lwip/prot/ethernet.h"
+#include "lwip/ip4_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef ETHARP_HWADDR_LEN
+#define ETHARP_HWADDR_LEN     ETH_HWADDR_LEN
+#endif
+
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+/** the ARP message, see RFC 826 ("Packet format") */
+struct etharp_hdr {
+  PACK_STRUCT_FIELD(u16_t hwtype);
+  PACK_STRUCT_FIELD(u16_t proto);
+  PACK_STRUCT_FLD_8(u8_t  hwlen);
+  PACK_STRUCT_FLD_8(u8_t  protolen);
+  PACK_STRUCT_FIELD(u16_t opcode);
+  PACK_STRUCT_FLD_S(struct eth_addr shwaddr);
+  PACK_STRUCT_FLD_S(struct ip4_addr2 sipaddr);
+  PACK_STRUCT_FLD_S(struct eth_addr dhwaddr);
+  PACK_STRUCT_FLD_S(struct ip4_addr2 dipaddr);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+#define SIZEOF_ETHARP_HDR 28
+
+/* ARP hwtype values */
+enum etharp_hwtype {
+  HWTYPE_ETHERNET = 1
+  /* others not used */
+};
+
+/* ARP message types (opcodes) */
+enum etharp_opcode {
+  ARP_REQUEST = 1,
+  ARP_REPLY   = 2
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_ETHARP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/ethernet.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/ethernet.h
new file mode 100644
index 000000000..e4baa29dc
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/ethernet.h
@@ -0,0 +1,170 @@
+/**
+ * @file
+ * Ethernet protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_PROT_ETHERNET_H
+#define LWIP_HDR_PROT_ETHERNET_H
+
+#include "lwip/arch.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef ETH_HWADDR_LEN
+#ifdef ETHARP_HWADDR_LEN
+#define ETH_HWADDR_LEN    ETHARP_HWADDR_LEN /* compatibility mode */
+#else
+#define ETH_HWADDR_LEN    6
+#endif
+#endif
+
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct eth_addr {
+  PACK_STRUCT_FLD_8(u8_t addr[ETH_HWADDR_LEN]);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+/** Ethernet header */
+struct eth_hdr {
+#if ETH_PAD_SIZE
+  PACK_STRUCT_FLD_8(u8_t padding[ETH_PAD_SIZE]);
+#endif
+  PACK_STRUCT_FLD_S(struct eth_addr dest);
+  PACK_STRUCT_FLD_S(struct eth_addr src);
+  PACK_STRUCT_FIELD(u16_t type);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+#define SIZEOF_ETH_HDR (14 + ETH_PAD_SIZE)
+
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+/** VLAN header inserted between ethernet header and payload
+ * if 'type' in ethernet header is ETHTYPE_VLAN.
+ * See IEEE802.Q */
+struct eth_vlan_hdr {
+  PACK_STRUCT_FIELD(u16_t prio_vid);
+  PACK_STRUCT_FIELD(u16_t tpid);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+#define SIZEOF_VLAN_HDR 4
+#define VLAN_ID(vlan_hdr) (lwip_htons((vlan_hdr)->prio_vid) & 0xFFF)
+
+/**
+ * @ingroup ethernet
+ * A list of often ethtypes (although lwIP does not use all of them): */
+enum eth_type {
+  /** Internet protocol v4 */
+  ETHTYPE_IP        = 0x0800U,
+  /** Address resolution protocol */
+  ETHTYPE_ARP       = 0x0806U, 
+  /** Wake on lan */
+  ETHTYPE_WOL       = 0x0842U,
+  /** RARP */
+  ETHTYPE_RARP      = 0x8035U,
+  /** Virtual local area network */
+  ETHTYPE_VLAN      = 0x8100U,
+  /** Internet protocol v6 */
+  ETHTYPE_IPV6      = 0x86DDU,
+  /** PPP Over Ethernet Discovery Stage */
+  ETHTYPE_PPPOEDISC = 0x8863U,
+  /** PPP Over Ethernet Session Stage */
+  ETHTYPE_PPPOE     = 0x8864U,
+  /** Jumbo Frames */
+  ETHTYPE_JUMBO     = 0x8870U,
+  /** Process field network */
+  ETHTYPE_PROFINET  = 0x8892U,
+  /** Ethernet for control automation technology */
+  ETHTYPE_ETHERCAT  = 0x88A4U,
+  /** Link layer discovery protocol */
+  ETHTYPE_LLDP      = 0x88CCU,
+  /** Serial real-time communication system */
+  ETHTYPE_SERCOS    = 0x88CDU,
+  /** Media redundancy protocol */
+  ETHTYPE_MRP       = 0x88E3U,
+  /** Precision time protocol */
+  ETHTYPE_PTP       = 0x88F7U,
+  /** Q-in-Q, 802.1ad */
+  ETHTYPE_QINQ      = 0x9100U
+};
+
+/** The 24-bit IANA IPv4-multicast OUI is 01-00-5e: */
+#define LL_IP4_MULTICAST_ADDR_0 0x01
+#define LL_IP4_MULTICAST_ADDR_1 0x00
+#define LL_IP4_MULTICAST_ADDR_2 0x5e
+
+/** IPv6 multicast uses this prefix */
+#define LL_IP6_MULTICAST_ADDR_0 0x33
+#define LL_IP6_MULTICAST_ADDR_1 0x33
+
+/** MEMCPY-like macro to copy to/from struct eth_addr's that are local variables
+ * or known to be 32-bit aligned within the protocol header. */
+#ifndef ETHADDR32_COPY
+#define ETHADDR32_COPY(dst, src)  SMEMCPY(dst, src, ETH_HWADDR_LEN)
+#endif
+
+/** MEMCPY-like macro to copy to/from struct eth_addr's that are no local
+ * variables and known to be 16-bit aligned within the protocol header. */
+#ifndef ETHADDR16_COPY
+#define ETHADDR16_COPY(dst, src)  SMEMCPY(dst, src, ETH_HWADDR_LEN)
+#endif
+
+#define eth_addr_cmp(addr1, addr2) (memcmp((addr1)->addr, (addr2)->addr, ETH_HWADDR_LEN) == 0)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_ETHERNET_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/icmp.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/icmp.h
new file mode 100644
index 000000000..7d19385c7
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/icmp.h
@@ -0,0 +1,91 @@
+/**
+ * @file
+ * ICMP protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_PROT_ICMP_H
+#define LWIP_HDR_PROT_ICMP_H
+
+#include "lwip/arch.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ICMP_ER   0    /* echo reply */
+#define ICMP_DUR  3    /* destination unreachable */
+#define ICMP_SQ   4    /* source quench */
+#define ICMP_RD   5    /* redirect */
+#define ICMP_ECHO 8    /* echo */
+#define ICMP_TE  11    /* time exceeded */
+#define ICMP_PP  12    /* parameter problem */
+#define ICMP_TS  13    /* timestamp */
+#define ICMP_TSR 14    /* timestamp reply */
+#define ICMP_IRQ 15    /* information request */
+#define ICMP_IR  16    /* information reply */
+#define ICMP_AM  17    /* address mask request */
+#define ICMP_AMR 18    /* address mask reply */
+
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+/** This is the standard ICMP header only that the u32_t data
+ *  is split to two u16_t like ICMP echo needs it.
+ *  This header is also used for other ICMP types that do not
+ *  use the data part.
+ */
+PACK_STRUCT_BEGIN
+struct icmp_echo_hdr {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t code);
+  PACK_STRUCT_FIELD(u16_t chksum);
+  PACK_STRUCT_FIELD(u16_t id);
+  PACK_STRUCT_FIELD(u16_t seqno);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/* Compatibility defines, old versions used to combine type and code to an u16_t */
+#define ICMPH_TYPE(hdr) ((hdr)->type)
+#define ICMPH_CODE(hdr) ((hdr)->code)
+#define ICMPH_TYPE_SET(hdr, t) ((hdr)->type = (t))
+#define ICMPH_CODE_SET(hdr, c) ((hdr)->code = (c))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_ICMP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/icmp6.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/icmp6.h
new file mode 100644
index 000000000..346112042
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/icmp6.h
@@ -0,0 +1,170 @@
+/**
+ * @file
+ * ICMP6 protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_PROT_ICMP6_H
+#define LWIP_HDR_PROT_ICMP6_H
+
+#include "lwip/arch.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** ICMP type */
+enum icmp6_type {
+  /** Destination unreachable */
+  ICMP6_TYPE_DUR = 1,
+  /** Packet too big */
+  ICMP6_TYPE_PTB = 2,
+  /** Time exceeded */
+  ICMP6_TYPE_TE = 3,
+  /** Parameter problem */
+  ICMP6_TYPE_PP = 4,
+  /** Private experimentation */
+  ICMP6_TYPE_PE1 = 100,
+  /** Private experimentation */
+  ICMP6_TYPE_PE2 = 101,
+  /** Reserved for expansion of error messages */
+  ICMP6_TYPE_RSV_ERR = 127,
+
+  /** Echo request */
+  ICMP6_TYPE_EREQ = 128,
+  /** Echo reply */
+  ICMP6_TYPE_EREP = 129,
+  /** Multicast listener query */
+  ICMP6_TYPE_MLQ = 130,
+  /** Multicast listener report */
+  ICMP6_TYPE_MLR = 131,
+  /** Multicast listener done */
+  ICMP6_TYPE_MLD = 132,
+  /** Router solicitation */
+  ICMP6_TYPE_RS = 133,
+  /** Router advertisement */
+  ICMP6_TYPE_RA = 134,
+  /** Neighbor solicitation */
+  ICMP6_TYPE_NS = 135,
+  /** Neighbor advertisement */
+  ICMP6_TYPE_NA = 136,
+  /** Redirect */
+  ICMP6_TYPE_RD = 137,
+  /** Multicast router advertisement */
+  ICMP6_TYPE_MRA = 151,
+  /** Multicast router solicitation */
+  ICMP6_TYPE_MRS = 152,
+  /** Multicast router termination */
+  ICMP6_TYPE_MRT = 153,
+  /** Private experimentation */
+  ICMP6_TYPE_PE3 = 200,
+  /** Private experimentation */
+  ICMP6_TYPE_PE4 = 201,
+  /** Reserved for expansion of informational messages */
+  ICMP6_TYPE_RSV_INF = 255
+};
+
+/** ICMP destination unreachable codes */
+enum icmp6_dur_code {
+  /** No route to destination */
+  ICMP6_DUR_NO_ROUTE = 0,
+  /** Communication with destination administratively prohibited */
+  ICMP6_DUR_PROHIBITED = 1,
+  /** Beyond scope of source address */
+  ICMP6_DUR_SCOPE = 2,
+  /** Address unreachable */
+  ICMP6_DUR_ADDRESS = 3,
+  /** Port unreachable */
+  ICMP6_DUR_PORT = 4,
+  /** Source address failed ingress/egress policy */
+  ICMP6_DUR_POLICY = 5,
+  /** Reject route to destination */
+  ICMP6_DUR_REJECT_ROUTE = 6
+};
+
+/** ICMP time exceeded codes */
+enum icmp6_te_code {
+  /** Hop limit exceeded in transit */
+  ICMP6_TE_HL = 0,
+  /** Fragment reassembly time exceeded */
+  ICMP6_TE_FRAG = 1
+};
+
+/** ICMP parameter code */
+enum icmp6_pp_code {
+  /** Erroneous header field encountered */
+  ICMP6_PP_FIELD = 0,
+  /** Unrecognized next header type encountered */
+  ICMP6_PP_HEADER = 1,
+  /** Unrecognized IPv6 option encountered */
+  ICMP6_PP_OPTION = 2
+};
+
+/** This is the standard ICMP6 header. */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct icmp6_hdr {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t code);
+  PACK_STRUCT_FIELD(u16_t chksum);
+  PACK_STRUCT_FIELD(u32_t data);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/** This is the ICMP6 header adapted for echo req/resp. */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct icmp6_echo_hdr {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t code);
+  PACK_STRUCT_FIELD(u16_t chksum);
+  PACK_STRUCT_FIELD(u16_t id);
+  PACK_STRUCT_FIELD(u16_t seqno);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_ICMP6_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/igmp.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/igmp.h
new file mode 100644
index 000000000..d60cb31ee
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/igmp.h
@@ -0,0 +1,90 @@
+/**
+ * @file
+ * IGMP protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_PROT_IGMP_H
+#define LWIP_HDR_PROT_IGMP_H
+
+#include "lwip/arch.h"
+#include "lwip/ip4_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * IGMP constants
+ */
+#define IGMP_TTL                       1
+#define IGMP_MINLEN                    8
+#define ROUTER_ALERT                   0x9404U
+#define ROUTER_ALERTLEN                4
+
+/*
+ * IGMP message types, including version number.
+ */
+#define IGMP_MEMB_QUERY                0x11 /* Membership query         */
+#define IGMP_V1_MEMB_REPORT            0x12 /* Ver. 1 membership report */
+#define IGMP_V2_MEMB_REPORT            0x16 /* Ver. 2 membership report */
+#define IGMP_LEAVE_GROUP               0x17 /* Leave-group message      */
+
+/* Group  membership states */
+#define IGMP_GROUP_NON_MEMBER          0
+#define IGMP_GROUP_DELAYING_MEMBER     1
+#define IGMP_GROUP_IDLE_MEMBER         2
+
+/**
+ * IGMP packet format.
+ */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct igmp_msg {
+  PACK_STRUCT_FLD_8(u8_t         igmp_msgtype);
+  PACK_STRUCT_FLD_8(u8_t         igmp_maxresp);
+  PACK_STRUCT_FIELD(u16_t        igmp_checksum);
+  PACK_STRUCT_FLD_S(ip4_addr_p_t igmp_group_address);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_IGMP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/ip.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/ip.h
new file mode 100644
index 000000000..bbfae3675
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/ip.h
@@ -0,0 +1,51 @@
+/**
+ * @file
+ * IP protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_PROT_IP_H
+#define LWIP_HDR_PROT_IP_H
+
+#include "lwip/arch.h"
+
+#define IP_PROTO_ICMP    1
+#define IP_PROTO_IGMP    2
+#define IP_PROTO_UDP     17
+#define IP_PROTO_UDPLITE 136
+#define IP_PROTO_TCP     6
+
+/** This operates on a void* by loading the first byte */
+#define IP_HDR_GET_VERSION(ptr)   ((*(u8_t*)(ptr)) >> 4)
+
+#endif /* LWIP_HDR_PROT_IP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/ip4.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/ip4.h
new file mode 100644
index 000000000..bd442c689
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/ip4.h
@@ -0,0 +1,127 @@
+/**
+ * @file
+ * IPv4 protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_PROT_IP4_H
+#define LWIP_HDR_PROT_IP4_H
+
+#include "lwip/arch.h"
+#include "lwip/ip4_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** This is the packed version of ip4_addr_t,
+    used in network headers that are itself packed */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct ip4_addr_packed {
+  PACK_STRUCT_FIELD(u32_t addr);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+typedef struct ip4_addr_packed ip4_addr_p_t;
+
+/* Size of the IPv4 header. Same as 'sizeof(struct ip_hdr)'. */
+#define IP_HLEN 20
+
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+/* The IPv4 header */
+struct ip_hdr {
+  /* version / header length */
+  PACK_STRUCT_FLD_8(u8_t _v_hl);
+  /* type of service */
+  PACK_STRUCT_FLD_8(u8_t _tos);
+  /* total length */
+  PACK_STRUCT_FIELD(u16_t _len);
+  /* identification */
+  PACK_STRUCT_FIELD(u16_t _id);
+  /* fragment offset field */
+  PACK_STRUCT_FIELD(u16_t _offset);
+#define IP_RF 0x8000U        /* reserved fragment flag */
+#define IP_DF 0x4000U        /* don't fragment flag */
+#define IP_MF 0x2000U        /* more fragments flag */
+#define IP_OFFMASK 0x1fffU   /* mask for fragmenting bits */
+  /* time to live */
+  PACK_STRUCT_FLD_8(u8_t _ttl);
+  /* protocol*/
+  PACK_STRUCT_FLD_8(u8_t _proto);
+  /* checksum */
+  PACK_STRUCT_FIELD(u16_t _chksum);
+  /* source and destination IP addresses */
+  PACK_STRUCT_FLD_S(ip4_addr_p_t src);
+  PACK_STRUCT_FLD_S(ip4_addr_p_t dest);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/* Macros to get struct ip_hdr fields: */
+#define IPH_V(hdr)  ((hdr)->_v_hl >> 4)
+#define IPH_HL(hdr) ((hdr)->_v_hl & 0x0f)
+#define IPH_TOS(hdr) ((hdr)->_tos)
+#define IPH_LEN(hdr) ((hdr)->_len)
+#define IPH_ID(hdr) ((hdr)->_id)
+#define IPH_OFFSET(hdr) ((hdr)->_offset)
+#define IPH_TTL(hdr) ((hdr)->_ttl)
+#define IPH_PROTO(hdr) ((hdr)->_proto)
+#define IPH_CHKSUM(hdr) ((hdr)->_chksum)
+
+/* Macros to set struct ip_hdr fields: */
+#define IPH_VHL_SET(hdr, v, hl) (hdr)->_v_hl = (u8_t)((((v) << 4) | (hl)))
+#define IPH_TOS_SET(hdr, tos) (hdr)->_tos = (tos)
+#define IPH_LEN_SET(hdr, len) (hdr)->_len = (len)
+#define IPH_ID_SET(hdr, id) (hdr)->_id = (id)
+#define IPH_OFFSET_SET(hdr, off) (hdr)->_offset = (off)
+#define IPH_TTL_SET(hdr, ttl) (hdr)->_ttl = (u8_t)(ttl)
+#define IPH_PROTO_SET(hdr, proto) (hdr)->_proto = (u8_t)(proto)
+#define IPH_CHKSUM_SET(hdr, chksum) (hdr)->_chksum = (chksum)
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_IP4_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/ip6.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/ip6.h
new file mode 100644
index 000000000..61a553d10
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/ip6.h
@@ -0,0 +1,171 @@
+/**
+ * @file
+ * IPv6 protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_PROT_IP6_H
+#define LWIP_HDR_PROT_IP6_H
+
+#include "lwip/arch.h"
+#include "lwip/ip6_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define IP6_MIN_MTU 1280
+
+/** This is the packed version of ip6_addr_t,
+    used in network headers that are itself packed */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct ip6_addr_packed {
+  PACK_STRUCT_FIELD(u32_t addr[4]);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+typedef struct ip6_addr_packed ip6_addr_p_t;
+
+#define IP6_HLEN 40
+
+#define IP6_NEXTH_HOPBYHOP  0
+#define IP6_NEXTH_TCP       6
+#define IP6_NEXTH_UDP       17
+#define IP6_NEXTH_ENCAPS    41
+#define IP6_NEXTH_ROUTING   43
+#define IP6_NEXTH_FRAGMENT  44
+#define IP6_NEXTH_ICMP6     58
+#define IP6_NEXTH_NONE      59
+#define IP6_NEXTH_DESTOPTS  60
+#define IP6_NEXTH_UDPLITE   136
+
+/** The IPv6 header. */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct ip6_hdr {
+  /** version / traffic class / flow label */
+  PACK_STRUCT_FIELD(u32_t _v_tc_fl);
+  /** payload length */
+  PACK_STRUCT_FIELD(u16_t _plen);
+  /** next header */
+  PACK_STRUCT_FLD_8(u8_t _nexth);
+  /** hop limit */
+  PACK_STRUCT_FLD_8(u8_t _hoplim);
+  /** source and destination IP addresses */
+  PACK_STRUCT_FLD_S(ip6_addr_p_t src);
+  PACK_STRUCT_FLD_S(ip6_addr_p_t dest);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/* Hop-by-hop router alert option. */
+#define IP6_HBH_HLEN    8
+#define IP6_PAD1_OPTION         0
+#define IP6_PADN_ALERT_OPTION   1
+#define IP6_ROUTER_ALERT_OPTION 5
+#define IP6_ROUTER_ALERT_VALUE_MLD 0
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct ip6_hbh_hdr {
+  /* next header */
+  PACK_STRUCT_FLD_8(u8_t _nexth);
+  /* header length */
+  PACK_STRUCT_FLD_8(u8_t _hlen);
+  /* router alert option type */
+  PACK_STRUCT_FLD_8(u8_t _ra_opt_type);
+  /* router alert option data len */
+  PACK_STRUCT_FLD_8(u8_t _ra_opt_dlen);
+  /* router alert option data */
+  PACK_STRUCT_FIELD(u16_t _ra_opt_data);
+  /* PadN option type */
+  PACK_STRUCT_FLD_8(u8_t _padn_opt_type);
+  /* PadN option data len */
+  PACK_STRUCT_FLD_8(u8_t _padn_opt_dlen);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/* Fragment header. */
+#define IP6_FRAG_HLEN    8
+#define IP6_FRAG_OFFSET_MASK    0xfff8
+#define IP6_FRAG_MORE_FLAG      0x0001
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct ip6_frag_hdr {
+  /* next header */
+  PACK_STRUCT_FLD_8(u8_t _nexth);
+  /* reserved */
+  PACK_STRUCT_FLD_8(u8_t reserved);
+  /* fragment offset */
+  PACK_STRUCT_FIELD(u16_t _fragment_offset);
+  /* fragmented packet identification */
+  PACK_STRUCT_FIELD(u32_t _identification);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+#define IP6H_V(hdr)  ((lwip_ntohl((hdr)->_v_tc_fl) >> 28) & 0x0f)
+#define IP6H_TC(hdr) ((lwip_ntohl((hdr)->_v_tc_fl) >> 20) & 0xff)
+#define IP6H_FL(hdr) (lwip_ntohl((hdr)->_v_tc_fl) & 0x000fffff)
+#define IP6H_PLEN(hdr) (lwip_ntohs((hdr)->_plen))
+#define IP6H_NEXTH(hdr) ((hdr)->_nexth)
+#define IP6H_NEXTH_P(hdr) ((u8_t *)(hdr) + 6)
+#define IP6H_HOPLIM(hdr) ((hdr)->_hoplim)
+
+#define IP6H_VTCFL_SET(hdr, v, tc, fl) (hdr)->_v_tc_fl = (lwip_htonl((((u32_t)(v)) << 28) | (((u32_t)(tc)) << 20) | (fl)))
+#define IP6H_PLEN_SET(hdr, plen) (hdr)->_plen = lwip_htons(plen)
+#define IP6H_NEXTH_SET(hdr, nexth) (hdr)->_nexth = (nexth)
+#define IP6H_HOPLIM_SET(hdr, hl) (hdr)->_hoplim = (u8_t)(hl)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_IP6_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/mld6.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/mld6.h
new file mode 100644
index 000000000..be3a006af
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/mld6.h
@@ -0,0 +1,70 @@
+/**
+ * @file
+ * MLD6 protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_PROT_MLD6_H
+#define LWIP_HDR_PROT_MLD6_H
+
+#include "lwip/arch.h"
+#include "lwip/prot/ip6.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** Multicast listener report/query/done message header. */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct mld_header {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t code);
+  PACK_STRUCT_FIELD(u16_t chksum);
+  PACK_STRUCT_FIELD(u16_t max_resp_delay);
+  PACK_STRUCT_FIELD(u16_t reserved);
+  PACK_STRUCT_FLD_S(ip6_addr_p_t multicast_address);
+  /* Options follow. */
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_MLD6_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/nd6.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/nd6.h
new file mode 100644
index 000000000..4455066d5
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/nd6.h
@@ -0,0 +1,290 @@
+/**
+ * @file
+ * ND6 protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_PROT_ND6_H
+#define LWIP_HDR_PROT_ND6_H
+
+#include "lwip/arch.h"
+#include "lwip/ip6_addr.h"
+#include "lwip/prot/ip6.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** Neighbor solicitation message header. */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct ns_header {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t code);
+  PACK_STRUCT_FIELD(u16_t chksum);
+  PACK_STRUCT_FIELD(u32_t reserved);
+  PACK_STRUCT_FLD_S(ip6_addr_p_t target_address);
+  /* Options follow. */
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/** Neighbor advertisement message header. */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct na_header {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t code);
+  PACK_STRUCT_FIELD(u16_t chksum);
+  PACK_STRUCT_FLD_8(u8_t flags);
+  PACK_STRUCT_FLD_8(u8_t reserved[3]);
+  PACK_STRUCT_FLD_S(ip6_addr_p_t target_address);
+  /* Options follow. */
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+#define ND6_FLAG_ROUTER      (0x80)
+#define ND6_FLAG_SOLICITED   (0x40)
+#define ND6_FLAG_OVERRIDE    (0x20)
+
+/** Router solicitation message header. */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct rs_header {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t code);
+  PACK_STRUCT_FIELD(u16_t chksum);
+  PACK_STRUCT_FIELD(u32_t reserved);
+  /* Options follow. */
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/** Router advertisement message header. */
+#define ND6_RA_FLAG_MANAGED_ADDR_CONFIG (0x80)
+#define ND6_RA_FLAG_OTHER_CONFIG (0x40)
+#define ND6_RA_FLAG_HOME_AGENT (0x20)
+#define ND6_RA_PREFERENCE_MASK (0x18)
+#define ND6_RA_PREFERENCE_HIGH (0x08)
+#define ND6_RA_PREFERENCE_MEDIUM (0x00)
+#define ND6_RA_PREFERENCE_LOW (0x18)
+#define ND6_RA_PREFERENCE_DISABLED (0x10)
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct ra_header {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t code);
+  PACK_STRUCT_FIELD(u16_t chksum);
+  PACK_STRUCT_FLD_8(u8_t current_hop_limit);
+  PACK_STRUCT_FLD_8(u8_t flags);
+  PACK_STRUCT_FIELD(u16_t router_lifetime);
+  PACK_STRUCT_FIELD(u32_t reachable_time);
+  PACK_STRUCT_FIELD(u32_t retrans_timer);
+  /* Options follow. */
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/** Redirect message header. */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct redirect_header {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t code);
+  PACK_STRUCT_FIELD(u16_t chksum);
+  PACK_STRUCT_FIELD(u32_t reserved);
+  PACK_STRUCT_FLD_S(ip6_addr_p_t target_address);
+  PACK_STRUCT_FLD_S(ip6_addr_p_t destination_address);
+  /* Options follow. */
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/** Link-layer address option. */
+#define ND6_OPTION_TYPE_SOURCE_LLADDR (0x01)
+#define ND6_OPTION_TYPE_TARGET_LLADDR (0x02)
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct lladdr_option {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t length);
+  PACK_STRUCT_FLD_8(u8_t addr[NETIF_MAX_HWADDR_LEN]);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/** The address field is variable and not fixed in length, use the
+  * appropriate macros when accessing the length field or calculating
+  * the option size.
+  */
+#define __OFFSETOF(t, m)                       ((size_t)(&(((t *)0)->m)))
+#define __ROUND_UP(n, m)                       ((((n) + ((m) - 1)) / (m)) * (m))
+#define ND6_LLADDR_OPTION_LENGTH_SHIFT         3
+#define ND6_LLADDR_OPTION_LENGTH_SIZE          (1 << ND6_LLADDR_OPTION_LENGTH_SHIFT)
+#define ND6_LLADDR_OPTION_LENGTH_MASK          (ND6_LLADDR_OPTION_LENGTH_SIZE - 1)
+#define ND6_LLADDR_OPTION_LENGTH_ENCODE(hwlen) (__ROUND_UP(hwlen, ND6_LLADDR_OPTION_LENGTH_SIZE) >> ND6_LLADDR_OPTION_LENGTH_SHIFT)
+#define ND6_LLADDR_OPTION_LENGTH_DECODE(value) ((value) << ND6_LLADDR_OPTION_LENGTH_SHIFT)
+#define ND6_LLADDR_OPTION_SIZE(hwlen)          (__OFFSETOF(struct lladdr_option, addr) + (hwlen))
+
+/** Prefix information option. */
+#define ND6_OPTION_TYPE_PREFIX_INFO (0x03)
+#define ND6_PREFIX_FLAG_ON_LINK (0x80)
+#define ND6_PREFIX_FLAG_AUTONOMOUS (0x40)
+#define ND6_PREFIX_FLAG_ROUTER_ADDRESS (0x20)
+#define ND6_PREFIX_FLAG_SITE_PREFIX (0x10)
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct prefix_option {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t length);
+  PACK_STRUCT_FLD_8(u8_t prefix_length);
+  PACK_STRUCT_FLD_8(u8_t flags);
+  PACK_STRUCT_FIELD(u32_t valid_lifetime);
+  PACK_STRUCT_FIELD(u32_t preferred_lifetime);
+  PACK_STRUCT_FLD_8(u8_t reserved2[3]);
+  PACK_STRUCT_FLD_8(u8_t site_prefix_length);
+  PACK_STRUCT_FLD_S(ip6_addr_p_t prefix);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/** Redirected header option. */
+#define ND6_OPTION_TYPE_REDIR_HDR (0x04)
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct redirected_header_option {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t length);
+  PACK_STRUCT_FLD_8(u8_t reserved[6]);
+  /* Portion of redirected packet follows. */
+  /* PACK_STRUCT_FLD_8(u8_t redirected[8]); */
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/** MTU option. */
+#define ND6_OPTION_TYPE_MTU (0x05)
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct mtu_option {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t length);
+  PACK_STRUCT_FIELD(u16_t reserved);
+  PACK_STRUCT_FIELD(u32_t mtu);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/** Route information option. */
+#define ND6_OPTION_TYPE_ROUTE_INFO (24)
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct route_option {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t length);
+  PACK_STRUCT_FLD_8(u8_t prefix_length);
+  PACK_STRUCT_FLD_8(u8_t preference);
+  PACK_STRUCT_FIELD(u32_t route_lifetime);
+  PACK_STRUCT_FLD_S(ip6_addr_p_t prefix);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/** Recursive DNS Server Option. */
+#if LWIP_ND6_RDNSS_MAX_DNS_SERVERS
+#define LWIP_RDNSS_OPTION_MAX_SERVERS LWIP_ND6_RDNSS_MAX_DNS_SERVERS
+#else
+#define LWIP_RDNSS_OPTION_MAX_SERVERS 1
+#endif
+#define ND6_OPTION_TYPE_RDNSS (25)
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct rdnss_option {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t length);
+  PACK_STRUCT_FIELD(u16_t reserved);
+  PACK_STRUCT_FIELD(u32_t lifetime);
+  PACK_STRUCT_FLD_S(ip6_addr_p_t rdnss_address[LWIP_RDNSS_OPTION_MAX_SERVERS]);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_ND6_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/tcp.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/tcp.h
new file mode 100644
index 000000000..b251b80a8
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/tcp.h
@@ -0,0 +1,98 @@
+/**
+ * @file
+ * TCP protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_PROT_TCP_H
+#define LWIP_HDR_PROT_TCP_H
+
+#include "lwip/arch.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Length of the TCP header, excluding options. */
+#define TCP_HLEN 20
+
+/* Fields are (of course) in network byte order.
+ * Some fields are converted to host byte order in tcp_input().
+ */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct tcp_hdr {
+  PACK_STRUCT_FIELD(u16_t src);
+  PACK_STRUCT_FIELD(u16_t dest);
+  PACK_STRUCT_FIELD(u32_t seqno);
+  PACK_STRUCT_FIELD(u32_t ackno);
+  PACK_STRUCT_FIELD(u16_t _hdrlen_rsvd_flags);
+  PACK_STRUCT_FIELD(u16_t wnd);
+  PACK_STRUCT_FIELD(u16_t chksum);
+  PACK_STRUCT_FIELD(u16_t urgp);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/* TCP header flags bits */
+#define TCP_FIN 0x01U
+#define TCP_SYN 0x02U
+#define TCP_RST 0x04U
+#define TCP_PSH 0x08U
+#define TCP_ACK 0x10U
+#define TCP_URG 0x20U
+#define TCP_ECE 0x40U
+#define TCP_CWR 0x80U
+/* Valid TCP header flags */
+#define TCP_FLAGS 0x3fU
+
+#define TCPH_HDRLEN(phdr) ((u16_t)(lwip_ntohs((phdr)->_hdrlen_rsvd_flags) >> 12))
+#define TCPH_HDRLEN_BYTES(phdr) ((u8_t)(TCPH_HDRLEN(phdr) << 2))
+#define TCPH_FLAGS(phdr)  ((u16_t)(lwip_ntohs((phdr)->_hdrlen_rsvd_flags) & TCP_FLAGS))
+
+#define TCPH_HDRLEN_SET(phdr, len) (phdr)->_hdrlen_rsvd_flags = lwip_htons(((len) << 12) | TCPH_FLAGS(phdr))
+#define TCPH_FLAGS_SET(phdr, flags) (phdr)->_hdrlen_rsvd_flags = (((phdr)->_hdrlen_rsvd_flags & PP_HTONS(~TCP_FLAGS)) | lwip_htons(flags))
+#define TCPH_HDRLEN_FLAGS_SET(phdr, len, flags) (phdr)->_hdrlen_rsvd_flags = (u16_t)(lwip_htons((u16_t)((len) << 12) | (flags)))
+
+#define TCPH_SET_FLAG(phdr, flags ) (phdr)->_hdrlen_rsvd_flags = ((phdr)->_hdrlen_rsvd_flags | lwip_htons(flags))
+#define TCPH_UNSET_FLAG(phdr, flags) (phdr)->_hdrlen_rsvd_flags = ((phdr)->_hdrlen_rsvd_flags & ~lwip_htons(flags))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_TCP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/udp.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/udp.h
new file mode 100644
index 000000000..664f19a3e
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/prot/udp.h
@@ -0,0 +1,68 @@
+/**
+ * @file
+ * UDP protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_PROT_UDP_H
+#define LWIP_HDR_PROT_UDP_H
+
+#include "lwip/arch.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define UDP_HLEN 8
+
+/* Fields are (of course) in network byte order. */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct udp_hdr {
+  PACK_STRUCT_FIELD(u16_t src);
+  PACK_STRUCT_FIELD(u16_t dest);  /* src/dest UDP ports */
+  PACK_STRUCT_FIELD(u16_t len);
+  PACK_STRUCT_FIELD(u16_t chksum);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_UDP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/raw.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/raw.h
new file mode 100644
index 000000000..787d91802
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/raw.h
@@ -0,0 +1,147 @@
+/**
+ * @file
+ * raw API (to be used from TCPIP thread)\n
+ * See also @ref raw_raw
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_RAW_H
+#define LWIP_HDR_RAW_H
+
+#include "lwip/opt.h"
+
+#if LWIP_RAW /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/pbuf.h"
+#include "lwip/def.h"
+#include "lwip/ip.h"
+#include "lwip/ip_addr.h"
+#include "lwip/ip6_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define RAW_FLAGS_CONNECTED      0x01U
+#define RAW_FLAGS_MULTICAST_LOOP 0x04U
+
+struct raw_pcb;
+
+/** Function prototype for raw pcb receive callback functions.
+ * @param arg user supplied argument (raw_pcb.recv_arg)
+ * @param pcb the raw_pcb which received data
+ * @param p the packet buffer that was received
+ * @param addr the remote IP address from which the packet was received
+ * @return 1 if the packet was 'eaten' (aka. deleted),
+ *         0 if the packet lives on
+ * If returning 1, the callback is responsible for freeing the pbuf
+ * if it's not used any more.
+ */
+typedef u8_t (*raw_recv_fn)(void *arg, struct raw_pcb *pcb, struct pbuf *p,
+    const ip_addr_t *addr);
+
+/** the RAW protocol control block */
+struct raw_pcb {
+  /* Common members of all PCB types */
+  IP_PCB;
+
+  struct raw_pcb *next;
+  struct netif *intf_filter;
+
+  u8_t protocol;
+  u8_t flags;
+
+#if LWIP_MULTICAST_TX_OPTIONS
+  /** outgoing network interface for multicast packets, by interface index (if nonzero) */
+  u8_t mcast_ifindex;
+  /** TTL for outgoing multicast packets */
+  u8_t mcast_ttl;
+#endif /* LWIP_MULTICAST_TX_OPTIONS */
+
+  /** receive callback function */
+  raw_recv_fn recv;
+  /* user-supplied argument for the recv callback */
+  void *recv_arg;
+#if LWIP_IPV6
+  /* fields for handling checksum computations as per RFC3542. */
+  u16_t chksum_offset;
+  u8_t  chksum_reqd;
+#endif
+};
+
+/* The following functions is the application layer interface to the
+   RAW code. */
+struct raw_pcb * raw_new        (u8_t proto);
+struct raw_pcb * raw_new_ip_type(u8_t type, u8_t proto);
+void             raw_remove     (struct raw_pcb *pcb);
+err_t            raw_bind       (struct raw_pcb *pcb, const ip_addr_t *ipaddr);
+void             raw_bind_netif (struct raw_pcb *pcb, const struct netif *netif);
+err_t            raw_connect    (struct raw_pcb *pcb, const ip_addr_t *ipaddr);
+void             raw_disconnect (struct raw_pcb *pcb);
+
+err_t            raw_sendto     (struct raw_pcb *pcb, struct pbuf *p, const ip_addr_t *ipaddr);
+err_t            raw_sendto_if_src(struct raw_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip, struct netif *netif, const ip_addr_t *src_ip);
+err_t            raw_send       (struct raw_pcb *pcb, struct pbuf *p);
+
+void             raw_recv       (struct raw_pcb *pcb, raw_recv_fn recv, void *recv_arg);
+
+#define          raw_flags(pcb) ((pcb)->flags)
+#define          raw_setflags(pcb,f)  ((pcb)->flags = (f))
+
+#define          raw_set_flags(pcb, set_flags)     do { (pcb)->flags = (u8_t)((pcb)->flags |  (set_flags)); } while(0)
+#define          raw_clear_flags(pcb, clr_flags)   do { (pcb)->flags = (u8_t)((pcb)->flags & ~(clr_flags)); } while(0)
+#define          raw_is_flag_set(pcb, flag)        (((pcb)->flags & (flag)) != 0)
+
+/* The following functions are the lower layer interface to RAW. */
+u8_t             raw_input      (struct pbuf *p, struct netif *inp);
+#define raw_init() /* Compatibility define, no init needed. */
+
+void raw_netif_ip_addr_changed(const ip_addr_t* old_addr, const ip_addr_t* new_addr);
+
+/* for compatibility with older implementation */
+#define raw_new_ip6(proto) raw_new_ip_type(IPADDR_TYPE_V6, proto)
+
+#if LWIP_MULTICAST_TX_OPTIONS
+#define raw_set_multicast_netif_index(pcb, idx) ((pcb)->mcast_ifindex = (idx))
+#define raw_get_multicast_netif_index(pcb)      ((pcb)->mcast_ifindex)
+#define raw_set_multicast_ttl(pcb, value)       ((pcb)->mcast_ttl = (value))
+#define raw_get_multicast_ttl(pcb)              ((pcb)->mcast_ttl)
+#endif /* LWIP_MULTICAST_TX_OPTIONS */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_RAW */
+
+#endif /* LWIP_HDR_RAW_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/sio.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/sio.h
new file mode 100644
index 000000000..7643e1956
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/sio.h
@@ -0,0 +1,142 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ */
+
+/*
+ * This is the interface to the platform specific serial IO module
+ * It needs to be implemented by those platforms which need SLIP or PPP
+ */
+
+#ifndef SIO_H
+#define SIO_H
+
+#include "lwip/arch.h"
+#include "lwip/opt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* If you want to define sio_fd_t elsewhere or differently,
+   define this in your cc.h file. */
+#ifndef __sio_fd_t_defined
+typedef void * sio_fd_t;
+#endif
+
+/* The following functions can be defined to something else in your cc.h file
+   or be implemented in your custom sio.c file. */
+
+#ifndef sio_open
+/**
+ * Opens a serial device for communication.
+ *
+ * @param devnum device number
+ * @return handle to serial device if successful, NULL otherwise
+ */
+sio_fd_t sio_open(u8_t devnum);
+#endif
+
+#ifndef sio_send
+/**
+ * Sends a single character to the serial device.
+ *
+ * @param c character to send
+ * @param fd serial device handle
+ *
+ * @note This function will block until the character can be sent.
+ */
+void sio_send(u8_t c, sio_fd_t fd);
+#endif
+
+#ifndef sio_recv
+/**
+ * Receives a single character from the serial device.
+ *
+ * @param fd serial device handle
+ *
+ * @note This function will block until a character is received.
+ */
+u8_t sio_recv(sio_fd_t fd);
+#endif
+
+#ifndef sio_read
+/**
+ * Reads from the serial device.
+ *
+ * @param fd serial device handle
+ * @param data pointer to data buffer for receiving
+ * @param len maximum length (in bytes) of data to receive
+ * @return number of bytes actually received - may be 0 if aborted by sio_read_abort
+ *
+ * @note This function will block until data can be received. The blocking
+ * can be cancelled by calling sio_read_abort().
+ */
+u32_t sio_read(sio_fd_t fd, u8_t *data, u32_t len);
+#endif
+
+#ifndef sio_tryread
+/**
+ * Tries to read from the serial device. Same as sio_read but returns
+ * immediately if no data is available and never blocks.
+ *
+ * @param fd serial device handle
+ * @param data pointer to data buffer for receiving
+ * @param len maximum length (in bytes) of data to receive
+ * @return number of bytes actually received
+ */
+u32_t sio_tryread(sio_fd_t fd, u8_t *data, u32_t len);
+#endif
+
+#ifndef sio_write
+/**
+ * Writes to the serial device.
+ *
+ * @param fd serial device handle
+ * @param data pointer to data to send
+ * @param len length (in bytes) of data to send
+ * @return number of bytes actually sent
+ *
+ * @note This function will block until all data can be sent.
+ */
+u32_t sio_write(sio_fd_t fd, u8_t *data, u32_t len);
+#endif
+
+#ifndef sio_read_abort
+/**
+ * Aborts a blocking sio_read() call.
+ *
+ * @param fd serial device handle
+ */
+void sio_read_abort(sio_fd_t fd);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* SIO_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/snmp.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/snmp.h
new file mode 100644
index 000000000..8704d0b4d
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/snmp.h
@@ -0,0 +1,213 @@
+/**
+ * @file
+ * SNMP support API for implementing netifs and statitics for MIB2
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Dirk Ziegelmeier <dziegel@gmx.de>
+ *
+ */
+#ifndef LWIP_HDR_SNMP_H
+#define LWIP_HDR_SNMP_H
+
+#include "lwip/opt.h"
+#include "lwip/ip_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct udp_pcb;
+struct netif;
+
+/**
+ * @defgroup netif_mib2 MIB2 statistics
+ * @ingroup netif
+ */
+
+/* MIB2 statistics functions */
+#if MIB2_STATS  /* don't build if not configured for use in lwipopts.h */
+/**
+ * @ingroup netif_mib2
+ * @see RFC1213, "MIB-II, 6. Definitions"
+ */
+enum snmp_ifType {
+  snmp_ifType_other=1,                /* none of the following */
+  snmp_ifType_regular1822,
+  snmp_ifType_hdh1822,
+  snmp_ifType_ddn_x25,
+  snmp_ifType_rfc877_x25,
+  snmp_ifType_ethernet_csmacd,
+  snmp_ifType_iso88023_csmacd,
+  snmp_ifType_iso88024_tokenBus,
+  snmp_ifType_iso88025_tokenRing,
+  snmp_ifType_iso88026_man,
+  snmp_ifType_starLan,
+  snmp_ifType_proteon_10Mbit,
+  snmp_ifType_proteon_80Mbit,
+  snmp_ifType_hyperchannel,
+  snmp_ifType_fddi,
+  snmp_ifType_lapb,
+  snmp_ifType_sdlc,
+  snmp_ifType_ds1,                    /* T-1 */
+  snmp_ifType_e1,                     /* european equiv. of T-1 */
+  snmp_ifType_basicISDN,
+  snmp_ifType_primaryISDN,            /* proprietary serial */
+  snmp_ifType_propPointToPointSerial,
+  snmp_ifType_ppp,
+  snmp_ifType_softwareLoopback,
+  snmp_ifType_eon,                    /* CLNP over IP [11] */
+  snmp_ifType_ethernet_3Mbit,
+  snmp_ifType_nsip,                   /* XNS over IP */
+  snmp_ifType_slip,                   /* generic SLIP */
+  snmp_ifType_ultra,                  /* ULTRA technologies */
+  snmp_ifType_ds3,                    /* T-3 */
+  snmp_ifType_sip,                    /* SMDS */
+  snmp_ifType_frame_relay
+};
+
+/** This macro has a precision of ~49 days because sys_now returns u32_t. \#define your own if you want ~490 days. */
+#ifndef MIB2_COPY_SYSUPTIME_TO
+#define MIB2_COPY_SYSUPTIME_TO(ptrToVal) (*(ptrToVal) = (sys_now() / 10))
+#endif
+
+/**
+ * @ingroup netif_mib2
+ * Increment stats member for SNMP MIB2 stats (struct stats_mib2_netif_ctrs)
+ */
+#define MIB2_STATS_NETIF_INC(n, x)      do { ++(n)->mib2_counters.x; } while(0)
+/**
+ * @ingroup netif_mib2
+ * Add value to stats member for SNMP MIB2 stats (struct stats_mib2_netif_ctrs)
+ */
+#define MIB2_STATS_NETIF_ADD(n, x, val) do { (n)->mib2_counters.x += (val); } while(0)
+
+/**
+ * @ingroup netif_mib2
+ * Init MIB2 statistic counters in netif
+ * @param netif Netif to init
+ * @param type one of enum @ref snmp_ifType
+ * @param speed your link speed here (units: bits per second)
+ */
+#define MIB2_INIT_NETIF(netif, type, speed) do { \
+  (netif)->link_type = (type);  \
+  (netif)->link_speed = (speed);\
+  (netif)->ts = 0;              \
+  (netif)->mib2_counters.ifinoctets = 0;      \
+  (netif)->mib2_counters.ifinucastpkts = 0;   \
+  (netif)->mib2_counters.ifinnucastpkts = 0;  \
+  (netif)->mib2_counters.ifindiscards = 0;    \
+  (netif)->mib2_counters.ifinerrors = 0;    \
+  (netif)->mib2_counters.ifinunknownprotos = 0;    \
+  (netif)->mib2_counters.ifoutoctets = 0;     \
+  (netif)->mib2_counters.ifoutucastpkts = 0;  \
+  (netif)->mib2_counters.ifoutnucastpkts = 0; \
+  (netif)->mib2_counters.ifoutdiscards = 0; \
+  (netif)->mib2_counters.ifouterrors = 0; } while(0)
+#else /* MIB2_STATS */
+#ifndef MIB2_COPY_SYSUPTIME_TO
+#define MIB2_COPY_SYSUPTIME_TO(ptrToVal)
+#endif
+#define MIB2_INIT_NETIF(netif, type, speed)
+#define MIB2_STATS_NETIF_INC(n, x)
+#define MIB2_STATS_NETIF_ADD(n, x, val)
+#endif /* MIB2_STATS */
+
+/* LWIP MIB2 callbacks */
+#if LWIP_MIB2_CALLBACKS /* don't build if not configured for use in lwipopts.h */
+/* network interface */
+void mib2_netif_added(struct netif *ni);
+void mib2_netif_removed(struct netif *ni);
+
+#if LWIP_IPV4 && LWIP_ARP
+/* ARP (for atTable and ipNetToMediaTable) */
+void mib2_add_arp_entry(struct netif *ni, ip4_addr_t *ip);
+void mib2_remove_arp_entry(struct netif *ni, ip4_addr_t *ip);
+#else /* LWIP_IPV4 && LWIP_ARP */
+#define mib2_add_arp_entry(ni,ip)
+#define mib2_remove_arp_entry(ni,ip)
+#endif /* LWIP_IPV4 && LWIP_ARP */
+
+/* IP */
+#if LWIP_IPV4
+void mib2_add_ip4(struct netif *ni);
+void mib2_remove_ip4(struct netif *ni);
+void mib2_add_route_ip4(u8_t dflt, struct netif *ni);
+void mib2_remove_route_ip4(u8_t dflt, struct netif *ni);
+#endif /* LWIP_IPV4 */
+
+/* UDP */
+#if LWIP_UDP
+void mib2_udp_bind(struct udp_pcb *pcb);
+void mib2_udp_unbind(struct udp_pcb *pcb);
+#endif /* LWIP_UDP */
+
+#else /* LWIP_MIB2_CALLBACKS */
+/* LWIP_MIB2_CALLBACKS support not available */
+/* define everything to be empty */
+
+/* network interface */
+#define mib2_netif_added(ni)
+#define mib2_netif_removed(ni)
+
+/* ARP */
+#define mib2_add_arp_entry(ni,ip)
+#define mib2_remove_arp_entry(ni,ip)
+
+/* IP */
+#define mib2_add_ip4(ni)
+#define mib2_remove_ip4(ni)
+#define mib2_add_route_ip4(dflt, ni)
+#define mib2_remove_route_ip4(dflt, ni)
+
+/* UDP */
+#define mib2_udp_bind(pcb)
+#define mib2_udp_unbind(pcb)
+#endif /* LWIP_MIB2_CALLBACKS */
+
+/* for source-code compatibility reasons only, can be removed (not used internally) */
+#define NETIF_INIT_SNMP                MIB2_INIT_NETIF
+#define snmp_add_ifinoctets(ni,value)  MIB2_STATS_NETIF_ADD(ni, ifinoctets, value)
+#define snmp_inc_ifinucastpkts(ni)     MIB2_STATS_NETIF_INC(ni, ifinucastpkts)
+#define snmp_inc_ifinnucastpkts(ni)    MIB2_STATS_NETIF_INC(ni, ifinnucastpkts)
+#define snmp_inc_ifindiscards(ni)      MIB2_STATS_NETIF_INC(ni, ifindiscards)
+#define snmp_inc_ifinerrors(ni)        MIB2_STATS_NETIF_INC(ni, ifinerrors)
+#define snmp_inc_ifinunknownprotos(ni) MIB2_STATS_NETIF_INC(ni, ifinunknownprotos)
+#define snmp_add_ifoutoctets(ni,value) MIB2_STATS_NETIF_ADD(ni, ifoutoctets, value)
+#define snmp_inc_ifoutucastpkts(ni)    MIB2_STATS_NETIF_INC(ni, ifoutucastpkts)
+#define snmp_inc_ifoutnucastpkts(ni)   MIB2_STATS_NETIF_INC(ni, ifoutnucastpkts)
+#define snmp_inc_ifoutdiscards(ni)     MIB2_STATS_NETIF_INC(ni, ifoutdiscards)
+#define snmp_inc_ifouterrors(ni)       MIB2_STATS_NETIF_INC(ni, ifouterrors)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_SNMP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/sockets.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/sockets.h
new file mode 100644
index 000000000..2522056db
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/sockets.h
@@ -0,0 +1,593 @@
+/**
+ * @file
+ * Socket API (to be used from non-TCPIP threads)
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+
+#ifndef LWIP_HDR_SOCKETS_H
+#define LWIP_HDR_SOCKETS_H
+
+#include "lwip/opt.h"
+
+#if LWIP_SOCKET /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/ip_addr.h"
+#include "lwip/err.h"
+#include "lwip/inet.h"
+#include "lwip/errno.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* If your port already typedef's sa_family_t, define SA_FAMILY_T_DEFINED
+   to prevent this code from redefining it. */
+#if !defined(sa_family_t) && !defined(SA_FAMILY_T_DEFINED)
+typedef u8_t sa_family_t;
+#endif
+/* If your port already typedef's in_port_t, define IN_PORT_T_DEFINED
+   to prevent this code from redefining it. */
+#if !defined(in_port_t) && !defined(IN_PORT_T_DEFINED)
+typedef u16_t in_port_t;
+#endif
+
+#if LWIP_IPV4
+/* members are in network byte order */
+struct sockaddr_in {
+  u8_t            sin_len;
+  sa_family_t     sin_family;
+  in_port_t       sin_port;
+  struct in_addr  sin_addr;
+#define SIN_ZERO_LEN 8
+  char            sin_zero[SIN_ZERO_LEN];
+};
+#endif /* LWIP_IPV4 */
+
+#if LWIP_IPV6
+struct sockaddr_in6 {
+  u8_t            sin6_len;      /* length of this structure    */
+  sa_family_t     sin6_family;   /* AF_INET6                    */
+  in_port_t       sin6_port;     /* Transport layer port #      */
+  u32_t           sin6_flowinfo; /* IPv6 flow information       */
+  struct in6_addr sin6_addr;     /* IPv6 address                */
+  u32_t           sin6_scope_id; /* Set of interfaces for scope */
+};
+#endif /* LWIP_IPV6 */
+
+struct sockaddr {
+  u8_t        sa_len;
+  sa_family_t sa_family;
+  char        sa_data[14];
+};
+
+struct sockaddr_storage {
+  u8_t        s2_len;
+  sa_family_t ss_family;
+  char        s2_data1[2];
+  u32_t       s2_data2[3];
+#if LWIP_IPV6
+  u32_t       s2_data3[3];
+#endif /* LWIP_IPV6 */
+};
+
+/* If your port already typedef's socklen_t, define SOCKLEN_T_DEFINED
+   to prevent this code from redefining it. */
+#if !defined(socklen_t) && !defined(SOCKLEN_T_DEFINED)
+typedef u32_t socklen_t;
+#endif
+
+struct lwip_sock;
+
+#if !LWIP_TCPIP_CORE_LOCKING
+/** Maximum optlen used by setsockopt/getsockopt */
+#define LWIP_SETGETSOCKOPT_MAXOPTLEN 16
+
+/** This struct is used to pass data to the set/getsockopt_internal
+ * functions running in tcpip_thread context (only a void* is allowed) */
+struct lwip_setgetsockopt_data {
+  /** socket index for which to change options */
+  int s;
+  /** level of the option to process */
+  int level;
+  /** name of the option to process */
+  int optname;
+  /** set: value to set the option to
+    * get: value of the option is stored here */
+#if LWIP_MPU_COMPATIBLE
+  u8_t optval[LWIP_SETGETSOCKOPT_MAXOPTLEN];
+#else
+  union {
+     void *p;
+     const void *pc;
+  } optval;
+#endif
+  /** size of *optval */
+  socklen_t optlen;
+  /** if an error occurs, it is temporarily stored here */
+  err_t err;
+  /** semaphore to wake up the calling task */
+  void* completed_sem;
+};
+#endif /* !LWIP_TCPIP_CORE_LOCKING */
+
+#if !defined(iovec)
+struct iovec {
+  void  *iov_base;
+  size_t iov_len;
+};
+#endif
+
+struct msghdr {
+  void         *msg_name;
+  socklen_t     msg_namelen;
+  struct iovec *msg_iov;
+  int           msg_iovlen;
+  void         *msg_control;
+  socklen_t     msg_controllen;
+  int           msg_flags;
+};
+
+/* Socket protocol types (TCP/UDP/RAW) */
+#define SOCK_STREAM     1
+#define SOCK_DGRAM      2
+#define SOCK_RAW        3
+
+/*
+ * Option flags per-socket. These must match the SOF_ flags in ip.h (checked in init.c)
+ */
+#define SO_REUSEADDR   0x0004 /* Allow local address reuse */
+#define SO_KEEPALIVE   0x0008 /* keep connections alive */
+#define SO_BROADCAST   0x0020 /* permit to send and to receive broadcast messages (see IP_SOF_BROADCAST option) */
+
+
+/*
+ * Additional options, not kept in so_options.
+ */
+#define SO_DEBUG       0x0001 /* Unimplemented: turn on debugging info recording */
+#define SO_ACCEPTCONN  0x0002 /* socket has had listen() */
+#define SO_DONTROUTE   0x0010 /* Unimplemented: just use interface addresses */
+#define SO_USELOOPBACK 0x0040 /* Unimplemented: bypass hardware when possible */
+#define SO_LINGER      0x0080 /* linger on close if data present */
+#define SO_DONTLINGER  ((int)(~SO_LINGER))
+#define SO_OOBINLINE   0x0100 /* Unimplemented: leave received OOB data in line */
+#define SO_REUSEPORT   0x0200 /* Unimplemented: allow local address & port reuse */
+#define SO_SNDBUF      0x1001 /* Unimplemented: send buffer size */
+#define SO_RCVBUF      0x1002 /* receive buffer size */
+#define SO_SNDLOWAT    0x1003 /* Unimplemented: send low-water mark */
+#define SO_RCVLOWAT    0x1004 /* Unimplemented: receive low-water mark */
+#define SO_SNDTIMEO    0x1005 /* send timeout */
+#define SO_RCVTIMEO    0x1006 /* receive timeout */
+#define SO_ERROR       0x1007 /* get error status and clear */
+#define SO_TYPE        0x1008 /* get socket type */
+#define SO_CONTIMEO    0x1009 /* Unimplemented: connect timeout */
+#define SO_NO_CHECK    0x100a /* don't create UDP checksum */
+
+
+/*
+ * Structure used for manipulating linger option.
+ */
+struct linger {
+       int l_onoff;                /* option on/off */
+       int l_linger;               /* linger time in seconds */
+};
+
+/*
+ * Level number for (get/set)sockopt() to apply to socket itself.
+ */
+#define  SOL_SOCKET  0xfff    /* options for socket level */
+
+
+#define AF_UNSPEC       0
+#define AF_INET         2
+#if LWIP_IPV6
+#define AF_INET6        10
+#else /* LWIP_IPV6 */
+#define AF_INET6        AF_UNSPEC
+#endif /* LWIP_IPV6 */
+#define PF_INET         AF_INET
+#define PF_INET6        AF_INET6
+#define PF_UNSPEC       AF_UNSPEC
+
+#define IPPROTO_IP      0
+#define IPPROTO_ICMP    1
+#define IPPROTO_TCP     6
+#define IPPROTO_UDP     17
+#if LWIP_IPV6
+#define IPPROTO_IPV6    41
+#define IPPROTO_ICMPV6  58
+#endif /* LWIP_IPV6 */
+#define IPPROTO_UDPLITE 136
+#define IPPROTO_RAW     255
+
+/* Flags we can use with send and recv. */
+#define MSG_PEEK       0x01    /* Peeks at an incoming message */
+#define MSG_WAITALL    0x02    /* Unimplemented: Requests that the function block until the full amount of data requested can be returned */
+#define MSG_OOB        0x04    /* Unimplemented: Requests out-of-band data. The significance and semantics of out-of-band data are protocol-specific */
+#define MSG_DONTWAIT   0x08    /* Nonblocking i/o for this operation only */
+#define MSG_MORE       0x10    /* Sender will send more */
+
+
+/*
+ * Options for level IPPROTO_IP
+ */
+#define IP_TOS             1
+#define IP_TTL             2
+
+#if LWIP_TCP
+/*
+ * Options for level IPPROTO_TCP
+ */
+#define TCP_NODELAY    0x01    /* don't delay send to coalesce packets */
+#define TCP_KEEPALIVE  0x02    /* send KEEPALIVE probes when idle for pcb->keep_idle milliseconds */
+#define TCP_KEEPIDLE   0x03    /* set pcb->keep_idle  - Same as TCP_KEEPALIVE, but use seconds for get/setsockopt */
+#define TCP_KEEPINTVL  0x04    /* set pcb->keep_intvl - Use seconds for get/setsockopt */
+#define TCP_KEEPCNT    0x05    /* set pcb->keep_cnt   - Use number of probes sent for get/setsockopt */
+#endif /* LWIP_TCP */
+
+#if LWIP_IPV6
+/*
+ * Options for level IPPROTO_IPV6
+ */
+#define IPV6_CHECKSUM       7  /* RFC3542: calculate and insert the ICMPv6 checksum for raw sockets. */
+#define IPV6_V6ONLY         27 /* RFC3493: boolean control to restrict AF_INET6 sockets to IPv6 communications only. */
+#endif /* LWIP_IPV6 */
+
+#if LWIP_UDP && LWIP_UDPLITE
+/*
+ * Options for level IPPROTO_UDPLITE
+ */
+#define UDPLITE_SEND_CSCOV 0x01 /* sender checksum coverage */
+#define UDPLITE_RECV_CSCOV 0x02 /* minimal receiver checksum coverage */
+#endif /* LWIP_UDP && LWIP_UDPLITE*/
+
+
+#if LWIP_MULTICAST_TX_OPTIONS
+/*
+ * Options and types for UDP multicast traffic handling
+ */
+#define IP_MULTICAST_TTL   5
+#define IP_MULTICAST_IF    6
+#define IP_MULTICAST_LOOP  7
+#endif /* LWIP_MULTICAST_TX_OPTIONS */
+
+#if LWIP_IGMP
+/*
+ * Options and types related to multicast membership
+ */
+#define IP_ADD_MEMBERSHIP  3
+#define IP_DROP_MEMBERSHIP 4
+
+typedef struct ip_mreq {
+    struct in_addr imr_multiaddr; /* IP multicast address of group */
+    struct in_addr imr_interface; /* local IP address of interface */
+} ip_mreq;
+#endif /* LWIP_IGMP */
+
+/*
+ * The Type of Service provides an indication of the abstract
+ * parameters of the quality of service desired.  These parameters are
+ * to be used to guide the selection of the actual service parameters
+ * when transmitting a datagram through a particular network.  Several
+ * networks offer service precedence, which somehow treats high
+ * precedence traffic as more important than other traffic (generally
+ * by accepting only traffic above a certain precedence at time of high
+ * load).  The major choice is a three way tradeoff between low-delay,
+ * high-reliability, and high-throughput.
+ * The use of the Delay, Throughput, and Reliability indications may
+ * increase the cost (in some sense) of the service.  In many networks
+ * better performance for one of these parameters is coupled with worse
+ * performance on another.  Except for very unusual cases at most two
+ * of these three indications should be set.
+ */
+#define IPTOS_TOS_MASK          0x1E
+#define IPTOS_TOS(tos)          ((tos) & IPTOS_TOS_MASK)
+#define IPTOS_LOWDELAY          0x10
+#define IPTOS_THROUGHPUT        0x08
+#define IPTOS_RELIABILITY       0x04
+#define IPTOS_LOWCOST           0x02
+#define IPTOS_MINCOST           IPTOS_LOWCOST
+
+/*
+ * The Network Control precedence designation is intended to be used
+ * within a network only.  The actual use and control of that
+ * designation is up to each network. The Internetwork Control
+ * designation is intended for use by gateway control originators only.
+ * If the actual use of these precedence designations is of concern to
+ * a particular network, it is the responsibility of that network to
+ * control the access to, and use of, those precedence designations.
+ */
+#define IPTOS_PREC_MASK                 0xe0
+#define IPTOS_PREC(tos)                ((tos) & IPTOS_PREC_MASK)
+#define IPTOS_PREC_NETCONTROL           0xe0
+#define IPTOS_PREC_INTERNETCONTROL      0xc0
+#define IPTOS_PREC_CRITIC_ECP           0xa0
+#define IPTOS_PREC_FLASHOVERRIDE        0x80
+#define IPTOS_PREC_FLASH                0x60
+#define IPTOS_PREC_IMMEDIATE            0x40
+#define IPTOS_PREC_PRIORITY             0x20
+#define IPTOS_PREC_ROUTINE              0x00
+
+
+/*
+ * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.
+ * lwip_ioctl only supports FIONREAD and FIONBIO, for now
+ *
+ * Ioctl's have the command encoded in the lower word,
+ * and the size of any in or out parameters in the upper
+ * word.  The high 2 bits of the upper word are used
+ * to encode the in/out status of the parameter; for now
+ * we restrict parameters to at most 128 bytes.
+ */
+#if !defined(FIONREAD) || !defined(FIONBIO)
+#define IOCPARM_MASK    0x7fU           /* parameters must be < 128 bytes */
+#define IOC_VOID        0x20000000UL    /* no parameters */
+#define IOC_OUT         0x40000000UL    /* copy out parameters */
+#define IOC_IN          0x80000000UL    /* copy in parameters */
+#define IOC_INOUT       (IOC_IN|IOC_OUT)
+                                        /* 0x20000000 distinguishes new &
+                                           old ioctl's */
+#define _IO(x,y)        (IOC_VOID|((x)<<8)|(y))
+
+#define _IOR(x,y,t)     (IOC_OUT|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))
+
+#define _IOW(x,y,t)     (IOC_IN|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))
+#endif /* !defined(FIONREAD) || !defined(FIONBIO) */
+
+#ifndef FIONREAD
+#define FIONREAD    _IOR('f', 127, unsigned long) /* get # bytes to read */
+#endif
+#ifndef FIONBIO
+#define FIONBIO     _IOW('f', 126, unsigned long) /* set/clear non-blocking i/o */
+#endif
+
+/* Socket I/O Controls: unimplemented */
+#ifndef SIOCSHIWAT
+#define SIOCSHIWAT  _IOW('s',  0, unsigned long)  /* set high watermark */
+#define SIOCGHIWAT  _IOR('s',  1, unsigned long)  /* get high watermark */
+#define SIOCSLOWAT  _IOW('s',  2, unsigned long)  /* set low watermark */
+#define SIOCGLOWAT  _IOR('s',  3, unsigned long)  /* get low watermark */
+#define SIOCATMARK  _IOR('s',  7, unsigned long)  /* at oob mark? */
+#endif
+
+/* commands for fnctl */
+#ifndef F_GETFL
+#define F_GETFL 3
+#endif
+#ifndef F_SETFL
+#define F_SETFL 4
+#endif
+
+/* File status flags and file access modes for fnctl,
+   these are bits in an int. */
+#ifndef O_NONBLOCK
+#define O_NONBLOCK  1 /* nonblocking I/O */
+#endif
+#ifndef O_NDELAY
+#define O_NDELAY    1 /* same as O_NONBLOCK, for compatibility */
+#endif
+
+#ifndef SHUT_RD
+  #define SHUT_RD   0
+  #define SHUT_WR   1
+  #define SHUT_RDWR 2
+#endif
+
+/* FD_SET used for lwip_select */
+#ifndef FD_SET
+#undef  FD_SETSIZE
+/* Make FD_SETSIZE match NUM_SOCKETS in socket.c */
+#define FD_SETSIZE    MEMP_NUM_NETCONN
+#define FDSETSAFESET(n, code) do { \
+  if (((n) - LWIP_SOCKET_OFFSET < MEMP_NUM_NETCONN) && (((int)(n) - LWIP_SOCKET_OFFSET) >= 0)) { \
+  code; }} while(0)
+#define FDSETSAFEGET(n, code) (((n) - LWIP_SOCKET_OFFSET < MEMP_NUM_NETCONN) && (((int)(n) - LWIP_SOCKET_OFFSET) >= 0) ?\
+  (code) : 0)
+#define FD_SET(n, p)  FDSETSAFESET(n, (p)->fd_bits[((n)-LWIP_SOCKET_OFFSET)/8] |=  (1 << (((n)-LWIP_SOCKET_OFFSET) & 7)))
+#define FD_CLR(n, p)  FDSETSAFESET(n, (p)->fd_bits[((n)-LWIP_SOCKET_OFFSET)/8] &= ~(1 << (((n)-LWIP_SOCKET_OFFSET) & 7)))
+#define FD_ISSET(n,p) FDSETSAFEGET(n, (p)->fd_bits[((n)-LWIP_SOCKET_OFFSET)/8] &   (1 << (((n)-LWIP_SOCKET_OFFSET) & 7)))
+#define FD_ZERO(p)    memset((void*)(p), 0, sizeof(*(p)))
+
+typedef struct fd_set
+{
+  unsigned char fd_bits [(FD_SETSIZE+7)/8];
+} fd_set;
+
+#elif LWIP_SOCKET_OFFSET
+#error LWIP_SOCKET_OFFSET does not work with external FD_SET!
+#elif FD_SETSIZE < MEMP_NUM_NETCONN
+#error "external FD_SETSIZE too small for number of sockets"
+#endif /* FD_SET */
+
+/** LWIP_TIMEVAL_PRIVATE: if you want to use the struct timeval provided
+ * by your system, set this to 0 and include <sys/time.h> in cc.h */
+#ifndef LWIP_TIMEVAL_PRIVATE
+#define LWIP_TIMEVAL_PRIVATE 1
+#endif
+
+#if LWIP_TIMEVAL_PRIVATE
+struct timeval {
+  long    tv_sec;         /* seconds */
+  long    tv_usec;        /* and microseconds */
+};
+#endif /* LWIP_TIMEVAL_PRIVATE */
+
+#define lwip_socket_init() /* Compatibility define, no init needed. */
+void lwip_socket_thread_init(void); /* LWIP_NETCONN_SEM_PER_THREAD==1: initialize thread-local semaphore */
+void lwip_socket_thread_cleanup(void); /* LWIP_NETCONN_SEM_PER_THREAD==1: destroy thread-local semaphore */
+
+#if LWIP_COMPAT_SOCKETS == 2
+/* This helps code parsers/code completion by not having the COMPAT functions as defines */
+#define lwip_accept       accept
+#define lwip_bind         bind
+#define lwip_shutdown     shutdown
+#define lwip_getpeername  getpeername
+#define lwip_getsockname  getsockname
+#define lwip_setsockopt   setsockopt
+#define lwip_getsockopt   getsockopt
+#define lwip_close        closesocket
+#define lwip_connect      connect
+#define lwip_listen       listen
+#define lwip_recv         recv
+#define lwip_recvfrom     recvfrom
+#define lwip_send         send
+#define lwip_sendmsg      sendmsg
+#define lwip_sendto       sendto
+#define lwip_socket       socket
+#define lwip_select       select
+#define lwip_ioctlsocket  ioctl
+
+#if LWIP_POSIX_SOCKETS_IO_NAMES
+#define lwip_read         read
+#define lwip_write        write
+#define lwip_writev       writev
+#undef lwip_close
+#define lwip_close        close
+#define closesocket(s)    close(s)
+#define lwip_fcntl        fcntl
+#define lwip_ioctl        ioctl
+#endif /* LWIP_POSIX_SOCKETS_IO_NAMES */
+#endif /* LWIP_COMPAT_SOCKETS == 2 */
+
+int lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen);
+int lwip_bind(int s, const struct sockaddr *name, socklen_t namelen);
+int lwip_shutdown(int s, int how);
+int lwip_getpeername (int s, struct sockaddr *name, socklen_t *namelen);
+int lwip_getsockname (int s, struct sockaddr *name, socklen_t *namelen);
+int lwip_getsockopt (int s, int level, int optname, void *optval, socklen_t *optlen);
+int lwip_setsockopt (int s, int level, int optname, const void *optval, socklen_t optlen);
+int lwip_close(int s);
+int lwip_connect(int s, const struct sockaddr *name, socklen_t namelen);
+int lwip_listen(int s, int backlog);
+int lwip_recv(int s, void *mem, size_t len, int flags);
+int lwip_read(int s, void *mem, size_t len);
+int lwip_recvfrom(int s, void *mem, size_t len, int flags,
+      struct sockaddr *from, socklen_t *fromlen);
+int lwip_send(int s, const void *dataptr, size_t size, int flags);
+int lwip_sendmsg(int s, const struct msghdr *message, int flags);
+int lwip_sendto(int s, const void *dataptr, size_t size, int flags,
+    const struct sockaddr *to, socklen_t tolen);
+int lwip_socket(int domain, int type, int protocol);
+int lwip_write(int s, const void *dataptr, size_t size);
+int lwip_writev(int s, const struct iovec *iov, int iovcnt);
+int lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
+                struct timeval *timeout);
+int lwip_ioctl(int s, long cmd, void *argp);
+int lwip_fcntl(int s, int cmd, int val);
+
+#if LWIP_COMPAT_SOCKETS
+#if LWIP_COMPAT_SOCKETS != 2
+/** @ingroup socket */
+#define accept(s,addr,addrlen)                    lwip_accept(s,addr,addrlen)
+/** @ingroup socket */
+#define bind(s,name,namelen)                      lwip_bind(s,name,namelen)
+/** @ingroup socket */
+#define shutdown(s,how)                           lwip_shutdown(s,how)
+/** @ingroup socket */
+#define getpeername(s,name,namelen)               lwip_getpeername(s,name,namelen)
+/** @ingroup socket */
+#define getsockname(s,name,namelen)               lwip_getsockname(s,name,namelen)
+/** @ingroup socket */
+#define setsockopt(s,level,optname,opval,optlen)  lwip_setsockopt(s,level,optname,opval,optlen)
+/** @ingroup socket */
+#define getsockopt(s,level,optname,opval,optlen)  lwip_getsockopt(s,level,optname,opval,optlen)
+/** @ingroup socket */
+#define closesocket(s)                            lwip_close(s)
+/** @ingroup socket */
+#define connect(s,name,namelen)                   lwip_connect(s,name,namelen)
+/** @ingroup socket */
+#define listen(s,backlog)                         lwip_listen(s,backlog)
+/** @ingroup socket */
+#define recv(s,mem,len,flags)                     lwip_recv(s,mem,len,flags)
+/** @ingroup socket */
+#define recvfrom(s,mem,len,flags,from,fromlen)    lwip_recvfrom(s,mem,len,flags,from,fromlen)
+/** @ingroup socket */
+#define send(s,dataptr,size,flags)                lwip_send(s,dataptr,size,flags)
+/** @ingroup socket */
+#define sendmsg(s,message,flags)                  lwip_sendmsg(s,message,flags)
+/** @ingroup socket */
+#define sendto(s,dataptr,size,flags,to,tolen)     lwip_sendto(s,dataptr,size,flags,to,tolen)
+/** @ingroup socket */
+#define socket(domain,type,protocol)              lwip_socket(domain,type,protocol)
+/** @ingroup socket */
+#define select(maxfdp1,readset,writeset,exceptset,timeout)     lwip_select(maxfdp1,readset,writeset,exceptset,timeout)
+/** @ingroup socket */
+#define ioctlsocket(s,cmd,argp)                   lwip_ioctl(s,cmd,argp)
+
+#if LWIP_POSIX_SOCKETS_IO_NAMES
+/** @ingroup socket */
+#define read(s,mem,len)                           lwip_read(s,mem,len)
+/** @ingroup socket */
+#define write(s,dataptr,len)                      lwip_write(s,dataptr,len)
+/** @ingroup socket */
+#define writev(s,iov,iovcnt)                      lwip_writev(s,iov,iovcnt)
+/** @ingroup socket */
+#define close(s)                                  lwip_close(s)
+/** @ingroup socket */
+#define fcntl(s,cmd,val)                          lwip_fcntl(s,cmd,val)
+/** @ingroup socket */
+#define ioctl(s,cmd,argp)                         lwip_ioctl(s,cmd,argp)
+#endif /* LWIP_POSIX_SOCKETS_IO_NAMES */
+#endif /* LWIP_COMPAT_SOCKETS != 2 */
+
+#if LWIP_IPV4 && LWIP_IPV6
+/** @ingroup socket */
+#define inet_ntop(af,src,dst,size) \
+    (((af) == AF_INET6) ? ip6addr_ntoa_r((const ip6_addr_t*)(src),(dst),(size)) \
+     : (((af) == AF_INET) ? ip4addr_ntoa_r((const ip4_addr_t*)(src),(dst),(size)) : NULL))
+/** @ingroup socket */
+#define inet_pton(af,src,dst) \
+    (((af) == AF_INET6) ? ip6addr_aton((src),(ip6_addr_t*)(dst)) \
+     : (((af) == AF_INET) ? ip4addr_aton((src),(ip4_addr_t*)(dst)) : 0))
+#elif LWIP_IPV4 /* LWIP_IPV4 && LWIP_IPV6 */
+#define inet_ntop(af,src,dst,size) \
+    (((af) == AF_INET) ? ip4addr_ntoa_r((const ip4_addr_t*)(src),(dst),(size)) : NULL)
+#define inet_pton(af,src,dst) \
+    (((af) == AF_INET) ? ip4addr_aton((src),(ip4_addr_t*)(dst)) : 0)
+#else /* LWIP_IPV4 && LWIP_IPV6 */
+#define inet_ntop(af,src,dst,size) \
+    (((af) == AF_INET6) ? ip6addr_ntoa_r((const ip6_addr_t*)(src),(dst),(size)) : NULL)
+#define inet_pton(af,src,dst) \
+    (((af) == AF_INET6) ? ip6addr_aton((src),(ip6_addr_t*)(dst)) : 0)
+#endif /* LWIP_IPV4 && LWIP_IPV6 */
+
+#endif /* LWIP_COMPAT_SOCKETS */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_SOCKET */
+
+#endif /* LWIP_HDR_SOCKETS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/stats.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/stats.h
new file mode 100644
index 000000000..b570dbacf
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/stats.h
@@ -0,0 +1,491 @@
+/**
+ * @file
+ * Statistics API (to be used from TCPIP thread)
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_STATS_H
+#define LWIP_HDR_STATS_H
+
+#include "lwip/opt.h"
+
+#include "lwip/mem.h"
+#include "lwip/memp.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_STATS
+
+#ifndef LWIP_STATS_LARGE
+#define LWIP_STATS_LARGE 0
+#endif
+
+#if LWIP_STATS_LARGE
+#define STAT_COUNTER     u32_t
+#define STAT_COUNTER_F   U32_F
+#else
+#define STAT_COUNTER     u16_t
+#define STAT_COUNTER_F   U16_F
+#endif
+
+/** Protocol related stats */
+struct stats_proto {
+  STAT_COUNTER xmit;             /* Transmitted packets. */
+  STAT_COUNTER recv;             /* Received packets. */
+  STAT_COUNTER fw;               /* Forwarded packets. */
+  STAT_COUNTER drop;             /* Dropped packets. */
+  STAT_COUNTER chkerr;           /* Checksum error. */
+  STAT_COUNTER lenerr;           /* Invalid length error. */
+  STAT_COUNTER memerr;           /* Out of memory error. */
+  STAT_COUNTER rterr;            /* Routing error. */
+  STAT_COUNTER proterr;          /* Protocol error. */
+  STAT_COUNTER opterr;           /* Error in options. */
+  STAT_COUNTER err;              /* Misc error. */
+  STAT_COUNTER cachehit;
+};
+
+/** IGMP stats */
+struct stats_igmp {
+  STAT_COUNTER xmit;             /* Transmitted packets. */
+  STAT_COUNTER recv;             /* Received packets. */
+  STAT_COUNTER drop;             /* Dropped packets. */
+  STAT_COUNTER chkerr;           /* Checksum error. */
+  STAT_COUNTER lenerr;           /* Invalid length error. */
+  STAT_COUNTER memerr;           /* Out of memory error. */
+  STAT_COUNTER proterr;          /* Protocol error. */
+  STAT_COUNTER rx_v1;            /* Received v1 frames. */
+  STAT_COUNTER rx_group;         /* Received group-specific queries. */
+  STAT_COUNTER rx_general;       /* Received general queries. */
+  STAT_COUNTER rx_report;        /* Received reports. */
+  STAT_COUNTER tx_join;          /* Sent joins. */
+  STAT_COUNTER tx_leave;         /* Sent leaves. */
+  STAT_COUNTER tx_report;        /* Sent reports. */
+};
+
+/** Memory stats */
+struct stats_mem {
+#if defined(LWIP_DEBUG) || LWIP_STATS_DISPLAY
+  const char *name;
+#endif /* defined(LWIP_DEBUG) || LWIP_STATS_DISPLAY */
+  STAT_COUNTER err;
+  mem_size_t avail;
+  mem_size_t used;
+  mem_size_t max;
+  STAT_COUNTER illegal;
+};
+
+/** System element stats */
+struct stats_syselem {
+  STAT_COUNTER used;
+  STAT_COUNTER max;
+  STAT_COUNTER err;
+};
+
+/** System stats */
+struct stats_sys {
+  struct stats_syselem sem;
+  struct stats_syselem mutex;
+  struct stats_syselem mbox;
+};
+
+/** SNMP MIB2 stats */
+struct stats_mib2 {
+  /* IP */
+  u32_t ipinhdrerrors;
+  u32_t ipinaddrerrors;
+  u32_t ipinunknownprotos;
+  u32_t ipindiscards;
+  u32_t ipindelivers;
+  u32_t ipoutrequests;
+  u32_t ipoutdiscards;
+  u32_t ipoutnoroutes;
+  u32_t ipreasmoks;
+  u32_t ipreasmfails;
+  u32_t ipfragoks;
+  u32_t ipfragfails;
+  u32_t ipfragcreates;
+  u32_t ipreasmreqds;
+  u32_t ipforwdatagrams;
+  u32_t ipinreceives;
+
+  /* TCP */
+  u32_t tcpactiveopens;
+  u32_t tcppassiveopens;
+  u32_t tcpattemptfails;
+  u32_t tcpestabresets;
+  u32_t tcpoutsegs;
+  u32_t tcpretranssegs;
+  u32_t tcpinsegs;
+  u32_t tcpinerrs;
+  u32_t tcpoutrsts;
+
+  /* UDP */
+  u32_t udpindatagrams;
+  u32_t udpnoports;
+  u32_t udpinerrors;
+  u32_t udpoutdatagrams;
+
+  /* ICMP */
+  u32_t icmpinmsgs;
+  u32_t icmpinerrors;
+  u32_t icmpindestunreachs;
+  u32_t icmpintimeexcds;
+  u32_t icmpinparmprobs;
+  u32_t icmpinsrcquenchs;
+  u32_t icmpinredirects;
+  u32_t icmpinechos;
+  u32_t icmpinechoreps;
+  u32_t icmpintimestamps;
+  u32_t icmpintimestampreps;
+  u32_t icmpinaddrmasks;
+  u32_t icmpinaddrmaskreps;
+  u32_t icmpoutmsgs;
+  u32_t icmpouterrors;
+  u32_t icmpoutdestunreachs;
+  u32_t icmpouttimeexcds;
+  u32_t icmpoutechos; /* can be incremented by user application ('ping') */
+  u32_t icmpoutechoreps;
+};
+
+/**
+ * @ingroup netif_mib2
+ * SNMP MIB2 interface stats
+ */
+struct stats_mib2_netif_ctrs {
+  /** The total number of octets received on the interface, including framing characters */
+  u32_t ifinoctets;
+  /** The number of packets, delivered by this sub-layer to a higher (sub-)layer, which were
+   * not addressed to a multicast or broadcast address at this sub-layer */
+  u32_t ifinucastpkts;
+  /** The number of packets, delivered by this sub-layer to a higher (sub-)layer, which were
+   * addressed to a multicast or broadcast address at this sub-layer */
+  u32_t ifinnucastpkts;
+  /** The number of inbound packets which were chosen to be discarded even though no errors had
+   * been detected to prevent their being deliverable to a higher-layer protocol. One possible
+   * reason for discarding such a packet could be to free up buffer space */
+  u32_t ifindiscards;
+  /** For packet-oriented interfaces, the number of inbound packets that contained errors
+   * preventing them from being deliverable to a higher-layer protocol.  For character-
+   * oriented or fixed-length interfaces, the number of inbound transmission units that
+   * contained errors preventing them from being deliverable to a higher-layer protocol. */
+  u32_t ifinerrors;
+  /** For packet-oriented interfaces, the number of packets received via the interface which
+   * were discarded because of an unknown or unsupported protocol.  For character-oriented
+   * or fixed-length interfaces that support protocol multiplexing the number of transmission
+   * units received via the interface which were discarded because of an unknown or unsupported
+   * protocol. For any interface that does not support protocol multiplexing, this counter will
+   * always be 0 */
+  u32_t ifinunknownprotos;
+  /** The total number of octets transmitted out of the interface, including framing characters. */
+  u32_t ifoutoctets;
+  /** The total number of packets that higher-level protocols requested be transmitted, and
+   * which were not addressed to a multicast or broadcast address at this sub-layer, including
+   * those that were discarded or not sent. */
+  u32_t ifoutucastpkts;
+  /** The total number of packets that higher-level protocols requested be transmitted, and which
+   * were addressed to a multicast or broadcast address at this sub-layer, including
+   * those that were discarded or not sent. */
+  u32_t ifoutnucastpkts;
+  /** The number of outbound packets which were chosen to be discarded even though no errors had
+   * been detected to prevent their being transmitted.  One possible reason for discarding
+   * such a packet could be to free up buffer space. */
+  u32_t ifoutdiscards;
+  /** For packet-oriented interfaces, the number of outbound packets that could not be transmitted
+   * because of errors. For character-oriented or fixed-length interfaces, the number of outbound
+   * transmission units that could not be transmitted because of errors. */
+  u32_t ifouterrors;
+};
+
+/** lwIP stats container */
+struct stats_ {
+#if LINK_STATS
+  /** Link level */
+  struct stats_proto link;
+#endif
+#if ETHARP_STATS
+  /** ARP */
+  struct stats_proto etharp;
+#endif
+#if IPFRAG_STATS
+  /** Fragmentation */
+  struct stats_proto ip_frag;
+#endif
+#if IP_STATS
+  /** IP */
+  struct stats_proto ip;
+#endif
+#if ICMP_STATS
+  /** ICMP */
+  struct stats_proto icmp;
+#endif
+#if IGMP_STATS
+  /** IGMP */
+  struct stats_igmp igmp;
+#endif
+#if UDP_STATS
+  /** UDP */
+  struct stats_proto udp;
+#endif
+#if TCP_STATS
+  /** TCP */
+  struct stats_proto tcp;
+#endif
+#if MEM_STATS
+  /** Heap */
+  struct stats_mem mem;
+#endif
+#if MEMP_STATS
+  /** Internal memory pools */
+  struct stats_mem *memp[MEMP_MAX];
+#endif
+#if SYS_STATS
+  /** System */
+  struct stats_sys sys;
+#endif
+#if IP6_STATS
+  /** IPv6 */
+  struct stats_proto ip6;
+#endif
+#if ICMP6_STATS
+  /** ICMP6 */
+  struct stats_proto icmp6;
+#endif
+#if IP6_FRAG_STATS
+  /** IPv6 fragmentation */
+  struct stats_proto ip6_frag;
+#endif
+#if MLD6_STATS
+  /** Multicast listener discovery */
+  struct stats_igmp mld6;
+#endif
+#if ND6_STATS
+  /** Neighbor discovery */
+  struct stats_proto nd6;
+#endif
+#if MIB2_STATS
+  /** SNMP MIB2 */
+  struct stats_mib2 mib2;
+#endif
+};
+
+/** Global variable containing lwIP internal statistics. Add this to your debugger's watchlist. */
+extern struct stats_ lwip_stats;
+
+/** Init statistics */
+void stats_init(void);
+
+#define STATS_INC(x) ++lwip_stats.x
+#define STATS_DEC(x) --lwip_stats.x
+#define STATS_INC_USED(x, y, type) do { lwip_stats.x.used = (type)(lwip_stats.x.used + y); \
+                                if (lwip_stats.x.max < lwip_stats.x.used) { \
+                                    lwip_stats.x.max = lwip_stats.x.used; \
+                                } \
+                             } while(0)
+#define STATS_GET(x) lwip_stats.x
+#else /* LWIP_STATS */
+#define stats_init()
+#define STATS_INC(x)
+#define STATS_DEC(x)
+#define STATS_INC_USED(x, y, type)
+#endif /* LWIP_STATS */
+
+#if TCP_STATS
+#define TCP_STATS_INC(x) STATS_INC(x)
+#define TCP_STATS_DISPLAY() stats_display_proto(&lwip_stats.tcp, "TCP")
+#else
+#define TCP_STATS_INC(x)
+#define TCP_STATS_DISPLAY()
+#endif
+
+#if UDP_STATS
+#define UDP_STATS_INC(x) STATS_INC(x)
+#define UDP_STATS_DISPLAY() stats_display_proto(&lwip_stats.udp, "UDP")
+#else
+#define UDP_STATS_INC(x)
+#define UDP_STATS_DISPLAY()
+#endif
+
+#if ICMP_STATS
+#define ICMP_STATS_INC(x) STATS_INC(x)
+#define ICMP_STATS_DISPLAY() stats_display_proto(&lwip_stats.icmp, "ICMP")
+#else
+#define ICMP_STATS_INC(x)
+#define ICMP_STATS_DISPLAY()
+#endif
+
+#if IGMP_STATS
+#define IGMP_STATS_INC(x) STATS_INC(x)
+#define IGMP_STATS_DISPLAY() stats_display_igmp(&lwip_stats.igmp, "IGMP")
+#else
+#define IGMP_STATS_INC(x)
+#define IGMP_STATS_DISPLAY()
+#endif
+
+#if IP_STATS
+#define IP_STATS_INC(x) STATS_INC(x)
+#define IP_STATS_DISPLAY() stats_display_proto(&lwip_stats.ip, "IP")
+#else
+#define IP_STATS_INC(x)
+#define IP_STATS_DISPLAY()
+#endif
+
+#if IPFRAG_STATS
+#define IPFRAG_STATS_INC(x) STATS_INC(x)
+#define IPFRAG_STATS_DISPLAY() stats_display_proto(&lwip_stats.ip_frag, "IP_FRAG")
+#else
+#define IPFRAG_STATS_INC(x)
+#define IPFRAG_STATS_DISPLAY()
+#endif
+
+#if ETHARP_STATS
+#define ETHARP_STATS_INC(x) STATS_INC(x)
+#define ETHARP_STATS_DISPLAY() stats_display_proto(&lwip_stats.etharp, "ETHARP")
+#else
+#define ETHARP_STATS_INC(x)
+#define ETHARP_STATS_DISPLAY()
+#endif
+
+#if LINK_STATS
+#define LINK_STATS_INC(x) STATS_INC(x)
+#define LINK_STATS_DISPLAY() stats_display_proto(&lwip_stats.link, "LINK")
+#else
+#define LINK_STATS_INC(x)
+#define LINK_STATS_DISPLAY()
+#endif
+
+#if MEM_STATS
+#define MEM_STATS_AVAIL(x, y) lwip_stats.mem.x = y
+#define MEM_STATS_INC(x) STATS_INC(mem.x)
+#define MEM_STATS_INC_USED(x, y) STATS_INC_USED(mem, y, mem_size_t)
+#define MEM_STATS_DEC_USED(x, y) lwip_stats.mem.x = (mem_size_t)((lwip_stats.mem.x) - (y))
+#define MEM_STATS_DISPLAY() stats_display_mem(&lwip_stats.mem, "HEAP")
+#else
+#define MEM_STATS_AVAIL(x, y)
+#define MEM_STATS_INC(x)
+#define MEM_STATS_INC_USED(x, y)
+#define MEM_STATS_DEC_USED(x, y)
+#define MEM_STATS_DISPLAY()
+#endif
+
+ #if MEMP_STATS
+#define MEMP_STATS_DEC(x, i) STATS_DEC(memp[i]->x)
+#define MEMP_STATS_DISPLAY(i) stats_display_memp(lwip_stats.memp[i], i)
+#define MEMP_STATS_GET(x, i) STATS_GET(memp[i]->x)
+ #else
+#define MEMP_STATS_DEC(x, i)
+#define MEMP_STATS_DISPLAY(i)
+#define MEMP_STATS_GET(x, i) 0
+#endif
+
+#if SYS_STATS
+#define SYS_STATS_INC(x) STATS_INC(sys.x)
+#define SYS_STATS_DEC(x) STATS_DEC(sys.x)
+#define SYS_STATS_INC_USED(x) STATS_INC_USED(sys.x, 1, STAT_COUNTER)
+#define SYS_STATS_DISPLAY() stats_display_sys(&lwip_stats.sys)
+#else
+#define SYS_STATS_INC(x)
+#define SYS_STATS_DEC(x)
+#define SYS_STATS_INC_USED(x)
+#define SYS_STATS_DISPLAY()
+#endif
+
+#if IP6_STATS
+#define IP6_STATS_INC(x) STATS_INC(x)
+#define IP6_STATS_DISPLAY() stats_display_proto(&lwip_stats.ip6, "IPv6")
+#else
+#define IP6_STATS_INC(x)
+#define IP6_STATS_DISPLAY()
+#endif
+
+#if ICMP6_STATS
+#define ICMP6_STATS_INC(x) STATS_INC(x)
+#define ICMP6_STATS_DISPLAY() stats_display_proto(&lwip_stats.icmp6, "ICMPv6")
+#else
+#define ICMP6_STATS_INC(x)
+#define ICMP6_STATS_DISPLAY()
+#endif
+
+#if IP6_FRAG_STATS
+#define IP6_FRAG_STATS_INC(x) STATS_INC(x)
+#define IP6_FRAG_STATS_DISPLAY() stats_display_proto(&lwip_stats.ip6_frag, "IPv6 FRAG")
+#else
+#define IP6_FRAG_STATS_INC(x)
+#define IP6_FRAG_STATS_DISPLAY()
+#endif
+
+#if MLD6_STATS
+#define MLD6_STATS_INC(x) STATS_INC(x)
+#define MLD6_STATS_DISPLAY() stats_display_igmp(&lwip_stats.mld6, "MLDv1")
+#else
+#define MLD6_STATS_INC(x)
+#define MLD6_STATS_DISPLAY()
+#endif
+
+#if ND6_STATS
+#define ND6_STATS_INC(x) STATS_INC(x)
+#define ND6_STATS_DISPLAY() stats_display_proto(&lwip_stats.nd6, "ND")
+#else
+#define ND6_STATS_INC(x)
+#define ND6_STATS_DISPLAY()
+#endif
+
+#if MIB2_STATS
+#define MIB2_STATS_INC(x) STATS_INC(x)
+#else
+#define MIB2_STATS_INC(x)
+#endif
+
+/* Display of statistics */
+#if LWIP_STATS_DISPLAY
+void stats_display(void);
+void stats_display_proto(struct stats_proto *proto, const char *name);
+void stats_display_igmp(struct stats_igmp *igmp, const char *name);
+void stats_display_mem(struct stats_mem *mem, const char *name);
+void stats_display_memp(struct stats_mem *mem, int index);
+void stats_display_sys(struct stats_sys *sys);
+#else /* LWIP_STATS_DISPLAY */
+#define stats_display()
+#define stats_display_proto(proto, name)
+#define stats_display_igmp(igmp, name)
+#define stats_display_mem(mem, name)
+#define stats_display_memp(mem, index)
+#define stats_display_sys(sys)
+#endif /* LWIP_STATS_DISPLAY */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_STATS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/sys.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/sys.h
new file mode 100644
index 000000000..bb4b96061
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/sys.h
@@ -0,0 +1,462 @@
+/**
+ * @file
+ * OS abstraction layer
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ */
+
+#ifndef LWIP_HDR_SYS_H
+#define LWIP_HDR_SYS_H
+
+#include "lwip/opt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if NO_SYS
+
+/* For a totally minimal and standalone system, we provide null
+   definitions of the sys_ functions. */
+typedef u8_t sys_sem_t;
+typedef u8_t sys_mutex_t;
+typedef u8_t sys_mbox_t;
+
+#define sys_sem_new(s, c) ERR_OK
+#define sys_sem_signal(s)
+#define sys_sem_wait(s)
+#define sys_arch_sem_wait(s,t)
+#define sys_sem_free(s)
+#define sys_sem_valid(s) 0
+#define sys_sem_valid_val(s) 0
+#define sys_sem_set_invalid(s)
+#define sys_sem_set_invalid_val(s)
+#define sys_mutex_new(mu) ERR_OK
+#define sys_mutex_lock(mu)
+#define sys_mutex_unlock(mu)
+#define sys_mutex_free(mu)
+#define sys_mutex_valid(mu) 0
+#define sys_mutex_set_invalid(mu)
+#define sys_mbox_new(m, s) ERR_OK
+#define sys_mbox_fetch(m,d)
+#define sys_mbox_tryfetch(m,d)
+#define sys_mbox_post(m,d)
+#define sys_mbox_trypost(m,d)
+#define sys_mbox_free(m)
+#define sys_mbox_valid(m)
+#define sys_mbox_valid_val(m)
+#define sys_mbox_set_invalid(m)
+#define sys_mbox_set_invalid_val(m)
+
+#define sys_thread_new(n,t,a,s,p)
+#define sys_thread_finish(a,b)
+
+#define sys_msleep(t)
+
+#else /* NO_SYS */
+
+/** Return code for timeouts from sys_arch_mbox_fetch and sys_arch_sem_wait */
+#define SYS_ARCH_TIMEOUT 0xffffffffUL
+
+/** sys_mbox_tryfetch() returns SYS_MBOX_EMPTY if appropriate.
+ * For now we use the same magic value, but we allow this to change in future.
+ */
+#define SYS_MBOX_EMPTY SYS_ARCH_TIMEOUT
+
+#include "lwip/err.h"
+#include "arch/sys_arch.h"
+
+/** Function prototype for thread functions */
+typedef void (*lwip_thread_fn)(void *arg);
+
+/* Function prototypes for functions to be implemented by platform ports
+   (in sys_arch.c) */
+
+/* Mutex functions: */
+
+/** Define LWIP_COMPAT_MUTEX if the port has no mutexes and binary semaphores
+    should be used instead */
+#ifndef LWIP_COMPAT_MUTEX
+#define LWIP_COMPAT_MUTEX 0
+#endif
+
+#if LWIP_COMPAT_MUTEX
+/* for old ports that don't have mutexes: define them to binary semaphores */
+#define sys_mutex_t                   sys_sem_t
+#define sys_mutex_new(mutex)          sys_sem_new(mutex, 1)
+#define sys_mutex_lock(mutex)         sys_sem_wait(mutex)
+#define sys_mutex_unlock(mutex)       sys_sem_signal(mutex)
+#define sys_mutex_free(mutex)         sys_sem_free(mutex)
+#define sys_mutex_valid(mutex)        sys_sem_valid(mutex)
+#define sys_mutex_set_invalid(mutex)  sys_sem_set_invalid(mutex)
+
+#else /* LWIP_COMPAT_MUTEX */
+
+/**
+ * @ingroup sys_mutex
+ * Create a new mutex.
+ * Note that mutexes are expected to not be taken recursively by the lwIP code,
+ * so both implementation types (recursive or non-recursive) should work.
+ * @param mutex pointer to the mutex to create
+ * @return ERR_OK if successful, another err_t otherwise
+ */
+err_t sys_mutex_new(sys_mutex_t *mutex);
+/**
+ * @ingroup sys_mutex
+ * Lock a mutex
+ * @param mutex the mutex to lock
+ */
+void sys_mutex_lock(sys_mutex_t *mutex);
+/**
+ * @ingroup sys_mutex
+ * Unlock a mutex
+ * @param mutex the mutex to unlock
+ */
+void sys_mutex_unlock(sys_mutex_t *mutex);
+/**
+ * @ingroup sys_mutex
+ * Delete a semaphore
+ * @param mutex the mutex to delete
+ */
+void sys_mutex_free(sys_mutex_t *mutex);
+#ifndef sys_mutex_valid
+/**
+ * @ingroup sys_mutex
+ * Check if a mutex is valid/allocated: return 1 for valid, 0 for invalid
+ */
+int sys_mutex_valid(sys_mutex_t *mutex);
+#endif
+#ifndef sys_mutex_set_invalid
+/**
+ * @ingroup sys_mutex
+ * Set a mutex invalid so that sys_mutex_valid returns 0
+ */
+void sys_mutex_set_invalid(sys_mutex_t *mutex);
+#endif
+#endif /* LWIP_COMPAT_MUTEX */
+
+/* Semaphore functions: */
+
+/**
+ * @ingroup sys_sem
+ * Create a new semaphore
+ * @param sem pointer to the semaphore to create
+ * @param count initial count of the semaphore
+ * @return ERR_OK if successful, another err_t otherwise
+ */
+err_t sys_sem_new(sys_sem_t *sem, u8_t count);
+/**
+ * @ingroup sys_sem
+ * Signals a semaphore
+ * @param sem the semaphore to signal
+ */
+void sys_sem_signal(sys_sem_t *sem);
+/**
+ * @ingroup sys_sem
+ * Wait for a semaphore for the specified timeout
+ * @param sem the semaphore to wait for
+ * @param timeout timeout in milliseconds to wait (0 = wait forever)
+ * @return time (in milliseconds) waited for the semaphore
+ *         or SYS_ARCH_TIMEOUT on timeout
+ */
+u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout);
+/**
+ * @ingroup sys_sem
+ * Delete a semaphore
+ * @param sem semaphore to delete
+ */
+void sys_sem_free(sys_sem_t *sem);
+/** Wait for a semaphore - forever/no timeout */
+#define sys_sem_wait(sem)                  sys_arch_sem_wait(sem, 0)
+#ifndef sys_sem_valid
+/**
+ * @ingroup sys_sem
+ * Check if a semaphore is valid/allocated: return 1 for valid, 0 for invalid
+ */
+int sys_sem_valid(sys_sem_t *sem);
+#endif
+#ifndef sys_sem_set_invalid
+/**
+ * @ingroup sys_sem
+ * Set a semaphore invalid so that sys_sem_valid returns 0
+ */
+void sys_sem_set_invalid(sys_sem_t *sem);
+#endif
+#ifndef sys_sem_valid_val
+/**
+ * Same as sys_sem_valid() but taking a value, not a pointer
+ */
+#define sys_sem_valid_val(sem)       sys_sem_valid(&(sem))
+#endif
+#ifndef sys_sem_set_invalid_val
+/**
+ * Same as sys_sem_set_invalid() but taking a value, not a pointer
+ */
+#define sys_sem_set_invalid_val(sem) sys_sem_set_invalid(&(sem))
+#endif
+
+#ifndef sys_msleep
+/**
+ * @ingroup sys_misc
+ * Sleep for specified number of ms
+ */
+void sys_msleep(u32_t ms); /* only has a (close to) 1 ms resolution. */
+#endif
+
+/* Mailbox functions. */
+
+/**
+ * @ingroup sys_mbox
+ * Create a new mbox of specified size
+ * @param mbox pointer to the mbox to create
+ * @param size (minimum) number of messages in this mbox
+ * @return ERR_OK if successful, another err_t otherwise
+ */
+err_t sys_mbox_new(sys_mbox_t *mbox, int size);
+/**
+ * @ingroup sys_mbox
+ * Post a message to an mbox - may not fail
+ * -> blocks if full, only used from tasks not from ISR
+ * @param mbox mbox to posts the message
+ * @param msg message to post (ATTENTION: can be NULL)
+ */
+void sys_mbox_post(sys_mbox_t *mbox, void *msg);
+/**
+ * @ingroup sys_mbox
+ * Try to post a message to an mbox - may fail if full or ISR
+ * @param mbox mbox to posts the message
+ * @param msg message to post (ATTENTION: can be NULL)
+ */
+err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg);
+/**
+ * @ingroup sys_mbox
+ * Wait for a new message to arrive in the mbox
+ * @param mbox mbox to get a message from
+ * @param msg pointer where the message is stored
+ * @param timeout maximum time (in milliseconds) to wait for a message (0 = wait forever)
+ * @return time (in milliseconds) waited for a message, may be 0 if not waited
+           or SYS_ARCH_TIMEOUT on timeout
+ *         The returned time has to be accurate to prevent timer jitter!
+ */
+u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout);
+/* Allow port to override with a macro, e.g. special timeout for sys_arch_mbox_fetch() */
+#ifndef sys_arch_mbox_tryfetch
+/**
+ * @ingroup sys_mbox
+ * Wait for a new message to arrive in the mbox
+ * @param mbox mbox to get a message from
+ * @param msg pointer where the message is stored
+ * @return 0 (milliseconds) if a message has been received
+ *         or SYS_MBOX_EMPTY if the mailbox is empty
+ */
+u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg);
+#endif
+/**
+ * For now, we map straight to sys_arch implementation.
+ */
+#define sys_mbox_tryfetch(mbox, msg) sys_arch_mbox_tryfetch(mbox, msg)
+/**
+ * @ingroup sys_mbox
+ * Delete an mbox
+ * @param mbox mbox to delete
+ */
+void sys_mbox_free(sys_mbox_t *mbox);
+#define sys_mbox_fetch(mbox, msg) sys_arch_mbox_fetch(mbox, msg, 0)
+#ifndef sys_mbox_valid
+/**
+ * @ingroup sys_mbox
+ * Check if an mbox is valid/allocated: return 1 for valid, 0 for invalid
+ */
+int sys_mbox_valid(sys_mbox_t *mbox);
+#endif
+#ifndef sys_mbox_set_invalid
+/**
+ * @ingroup sys_mbox
+ * Set an mbox invalid so that sys_mbox_valid returns 0
+ */
+void sys_mbox_set_invalid(sys_mbox_t *mbox);
+#endif
+#ifndef sys_mbox_valid_val
+/**
+ * Same as sys_mbox_valid() but taking a value, not a pointer
+ */
+#define sys_mbox_valid_val(mbox)       sys_mbox_valid(&(mbox))
+#endif
+#ifndef sys_mbox_set_invalid_val
+/**
+ * Same as sys_mbox_set_invalid() but taking a value, not a pointer
+ */
+#define sys_mbox_set_invalid_val(mbox) sys_mbox_set_invalid(&(mbox))
+#endif
+
+
+/**
+ * @ingroup sys_misc
+ * The only thread function:
+ * Creates a new thread
+ * ATTENTION: although this function returns a value, it MUST NOT FAIL (ports have to assert this!)
+ * @param name human-readable name for the thread (used for debugging purposes)
+ * @param thread thread-function
+ * @param arg parameter passed to 'thread'
+ * @param stacksize stack size in bytes for the new thread (may be ignored by ports)
+ * @param prio priority of the new thread (may be ignored by ports) */
+sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread, void *arg, int stacksize, int prio);
+
+/**
+ * Finishes an existing thread
+ * @param thread identifier returned by sys_thread_new
+ */
+err_t sys_thread_finish(sys_thread_t t);
+
+#endif /* NO_SYS */
+
+/* sys_init() must be called before anything else. */
+void sys_init(void);
+
+#ifndef sys_jiffies
+/**
+ * Ticks/jiffies since power up.
+ */
+u32_t sys_jiffies(void);
+#endif
+
+/**
+ * @ingroup sys_time
+ * Returns the current time in milliseconds,
+ * may be the same as sys_jiffies or at least based on it.
+ */
+u32_t sys_now(void);
+
+/* Critical Region Protection */
+/* These functions must be implemented in the sys_arch.c file.
+   In some implementations they can provide a more light-weight protection
+   mechanism than using semaphores. Otherwise semaphores can be used for
+   implementation */
+#ifndef SYS_ARCH_PROTECT
+/** SYS_LIGHTWEIGHT_PROT
+ * define SYS_LIGHTWEIGHT_PROT in lwipopts.h if you want inter-task protection
+ * for certain critical regions during buffer allocation, deallocation and memory
+ * allocation and deallocation.
+ */
+#if SYS_LIGHTWEIGHT_PROT
+
+/**
+ * @ingroup sys_prot
+ * SYS_ARCH_DECL_PROTECT
+ * declare a protection variable. This macro will default to defining a variable of
+ * type sys_prot_t. If a particular port needs a different implementation, then
+ * this macro may be defined in sys_arch.h.
+ */
+#define SYS_ARCH_DECL_PROTECT(lev) sys_prot_t lev
+/**
+ * @ingroup sys_prot
+ * SYS_ARCH_PROTECT
+ * Perform a "fast" protect. This could be implemented by
+ * disabling interrupts for an embedded system or by using a semaphore or
+ * mutex. The implementation should allow calling SYS_ARCH_PROTECT when
+ * already protected. The old protection level is returned in the variable
+ * "lev". This macro will default to calling the sys_arch_protect() function
+ * which should be implemented in sys_arch.c. If a particular port needs a
+ * different implementation, then this macro may be defined in sys_arch.h
+ */
+#define SYS_ARCH_PROTECT(lev) lev = sys_arch_protect()
+/**
+ * @ingroup sys_prot
+ * SYS_ARCH_UNPROTECT
+ * Perform a "fast" set of the protection level to "lev". This could be
+ * implemented by setting the interrupt level to "lev" within the MACRO or by
+ * using a semaphore or mutex.  This macro will default to calling the
+ * sys_arch_unprotect() function which should be implemented in
+ * sys_arch.c. If a particular port needs a different implementation, then
+ * this macro may be defined in sys_arch.h
+ */
+#define SYS_ARCH_UNPROTECT(lev) sys_arch_unprotect(lev)
+sys_prot_t sys_arch_protect(void);
+void sys_arch_unprotect(sys_prot_t pval);
+
+#else
+
+#define SYS_ARCH_DECL_PROTECT(lev)
+#define SYS_ARCH_PROTECT(lev)
+#define SYS_ARCH_UNPROTECT(lev)
+
+#endif /* SYS_LIGHTWEIGHT_PROT */
+
+#endif /* SYS_ARCH_PROTECT */
+
+/*
+ * Macros to set/get and increase/decrease variables in a thread-safe way.
+ * Use these for accessing variable that are used from more than one thread.
+ */
+
+#ifndef SYS_ARCH_INC
+#define SYS_ARCH_INC(var, val) do { \
+                                SYS_ARCH_DECL_PROTECT(old_level); \
+                                SYS_ARCH_PROTECT(old_level); \
+                                var += val; \
+                                SYS_ARCH_UNPROTECT(old_level); \
+                              } while(0)
+#endif /* SYS_ARCH_INC */
+
+#ifndef SYS_ARCH_DEC
+#define SYS_ARCH_DEC(var, val) do { \
+                                SYS_ARCH_DECL_PROTECT(old_level); \
+                                SYS_ARCH_PROTECT(old_level); \
+                                var -= val; \
+                                SYS_ARCH_UNPROTECT(old_level); \
+                              } while(0)
+#endif /* SYS_ARCH_DEC */
+
+#ifndef SYS_ARCH_GET
+#define SYS_ARCH_GET(var, ret) do { \
+                                SYS_ARCH_DECL_PROTECT(old_level); \
+                                SYS_ARCH_PROTECT(old_level); \
+                                ret = var; \
+                                SYS_ARCH_UNPROTECT(old_level); \
+                              } while(0)
+#endif /* SYS_ARCH_GET */
+
+#ifndef SYS_ARCH_SET
+#define SYS_ARCH_SET(var, val) do { \
+                                SYS_ARCH_DECL_PROTECT(old_level); \
+                                SYS_ARCH_PROTECT(old_level); \
+                                var = val; \
+                                SYS_ARCH_UNPROTECT(old_level); \
+                              } while(0)
+#endif /* SYS_ARCH_SET */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_SYS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/tcp.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/tcp.h
new file mode 100644
index 000000000..91dc6eeaa
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/tcp.h
@@ -0,0 +1,438 @@
+/**
+ * @file
+ * TCP API (to be used from TCPIP thread)\n
+ * See also @ref tcp_raw
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_TCP_H
+#define LWIP_HDR_TCP_H
+
+#include "lwip/opt.h"
+
+#if LWIP_TCP /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/mem.h"
+#include "lwip/pbuf.h"
+#include "lwip/ip.h"
+#include "lwip/icmp.h"
+#include "lwip/err.h"
+#include "lwip/ip6.h"
+#include "lwip/ip6_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct tcp_pcb;
+
+/** Function prototype for tcp accept callback functions. Called when a new
+ * connection can be accepted on a listening pcb.
+ *
+ * @param arg Additional argument to pass to the callback function (@see tcp_arg())
+ * @param newpcb The new connection pcb
+ * @param err An error code if there has been an error accepting.
+ *            Only return ERR_ABRT if you have called tcp_abort from within the
+ *            callback function!
+ */
+typedef err_t (*tcp_accept_fn)(void *arg, struct tcp_pcb *newpcb, err_t err);
+
+/** Function prototype for tcp receive callback functions. Called when data has
+ * been received.
+ *
+ * @param arg Additional argument to pass to the callback function (@see tcp_arg())
+ * @param tpcb The connection pcb which received data
+ * @param p The received data (or NULL when the connection has been closed!)
+ * @param err An error code if there has been an error receiving
+ *            Only return ERR_ABRT if you have called tcp_abort from within the
+ *            callback function!
+ */
+typedef err_t (*tcp_recv_fn)(void *arg, struct tcp_pcb *tpcb,
+                             struct pbuf *p, err_t err);
+
+/** Function prototype for tcp sent callback functions. Called when sent data has
+ * been acknowledged by the remote side. Use it to free corresponding resources.
+ * This also means that the pcb has now space available to send new data.
+ *
+ * @param arg Additional argument to pass to the callback function (@see tcp_arg())
+ * @param tpcb The connection pcb for which data has been acknowledged
+ * @param len The amount of bytes acknowledged
+ * @return ERR_OK: try to send some data by calling tcp_output
+ *            Only return ERR_ABRT if you have called tcp_abort from within the
+ *            callback function!
+ */
+typedef err_t (*tcp_sent_fn)(void *arg, struct tcp_pcb *tpcb,
+                              u16_t len);
+
+/** Function prototype for tcp poll callback functions. Called periodically as
+ * specified by @see tcp_poll.
+ *
+ * @param arg Additional argument to pass to the callback function (@see tcp_arg())
+ * @param tpcb tcp pcb
+ * @return ERR_OK: try to send some data by calling tcp_output
+ *            Only return ERR_ABRT if you have called tcp_abort from within the
+ *            callback function!
+ */
+typedef err_t (*tcp_poll_fn)(void *arg, struct tcp_pcb *tpcb);
+
+/** Function prototype for tcp error callback functions. Called when the pcb
+ * receives a RST or is unexpectedly closed for any other reason.
+ *
+ * @note The corresponding pcb is already freed when this callback is called!
+ *
+ * @param arg Additional argument to pass to the callback function (@see tcp_arg())
+ * @param err Error code to indicate why the pcb has been closed
+ *            ERR_ABRT: aborted through tcp_abort or by a TCP timer
+ *            ERR_RST: the connection was reset by the remote host
+ */
+typedef void  (*tcp_err_fn)(void *arg, err_t err);
+
+/** Function prototype for tcp connected callback functions. Called when a pcb
+ * is connected to the remote side after initiating a connection attempt by
+ * calling tcp_connect().
+ *
+ * @param arg Additional argument to pass to the callback function (@see tcp_arg())
+ * @param tpcb The connection pcb which is connected
+ * @param err An unused error code, always ERR_OK currently ;-) @todo!
+ *            Only return ERR_ABRT if you have called tcp_abort from within the
+ *            callback function!
+ *
+ * @note When a connection attempt fails, the error callback is currently called!
+ */
+typedef err_t (*tcp_connected_fn)(void *arg, struct tcp_pcb *tpcb, err_t err);
+
+#if LWIP_WND_SCALE
+#define RCV_WND_SCALE(pcb, wnd) (((wnd) >> (pcb)->rcv_scale))
+#define SND_WND_SCALE(pcb, wnd) (((wnd) << (pcb)->snd_scale))
+#define TCPWND16(x)             ((u16_t)LWIP_MIN((x), 0xFFFF))
+#define TCP_WND_MAX(pcb)        ((tcpwnd_size_t)(((pcb)->flags & TF_WND_SCALE) ? TCP_WND : TCPWND16(TCP_WND)))
+typedef u32_t tcpwnd_size_t;
+#else
+#define RCV_WND_SCALE(pcb, wnd) (wnd)
+#define SND_WND_SCALE(pcb, wnd) (wnd)
+#define TCPWND16(x)             (x)
+#define TCP_WND_MAX(pcb)        TCP_WND
+typedef u16_t tcpwnd_size_t;
+#endif
+
+#if LWIP_WND_SCALE || TCP_LISTEN_BACKLOG || LWIP_TCP_TIMESTAMPS
+typedef u16_t tcpflags_t;
+#else
+typedef u8_t tcpflags_t;
+#endif
+
+enum tcp_state {
+  CLOSED      = 0,
+  LISTEN      = 1,
+  SYN_SENT    = 2,
+  SYN_RCVD    = 3,
+  ESTABLISHED = 4,
+  FIN_WAIT_1  = 5,
+  FIN_WAIT_2  = 6,
+  CLOSE_WAIT  = 7,
+  CLOSING     = 8,
+  LAST_ACK    = 9,
+  TIME_WAIT   = 10
+};
+
+/**
+ * members common to struct tcp_pcb and struct tcp_listen_pcb
+ */
+#define TCP_PCB_COMMON(type) \
+  type *next; /* for the linked list */ \
+  void *callback_arg; \
+  enum tcp_state state; /* TCP state */ \
+  u8_t prio; \
+  /* ports are in host byte order */ \
+  u16_t local_port
+
+
+/** the TCP protocol control block for listening pcbs */
+struct tcp_pcb_listen {
+/** Common members of all PCB types */
+  IP_PCB;
+/** Protocol specific PCB members */
+  TCP_PCB_COMMON(struct tcp_pcb_listen);
+
+#if LWIP_CALLBACK_API
+  /* Function to call when a listener has been connected. */
+  tcp_accept_fn accept;
+#endif /* LWIP_CALLBACK_API */
+
+#if TCP_LISTEN_BACKLOG
+  u8_t backlog;
+  u8_t accepts_pending;
+#endif /* TCP_LISTEN_BACKLOG */
+};
+
+
+/** the TCP protocol control block */
+struct tcp_pcb {
+/** common PCB members */
+  IP_PCB;
+/** protocol specific PCB members */
+  TCP_PCB_COMMON(struct tcp_pcb);
+
+  /* ports are in host byte order */
+  u16_t remote_port;
+
+  tcpflags_t flags;
+#define TF_ACK_DELAY   0x01U   /* Delayed ACK. */
+#define TF_ACK_NOW     0x02U   /* Immediate ACK. */
+#define TF_INFR        0x04U   /* In fast recovery. */
+#define TF_CLOSEPEND   0x08U   /* If this is set, tcp_close failed to enqueue the FIN (retried in tcp_tmr) */
+#define TF_RXCLOSED    0x10U   /* rx closed by tcp_shutdown */
+#define TF_FIN         0x20U   /* Connection was closed locally (FIN segment enqueued). */
+#define TF_NODELAY     0x40U   /* Disable Nagle algorithm */
+#define TF_NAGLEMEMERR 0x80U   /* nagle enabled, memerr, try to output to prevent delayed ACK to happen */
+#if LWIP_WND_SCALE
+#define TF_WND_SCALE   0x0100U /* Window Scale option enabled */
+#endif
+#if TCP_LISTEN_BACKLOG
+#define TF_BACKLOGPEND 0x0200U /* If this is set, a connection pcb has increased the backlog on its listener */
+#endif
+#if LWIP_TCP_TIMESTAMPS
+#define TF_TIMESTAMP   0x0400U   /* Timestamp option enabled */
+#endif
+
+  /* the rest of the fields are in host byte order
+     as we have to do some math with them */
+
+  /* Timers */
+  u8_t polltmr, pollinterval;
+  u8_t last_timer;
+  u32_t tmr;
+
+  /* receiver variables */
+  u32_t rcv_nxt;   /* next seqno expected */
+  tcpwnd_size_t rcv_wnd;   /* receiver window available */
+  tcpwnd_size_t rcv_ann_wnd; /* receiver window to announce */
+  u32_t rcv_ann_right_edge; /* announced right edge of window */
+
+  /* Retransmission timer. */
+  s16_t rtime;
+
+  u16_t mss;   /* maximum segment size */
+
+  /* RTT (round trip time) estimation variables */
+  u32_t rttest; /* RTT estimate in 500ms ticks */
+  u32_t rtseq;  /* sequence number being timed */
+  s16_t sa, sv; /* @todo document this */
+
+  s16_t rto;    /* retransmission time-out */
+  u8_t nrtx;    /* number of retransmissions */
+
+  /* fast retransmit/recovery */
+  u8_t dupacks;
+  u32_t lastack; /* Highest acknowledged seqno. */
+
+  /* congestion avoidance/control variables */
+  tcpwnd_size_t cwnd;
+  tcpwnd_size_t ssthresh;
+
+  /* sender variables */
+  u32_t snd_nxt;   /* next new seqno to be sent */
+  u32_t snd_wl1, snd_wl2; /* Sequence and acknowledgement numbers of last
+                             window update. */
+  u32_t snd_lbb;       /* Sequence number of next byte to be buffered. */
+  tcpwnd_size_t snd_wnd;   /* sender window */
+  tcpwnd_size_t snd_wnd_max; /* the maximum sender window announced by the remote host */
+
+  tcpwnd_size_t snd_buf;   /* Available buffer space for sending (in bytes). */
+#define TCP_SNDQUEUELEN_OVERFLOW (0xffffU-3)
+  u16_t snd_queuelen; /* Number of pbufs currently in the send buffer. */
+
+#if TCP_OVERSIZE
+  /* Extra bytes available at the end of the last pbuf in unsent. */
+  u16_t unsent_oversize;
+#endif /* TCP_OVERSIZE */
+
+  /* These are ordered by sequence number: */
+  struct tcp_seg *unsent;   /* Unsent (queued) segments. */
+  struct tcp_seg *unacked;  /* Sent but unacknowledged segments. */
+#if TCP_QUEUE_OOSEQ
+  struct tcp_seg *ooseq;    /* Received out of sequence segments. */
+#endif /* TCP_QUEUE_OOSEQ */
+
+  struct pbuf *refused_data; /* Data previously received but not yet taken by upper layer */
+
+#if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
+  struct tcp_pcb_listen* listener;
+#endif /* LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG */
+
+#if LWIP_CALLBACK_API
+  /* Function to be called when more send buffer space is available. */
+  tcp_sent_fn sent;
+  /* Function to be called when (in-sequence) data has arrived. */
+  tcp_recv_fn recv;
+  /* Function to be called when a connection has been set up. */
+  tcp_connected_fn connected;
+  /* Function which is called periodically. */
+  tcp_poll_fn poll;
+  /* Function to be called whenever a fatal error occurs. */
+  tcp_err_fn errf;
+#endif /* LWIP_CALLBACK_API */
+
+#if LWIP_TCP_TIMESTAMPS
+  u32_t ts_lastacksent;
+  u32_t ts_recent;
+#endif /* LWIP_TCP_TIMESTAMPS */
+
+  /* idle time before KEEPALIVE is sent */
+  u32_t keep_idle;
+#if LWIP_TCP_KEEPALIVE
+  u32_t keep_intvl;
+  u32_t keep_cnt;
+#endif /* LWIP_TCP_KEEPALIVE */
+
+  /* Persist timer counter */
+  u8_t persist_cnt;
+  /* Persist timer back-off */
+  u8_t persist_backoff;
+
+  /* KEEPALIVE counter */
+  u8_t keep_cnt_sent;
+
+#if LWIP_WND_SCALE
+  u8_t snd_scale;
+  u8_t rcv_scale;
+#endif
+};
+
+#if LWIP_EVENT_API
+
+enum lwip_event {
+  LWIP_EVENT_ACCEPT,
+  LWIP_EVENT_SENT,
+  LWIP_EVENT_RECV,
+  LWIP_EVENT_CONNECTED,
+  LWIP_EVENT_POLL,
+  LWIP_EVENT_ERR
+};
+
+err_t lwip_tcp_event(void *arg, struct tcp_pcb *pcb,
+         enum lwip_event,
+         struct pbuf *p,
+         u16_t size,
+         err_t err);
+
+#endif /* LWIP_EVENT_API */
+
+/* Application program's interface: */
+struct tcp_pcb * tcp_new     (void);
+struct tcp_pcb * tcp_new_ip_type (u8_t type);
+
+void             tcp_arg     (struct tcp_pcb *pcb, void *arg);
+#if LWIP_CALLBACK_API
+void             tcp_recv    (struct tcp_pcb *pcb, tcp_recv_fn recv);
+void             tcp_sent    (struct tcp_pcb *pcb, tcp_sent_fn sent);
+void             tcp_err     (struct tcp_pcb *pcb, tcp_err_fn err);
+void             tcp_accept  (struct tcp_pcb *pcb, tcp_accept_fn accept);
+#endif /* LWIP_CALLBACK_API */
+void             tcp_poll    (struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval);
+
+#define          tcp_set_flags(pcb, set_flags)     do { (pcb)->flags = (tcpflags_t)((pcb)->flags |  (set_flags)); } while(0)
+#define          tcp_clear_flags(pcb, clr_flags)   do { (pcb)->flags = (tcpflags_t)((pcb)->flags & ~(clr_flags)); } while(0)
+#define          tcp_is_flag_set(pcb, flag)        (((pcb)->flags & (flag)) != 0)
+
+#if LWIP_TCP_TIMESTAMPS
+#define          tcp_mss(pcb)             (((pcb)->flags & TF_TIMESTAMP) ? ((pcb)->mss - 12)  : (pcb)->mss)
+#else /* LWIP_TCP_TIMESTAMPS */
+#define          tcp_mss(pcb)             ((pcb)->mss)
+#endif /* LWIP_TCP_TIMESTAMPS */
+#define          tcp_sndbuf(pcb)          (TCPWND16((pcb)->snd_buf))
+#define          tcp_sndqueuelen(pcb)     ((pcb)->snd_queuelen)
+/** @ingroup tcp_raw */
+#define          tcp_nagle_disable(pcb)   tcp_set_flags(pcb, TF_NODELAY)
+/** @ingroup tcp_raw */
+#define          tcp_nagle_enable(pcb)    tcp_clear_flags(pcb, TF_NODELAY)
+/** @ingroup tcp_raw */
+#define          tcp_nagle_disabled(pcb)  tcp_is_flag_set(pcb, TF_NODELAY)
+
+#if TCP_LISTEN_BACKLOG
+#define          tcp_backlog_set(pcb, new_backlog) do { \
+  LWIP_ASSERT("pcb->state == LISTEN (called for wrong pcb?)", (pcb)->state == LISTEN); \
+  ((struct tcp_pcb_listen *)(pcb))->backlog = ((new_backlog) ? (new_backlog) : 1); } while(0)
+void             tcp_backlog_delayed(struct tcp_pcb* pcb);
+void             tcp_backlog_accepted(struct tcp_pcb* pcb);
+#else  /* TCP_LISTEN_BACKLOG */
+#define          tcp_backlog_set(pcb, new_backlog)
+#define          tcp_backlog_delayed(pcb)
+#define          tcp_backlog_accepted(pcb)
+#endif /* TCP_LISTEN_BACKLOG */
+#define          tcp_accepted(pcb) /* compatibility define, not needed any more */
+
+void             tcp_recved  (struct tcp_pcb *pcb, u16_t len);
+err_t            tcp_bind    (struct tcp_pcb *pcb, const ip_addr_t *ipaddr,
+                              u16_t port);
+void             tcp_bind_netif(struct tcp_pcb *pcb, const struct netif *netif);
+err_t            tcp_connect (struct tcp_pcb *pcb, const ip_addr_t *ipaddr,
+                              u16_t port, tcp_connected_fn connected);
+
+struct tcp_pcb * tcp_listen_with_backlog_and_err(struct tcp_pcb *pcb, u8_t backlog, err_t *err);
+struct tcp_pcb * tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog);
+/** @ingroup tcp_raw */
+#define          tcp_listen(pcb) tcp_listen_with_backlog(pcb, TCP_DEFAULT_LISTEN_BACKLOG)
+
+void             tcp_abort (struct tcp_pcb *pcb);
+err_t            tcp_close   (struct tcp_pcb *pcb);
+err_t            tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx);
+
+/* Flags for "apiflags" parameter in tcp_write */
+#define TCP_WRITE_FLAG_COPY 0x01
+#define TCP_WRITE_FLAG_MORE 0x02
+
+err_t            tcp_write   (struct tcp_pcb *pcb, const void *dataptr, u16_t len,
+                              u8_t apiflags);
+
+void             tcp_setprio (struct tcp_pcb *pcb, u8_t prio);
+
+#define TCP_PRIO_MIN    1
+#define TCP_PRIO_NORMAL 64
+#define TCP_PRIO_MAX    127
+
+err_t            tcp_output  (struct tcp_pcb *pcb);
+
+
+const char* tcp_debug_state_str(enum tcp_state s);
+
+/* for compatibility with older implementation */
+#define tcp_new_ip6() tcp_new_ip_type(IPADDR_TYPE_V6)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_TCP */
+
+#endif /* LWIP_HDR_TCP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/tcpip.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/tcpip.h
new file mode 100644
index 000000000..3ebf18df7
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/tcpip.h
@@ -0,0 +1,116 @@
+/**
+ * @file
+ * Functions to sync with TCPIP thread
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_TCPIP_H
+#define LWIP_HDR_TCPIP_H
+
+#include "lwip/opt.h"
+
+#if !NO_SYS /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/err.h"
+#include "lwip/timeouts.h"
+#include "lwip/netif.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_TCPIP_CORE_LOCKING
+/** The global semaphore to lock the stack. */
+extern sys_mutex_t lock_tcpip_core;
+/** Lock lwIP core mutex (needs @ref LWIP_TCPIP_CORE_LOCKING 1) */
+#define LOCK_TCPIP_CORE()     sys_mutex_lock(&lock_tcpip_core)
+/** Unlock lwIP core mutex (needs @ref LWIP_TCPIP_CORE_LOCKING 1) */
+#define UNLOCK_TCPIP_CORE()   sys_mutex_unlock(&lock_tcpip_core)
+#else /* LWIP_TCPIP_CORE_LOCKING */
+#define LOCK_TCPIP_CORE()
+#define UNLOCK_TCPIP_CORE()
+#endif /* LWIP_TCPIP_CORE_LOCKING */
+
+struct pbuf;
+struct netif;
+
+#if LWIP_NETCONN
+struct api_msg;
+#endif /* LWIP_NETCONN */
+
+/** Function prototype for the init_done function passed to tcpip_init */
+typedef void (*tcpip_init_done_fn)(void *arg);
+typedef void (*tcpip_will_finish_fn)(void *arg);
+/** Function prototype for functions passed to tcpip_callback() */
+typedef void (*tcpip_callback_fn)(void *ctx);
+
+/* Forward declarations */
+struct tcpip_callback_msg;
+
+void   tcpip_init(tcpip_init_done_fn tcpip_init_done, void *arg);
+err_t  tcpip_finish(tcpip_will_finish_fn tcpip_will_finish, void *arg);
+
+#if LWIP_NETCONN
+err_t  tcpip_apimsg(struct api_msg *apimsg);
+#endif /* LWIP_NETCONN */
+
+err_t  tcpip_inpkt(struct pbuf *p, struct netif *inp, netif_input_fn input_fn);
+err_t  tcpip_input(struct pbuf *p, struct netif *inp);
+
+err_t  tcpip_callback_with_block(tcpip_callback_fn function, void *ctx, u8_t block);
+/**
+ * @ingroup lwip_os
+ * @see tcpip_callback_with_block
+ */
+#define tcpip_callback(f, ctx)  tcpip_callback_with_block(f, ctx, 1)
+
+struct tcpip_callback_msg* tcpip_callbackmsg_new(tcpip_callback_fn function, void *ctx);
+void   tcpip_callbackmsg_delete(struct tcpip_callback_msg* msg);
+err_t  tcpip_trycallback(struct tcpip_callback_msg* msg);
+
+/* free pbufs or heap memory from another context without blocking */
+err_t  pbuf_free_callback(struct pbuf *p);
+err_t  mem_free_callback(void *m);
+
+#if LWIP_TCPIP_TIMEOUT && LWIP_TIMERS
+err_t  tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg);
+err_t  tcpip_untimeout(sys_timeout_handler h, void *arg);
+#endif /* LWIP_TCPIP_TIMEOUT && LWIP_TIMERS */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !NO_SYS */
+
+#endif /* LWIP_HDR_TCPIP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/timeouts.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/timeouts.h
new file mode 100644
index 000000000..c9b93aa02
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/timeouts.h
@@ -0,0 +1,121 @@
+/**
+ * @file
+ * Timer implementations
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *         Simon Goldschmidt
+ *
+ */
+#ifndef LWIP_HDR_TIMEOUTS_H
+#define LWIP_HDR_TIMEOUTS_H
+
+#include "lwip/opt.h"
+#include "lwip/err.h"
+#if !NO_SYS
+#include "lwip/sys.h"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef LWIP_DEBUG_TIMERNAMES
+#ifdef LWIP_DEBUG
+#define LWIP_DEBUG_TIMERNAMES SYS_DEBUG
+#else /* LWIP_DEBUG */
+#define LWIP_DEBUG_TIMERNAMES 0
+#endif /* LWIP_DEBUG*/
+#endif
+
+/** Function prototype for a stack-internal timer function that has to be
+ * called at a defined interval */
+typedef void (* lwip_cyclic_timer_handler)(void);
+
+/** This struct contains information about a stack-internal timer function
+ that has to be called at a defined interval */
+struct lwip_cyclic_timer {
+  u32_t interval_ms;
+  lwip_cyclic_timer_handler handler;
+#if LWIP_DEBUG_TIMERNAMES
+  const char* handler_name;
+#endif /* LWIP_DEBUG_TIMERNAMES */
+};
+
+/** This array contains all stack-internal cyclic timers. To get the number of
+ * timers, use LWIP_ARRAYSIZE() */
+extern const struct lwip_cyclic_timer lwip_cyclic_timers[];
+
+#if LWIP_TIMERS
+
+/** Function prototype for a timeout callback function. Register such a function
+ * using sys_timeout().
+ *
+ * @param arg Additional argument to pass to the function - set up by sys_timeout()
+ */
+typedef void (* sys_timeout_handler)(void *arg);
+
+struct sys_timeo {
+  struct sys_timeo *next;
+  u32_t time;
+  sys_timeout_handler h;
+  void *arg;
+#if LWIP_DEBUG_TIMERNAMES
+  const char* handler_name;
+#endif /* LWIP_DEBUG_TIMERNAMES */
+};
+
+void sys_timeouts_init(void);
+
+#if LWIP_DEBUG_TIMERNAMES
+void sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char* handler_name);
+#define sys_timeout(msecs, handler, arg) sys_timeout_debug(msecs, handler, arg, #handler)
+#else /* LWIP_DEBUG_TIMERNAMES */
+void sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg);
+#endif /* LWIP_DEBUG_TIMERNAMES */
+
+void sys_untimeout(sys_timeout_handler handler, void *arg);
+void sys_restart_timeouts(void);
+#if NO_SYS
+void sys_check_timeouts(void);
+u32_t sys_timeouts_sleeptime(void);
+#else /* NO_SYS */
+void sys_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg);
+#endif /* NO_SYS */
+
+
+#endif /* LWIP_TIMERS */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_TIMEOUTS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/lwip/udp.h b/cores/nRF5/nordic/config/nrf52840/config/lwip/udp.h
new file mode 100644
index 000000000..85fdd3947
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/lwip/udp.h
@@ -0,0 +1,196 @@
+/**
+ * @file
+ * UDP API (to be used from TCPIP thread)\n
+ * See also @ref udp_raw
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_UDP_H
+#define LWIP_HDR_UDP_H
+
+#include "lwip/opt.h"
+
+#if LWIP_UDP /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/pbuf.h"
+#include "lwip/netif.h"
+#include "lwip/ip_addr.h"
+#include "lwip/ip.h"
+#include "lwip/ip6_addr.h"
+#include "lwip/prot/udp.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define UDP_FLAGS_NOCHKSUM       0x01U
+#define UDP_FLAGS_UDPLITE        0x02U
+#define UDP_FLAGS_CONNECTED      0x04U
+#define UDP_FLAGS_MULTICAST_LOOP 0x08U
+
+struct udp_pcb;
+
+/** Function prototype for udp pcb receive callback functions
+ * addr and port are in same byte order as in the pcb
+ * The callback is responsible for freeing the pbuf
+ * if it's not used any more.
+ *
+ * ATTENTION: Be aware that 'addr' might point into the pbuf 'p' so freeing this pbuf
+ *            can make 'addr' invalid, too.
+ *
+ * @param arg user supplied argument (udp_pcb.recv_arg)
+ * @param pcb the udp_pcb which received data
+ * @param p the packet buffer that was received
+ * @param addr the remote IP address from which the packet was received
+ * @param port the remote port from which the packet was received
+ */
+typedef void (*udp_recv_fn)(void *arg, struct udp_pcb *pcb, struct pbuf *p,
+    const ip_addr_t *addr, u16_t port);
+
+/** the UDP protocol control block */
+struct udp_pcb {
+/** Common members of all PCB types */
+  IP_PCB;
+
+/* Protocol specific PCB members */
+
+  struct udp_pcb *next;
+  struct netif *intf_filter;
+
+  u8_t flags;
+  /** ports are in host byte order */
+  u16_t local_port, remote_port;
+
+#if LWIP_MULTICAST_TX_OPTIONS
+#if LWIP_IPV4
+  /** outgoing network interface for multicast packets, by IPv4 address (if not 'any') */
+  ip4_addr_t mcast_ip4;
+#endif /* LWIP_IPV4 */
+  /** outgoing network interface for multicast packets, by interface index (if nonzero) */
+  u8_t mcast_ifindex;
+  /** TTL for outgoing multicast packets */
+  u8_t mcast_ttl;
+#endif /* LWIP_MULTICAST_TX_OPTIONS */
+
+#if LWIP_UDPLITE
+  /** used for UDP_LITE only */
+  u16_t chksum_len_rx, chksum_len_tx;
+#endif /* LWIP_UDPLITE */
+
+  /** receive callback function */
+  udp_recv_fn recv;
+  /** user-supplied argument for the recv callback */
+  void *recv_arg;
+};
+/* udp_pcbs export for external reference (e.g. SNMP agent) */
+extern struct udp_pcb *udp_pcbs;
+
+/* The following functions is the application layer interface to the
+   UDP code. */
+struct udp_pcb * udp_new        (void);
+struct udp_pcb * udp_new_ip_type(u8_t type);
+void             udp_remove     (struct udp_pcb *pcb);
+err_t            udp_bind       (struct udp_pcb *pcb, const ip_addr_t *ipaddr,
+                                 u16_t port);
+void             udp_bind_netif (struct udp_pcb *pcb, const struct netif* netif);
+err_t            udp_connect    (struct udp_pcb *pcb, const ip_addr_t *ipaddr,
+                                 u16_t port);
+void             udp_disconnect (struct udp_pcb *pcb);
+void             udp_recv       (struct udp_pcb *pcb, udp_recv_fn recv,
+                                 void *recv_arg);
+err_t            udp_sendto_if  (struct udp_pcb *pcb, struct pbuf *p,
+                                 const ip_addr_t *dst_ip, u16_t dst_port,
+                                 struct netif *netif);
+err_t            udp_sendto_if_src(struct udp_pcb *pcb, struct pbuf *p,
+                                 const ip_addr_t *dst_ip, u16_t dst_port,
+                                 struct netif *netif, const ip_addr_t *src_ip);
+err_t            udp_sendto     (struct udp_pcb *pcb, struct pbuf *p,
+                                 const ip_addr_t *dst_ip, u16_t dst_port);
+err_t            udp_send       (struct udp_pcb *pcb, struct pbuf *p);
+
+#if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
+err_t            udp_sendto_if_chksum(struct udp_pcb *pcb, struct pbuf *p,
+                                 const ip_addr_t *dst_ip, u16_t dst_port,
+                                 struct netif *netif, u8_t have_chksum,
+                                 u16_t chksum);
+err_t            udp_sendto_chksum(struct udp_pcb *pcb, struct pbuf *p,
+                                 const ip_addr_t *dst_ip, u16_t dst_port,
+                                 u8_t have_chksum, u16_t chksum);
+err_t            udp_send_chksum(struct udp_pcb *pcb, struct pbuf *p,
+                                 u8_t have_chksum, u16_t chksum);
+err_t            udp_sendto_if_src_chksum(struct udp_pcb *pcb, struct pbuf *p,
+                                 const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif,
+                                 u8_t have_chksum, u16_t chksum, const ip_addr_t *src_ip);
+#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
+
+#define          udp_flags(pcb) ((pcb)->flags)
+#define          udp_setflags(pcb, f)  ((pcb)->flags = (f))
+
+#define          udp_set_flags(pcb, set_flags)     do { (pcb)->flags = (u8_t)((pcb)->flags |  (set_flags)); } while(0)
+#define          udp_clear_flags(pcb, clr_flags)   do { (pcb)->flags = (u8_t)((pcb)->flags & ~(clr_flags)); } while(0)
+#define          udp_is_flag_set(pcb, flag)        (((pcb)->flags & (flag)) != 0)
+
+/* The following functions are the lower layer interface to UDP. */
+void             udp_input      (struct pbuf *p, struct netif *inp);
+
+void             udp_init       (void);
+
+/* for compatibility with older implementation */
+#define udp_new_ip6() udp_new_ip_type(IPADDR_TYPE_V6)
+
+#if LWIP_MULTICAST_TX_OPTIONS
+#if LWIP_IPV4
+#define udp_set_multicast_netif_addr(pcb, ip4addr) ip4_addr_copy((pcb)->mcast_ip4, *(ip4addr))
+#define udp_get_multicast_netif_addr(pcb)          (&(pcb)->mcast_ip4)
+#endif /* LWIP_IPV4 */
+#define udp_set_multicast_netif_index(pcb, idx)    ((pcb)->mcast_ifindex = (idx))
+#define udp_get_multicast_netif_index(pcb)         ((pcb)->mcast_ifindex)
+#define udp_set_multicast_ttl(pcb, value)          ((pcb)->mcast_ttl = (value))
+#define udp_get_multicast_ttl(pcb)                 ((pcb)->mcast_ttl)
+#endif /* LWIP_MULTICAST_TX_OPTIONS */
+
+#if UDP_DEBUG
+void udp_debug_print(struct udp_hdr *udphdr);
+#else
+#define udp_debug_print(udphdr)
+#endif
+
+void udp_netif_ip_addr_changed(const ip_addr_t* old_addr, const ip_addr_t* new_addr);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_UDP */
+
+#endif /* LWIP_HDR_UDP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/messaging/tests/echo/README.md b/cores/nRF5/nordic/config/nrf52840/config/messaging/tests/echo/README.md
new file mode 100644
index 000000000..8606b2130
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/messaging/tests/echo/README.md
@@ -0,0 +1,51 @@
+# CHIP Example Application Tutorial
+
+## Introduction
+
+The CHIP Echo example application shows you how to implement a CHIP application
+program using one of the supported CHIP protocols, namely the very simple CHIP
+Echo protocol. This protocol allows you to send a CHIP message to a peer and
+expect a CHIP response (similar to the ICMP Echo Request/Echo Response
+messages).
+
+CHIP Protocols are, essentially, implementations of specific protocols over the
+CHIP transport. Furthermore, when two CHIP nodes are exchanging messages of a
+particular CHIP protocol, they do so over a construct called a CHIP Exchange
+which is a description of a CHIP-based conversation over a CHIP protocol. A CHIP
+Exchange is characterised by the ExchangeContext object, and every CHIP node
+must create an ExchangeContext object before initiating a CHIP conversation.
+
+After constructing a CHIP ExchangeContext, CHIP messages are sent and received
+using the ChipMessageLayer class which sends the CHIP message over a chosen
+transport (TCP, UDP, or MRP).
+
+## Building
+
+```
+source scripts/activate.sh
+gn gen out/debug
+ninja -C out/debug
+```
+
+-   After the applications are built, it can be found in the build directory as
+    `out/debug/chip-echo-requester and out/debug/chip-echo-responder`
+
+## Example Applications Walk Through
+
+As part of this example, we have a ChipEchoRequester program that acts as the
+client and sends echo requests to a ChipEchoResponder program that receives
+EchoRequests and sends back EchoResponse messages.
+
+### Ping a device over IP
+
+To start the Server in echo mode, run the built executable.
+
+    $ ./chip-echo-responder [--tcp]
+
+To start the Client in echo mode, run the built executable and pass it the IP
+address of the server to talk to.
+
+    $ ./chip-echo-requester <Server's IPv4 address> [--tcp]
+
+If valid values are supplied, it will begin to periodically send messages to the
+server address provided for three times.
diff --git a/cores/nRF5/nordic/config/nrf52840/config/messaging/tests/echo/common.h b/cores/nRF5/nordic/config/nrf52840/config/messaging/tests/echo/common.h
new file mode 100644
index 000000000..652cd8909
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/messaging/tests/echo/common.h
@@ -0,0 +1,40 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines some of the common constants, globals and interfaces
+ *      that are common to and used by CHIP example applications.
+ *
+ */
+
+#pragma once
+
+#include <messaging/ExchangeMgr.h>
+#include <protocols/secure_channel/MessageCounterManager.h>
+#include <transport/SecureSessionMgr.h>
+
+constexpr size_t kMaxTcpActiveConnectionCount = 4;
+constexpr size_t kMaxTcpPendingPackets        = 4;
+constexpr size_t kNetworkSleepTimeMsecs       = (100 * 1000);
+
+extern chip::SecureSessionMgr gSessionManager;
+extern chip::Messaging::ExchangeManager gExchangeManager;
+extern chip::secure_channel::MessageCounterManager gMessageCounterManager;
+
+void InitializeChip(void);
+void ShutdownChip(void);
diff --git a/cores/nRF5/nordic/config/nrf52840/config/nlassert-internal.h b/cores/nRF5/nordic/config/nrf52840/config/nlassert-internal.h
new file mode 100644
index 000000000..174b37fc3
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/nlassert-internal.h
@@ -0,0 +1,489 @@
+/*
+ *   Copyright 2010-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *   Licensed under the Apache License, Version 2.0 (the "License");
+ *   you may not use this file except in compliance with the License.
+ *   You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *   Unless required by applicable law or agreed to in writing, software
+ *   distributed under the License is distributed on an "AS IS" BASIS,
+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *   See the License for the specific language governing permissions and
+ *   limitations under the License.
+ *
+ *    Description:
+ *      This file defines macros internal to the implementation of the
+ *      Nest Labs assertion and exception checking facility.
+ *
+ */
+
+#ifndef NLASSERT_INTERNAL_H
+#define NLASSERT_INTERNAL_H
+
+#if defined(__GNUC__) && (__GNUC__ > 2) && defined(__OPTIMIZE__)
+# define __nlLIKELY(condition)        __builtin_expect(condition, 1)
+# define __nlUNLIKELY(condition)      __builtin_expect(condition, 0)
+#else
+# define __nlLIKELY(condition)        (condition)
+# define __nlUNLIKELY(condition)      (condition)
+#endif /* defined(__GNUC__) && (__GNUC__ > 2) && defined(__OPTIMIZE__) */
+
+// Notes on the unusual design of __nlSHOULD_ASSERT and __nl_ASSERT_UNUSED:
+//
+//
+// For non-production builds (aka "development" or "debug" builds)
+// ===============================================================
+//
+// The nlASSERT(condition) macro evaluates the "condition" expression and, if
+// it is false, calls NL_ASSERT_ABORT() to abort execution (after optionally
+// performing some logging and debugging operations). Partially expanded, for
+// clarity, it looks like this:
+//
+//     if (__nlSHOULD_ASSERT(condition))
+//     {
+//         do
+//         {
+//             /* optional logging, backtrace, and/or trap handling */
+//         } while (0);
+//
+//         {
+//             NL_ASSERT_ABORT();
+//         }
+//     }
+//     else do { /* nothing */ } while (0)
+//
+// NOTE: The "if (foo) / else do { } while (0)" construct is just a more
+//       robust version of the standard "do / while (0)" macro wrapper.
+//       It is explained below, in the comments accompanying __nlCHECK.
+//
+// The __nlSHOULD_ASSERT(condition) macro must evaluate to true if "condition"
+// is false; conceptually, its definition is "!(condition)". But it is not
+// actually defined that way, for this reason:
+//
+// It is not uncommon for an equality test like "if (x == y)" to be accidentally
+// written as an assignment: "if (x = y)". GCC and similar compilers can detect
+// this and emit a warning, but the warning is suppressed if the assignment is
+// surrounded by an extra pair of parentheses to indicate that it is
+// intentional: "if ((x = y))". So if __nlSHOULD_ASSERT(condition) were defined
+// as "!(condition)", the parentheses around "condition" -- required by the "!"
+// operator -- would be seen by the compiler as an indication that the
+// assignment was intentional, so no warning would be emitted if, for example,
+// "nlASSERT(x == y)" were mistakenly written as "nlASSERT(x = y)".
+//
+// Therefore, __nlSHOULD_ASSERT(condition) is defined so that there will be no
+// extra parentheses around "condition" when the nlASSERT(condition) macro is
+// expanded. With this definition, nlASSERT(condition) expands to:
+//
+//     if (condition)
+//     {
+//         /* do nothing */
+//     }
+//     else if (1)
+//     {
+//         do
+//         {
+//             /* optional logging, backtrace, and/or trap handling */
+//         } while (0);
+//
+//         {
+//             NL_ASSERT_ABORT();
+//         }
+//     }
+//     else do { /* nothing */ } while (0)
+//
+// GCC's branch-prediction hinting mechanism ("__builtin_expect(condition,1)")
+// would also suppress the "unintended assignment" warning, so is not used in
+// the macro definition. But the macro compiles to exactly the same assembly
+// code as it would if the hint were included, so omitting the hint incurs no
+// speed or memory cost. This is true for both ARM and x86 ISAs (tested under
+// GCC 4.x.x, with optimization for speed enabled via compiler flag -O3).
+//
+//
+// For production builds (aka "release" builds)
+// ============================================
+//
+// The nlASSERT(condition) macro is disabled by defining it as
+// __nlASSERT_UNUSED(condition).
+//
+// The  __nlASSERT_UNUSED(condition) macro must not perform any logging or
+// debugging operations, and it must not abort program execution even when
+// "condition" is false. It cannot simply be defined as "(void)0", however,
+// because it must allow side effects in "condition", if any, to occur exactly
+// as they would in the non-production version of the macro. And it can't be
+// defined as (void)(condition) because it is desirable for an unintended
+// assignment in "condition" to be caught by the compiler, just as it would be
+// in a non-production build.
+//
+// Therefore, __nl_ASSERT_UNUSED(condition) is defined so that "condition" is
+// treated as a truth value, to ensure that unintended assignment will be
+// caught, and so that "condition" is evaluated at runtime if and only if it
+// would also be evaluated by the non-production version of nlASSERT(condition),
+// to ensure that side effects will occur identically.
+
+#define __nlSHOULD_ASSERT(condition) condition) { /* do nothing */ } else if (1
+
+#define __nlASSERT_UNUSED(condition) do { if (condition) { /* do nothing */ } } while (0)
+
+/** @cond */
+#define __nlSTATIC_ASSERT_CONCAT(aPrefix, aSuffix) aPrefix ## aSuffix
+
+#define _nlSTATIC_ASSERT_CONCAT(aPrefix, aSuffix) __nlSTATIC_ASSERT_CONCAT(aPrefix, aSuffix)
+/** @endcond */
+
+/**
+ *  @def _nlSTATIC_ASSERT(aCondition)
+ *
+ *  @brief
+ *    This checks, at compile-time, for the specified condition, which
+ *    is expected to commonly be true and terminates compilation if the
+ *    condition is false. It is legal, in both C and C++, anywhere that
+ *    a declaration would be.
+ *
+ *  @note This is a package-internal interface. If C++11/C11 or greater is
+ *  available, this falls back to using C++11/C11 intrinsic facilities:
+ *  static_assert or _Static_assert.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion
+ *                          failure. Note, this message is not
+ *                          actually emitted in any meaningful way for
+ *                          non-C11 or -C++11 code. It serves to
+ *                          simply comment or annotate the assertion
+ *                          and to provide interface parallelism with
+ *                          the run-time assertion interfaces.
+ *
+ */
+#if defined(__cplusplus) && (__cplusplus >= 201103L)
+# define _nlSTATIC_ASSERT(aCondition, aMessage) static_assert(aCondition, aMessage)
+#elif defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)
+# define _nlSTATIC_ASSERT(aCondition, aMessage) _Static_assert(aCondition, aMessage)
+#else
+# ifdef __COUNTER__
+#  define _nlSTATIC_ASSERT(aCondition, aMessage) typedef char _nlSTATIC_ASSERT_CONCAT(STATIC_ASSERT_t_, __COUNTER__)[(aCondition) ? 1 : -1] __attribute__ ((unused))
+# else
+#  define _nlSTATIC_ASSERT(aCondition, aMessage) typedef char _nlSTATIC_ASSERT_CONCAT(STATIC_ASSERT_t_, __LINE__)[(aCondition) ? 1 : -1] __attribute__ ((unused))
+# endif
+#endif /* defined(__cplusplus) && (__cplusplus >= 201103L) */
+
+// __nlSTATIC_ASSERT_UNUSED(aCondition)
+//
+// Can be used everywhere that _nlSTATIC_ASSERT can, and behaves exactly the
+// same way except that it never asserts.
+#if defined(__cplusplus) && (__cplusplus >= 201103L)
+# define __nlSTATIC_ASSERT_UNUSED(aCondition, aMessage) static_assert((aCondition) || 1, aMessage)
+#elif defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)
+# define __nlSTATIC_ASSERT_UNUSED(aCondition, aMessage) _Static_assert((aCondition) || 1, aMessage)
+#else
+# ifdef __COUNTER__
+#  define __nlSTATIC_ASSERT_UNUSED(aCondition, aMessage) typedef char _nlSTATIC_ASSERT_CONCAT(STATIC_ASSERT_t_, __COUNTER__)[((aCondition) || 1) ? 1 : -1] __attribute__ ((unused))
+# else
+#  define __nlSTATIC_ASSERT_UNUSED(aCondition, aMessage) typedef char _nlSTATIC_ASSERT_CONCAT(STATIC_ASSERT_t_, __LINE__)[((aCondition) || 1) ? 1 : -1] __attribute__ ((unused))
+# endif
+#endif /* defined(__cplusplus) && (__cplusplus >= 201103L) */
+
+#define __NL_ASSERT_MAYBE_RUN_TRIGGERS(flags, prefix, name, condition, label, file, line, message)             \
+    do                                                                                    \
+    {                                                                                     \
+        if ((flags) & NL_ASSERT_FLAG_LOG) {                                               \
+            NL_ASSERT_LOG(prefix, name, condition, label, file, line, message);           \
+        }                                                                                 \
+        if ((flags) & NL_ASSERT_FLAG_BACKTRACE) {                                         \
+            NL_ASSERT_BACKTRACE();                                                        \
+        }                                                                                 \
+        if ((flags) & NL_ASSERT_FLAG_TRAP) {                                              \
+            NL_ASSERT_TRAP();                                                             \
+        }                                                                                 \
+    } while (0)
+
+#define __NL_ASSERT_MAYBE_RUN_PRE_ACTION_TRIGGERS(flags, prefix, name, condition, label, file, line, message)  \
+    do                                                                                    \
+    {                                                                                     \
+        if ((flags) & NL_ASSERT_FLAG_LOG) {                                               \
+            NL_ASSERT_LOG(prefix, name, condition, label, file, line, message);           \
+        }                                                                                 \
+        if ((flags) & NL_ASSERT_FLAG_BACKTRACE) {                                         \
+            NL_ASSERT_BACKTRACE();                                                        \
+        }                                                                                 \
+    } while (0)
+
+#define __NL_ASSERT_MAYBE_RUN_POST_ACTION_TRIGGERS(flags, prefix, name, condition, label, file, line, message) \
+    do                                                                                    \
+    {                                                                                     \
+        if ((flags) & NL_ASSERT_FLAG_TRAP) {                                              \
+            NL_ASSERT_TRAP();                                                             \
+        }                                                                                 \
+    } while (0)
+
+// __nlEXPECT
+
+#define __nlEXPECT(flags, condition, label)                                               \
+    do                                                                                    \
+    {                                                                                     \
+        if (__nlSHOULD_ASSERT(condition))                                                 \
+        {                                                                                 \
+            __NL_ASSERT_MAYBE_RUN_TRIGGERS((flags),                                       \
+                                           NL_ASSERT_PREFIX_STRING,                       \
+                                           NL_ASSERT_COMPONENT_STRING,                    \
+                                           #condition,                                    \
+                                           #label,                                        \
+                                           NL_ASSERT_FILE,                                \
+                                           __LINE__,                                      \
+                                           0);                                            \
+            goto label;                                                                   \
+        }                                                                                 \
+    } while (0)
+
+#define __nlEXPECT_PRINT(flags, condition, label, message)                                \
+    do                                                                                    \
+    {                                                                                     \
+        if (__nlSHOULD_ASSERT(condition))                                                 \
+        {                                                                                 \
+            __NL_ASSERT_MAYBE_RUN_TRIGGERS((flags),                                       \
+                                           NL_ASSERT_PREFIX_STRING,                       \
+                                           NL_ASSERT_COMPONENT_STRING,                    \
+                                           #condition,                                    \
+                                           #label,                                        \
+                                           NL_ASSERT_FILE,                                \
+                                           __LINE__,                                      \
+                                           message);                                      \
+            goto label;                                                                   \
+        }                                                                                 \
+    } while (0)
+
+#define __nlEXPECT_ACTION(flags, condition, label, action)                                \
+    do                                                                                    \
+    {                                                                                     \
+        if (__nlSHOULD_ASSERT(condition))                                                 \
+        {                                                                                 \
+            __NL_ASSERT_MAYBE_RUN_PRE_ACTION_TRIGGERS((flags),                            \
+                                                      NL_ASSERT_PREFIX_STRING,            \
+                                                      NL_ASSERT_COMPONENT_STRING,         \
+                                                      #condition,                         \
+                                                      #label,                             \
+                                                      NL_ASSERT_FILE,                     \
+                                                      __LINE__,                           \
+                                                      0);                                 \
+            {                                                                             \
+                action;                                                                   \
+            }                                                                             \
+            __NL_ASSERT_MAYBE_RUN_POST_ACTION_TRIGGERS((flags),                           \
+                                                       NL_ASSERT_PREFIX_STRING,           \
+                                                       NL_ASSERT_COMPONENT_STRING,        \
+                                                       #condition,                        \
+                                                       #label,                            \
+                                                       NL_ASSERT_FILE,                    \
+                                                       __LINE__,                          \
+                                                       0);                                \
+            goto label;                                                                   \
+        }                                                                                 \
+    } while (0)
+
+#define __nlEXPECT_ACTION_PRINT(flags, condition, label, action, message)                 \
+    do                                                                                    \
+    {                                                                                     \
+        if (__nlSHOULD_ASSERT(condition))                                                 \
+        {                                                                                 \
+            __NL_ASSERT_MAYBE_RUN_PRE_ACTION_TRIGGERS((flags),                            \
+                                                      NL_ASSERT_PREFIX_STRING,            \
+                                                      NL_ASSERT_COMPONENT_STRING,         \
+                                                      #condition,                         \
+                                                      #label,                             \
+                                                      NL_ASSERT_FILE,                     \
+                                                      __LINE__,                           \
+                                                      message);                           \
+            {                                                                             \
+                action;                                                                   \
+            }                                                                             \
+            __NL_ASSERT_MAYBE_RUN_POST_ACTION_TRIGGERS((flags),                           \
+                                                       NL_ASSERT_PREFIX_STRING,           \
+                                                       NL_ASSERT_COMPONENT_STRING,        \
+                                                       #condition,                        \
+                                                       #label,                            \
+                                                       NL_ASSERT_FILE,                    \
+                                                       __LINE__,                          \
+                                                       message);                          \
+            goto label;                                                                   \
+        }                                                                                 \
+    } while (0)
+
+#define __nlEXPECT_SUCCESS(flags, status, label)                                          __nlEXPECT(flags, status == 0, label)
+#define __nlEXPECT_SUCCESS_PRINT(flags, status, label, message)                           __nlEXPECT_PRINT(flags, status == 0, label, message)
+#define __nlEXPECT_SUCCESS_ACTION(flags, status, label, action)                           __nlEXPECT_ACTION(flags, status == 0, label, action)
+#define __nlEXPECT_SUCCESS_ACTION_PRINT(flags, status, label, action, message)            __nlEXPECT_ACTION_PRINT(flags, status == 0, label, action, message)
+
+#define __nlNEXPECT(flags, condition, label)                                              __nlEXPECT(flags, !(condition), label)
+#define __nlNEXPECT_PRINT(flags, condition, label, message)                               __nlEXPECT_PRINT(flags, !(condition), label, message)
+#define __nlNEXPECT_ACTION(flags, condition, label, action)                               __nlEXPECT_ACTION(flags, !(condition), label, action)
+#define __nlNEXPECT_ACTION_PRINT(flags, condition, label, action, message)                __nlEXPECT_ACTION_PRINT(flags, !(condition), label, action, message)
+
+// __nlCHECK
+//
+// NOTE: Some of these macros take a C statement as a parameter. The unusual
+// "else do {} while(0)" construct allows those macros to work properly when
+// that parameter is set to "continue" or "break" (which isn't unexpected in
+// an assert macro).
+//
+// If the macros were written in the standard way by wrapping them in a
+// "do/while(0)", they could fail silently: A "continue" or "break" statement,
+// intended to break out of one or all iterations of the loop containing the
+// macro invocation -- would instead just break out of the macro's internal
+// do-while.
+
+#define __nlCHECK(flags, condition)                                                       \
+    if (__nlSHOULD_ASSERT(condition))                                                     \
+    {                                                                                     \
+        __NL_ASSERT_MAYBE_RUN_TRIGGERS((flags),                                           \
+                                       NL_ASSERT_PREFIX_STRING,                           \
+                                       NL_ASSERT_COMPONENT_STRING,                        \
+                                       #condition,                                        \
+                                       0,                                                 \
+                                       NL_ASSERT_FILE,                                    \
+                                       __LINE__,                                          \
+                                       0);                                                \
+    }                                                                                     \
+    else do {} while (0)
+
+#define __nlCHECK_ACTION(flags, condition, action)                                        \
+    if (__nlSHOULD_ASSERT(condition))                                                     \
+    {                                                                                     \
+        __NL_ASSERT_MAYBE_RUN_PRE_ACTION_TRIGGERS((flags),                                \
+                                                  NL_ASSERT_PREFIX_STRING,                \
+                                                  NL_ASSERT_COMPONENT_STRING,             \
+                                                  #condition,                             \
+                                                  0,                                      \
+                                                  NL_ASSERT_FILE,                         \
+                                                  __LINE__,                               \
+                                                  0);                                     \
+        {                                                                                 \
+            action;                                                                       \
+        }                                                                                 \
+        __NL_ASSERT_MAYBE_RUN_POST_ACTION_TRIGGERS((flags),                               \
+                                                   NL_ASSERT_PREFIX_STRING,               \
+                                                   NL_ASSERT_COMPONENT_STRING,            \
+                                                   #condition,                            \
+                                                   0,                                     \
+                                                   NL_ASSERT_FILE,                        \
+                                                   __LINE__,                              \
+                                                   0);                                    \
+    }                                                                                     \
+    else do {} while (0) /* This is explained in the comment above __nlCHECK */
+
+#define __nlCHECK_PRINT(flags, condition, message)                                        \
+    if (__nlSHOULD_ASSERT(condition))                                                     \
+    {                                                                                     \
+        __NL_ASSERT_MAYBE_RUN_TRIGGERS((flags),                                           \
+                                       NL_ASSERT_PREFIX_STRING,                           \
+                                       NL_ASSERT_COMPONENT_STRING,                        \
+                                       #condition,                                        \
+                                       0,                                                 \
+                                       NL_ASSERT_FILE,                                    \
+                                       __LINE__,                                          \
+                                       message);                                          \
+    }                                                                                     \
+    else do {} while (0) /* This is explained in the comment above __nlCHECK */
+
+#define __nlCHECK_SUCCESS(flags, status)                                                  __nlCHECK(flags, status == 0)
+#define __nlCHECK_SUCCESS_ACTION(flags, status, action)                                   __nlCHECK_ACTION(flags, status == 0, action)
+#define __nlCHECK_SUCCESS_PRINT(flags, status, message)                                   __nlCHECK_PRINT(flags, status == 0, message)
+
+#define __nlNCHECK(flags, condition)                                                      __nlCHECK(flags, !(condition))
+#define __nlNCHECK_ACTION(flags, condition, action)                                       __nlCHECK_ACTION(flags, !(condition), action)
+#define __nlNCHECK_PRINT(flags, condition, message)                                       __nlCHECK_PRINT(flags, !(condition), message)
+
+// __nlVERIFY
+
+#define __nlVERIFY(flags, condition)                                                      __nlCHECK(flags, condition)
+#define __nlVERIFY_ACTION(flags, condition, action)                                       __nlCHECK_ACTION(flags, condition, action)
+#define __nlVERIFY_PRINT(flags, condition, message)                                       __nlCHECK_PRINT(flags, condition, message)
+
+#define __nlVERIFY_SUCCESS(flags, status)                                                 __nlCHECK_SUCCESS(flags, status)
+#define __nlVERIFY_SUCCESS_ACTION(flags, status, action)                                  __nlCHECK_SUCCESS_ACTION(flags, status, action)
+#define __nlVERIFY_SUCCESS_PRINT(flags, status, message)                                  __nlCHECK_SUCCESS_PRINT(flags, status, message)
+
+#define __nlNVERIFY(flags, condition)                                                     __nlNCHECK(flags, condition)
+#define __nlNVERIFY_ACTION(flags, condition, action)                                      __nlNCHECK_ACTION(flags, condition, action)
+#define __nlNVERIFY_PRINT(flags, condition, message)                                      __nlNCHECK_PRINT(flags, condition, message)
+
+// __nlPRECONDITION
+
+#define __nlPRECONDITION(flags, condition, termination)                                   \
+    if (__nlSHOULD_ASSERT(condition))                                                     \
+    {                                                                                     \
+        __NL_ASSERT_MAYBE_RUN_TRIGGERS((flags),                                           \
+                                       NL_ASSERT_PREFIX_STRING,                           \
+                                       NL_ASSERT_COMPONENT_STRING,                        \
+                                       #condition,                                        \
+                                       0,                                                 \
+                                       NL_ASSERT_FILE,                                    \
+                                       __LINE__,                                          \
+                                       0);                                                \
+        {                                                                                 \
+            termination;                                                                  \
+        }                                                                                 \
+    }                                                                                     \
+    else do {} while (0) /* This is explained in the comment above __nlCHECK */
+
+#define __nlPRECONDITION_ACTION(flags, condition, termination, action)                    \
+    if (__nlSHOULD_ASSERT(condition))                                                     \
+    {                                                                                     \
+        __NL_ASSERT_MAYBE_RUN_PRE_ACTION_TRIGGERS((flags),                                \
+                                                  NL_ASSERT_PREFIX_STRING,                \
+                                                  NL_ASSERT_COMPONENT_STRING,             \
+                                                  #condition,                             \
+                                                  0,                                      \
+                                                  NL_ASSERT_FILE,                         \
+                                                  __LINE__,                               \
+                                                  0);                                     \
+        {                                                                                 \
+            action;                                                                       \
+        }                                                                                 \
+        __NL_ASSERT_MAYBE_RUN_POST_ACTION_TRIGGERS((flags),                               \
+                                                   NL_ASSERT_PREFIX_STRING,               \
+                                                   NL_ASSERT_COMPONENT_STRING,            \
+                                                   #condition,                            \
+                                                   0,                                     \
+                                                   NL_ASSERT_FILE,                        \
+                                                   __LINE__,                              \
+                                                   0);                                    \
+        {                                                                                 \
+            termination;                                                                  \
+        }                                                                                 \
+    }                                                                                     \
+    else do {} while (0) /* This is explained in the comment above __nlCHECK */
+
+#define __nlPRECONDITION_PRINT(flags, condition, termination, message)                    \
+    if (__nlSHOULD_ASSERT(condition))                                                     \
+    {                                                                                     \
+        __NL_ASSERT_MAYBE_RUN_TRIGGERS((flags),                                           \
+                                       NL_ASSERT_PREFIX_STRING,                           \
+                                       NL_ASSERT_COMPONENT_STRING,                        \
+                                       #condition,                                        \
+                                       0,                                                 \
+                                       NL_ASSERT_FILE,                                    \
+                                       __LINE__,                                          \
+                                       message);                                          \
+        {                                                                                 \
+            termination;                                                                  \
+        }                                                                                 \
+    }                                                                                     \
+    else do {} while (0) /* This is explained in the comment above __nlCHECK */
+
+#define __nlPRECONDITION_SUCCESS(flags, status, termination)                              __nlPRECONDITION(flags, status == 0, termination)
+#define __nlPRECONDITION_SUCCESS_ACTION(flags, status, termination, action)               __nlPRECONDITION_ACTION(flags, status == 0, termination, action)
+#define __nlPRECONDITION_SUCCESS_PRINT(flags, status, termination, message)               __nlPRECONDITION_PRINT(flags, status == 0, termination, message)
+
+#define __nlNPRECONDITION(flags, condition, termination)                                  __nlPRECONDITION(flags, !(condition), termination)
+#define __nlNPRECONDITION_ACTION(flags, condition, termination, action)                   __nlPRECONDITION_ACTION(flags, !(condition), termination, action)
+#define __nlNPRECONDITION_PRINT(flags, condition, termination, message)                   __nlPRECONDITION_PRINT(flags, !(condition), termination, message)
+
+// __nlABORT
+
+#define __nlABORT(flags, condition)                                                       __nlPRECONDITION(flags, condition, NL_ASSERT_ABORT())
+
+#define __nlABORT_ACTION(flags, condition, action)                                        __nlPRECONDITION_ACTION(flags, condition, NL_ASSERT_ABORT(), action)
+
+#endif /* NLASSERT_INTERNAL_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/nlassert-nonproduction.h b/cores/nRF5/nordic/config/nrf52840/config/nlassert-nonproduction.h
new file mode 100644
index 000000000..9c1d65367
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/nlassert-nonproduction.h
@@ -0,0 +1,2143 @@
+/*
+ *   Copyright 2010-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *   Licensed under the Apache License, Version 2.0 (the "License");
+ *   you may not use this file except in compliance with the License.
+ *   You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *   Unless required by applicable law or agreed to in writing, software
+ *   distributed under the License is distributed on an "AS IS" BASIS,
+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *   See the License for the specific language governing permissions and
+ *   limitations under the License.
+ *
+ */
+
+/**
+ *    @file
+ *      This file defines macros and interfaces for performing
+ *      compile- and run-time assertion checking and run-time
+ *      exception handling when #NL_ASSERT_PRODUCTION is false.
+ *
+ */
+
+#ifndef NLCORE_NLASSERT_NONPRODUCTION_H
+#define NLCORE_NLASSERT_NONPRODUCTION_H
+
+#include "nlassert-internal.h"
+
+/**
+ *  @ingroup check-style
+ *
+ *  @{
+ *
+ */
+
+/**
+ *  @def NL_ASSERT_CHECK_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for check-style
+ *    exception family assertions when #NL_ASSERT_PRODUCTION is
+ *    disabled.
+ *
+ *  This may be used to override #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_CHECK_NONPRODUCTION_FLAGS NL_ASSERT_CHECK_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ */
+#define NL_ASSERT_CHECK_NONPRODUCTION_FLAGS_DEFAULT                             (NL_ASSERT_FLAG_BACKTRACE | NL_ASSERT_FLAG_LOG | NL_ASSERT_FLAG_TRAP)
+
+/**
+ *  @def NL_ASSERT_CHECK_NONPRODUCTION_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags when #NL_ASSERT_PRODUCTION is
+ *    disabled that govern the behavior for check-style exception
+ *    family assertions when the assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_CHECK_NONPRODUCTION_FLAGS                                     NL_ASSERT_CHECK_NONPRODUCTION_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_CHECK_NONPRODUCTION_FLAGS)
+#define NL_ASSERT_CHECK_NONPRODUCTION_FLAGS                                     (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @def nlCHECK(aCondition)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true and takes action, based on configuration, if
+ *    the condition is false.
+ *
+ *  @note If #NL_ASSERT_PRODUCTION is true, the check is made inactive. But
+ *  side-effects, if any, in the asserted expression will still be produced.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *
+ *  @sa #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS
+ *
+ *  @sa #nlVERIFY
+ *
+ */
+#define nlCHECK(aCondition)                                                     __nlCHECK(NL_ASSERT_CHECK_NONPRODUCTION_FLAGS, aCondition)
+
+/**
+ *  @def nlCHECK_ACTION(aCondition, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true and takes action, based on configuration, and
+ *    executes @p anAction if the condition is false.
+ *
+ *  @note If #NL_ASSERT_PRODUCTION is true, the check is made inactive. But
+ *  side-effects, if any, in the asserted expression will still be produced.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS
+ *
+ *  @sa #nlVERIFY_ACTION
+ *
+ */
+#define nlCHECK_ACTION(aCondition, anAction)                                    __nlCHECK_ACTION(NL_ASSERT_CHECK_NONPRODUCTION_FLAGS, aCondition, anAction)
+
+/**
+ *  @def nlCHECK_PRINT(aCondition, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true and takes action, based on configuration, and
+ *    prints @p aMessage if the condition is false.
+ *
+ *  @note If #NL_ASSERT_PRODUCTION is true, the check is made inactive. But
+ *  side-effects, if any, in the asserted expression will still be produced.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS
+ *
+ *  @sa #nlVERIFY_PRINT
+ *
+ */
+#define nlCHECK_PRINT(aCondition, aMessage)                                     __nlCHECK_PRINT(NL_ASSERT_CHECK_NONPRODUCTION_FLAGS, aCondition, aMessage)
+
+/**
+ *  @def nlCHECK_SUCCESS(aStatus)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)) and takes action, based
+ *    on configuration, if the status is unsuccessful.
+ *
+ *  @note If #NL_ASSERT_PRODUCTION is true, the check is made inactive. But
+ *  side-effects, if any, in the asserted expression will still be produced.
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *
+ *  @sa #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS
+ *
+ *  @sa #nlVERIFY_SUCCESS
+ *
+ */
+#define nlCHECK_SUCCESS(aStatus)                                                __nlCHECK_SUCCESS(NL_ASSERT_CHECK_NONPRODUCTION_FLAGS, aStatus)
+
+/**
+ *  @def nlCHECK_SUCCESS_ACTION(aStatus, anAction)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)) and takes action, based
+ *    on configuration, and executes @p anAction if the status is
+ *    unsuccessful.
+ *
+ *  @note If #NL_ASSERT_PRODUCTION is true, the check is made inactive. But
+ *  side-effects, if any, in the asserted expression will still be produced.
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS
+ *
+ *  @sa #nlVERIFY_SUCCESS_ACTION
+ *
+ */
+#define nlCHECK_SUCCESS_ACTION(aStatus, anAction)                               __nlCHECK_SUCCESS_ACTION(NL_ASSERT_CHECK_NONPRODUCTION_FLAGS, aStatus, anAction)
+
+/**
+ *  @def nlCHECK_SUCCESS_PRINT(aStatus, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)) and takes action, based
+ *    on configuration, and prints @p aMessage if the status is
+ *    unsuccessful.
+ *
+ *  @note If #NL_ASSERT_PRODUCTION is true, the check is made inactive. But
+ *  side-effects, if any, in the asserted expression will still be produced.
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS
+ *
+ *  @sa #nlVERIFY_SUCCESS_PRINT
+ *
+ */
+#define nlCHECK_SUCCESS_PRINT(aStatus, aMessage)                                __nlCHECK_SUCCESS_PRINT(NL_ASSERT_CHECK_NONPRODUCTION_FLAGS, aStatus, aMessage)
+
+/**
+ *  @def nlNCHECK(aCondition)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false and takes action, based on configuration, if
+ *    the condition is true.
+ *
+ *  @note This is the logical inverse of #nlCHECK
+ *
+ *  @note If #NL_ASSERT_PRODUCTION is true, the check is made inactive. But
+ *  side-effects, if any, in the asserted expression will still be produced.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *
+ *  @sa #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK
+ *  @sa #nlNVERIFY
+ *
+ */
+#define nlNCHECK(aCondition)                                                    __nlNCHECK(NL_ASSERT_CHECK_NONPRODUCTION_FLAGS, aCondition)
+
+/**
+ *  @def nlNCHECK_ACTION(aCondition, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false and takes action, based on configuration, and
+ *    executes @p anAction if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlCHECK_ACTION
+ *
+ *  @note If #NL_ASSERT_PRODUCTION is true, the check is made inactive. But
+ *  side-effects, if any, in the asserted expression will still be produced.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK_ACTION
+ *  @sa #nlNVERIFY_ACTION
+ *
+ */
+#define nlNCHECK_ACTION(aCondition, anAction)                                   __nlNCHECK_ACTION(NL_ASSERT_CHECK_NONPRODUCTION_FLAGS, aCondition, anAction)
+
+/**
+ *  @def nlNCHECK_PRINT(aCondition, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false and takes action, based on configuration, and
+ *    prints @p aMessage if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlCHECK_PRINT
+ *
+ *  @note If #NL_ASSERT_PRODUCTION is true, the check is made inactive. But
+ *  side-effects, if any, in the asserted expression will still be produced.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK_PRINT
+ *  @sa #nlNVERIFY_PRINT
+ *
+ */
+#define nlNCHECK_PRINT(aCondition, aMessage)                                    __nlNCHECK_PRINT(NL_ASSERT_CHECK_NONPRODUCTION_FLAGS, aCondition, aMessage)
+
+/**
+ *  @}
+ *
+ */
+
+/**
+ *  @ingroup verify-style
+ *
+ *  @{
+ *
+ */
+
+/**
+ *  @def NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for verify-style
+ *    exception family assertions when #NL_ASSERT_PRODUCTION is
+ *    disabled.
+ *
+ *  This may be used to override #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ */
+#define NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS_DEFAULT                            (NL_ASSERT_FLAG_BACKTRACE | NL_ASSERT_FLAG_LOG | NL_ASSERT_FLAG_TRAP)
+
+/**
+ *  @def NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags when #NL_ASSERT_PRODUCTION is
+ *    disabled that govern the behavior for verify-style exception
+ *    family assertions when the assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS                                    NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS)
+#define NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS                                    (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @def nlVERIFY(aCondition)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true and takes action, based on configuration, if
+ *    the condition is false.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *
+ *  @sa #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_VERIFY_PRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK
+ *
+ */
+#define nlVERIFY(aCondition)                                                    __nlVERIFY(NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS, aCondition)
+
+/**
+ *  @def nlVERIFY_ACTION(aCondition, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true and takes action, based on configuration, and
+ *    executes @p anAction if the condition is false.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_VERIFY_PRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK_ACTION
+ *
+ */
+#define nlVERIFY_ACTION(aCondition, anAction)                                   __nlVERIFY_ACTION(NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS, aCondition, anAction)
+
+/**
+ *  @def nlVERIFY_PRINT(aCondition, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true and takes action, based on configuration, and
+ *    prints @p aMessage if the condition is false.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_VERIFY_PRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK_PRINT
+ *
+ */
+#define nlVERIFY_PRINT(aCondition, aMessage)                                    __nlVERIFY_PRINT(NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS, aCondition, aMessage)
+
+/**
+ *  @def nlVERIFY_SUCCESS(aStatus)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)) and takes action, based
+ *    on configuration, if the status is unsuccessful.
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *
+ *  @sa #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_VERIFY_PRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK_SUCCESS
+ *
+ */
+#define nlVERIFY_SUCCESS(aStatus)                                               __nlVERIFY_SUCCESS(NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS, aStatus)
+
+/**
+ *  @def nlVERIFY_SUCCESS_ACTION(aStatus, anAction)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)) and takes action, based
+ *    on configuration, and executes @p anAction if the status is
+ *    unsuccessful.
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_VERIFY_PRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK_SUCCESS_ACTION
+ *
+ */
+#define nlVERIFY_SUCCESS_ACTION(aStatus, anAction)                              __nlVERIFY_SUCCESS_ACTION(NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS, aStatus, anAction)
+
+/**
+ *  @def nlVERIFY_SUCCESS_PRINT(aStatus, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)) and takes action, based
+ *    on configuration, and prints @p aMessage if the status is
+ *    unsuccessful.
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_VERIFY_PRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK_SUCCESS_PRINT
+ *
+ */
+#define nlVERIFY_SUCCESS_PRINT(aStatus, aMessage)                               __nlVERIFY_SUCCESS_PRINT(NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS, aStatus, aMessage)
+
+/**
+ *  @def nlNVERIFY(aCondition)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false and takes action, based on configuration, if
+ *    the condition is true.
+ *
+ *  @note This is the logical inverse of #nlVERIFY
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *
+ *  @sa #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_VERIFY_PRODUCTION_FLAGS
+ *
+ *  @sa #nlVERIFY
+ *  @sa #nlNCHECK
+ *
+ */
+#define nlNVERIFY(aCondition)                                                   __nlNVERIFY(NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS, aCondition)
+
+/**
+ *  @def nlNVERIFY_ACTION(aCondition, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false and takes action, based on configuration, and
+ *    executes @p anAction if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlVERIFY_ACTION
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_VERIFY_PRODUCTION_FLAGS
+ *
+ *  @sa #nlVERIFY_ACTION
+ *  @sa #nlNCHECK_ACTION
+ *
+ */
+#define nlNVERIFY_ACTION(aCondition, anAction)                                  __nlNVERIFY_ACTION(NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS, aCondition, anAction)
+
+/**
+ *  @def nlNVERIFY_PRINT(aCondition, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false and takes action, based on configuration, and
+ *    prints @p aMessage if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlVERIFY_PRINT
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_VERIFY_PRODUCTION_FLAGS
+ *
+ *  @sa #nlVERIFY_PRINT
+ *  @sa #nlNCHECK_PRINT
+ *
+ */
+#define nlNVERIFY_PRINT(aCondition, aMessage)                                   __nlNVERIFY_PRINT(NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS, aCondition, aMessage)
+
+/**
+ *  @}
+ *
+ */
+
+/**
+ *  @ingroup desire-style
+ *
+ *  @{
+ *
+ */
+
+/**
+ *  @def NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for desire-style
+ *    exception family assertions when #NL_ASSERT_PRODUCTION is
+ *    disabled.
+ *
+ *  This may be used to override #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ */
+#define NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS_DEFAULT                            (NL_ASSERT_FLAG_LOG)
+
+/**
+ *  @def NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags when #NL_ASSERT_PRODUCTION is
+ *    disabled that govern the behavior for desire-style exception
+ *    family assertions when the assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS                                    NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS)
+#define NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS                                    (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @def nlDESIRE(aCondition, aLabel)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and branches to @p aLabel if the condition is
+ *    false.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT
+ *  @sa #nlREQUIRE
+ *
+ */
+#define nlDESIRE(aCondition, aLabel)                                            __nlEXPECT(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS, aCondition, aLabel)
+
+/**
+ *  @def nlDESIRE_PRINT(aCondition, aLabel, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and both prints @p aMessage and then branches
+ *    to @p aLabel if the condition is false.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_PRINT
+ *  @sa #nlREQUIRE_PRINT
+ *
+ */
+#define nlDESIRE_PRINT(aCondition, aLabel, aMessage)                            __nlEXPECT_PRINT(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS, aCondition, aLabel, aMessage)
+
+/**
+ *  @def nlDESIRE_ACTION(aCondition, aLabel, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and both executes @p anAction and branches to
+ *    @p aLabel if the condition is false.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_ACTION
+ *  @sa #nlREQUIRE_ACTION
+ *
+ */
+#define nlDESIRE_ACTION(aCondition, aLabel, anAction)                           __nlEXPECT_ACTION(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS, aCondition, aLabel, anAction)
+
+/**
+ *  @def nlDESIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, prints @p aMessage, executes @p anAction, and
+ *    branches to @p aLabel if the condition is false.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_ACTION_PRINT
+ *  @sa #nlREQUIRE_ACTION_PRINT
+ *
+ */
+#define nlDESIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)           __nlEXPECT_ACTION_PRINT(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS, aCondition, aLabel, anAction, aMessage)
+
+/**
+ *  @def nlDESIRE_SUCCESS(aStatus, aLabel)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and branches to @p
+ *    aLabel if the status is unsuccessful.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aStatus does not evaluate to zero
+ *                          (0).
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS
+ *  @sa #nlREQUIRE_SUCCESS
+ *
+ */
+#define nlDESIRE_SUCCESS(aStatus, aLabel)                                       __nlEXPECT_SUCCESS(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS, aStatus, aLabel)
+
+/**
+ *  @def nlDESIRE_SUCCESS_PRINT(aStatus, aLabel, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and both prints @p
+ *    aMessage and then branches to @p aLabel if the status is
+ *    unsuccessful.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aStatus does not evaluate to zero
+ *                          (0).
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS_PRINT
+ *  @sa #nlREQUIRE_SUCCESS_PRINT
+ *
+ */
+#define nlDESIRE_SUCCESS_PRINT(aStatus, aLabel, aMessage)                       __nlEXPECT_SUCCESS_PRINT(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS, aStatus, aLabel, aMessage)
+
+/**
+ *  @def nlDESIRE_SUCCESS_ACTION(aStatus, aLabel, anAction)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and both executes @p
+ *    anAction and branches to @p aLabel if the status is
+ *    unsuccessful.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aStatus does not evaluate to zero
+ *                          (0).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS_ACTION
+ *  @sa #nlREQUIRE_SUCCESS_ACTION
+ *
+ */
+#define nlDESIRE_SUCCESS_ACTION(aStatus, aLabel, anAction)                      __nlEXPECT_SUCCESS_ACTION(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS, aStatus, aLabel, anAction)
+
+/**
+ *  @def nlDESIRE_SUCCESS_ACTION_PRINT(aStatus, aLabel, anAction, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), prints @p aMessage,
+ *    executes @p anAction, and branches to @p aLabel if the status is
+ *    unsuccessful.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aStatus does not evaluate to zero
+ *                          (0).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS_ACTION_PRINT
+ *  @sa #nlREQUIRE_SUCCESS_ACTION_PRINT
+ *
+ */
+#define nlDESIRE_SUCCESS_ACTION_PRINT(aStatus, aLabel, anAction, aMessage)      __nlEXPECT_SUCCESS_ACTION_PRINT(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS, aStatus, aLabel, anAction, aMessage)
+
+/**
+ *  @def nlNDESIRE(aCondition, aLabel)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and branches to @p aLabel if the condition is
+ *    true.
+ *
+ *  @note This is the logical inverse of #nlDESIRE.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlDESIRE
+ *  @sa #nlNEXPECT
+ *  @sa #nlNREQUIRE
+ *
+ */
+#define nlNDESIRE(aCondition, aLabel)                                           __nlNEXPECT(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS, aCondition, aLabel)
+
+/**
+ *  @def nlNDESIRE_PRINT(aCondition, aLabel, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and both prints @p aMessage and then branches
+ *    to @p aLabel if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlDESIRE_PRINT.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlDESIRE_PRINT
+ *  @sa #nlNEXPECT_PRINT
+ *  @sa #nlNREQUIRE_PRINT
+ *
+ */
+#define nlNDESIRE_PRINT(aCondition, aLabel, aMessage)                           __nlNEXPECT_PRINT(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS, aCondition, aLabel, aMessage)
+
+/**
+ *  @def nlNDESIRE_ACTION(aCondition, aLabel, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and both executes @p anAction and branches to
+ *    @p aLabel if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlDESIRE_ACTION.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlDESIRE_ACTION
+ *  @sa #nlNEXPECT_ACTION
+ *  @sa #nlNREQUIRE_ACTION
+ *
+ */
+#define nlNDESIRE_ACTION(aCondition, aLabel, anAction)                          __nlNEXPECT_ACTION(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS, aCondition, aLabel, anAction)
+
+/**
+ *  @def nlNDESIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, prints @p aMessage, executes @p anAction, and
+ *    branches to @p aLabel if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlDESIRE_ACTION_PRINT.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlDESIRE_ACTION_PRINT
+ *  @sa #nlNEXPECT_ACTION_PRINT
+ *  @sa #nlNREQUIRE_ACTION_PRINT
+ *
+ */
+#define nlNDESIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)          __nlNEXPECT_ACTION_PRINT(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS, aCondition, aLabel, anAction, aMessage)
+
+/**
+ *  @}
+ *
+ */
+
+/**
+ *  @ingroup require-style
+ *
+ *  @{
+ *
+ */
+
+/**
+ *  @def NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for require-style
+ *    exception family assertions when #NL_ASSERT_PRODUCTION is
+ *    disabled.
+ *
+ *  This may be used to override #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ */
+#define NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS_DEFAULT                           (NL_ASSERT_FLAG_BACKTRACE | NL_ASSERT_FLAG_LOG | NL_ASSERT_FLAG_TRAP)
+
+/**
+ *  @def NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags when #NL_ASSERT_PRODUCTION is
+ *    disabled that govern the behavior for require-style exception
+ *    family assertions when the assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS                                   NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS)
+#define NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS                                   (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @def nlREQUIRE(aCondition, aLabel)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and branches to @p aLabel if the condition is
+ *    false.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT
+ *  @sa #nlDESIRE
+ *
+ */
+#define nlREQUIRE(aCondition, aLabel)                                           __nlEXPECT(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS, aCondition, aLabel)
+
+/**
+ *  @def nlREQUIRE_PRINT(aCondition, aLabel, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and both prints @p aMessage and then branches
+ *    to @p aLabel if the condition is false.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_PRINT
+ *  @sa #nlDESIRE_PRINT
+ *
+ */
+#define nlREQUIRE_PRINT(aCondition, aLabel, aMessage)                           __nlEXPECT_PRINT(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS, aCondition, aLabel, aMessage)
+
+/**
+ *  @def nlREQUIRE_ACTION(aCondition, aLabel, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and both executes @p anAction and branches to
+ *    @p aLabel if the condition is false.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_ACTION
+ *  @sa #nlDESIRE_ACTION
+ *
+ */
+#define nlREQUIRE_ACTION(aCondition, aLabel, anAction)                          __nlEXPECT_ACTION(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS, aCondition, aLabel, anAction)
+
+/**
+ *  @def nlREQUIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, prints @p aMessage, executes @p anAction, and
+ *    branches to @p aLabel if the condition is false.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_ACTION_PRINT
+ *  @sa #nlDESIRE_ACTION_PRINT
+ *
+ */
+#define nlREQUIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)          __nlEXPECT_ACTION_PRINT(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS, aCondition, aLabel, anAction, aMessage)
+
+/**
+ *  @def nlREQUIRE_SUCCESS(aStatus, aLabel)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and branches to @p
+ *    aLabel if the status is unsuccessful.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aStatus does not evaluate to zero
+ *                          (0).
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS
+ *  @sa #nlDESIRE_SUCCESS
+ *
+ */
+#define nlREQUIRE_SUCCESS(aStatus, aLabel)                                      __nlEXPECT_SUCCESS(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS, aStatus, aLabel)
+
+/**
+ *  @def nlREQUIRE_SUCCESS_PRINT(aStatus, aLabel, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and both prints @p
+ *    aMessage and then branches to @p aLabel if the status is
+ *    unsuccessful.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aStatus does not evaluate to zero
+ *                          (0).
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS_PRINT
+ *  @sa #nlDESIRE_SUCCESS_PRINT
+ *
+ */
+#define nlREQUIRE_SUCCESS_PRINT(aStatus, aLabel, aMessage)                      __nlEXPECT_SUCCESS_PRINT(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS, aStatus, aLabel, aMessage)
+
+/**
+ *  @def nlREQUIRE_SUCCESS_ACTION(aStatus, aLabel, anAction)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and both executes @p
+ *    anAction and branches to @p aLabel if the status is
+ *    unsuccessful.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aStatus does not evaluate to zero
+ *                          (0).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS_ACTION
+ *  @sa #nlDESIRE_SUCCESS_ACTION
+ *
+ */
+#define nlREQUIRE_SUCCESS_ACTION(aStatus, aLabel, anAction)                     __nlEXPECT_SUCCESS_ACTION(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS, aStatus, aLabel, anAction)
+
+/**
+ *  @def nlREQUIRE_SUCCESS_ACTION_PRINT(aStatus, aLabel, anAction, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), prints @p aMessage,
+ *    executes @p anAction, and branches to @p aLabel if the status is
+ *    unsuccessful.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aStatus does not evaluate to zero
+ *                          (0).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS_ACTION_PRINT
+ *  @sa #nlDESIRE_SUCCESS_ACTION_PRINT
+ *
+ */
+#define nlREQUIRE_SUCCESS_ACTION_PRINT(aStatus, aLabel, anAction, aMessage)     __nlEXPECT_SUCCESS_ACTION_PRINT(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS, aStatus, aLabel, anAction, aMessage)
+
+/**
+ *  @def nlNREQUIRE(aCondition, aLabel)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and branches to @p aLabel if the condition is
+ *    true.
+ *
+ *  @note This is the logical inverse of #nlREQUIRE.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlREQUIRE
+ *  @sa #nlNEXPECT
+ *  @sa #nlNDESIRE
+ *
+ */
+#define nlNREQUIRE(aCondition, aLabel)                                          __nlNEXPECT(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS, aCondition, aLabel)
+
+/**
+ *  @def nlNREQUIRE_PRINT(aCondition, aLabel, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and both prints @p aMessage and then branches
+ *    to @p aLabel if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlREQUIRE_PRINT.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlREQUIRE_PRINT
+ *  @sa #nlNEXPECT_PRINT
+ *  @sa #nlNDESIRE_PRINT
+ *
+ */
+#define nlNREQUIRE_PRINT(aCondition, aLabel, aMessage)                          __nlNEXPECT_PRINT(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS, aCondition, aLabel, aMessage)
+
+/**
+ *  @def nlNREQUIRE_ACTION(aCondition, aLabel, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and both executes @p anAction and branches to
+ *    @p aLabel if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlREQUIRE_ACTION.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlREQUIRE_ACTION
+ *  @sa #nlNEXPECT_ACTION
+ *  @sa #nlNDESIRE_ACTION
+ *
+ */
+#define nlNREQUIRE_ACTION(aCondition, aLabel, anAction)                         __nlNEXPECT_ACTION(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS, aCondition, aLabel, anAction)
+
+/**
+ *  @def nlNREQUIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, prints @p aMessage, executes @p anAction, and
+ *    branches to @p aLabel if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlREQUIRE_ACTION_PRINT.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlREQUIRE_ACTION_PRINT
+ *  @sa #nlNEXPECT_ACTION_PRINT
+ *  @sa #nlNDESIRE_ACTION_PRINT
+ *
+ */
+#define nlNREQUIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)         __nlNEXPECT_ACTION_PRINT(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS, aCondition, aLabel, anAction, aMessage)
+
+/**
+ *  @}
+ *
+ */
+
+/**
+ *  @ingroup precondition-style
+ *
+ *  @{
+ *
+ */
+
+/**
+ *  @def NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for precondition-style
+ *    exception family assertions when #NL_ASSERT_PRODUCTION is
+ *    disabled.
+ *
+ *  This may be used to override #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ */
+#define NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS_DEFAULT                      (NL_ASSERT_FLAG_BACKTRACE | NL_ASSERT_FLAG_LOG | NL_ASSERT_FLAG_TRAP)
+
+/**
+ *  @def NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags when #NL_ASSERT_PRODUCTION is
+ *    disabled that govern the behavior for precondition-style exception
+ *    family assertions when the assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS                              NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS)
+#define NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS                              (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @def nlPRECONDITION(aCondition)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and returns from the enclosing function if the
+ *    condition is false.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT
+ *  @sa #nlDESIRE
+ *  @sa #nlREQUIRE
+ *
+ */
+#define nlPRECONDITION(aCondition)                                              __nlPRECONDITION(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aCondition, return)
+
+/**
+ *  @def nlPRECONDITION_ACTION(aCondition, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and both executes @p anAction and returns from
+ *    the enclosing function if the condition is false.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_ACTION
+ *  @sa #nlDESIRE_ACTION
+ *  @sa #nlREQUIRE_ACTION
+ *
+ */
+#define nlPRECONDITION_ACTION(aCondition, anAction)                             __nlPRECONDITION_ACTION(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aCondition, return, anAction)
+
+/**
+ *  @def nlPRECONDITION_PRINT(aCondition, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and both prints @p aMessage and then returns
+ *    from the enclosing function if the condition is false.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_PRINT
+ *  @sa #nlDESIRE_PRINT
+ *  @sa #nlREQUIRE_PRINT
+ *
+ */
+#define nlPRECONDITION_PRINT(aCondition, aMessage)                              __nlPRECONDITION_PRINT(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aCondition, return, aMessage)
+
+/**
+ *  @def nlPRECONDITION_SUCCESS(aStatus)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and returns from the
+ *    enclosing function if the status is unsuccessful.
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS
+ *  @sa #nlDESIRE_SUCCESS
+ *  @sa #nlREQUIRE_SUCCESS
+ *
+ */
+#define nlPRECONDITION_SUCCESS(aStatus)                                         __nlPRECONDITION_SUCCESS(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aStatus, return)
+
+/**
+ *  @def nlPRECONDITION_SUCCESS_ACTION(aStatus, anAction)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and both executes @p
+ *    anAction and returns from the enclosing function if the status
+ *    is unsuccessful.
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS_ACTION
+ *  @sa #nlDESIRE_SUCCESS_ACTION
+ *  @sa #nlREQUIRE_SUCCESS_ACTION
+ *
+ */
+#define nlPRECONDITION_SUCCESS_ACTION(aStatus, anAction)                        __nlPRECONDITION_SUCCESS_ACTION(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aStatus, return, anAction)
+
+/**
+ *  @def nlPRECONDITION_SUCCESS_PRINT(aStatus, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and both prints @p
+ *    aMessage and then returns from the enclosing function if the
+ *    status is unsuccessful.
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS_PRINT
+ *  @sa #nlDESIRE_SUCCESS_PRINT
+ *  @sa #nlREQUIRE_SUCCESS_PRINT
+ *
+ */
+#define nlPRECONDITION_SUCCESS_PRINT(aStatus, aMessage)                         __nlPRECONDITION_SUCCESS_PRINT(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aStatus, return, aMessage)
+
+/**
+ *  @def nlNPRECONDITION(aCondition)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and returns from the enclosing function if
+ *    the condition is true.
+ *
+ *  @note This is the logical inverse of #nlPRECONDITION.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlPRECONDITION
+ *
+ *  @sa #nlNEXPECT
+ *  @sa #nlNDESIRE
+ *  @sa #nlNREQUIRE
+ *
+ */
+#define nlNPRECONDITION(aCondition)                                             __nlNPRECONDITION(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aCondition, return)
+
+/**
+ *  @def nlNPRECONDITION_ACTION(aCondition, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and both executes @p anAction and returns from
+ *    the enclosing function if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlPRECONDITION_ACTION.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlPRECONDITION_ACTION
+ *
+ *  @sa #nlNEXPECT_ACTION
+ *  @sa #nlNDESIRE_ACTION
+ *  @sa #nlNREQUIRE_ACTION
+ *
+ */
+#define nlNPRECONDITION_ACTION(aCondition, anAction)                            __nlNPRECONDITION_ACTION(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aCondition, return, anAction)
+
+/**
+ *  @def nlNPRECONDITION_PRINT(aCondition, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and both prints @p aMessage and then returns
+ *    from the enclosing function if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlPRECONDITION_PRINT.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlPRECONDITION_PRINT
+ *
+ *  @sa #nlNEXPECT_PRINT
+ *  @sa #nlNDESIRE_PRINT
+ *  @sa #nlNREQUIRE_PRINT
+ *
+ */
+#define nlNPRECONDITION_PRINT(aCondition, aMessage)                             __nlNPRECONDITION_PRINT(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aCondition, return, aMessage)
+
+/**
+ *  @def nlPRECONDITION_VALUE(aCondition, aValue)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and returns @p aValue from the enclosing
+ *    function if the condition is false.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aValue      The value to be returned when the assertion
+ *                          fails.
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT
+ *  @sa #nlDESIRE
+ *  @sa #nlREQUIRE
+ *
+ */
+#define nlPRECONDITION_VALUE(aCondition, aValue)                                __nlPRECONDITION(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aCondition, return aValue)
+
+/**
+ *  @def nlPRECONDITION_VALUE_ACTION(aCondition, aValue, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and both executes @p anAction and returns @p
+ *    aValue from the enclosing function if the condition is false.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aValue      The value to be returned when the assertion
+ *                          fails.
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_ACTION
+ *  @sa #nlDESIRE_ACTION
+ *  @sa #nlREQUIRE_ACTION
+ *
+ */
+#define nlPRECONDITION_VALUE_ACTION(aCondition, aValue, anAction)               __nlPRECONDITION_ACTION(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aCondition, return aValue, anAction)
+
+/**
+ *  @def nlPRECONDITION_VALUE_PRINT(aCondition, aValue, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and both prints @p aMessage and then returns
+ *    @p aValue from the enclosing function if the condition is false.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aValue      The value to be returned when the assertion
+ *                          fails.
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_PRINT
+ *  @sa #nlDESIRE_PRINT
+ *  @sa #nlREQUIRE_PRINT
+ *
+ */
+#define nlPRECONDITION_VALUE_PRINT(aCondition, aValue, aMessage)                __nlPRECONDITION_PRINT(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aCondition, return aValue, aMessage)
+
+/**
+ *  @def nlPRECONDITION_VALUE_SUCCESS(aStatus, aValue)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and returns @p aValue
+ *    from the enclosing function if the status is unsuccessful.
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aValue      The value to be returned when the assertion
+ *                          fails.
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS
+ *  @sa #nlDESIRE_SUCCESS
+ *  @sa #nlREQUIRE_SUCCESS
+ *
+ */
+#define nlPRECONDITION_VALUE_SUCCESS(aStatus, aValue)                           __nlPRECONDITION_SUCCESS(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aStatus, return aValue)
+
+/**
+ *  @def nlPRECONDITION_VALUE_SUCCESS_ACTION(aStatus, aValue, anAction)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and both executes @p
+ *    anAction and returns @p aValue from the enclosing function if
+ *    the status is unsuccessful.
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aValue      The value to be returned when the assertion
+ *                          fails.
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS_ACTION
+ *  @sa #nlDESIRE_SUCCESS_ACTION
+ *  @sa #nlREQUIRE_SUCCESS_ACTION
+ *
+ */
+#define nlPRECONDITION_VALUE_SUCCESS_ACTION(aStatus, aValue, anAction)          __nlPRECONDITION_SUCCESS_ACTION(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aStatus, return aValue, anAction)
+
+/**
+ *  @def nlPRECONDITION_VALUE_SUCCESS_PRINT(aStatus, aValue, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and both prints @p
+ *    aMessage and then returns @p aValue from the enclosing function
+ *    if the status is unsuccessful.
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aValue      The value to be returned when the assertion
+ *                          fails.
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS_PRINT
+ *  @sa #nlDESIRE_SUCCESS_PRINT
+ *  @sa #nlREQUIRE_SUCCESS_PRINT
+ *
+ */
+#define nlPRECONDITION_VALUE_SUCCESS_PRINT(aStatus, aValue, aMessage)           __nlPRECONDITION_SUCCESS_PRINT(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aStatus, return aValue, aMessage)
+
+/**
+ *  @def nlNPRECONDITION_VALUE(aCondition, aValue)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and returns @p aValue from the enclosing
+ *    function if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlPRECONDITION_VALUE.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aValue      The value to be returned when the assertion
+ *                          fails.
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlPRECONDITION_VALUE
+ *
+ *  @sa #nlNEXPECT
+ *  @sa #nlNDESIRE
+ *  @sa #nlNREQUIRE
+ *
+ */
+#define nlNPRECONDITION_VALUE(aCondition, aValue)                               __nlNPRECONDITION(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aCondition, return aValue)
+
+/**
+ *  @def nlNPRECONDITION_VALUE_ACTION(aCondition, aValue, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and both executes @p anAction and returns @p
+ *    aValue from the enclosing function if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlPRECONDITION_VALUE_ACTION.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aValue      The value to be returned when the assertion
+ *                          fails.
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlPRECONDITION_VALUE_ACTION
+ *
+ *  @sa #nlNEXPECT_ACTION
+ *  @sa #nlNDESIRE_ACTION
+ *  @sa #nlNREQUIRE_ACTION
+ *
+ */
+#define nlNPRECONDITION_VALUE_ACTION(aCondition, aValue, anAction)              __nlNPRECONDITION_ACTION(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aCondition, return aValue, anAction)
+
+/**
+ *  @def nlNPRECONDITION_VALUE_PRINT(aCondition, aValue, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and both prints @p aMessage and then returns
+ *    @p aValue from the enclosing function if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlPRECONDITION_VALUE_PRINT.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aValue      The value to be returned when the assertion
+ *                          fails.
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlPRECONDITION_VALUE_PRINT
+ *
+ *  @sa #nlNEXPECT_PRINT
+ *  @sa #nlNDESIRE_PRINT
+ *  @sa #nlNREQUIRE_PRINT
+ *
+ */
+#define nlNPRECONDITION_VALUE_PRINT(aCondition, aValue, aMessage)               __nlNPRECONDITION_PRINT(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aCondition, return aValue, aMessage)
+
+/**
+ *  @}
+ *
+ */
+
+/**
+ *  @ingroup assert-style
+ *
+ *  @{
+ *
+ */
+
+/**
+ *  @def NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for assert-style
+ *    exception family assertions when #NL_ASSERT_PRODUCTION is
+ *    disabled.
+ *
+ *  This may be used to override #NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ */
+#define NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS_DEFAULT                            (NL_ASSERT_FLAG_BACKTRACE | NL_ASSERT_FLAG_LOG)
+
+/**
+ *  @def NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags when #NL_ASSERT_PRODUCTION is
+ *    disabled that govern the behavior for assert-style exception
+ *    family assertions when the assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS                                     NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS)
+#define NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS                                    (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @def nlASSERT(aCondition)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true and takes action, based on configuration, and
+ *    invokes #NL_ASSERT_ABORT() if the condition is false.
+ *
+ *  @note If #NL_ASSERT_PRODUCTION is true, the check is made inactive. But
+ *  side-effects, if any, in the asserted expression will still be produced.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *
+ *  @sa #NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK
+ *  @sa #nlVERIFY
+ *  @sa #nlABORT
+ *
+ */
+#define nlASSERT(aCondition)                                                    __nlABORT(NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS, aCondition)
+
+/**
+ *  @def nlASSERT_ACTION(aCondition, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true and takes action, based on configuration, and
+ *    both executes @p anAction and then invokes #NL_ASSERT_ABORT() if
+ *    the condition is false.
+ *
+ *  @note If #NL_ASSERT_PRODUCTION is true, the check is made inactive. But
+ *  side-effects, if any, in the asserted expression will still be produced.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK_ACTION
+ *  @sa #nlVERIFY_ACTION
+ *  @sa #nlABORT_ACTION
+ *
+ */
+#define nlASSERT_ACTION(aCondition, anAction)                                   __nlABORT_ACTION(NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS, aCondition, anAction)
+
+/**
+ *  @}
+ *
+ */
+
+/**
+ *  @ingroup abort-style
+ *
+ *  @{
+ *
+ */
+
+/**
+ *  @def NL_ASSERT_ABORT_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for abort-style
+ *    exception family assertions when #NL_ASSERT_PRODUCTION is
+ *    disabled.
+ *
+ *  This may be used to override #NL_ASSERT_ABORT_NONPRODUCTION_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_ABORT_NONPRODUCTION_FLAGS NL_ASSERT_ABORT_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_ABORT_NONPRODUCTION_FLAGS
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ */
+#define NL_ASSERT_ABORT_NONPRODUCTION_FLAGS_DEFAULT                             (NL_ASSERT_FLAG_BACKTRACE | NL_ASSERT_FLAG_LOG)
+
+/**
+ *  @def NL_ASSERT_ABORT_NONPRODUCTION_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags when #NL_ASSERT_PRODUCTION is
+ *    disabled that govern the behavior for abort-style exception
+ *    family assertions when the assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_ABORT_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_ABORT_NONPRODUCTION_FLAGS                                     NL_ASSERT_ABORT_NONPRODUCTION_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_ABORT_NONPRODUCTION_FLAGS)
+#define NL_ASSERT_ABORT_NONPRODUCTION_FLAGS                                     (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @def nlABORT(aCondition)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true and takes action, based on configuration, and
+ *    invokes #NL_ASSERT_ABORT() if the condition is false.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *
+ *  @sa #NL_ASSERT_ABORT_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_ABORT_PRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK
+ *  @sa #nlVERIFY
+ *  @sa #nlASSERT
+ *
+ */
+#define nlABORT(aCondition)                                                     __nlABORT(NL_ASSERT_ABORT_NONPRODUCTION_FLAGS, aCondition)
+
+/**
+ *  @def nlABORT_ACTION(aCondition, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true and takes action, based on configuration, and
+ *    both executes @p anAction and then invokes #NL_ASSERT_ABORT() if
+ *    the condition is false.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_ABORT_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_ABORT_PRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK_ACTION
+ *  @sa #nlVERIFY_ACTION
+ *  @sa #nlASSERT_ACTION
+ *
+ */
+#define nlABORT_ACTION(aCondition, anAction)                                    __nlABORT_ACTION(NL_ASSERT_ABORT_NONPRODUCTION_FLAGS, aCondition, anAction)
+
+/**
+ *  @}
+ *
+ */
+
+#endif /* NLCORE_NLASSERT_NONPRODUCTION_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/nlassert-production.h b/cores/nRF5/nordic/config/nrf52840/config/nlassert-production.h
new file mode 100644
index 000000000..43ad869c7
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/nlassert-production.h
@@ -0,0 +1,713 @@
+/*
+ *   Copyright 2010-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *   Licensed under the Apache License, Version 2.0 (the "License");
+ *   you may not use this file except in compliance with the License.
+ *   You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *   Unless required by applicable law or agreed to in writing, software
+ *   distributed under the License is distributed on an "AS IS" BASIS,
+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *   See the License for the specific language governing permissions and
+ *   limitations under the License.
+ *
+ */
+
+/**
+ *    @file
+ *      This file defines macros and interfaces for performing
+ *      compile- and run-time assertion checking and run-time
+ *      exception handling when #NL_ASSERT_PRODUCTION is true.
+ *
+ */
+
+#ifndef NLASSERT_PRODUCTION_H
+#define NLASSERT_PRODUCTION_H
+
+#include "nlassert-internal.h"
+
+// nlCHECK
+
+/**
+ *  @implements nlCHECK(aCondition)
+ *
+ */
+#define nlCHECK(aCondition)                                                     __nlASSERT_UNUSED(aCondition)
+
+/**
+ *  @implements nlCHECK_ACTION(aCondition, anAction)
+ *
+ */
+#define nlCHECK_ACTION(aCondition, anAction)                                    __nlASSERT_UNUSED(aCondition)
+
+/**
+ *  @implements nlCHECK_PRINT(aCondition, aMessage)
+ *
+ */
+#define nlCHECK_PRINT(aCondition, aMessage)                                     __nlASSERT_UNUSED(aCondition)
+
+/**
+ *  @implements nlCHECK_SUCCESS(aStatus)
+ *
+ */
+#define nlCHECK_SUCCESS(aStatus)                                                __nlASSERT_UNUSED(aStatus)
+
+/**
+ *  @implements nlCHECK_SUCCESS_ACTION(aStatus, anAction)
+ *
+ */
+#define nlCHECK_SUCCESS_ACTION(aStatus, anAction)                               __nlASSERT_UNUSED(aStatus)
+
+/**
+ *  @implements nlCHECK_SUCCESS_PRINT(aStatus, aMessage)
+ *
+ */
+#define nlCHECK_SUCCESS_PRINT(aStatus, aMessage)                                __nlASSERT_UNUSED(aStatus)
+
+/**
+ *  @implements nlNCHECK(aCondition)
+ *
+ */
+#define nlNCHECK(aCondition)                                                    __nlASSERT_UNUSED(aCondition)
+
+/**
+ *  @implements nlNCHECK_ACTION(aCondition, anAction)
+ *
+ */
+#define nlNCHECK_ACTION(aCondition, anAction)                                   __nlASSERT_UNUSED(aCondition)
+
+/**
+ *  @implements nlNCHECK_PRINT(aCondition, aMessage)
+ *
+ */
+#define nlNCHECK_PRINT(aCondition, aMessage)                                    __nlASSERT_UNUSED(aCondition)
+
+// nlVERIFY
+
+/**
+ *  @def NL_ASSERT_VERIFY_PRODUCTION_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for verify-style
+ *    exception family assertions when #NL_ASSERT_PRODUCTION is
+ *    enabled.
+ *
+ *  This may be used to override #NL_ASSERT_VERIFY_PRODUCTION_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_VERIFY_PRODUCTION_FLAGS NL_ASSERT_VERIFY_PRODUCTION_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_VERIFY_PRODUCTION_FLAGS
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ *  @ingroup verify-style
+ *
+ */
+#define NL_ASSERT_VERIFY_PRODUCTION_FLAGS_DEFAULT                               (NL_ASSERT_FLAG_BACKTRACE | NL_ASSERT_FLAG_LOG)
+
+/**
+ *  @def NL_ASSERT_VERIFY_PRODUCTION_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags when #NL_ASSERT_PRODUCTION is
+ *    enabled that govern the behavior for verify-style exception
+ *    family assertions when the assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_VERIFY_PRODUCTION_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ *  @ingroup verify-style
+ *
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_VERIFY_PRODUCTION_FLAGS                                       NL_ASSERT_VERIFY_PRODUCTION_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_VERIFY_PRODUCTION_FLAGS)
+#define NL_ASSERT_VERIFY_PRODUCTION_FLAGS                                       (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @implements nlVERIFY(aCondition)
+ *
+ */
+#define nlVERIFY(aCondition)                                                    __nlVERIFY(NL_ASSERT_VERIFY_PRODUCTION_FLAGS, aCondition)
+
+/**
+ *  @implements nlVERIFY_ACTION(aCondition, anAction)
+ *
+ */
+#define nlVERIFY_ACTION(aCondition, anAction)                                   __nlVERIFY_ACTION(NL_ASSERT_VERIFY_PRODUCTION_FLAGS, aCondition, anAction)
+
+/**
+ *  @implements nlVERIFY_PRINT(aCondition, aMessage)
+ *
+ */
+#define nlVERIFY_PRINT(aCondition, aMessage)                                    __nlVERIFY_PRINT(NL_ASSERT_VERIFY_PRODUCTION_FLAGS, aCondition, aMessage)
+
+/**
+ *  @implements nlVERIFY_SUCCESS(aStatus)
+ *
+ */
+#define nlVERIFY_SUCCESS(aStatus)                                               __nlVERIFY_SUCCESS(NL_ASSERT_VERIFY_PRODUCTION_FLAGS, aStatus)
+
+/**
+ *  @implements nlVERIFY_SUCCESS_ACTION(aStatus, anAction)
+ *
+ */
+#define nlVERIFY_SUCCESS_ACTION(aStatus, anAction)                              __nlVERIFY_SUCCESS_ACTION(NL_ASSERT_VERIFY_PRODUCTION_FLAGS, aStatus, anAction)
+
+/**
+ *  @implements nlVERIFY_SUCCESS_PRINT(aStatus, aMessage)
+ *
+ */
+#define nlVERIFY_SUCCESS_PRINT(aStatus, aMessage)                               __nlVERIFY_SUCCESS_PRINT(NL_ASSERT_VERIFY_PRODUCTION_FLAGS, aStatus, aMessage)
+
+/**
+ *  @implements nlNVERIFY(aCondition)
+ *
+ */
+#define nlNVERIFY(aCondition)                                                   __nlNVERIFY(NL_ASSERT_VERIFY_PRODUCTION_FLAGS, aCondition)
+
+/**
+ *  @implements nlNVERIFY_ACTION(aCondition, anAction)
+ *
+ */
+#define nlNVERIFY_ACTION(aCondition, anAction)                                  __nlNVERIFY_ACTION(NL_ASSERT_VERIFY_PRODUCTION_FLAGS, aCondition, anAction)
+
+/**
+ *  @implements nlNVERIFY_PRINT(aCondition, aMessage)
+ *
+ */
+#define nlNVERIFY_PRINT(aCondition, aMessage)                                   __nlNVERIFY_PRINT(NL_ASSERT_VERIFY_PRODUCTION_FLAGS, aCondition, aMessage)
+
+// nlDESIRE
+
+/**
+ *  @def NL_ASSERT_DESIRE_PRODUCTION_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for desire-style
+ *    exception family assertions when #NL_ASSERT_PRODUCTION is
+ *    enabled.
+ *
+ *  This may be used to override #NL_ASSERT_DESIRE_PRODUCTION_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_DESIRE_PRODUCTION_FLAGS NL_ASSERT_DESIRE_PRODUCTION_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ *  @ingroup desire-style
+ *
+ */
+#define NL_ASSERT_DESIRE_PRODUCTION_FLAGS_DEFAULT                               (NL_ASSERT_FLAG_NONE)
+
+/**
+ *  @def NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags when #NL_ASSERT_PRODUCTION is
+ *    enabled that govern the behavior for desire-style exception
+ *    family assertions when the assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ *  @ingroup desire-style
+ *
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_DESIRE_PRODUCTION_FLAGS                                       NL_ASSERT_DESIRE_PRODUCTION_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_DESIRE_PRODUCTION_FLAGS)
+#define NL_ASSERT_DESIRE_PRODUCTION_FLAGS                                       (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @implements nlDESIRE(aCondition, aLabel)
+ *
+ */
+#define nlDESIRE(aCondition, aLabel)                                            __nlEXPECT(NL_ASSERT_DESIRE_PRODUCTION_FLAGS, aCondition, aLabel)
+
+/**
+ *  @implements nlDESIRE_PRINT(aCondition, aLabel, aMessage)
+ *
+ */
+#define nlDESIRE_PRINT(aCondition, aLabel, aMessage)                            __nlEXPECT_PRINT(NL_ASSERT_DESIRE_PRODUCTION_FLAGS, aCondition, aLabel, aMessage)
+
+/**
+ *  @implements nlDESIRE_ACTION(aCondition, aLabel, anAction)
+ *
+ */
+#define nlDESIRE_ACTION(aCondition, aLabel, anAction)                           __nlEXPECT_ACTION(NL_ASSERT_DESIRE_PRODUCTION_FLAGS, aCondition, aLabel, anAction)
+
+/**
+ *  @implements nlDESIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)
+ *
+ */
+#define nlDESIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)           __nlEXPECT_ACTION_PRINT(NL_ASSERT_DESIRE_PRODUCTION_FLAGS, aCondition, aLabel, anAction, aMessage)
+
+/**
+ *  @implements nlDESIRE_SUCCESS(aStatus, aLabel)
+ *
+ */
+#define nlDESIRE_SUCCESS(aStatus, aLabel)                                       __nlEXPECT_SUCCESS(NL_ASSERT_DESIRE_PRODUCTION_FLAGS, aStatus, aLabel)
+
+/**
+ *  @implements nlDESIRE_SUCCESS_PRINT(aStatus, aLabel, aMessage)
+ *
+ */
+#define nlDESIRE_SUCCESS_PRINT(aStatus, aLabel, aMessage)                       __nlEXPECT_SUCCESS_PRINT(NL_ASSERT_DESIRE_PRODUCTION_FLAGS, aStatus, aLabel, aMessage)
+
+/**
+ *  @implements nlDESIRE_SUCCESS_ACTION(aStatus, aLabel, anAction)
+ *
+ */
+#define nlDESIRE_SUCCESS_ACTION(aStatus, aLabel, anAction)                      __nlEXPECT_SUCCESS_ACTION(NL_ASSERT_DESIRE_PRODUCTION_FLAGS, aStatus, aLabel, anAction)
+
+/**
+ *  @implements nlDESIRE_SUCCESS_ACTION_PRINT(aStatus, aLabel, anAction, aMessage)
+ *
+ */
+#define nlDESIRE_SUCCESS_ACTION_PRINT(aStatus, aLabel, anAction, aMessage)      __nlEXPECT_SUCCESS_ACTION_PRINT(NL_ASSERT_DESIRE_PRODUCTION_FLAGS, aStatus, aLabel, anAction, aMessage)
+
+/**
+ *  @implements nlNDESIRE(aCondition, aLabel)
+ *
+ */
+#define nlNDESIRE(aCondition, aLabel)                                           __nlNEXPECT(NL_ASSERT_DESIRE_PRODUCTION_FLAGS, aCondition, aLabel)
+
+/**
+ *  @implements nlNDESIRE_PRINT(aCondition, aLabel, aMessage)
+ *
+ */
+#define nlNDESIRE_PRINT(aCondition, aLabel, aMessage)                           __nlNEXPECT_PRINT(NL_ASSERT_DESIRE_PRODUCTION_FLAGS, aCondition, aLabel, aMessage)
+
+/**
+ *  @implements nlNDESIRE_ACTION(aCondition, aLabel, anAction)
+ *
+ */
+#define nlNDESIRE_ACTION(aCondition, aLabel, anAction)                          __nlNEXPECT_ACTION(NL_ASSERT_DESIRE_PRODUCTION_FLAGS, aCondition, aLabel, anAction)
+
+/**
+ *  @implements nlNDESIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)
+ *
+ */
+#define nlNDESIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)          __nlNEXPECT_ACTION_PRINT(NL_ASSERT_DESIRE_PRODUCTION_FLAGS, aCondition, aLabel, anAction, aMessage)
+
+// nlREQUIRE
+
+/**
+ *  @def NL_ASSERT_REQUIRE_PRODUCTION_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for require-style
+ *    exception family assertions when #NL_ASSERT_PRODUCTION is
+ *    enabled.
+ *
+ *  This may be used to override #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_REQUIRE_PRODUCTION_FLAGS NL_ASSERT_REQUIRE_PRODUCTION_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ *  @ingroup require-style
+ *
+ */
+#define NL_ASSERT_REQUIRE_PRODUCTION_FLAGS_DEFAULT                              (NL_ASSERT_FLAG_BACKTRACE | NL_ASSERT_FLAG_LOG)
+
+/**
+ *  @def NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags when #NL_ASSERT_PRODUCTION is
+ *    enabled that govern the behavior for require-style exception
+ *    family assertions when the assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ *  @ingroup require-style
+ *
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_REQUIRE_PRODUCTION_FLAGS                                      NL_ASSERT_REQUIRE_PRODUCTION_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS)
+#define NL_ASSERT_REQUIRE_PRODUCTION_FLAGS                                      (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @implements nlREQUIRE(aCondition, aLabel)
+ *
+ */
+#define nlREQUIRE(aCondition, aLabel)                                           __nlEXPECT(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS, aCondition, aLabel)
+
+/**
+ *  @implements nlREQUIRE_PRINT(aCondition, aLabel, aMessage)
+ */
+#define nlREQUIRE_PRINT(aCondition, aLabel, aMessage)                           __nlEXPECT_PRINT(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS, aCondition, aLabel, aMessage)
+
+/**
+ *  @implements nlREQUIRE_ACTION(aCondition, aLabel, anAction)
+ *
+ */
+#define nlREQUIRE_ACTION(aCondition, aLabel, anAction)                          __nlEXPECT_ACTION(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS, aCondition, aLabel, anAction)
+
+/**
+ *  @implements nlREQUIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)
+ *
+ */
+#define nlREQUIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)          __nlEXPECT_ACTION_PRINT(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS, aCondition, aLabel, anAction, aMessage)
+
+/**
+ *  @implements nlREQUIRE_SUCCESS(aStatus, aLabel)
+ *
+ */
+#define nlREQUIRE_SUCCESS(aStatus, aLabel)                                      __nlEXPECT_SUCCESS(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS, aStatus, aLabel)
+
+/**
+ *  @implements nlREQUIRE_SUCCESS_PRINT(aStatus, aLabel, aMessage)
+ *
+ */
+#define nlREQUIRE_SUCCESS_PRINT(aStatus, aLabel, aMessage)                      __nlEXPECT_SUCCESS_PRINT(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS, aStatus, aLabel, aMessage)
+
+/**
+ *  @implements nlREQUIRE_SUCCESS_ACTION(aStatus, aLabel, anAction)
+ *
+ */
+#define nlREQUIRE_SUCCESS_ACTION(aStatus, aLabel, anAction)                     __nlEXPECT_SUCCESS_ACTION(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS, aStatus, aLabel, anAction)
+
+/**
+ *  @implements nlREQUIRE_SUCCESS_ACTION_PRINT(aStatus, aLabel, anAction, aMessage)
+ *
+ */
+#define nlREQUIRE_SUCCESS_ACTION_PRINT(aStatus, aLabel, anAction, aMessage)     __nlEXPECT_SUCCESS_ACTION_PRINT(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS, aStatus, aLabel, anAction, aMessage)
+
+/**
+ *  @implements nlNREQUIRE(aCondition, aLabel)
+ *
+ */
+#define nlNREQUIRE(aCondition, aLabel)                                          __nlNEXPECT(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS, aCondition, aLabel)
+
+/**
+ *  @implements nlNREQUIRE_PRINT(aCondition, aLabel, aMessage)
+ *
+ */
+#define nlNREQUIRE_PRINT(aCondition, aLabel, aMessage)                          __nlNEXPECT_PRINT(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS, aCondition, aLabel, aMessage)
+
+/**
+ *  @implements nlNREQUIRE_ACTION(aCondition, aLabel, anAction)
+ *
+ */
+#define nlNREQUIRE_ACTION(aCondition, aLabel, anAction)                         __nlNEXPECT_ACTION(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS, aCondition, aLabel, anAction)
+
+/**
+ *  @implements nlNREQUIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)
+ *
+ */
+#define nlNREQUIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)         __nlNEXPECT_ACTION_PRINT(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS, aCondition, aLabel, anAction, aMessage)
+
+// nlPRECONDITION
+
+/**
+ *  @def NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for precondition-style
+ *    exception family assertions when #NL_ASSERT_PRODUCTION is
+ *    enabled.
+ *
+ *  This may be used to override #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ *  @ingroup precondition-style
+ *
+ */
+#define NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS_DEFAULT                         (NL_ASSERT_FLAG_BACKTRACE | NL_ASSERT_FLAG_LOG)
+
+/**
+ *  @def NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags when #NL_ASSERT_PRODUCTION is
+ *    disabled that govern the behavior for precondition-style exception
+ *    family assertions when the assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ *  @ingroup precondition-style
+ *
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS                                 NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS)
+#define NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS                                 (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @implements nlPRECONDITION(aCondition)
+ *
+ */
+#define nlPRECONDITION(aCondition)                                              __nlPRECONDITION(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aCondition, return)
+
+/**
+ *  @implements nlPRECONDITION_ACTION(aCondition, anAction)
+ *
+ */
+#define nlPRECONDITION_ACTION(aCondition, anAction)                             __nlPRECONDITION_ACTION(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aCondition, return, anAction)
+
+/**
+ *  @implements nlPRECONDITION_PRINT(aCondition, aMessage)
+ *
+ */
+#define nlPRECONDITION_PRINT(aCondition, aMessage)                              __nlPRECONDITION_PRINT(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aCondition, return, aMessage)
+
+/**
+ *  @implements nlPRECONDITION_SUCCESS(aStatus)
+ *
+ */
+#define nlPRECONDITION_SUCCESS(aStatus)                                         __nlPRECONDITION_SUCCESS(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aStatus, return)
+
+/**
+ *  @implements nlPRECONDITION_SUCCESS_ACTION(aStatus, anAction)
+ *
+ */
+#define nlPRECONDITION_SUCCESS_ACTION(aStatus, anAction)                        __nlPRECONDITION_SUCCESS_ACTION(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aStatus, return, anAction)
+
+/**
+ *  @implements nlPRECONDITION_SUCCESS_PRINT(aStatus, aMessage)
+ *
+ */
+#define nlPRECONDITION_SUCCESS_PRINT(aStatus, aMessage)                         __nlPRECONDITION_SUCCESS_PRINT(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aStatus, return, aMessage)
+
+/**
+ *  @implements nlNPRECONDITION(aCondition)
+ *
+ */
+#define nlNPRECONDITION(aCondition)                                             __nlNPRECONDITION(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aCondition, return)
+
+/**
+ *  @implements nlNPRECONDITION_ACTION(aCondition, anAction)
+ *
+ */
+#define nlNPRECONDITION_ACTION(aCondition, anAction)                            __nlNPRECONDITION_ACTION(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aCondition, return, anAction)
+
+/**
+ *  @implements nlNPRECONDITION_PRINT(aCondition, aMessage)
+ *
+ */
+#define nlNPRECONDITION_PRINT(aCondition, aMessage)                             __nlNPRECONDITION_PRINT(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aCondition, return, aMessage)
+
+/**
+ *  @implements nlPRECONDITION_VALUE(aCondition, aValue)
+ *
+ */
+#define nlPRECONDITION_VALUE(aCondition, aValue)                                __nlPRECONDITION(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aCondition, return aValue)
+
+/**
+ *  @implements nlPRECONDITION_VALUE_ACTION(aCondition, aValue, anAction)
+ *
+ */
+#define nlPRECONDITION_VALUE_ACTION(aCondition, aValue, anAction)               __nlPRECONDITION_ACTION(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aCondition, return aValue, anAction)
+
+/**
+ *  @implements nlPRECONDITION_VALUE_PRINT(aCondition, aValue, aMessage)
+ *
+ */
+#define nlPRECONDITION_VALUE_PRINT(aCondition, aValue, aMessage)                __nlPRECONDITION_PRINT(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aCondition, return aValue, aMessage)
+
+/**
+ *  @implements nlPRECONDITION_VALUE_SUCCESS(aStatus, aValue)
+ *
+ */
+#define nlPRECONDITION_VALUE_SUCCESS(aStatus, aValue)                           __nlPRECONDITION_SUCCESS(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aStatus, return aValue)
+
+/**
+ *  @implements nlPRECONDITION_VALUE_SUCCESS_ACTION(aStatus, aValue, anAction)
+ *
+ */
+#define nlPRECONDITION_VALUE_SUCCESS_ACTION(aStatus, aValue, anAction)          __nlPRECONDITION_SUCCESS_ACTION(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aStatus, return aValue, anAction)
+
+/**
+ *  @implements nlPRECONDITION_VALUE_SUCCESS_PRINT(aStatus, aValue, aMessage)
+ *
+ */
+#define nlPRECONDITION_VALUE_SUCCESS_PRINT(aStatus, aValue, aMessage)           __nlPRECONDITION_SUCCESS_PRINT(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aStatus, return aValue, aMessage)
+
+/**
+ *  @implements nlNPRECONDITION_VALUE(aCondition, aValue)
+ *
+ */
+#define nlNPRECONDITION_VALUE(aCondition, aValue)                               __nlNPRECONDITION(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aCondition, return aValue)
+
+/**
+ *  @implements nlNPRECONDITION_VALUE_ACTION(aCondition, aValue, anAction)
+ *
+ */
+#define nlNPRECONDITION_VALUE_ACTION(aCondition, aValue, anAction)              __nlNPRECONDITION_ACTION(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aCondition, return aValue, anAction)
+
+/**
+ *  @implements nlNPRECONDITION_VALUE_PRINT(aCondition, aValue, aMessage)
+ *
+ */
+#define nlNPRECONDITION_VALUE_PRINT(aCondition, aValue, aMessage)               __nlNPRECONDITION_PRINT(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aCondition, return aValue, aMessage)
+
+// nlASSERT
+
+/**
+ *  @implements nlASSERT(aCondition)
+ *
+ */
+#define nlASSERT(aCondition)                                                    __nlASSERT_UNUSED(aCondition)
+
+/**
+ *  @implements nlASSERT_ACTION(aCondition, anAction)
+ *
+ */
+#define nlASSERT_ACTION(aCondition, anAction)                                   __nlASSERT_UNUSED(aCondition)
+
+// nlABORT
+
+/**
+ *  @def NL_ASSERT_ABORT_PRODUCTION_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for abort-style
+ *    exception family assertions when #NL_ASSERT_PRODUCTION is
+ *    enabled.
+ *
+ *  This may be used to override #NL_ASSERT_ABORT_PRODUCTION_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_ABORT_PRODUCTION_FLAGS NL_ASSERT_ABORT_PRODUCTION_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_ABORT_PRODUCTION_FLAGS
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ *  @ingroup abort-style
+ *
+ */
+#define NL_ASSERT_ABORT_PRODUCTION_FLAGS_DEFAULT                                (NL_ASSERT_FLAG_BACKTRACE | NL_ASSERT_FLAG_LOG)
+
+/**
+ *  @def NL_ASSERT_ABORT_PRODUCTION_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags when #NL_ASSERT_PRODUCTION is
+ *    enabled that govern the behavior for abort-style exception
+ *    family assertions when the assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_ABORT_PRODUCTION_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ *  @ingroup abort-style
+ *
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_ABORT_PRODUCTION_FLAGS                                        NL_ASSERT_ABORT_PRODUCTION_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_ABORT_PRODUCTION_FLAGS)
+#define NL_ASSERT_ABORT_PRODUCTION_FLAGS                                        (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @implements nlABORT(aCondition)
+ *
+ */
+#define nlABORT(aCondition)                                                     __nlABORT(NL_ASSERT_ABORT_PRODUCTION_FLAGS, aCondition)
+
+/**
+ *  @implements nlABORT_ACTION(aCondition, anAction)
+ *
+ */
+#define nlABORT_ACTION(aCondition, anAction)                                    __nlABORT_ACTION(NL_ASSERT_ABORT_PRODUCTION_FLAGS, aCondition, anAction)
+
+#endif /* NLASSERT_PRODUCTION_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/nlassert.h b/cores/nRF5/nordic/config/nrf52840/config/nlassert.h
new file mode 100644
index 000000000..8ba0d1fa0
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/nlassert.h
@@ -0,0 +1,1728 @@
+/*
+ *   Copyright 2010-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *   Licensed under the Apache License, Version 2.0 (the "License");
+ *   you may not use this file except in compliance with the License.
+ *   You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *   Unless required by applicable law or agreed to in writing, software
+ *   distributed under the License is distributed on an "AS IS" BASIS,
+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *   See the License for the specific language governing permissions and
+ *   limitations under the License.
+ *
+ */
+
+/**
+ *    @file
+ *      This file defines macros and interfaces for performing both
+ *      compile- and run-time assertion checking and run-time
+ *      exception handling.
+ *
+ *      Where exception-handing is concerned, the format of the macros
+ *      are inspired by those found in Mac OS Classic and, later, Mac
+ *      OS X. These, in turn, were inspired by "Living In an
+ *      Exceptional World" by Sean Parent (develop, The Apple
+ *      Technical Journal, Issue 11, August/September 1992)
+ *      <http://www.mactech.com/articles/develop/issue_11/Parent_final.html>
+ *      for the methodology behind these error handling and assertion
+ *      macros.
+ *
+ */
+
+/**
+ *  @mainpage notitle
+ *
+ *  @section introduction Introduction
+ *
+ *  This package defines macros and interfaces for performing both
+ *  compile- and run-time assertion checking and run-time exception
+ *  handling.
+ *
+ *  Where exception-handing is concerned, the format of the macros are
+ *  inspired by those found in Mac OS Classic and, later, Mac OS
+ *  X. These, in turn, were inspired by "Living In an Exceptional
+ *  World" by Sean Parent (develop, The Apple Technical Journal, Issue
+ *  11, August/September 1992). See:
+ *
+ *    http://www.mactech.com/articles/develop/issue_11/Parent_final.html
+ *
+ *  for the methodology behind these error handling and assertion
+ *  macros.
+ *
+ *  @section overview Overview
+ *
+ *  The interfaces in this package come in two interface modalities:
+ *
+ *  <dl>
+ *     <dt>[Run-time](@ref run-time)</dt>
+ *         <dd>Interfaces that dynamically check a logical assertion and
+ *             alter run-time execution on assertion firing.</dd>
+ *     <dt>[Compile-time](@ref compile-time)</dt>
+ *         <dd>Interfaces that statically check a logical assertion and
+ *             terminate compile-time execution on assertion firing.</dd>
+ *  </dl>
+ *
+ *  @subsection run-time Run-time
+ *
+ *  The [run-time modality interfaces](@ref run-time-interfaces) in
+ *  this package come in three families:
+ *
+ *  <dl>
+ *      <dt>[Assertion](@ref run-time-assertions)</dt>
+ *          <dd>Similar to the traditional C Standard Library
+ *          [assert()](http://pubs.opengroup.org/onlinepubs/009695399/functions/assert.html).</dd>
+ *
+ *      <dt>[Precondition](@ref preconditions)</dt>
+ *          <dd>Designed to be placed at the head of an interface or
+ *          method to check incoming parameters and return on
+ *          assertion failure.</dd>
+ *
+ *      <dt>[Exception](@ref exceptions)</dt>
+ *          <dd>Designed to jump to a local label on assertion failure
+ *          to support the method of error and exception handling that
+ *          advocates a single function or method return site and, by
+ *          extension, consolidated points of exception and error
+ *          handling as well as resource clean-up.</dd>
+ *  </dl>
+ *
+ *  There are several styles of interfaces within each family and
+ *  several potential variants within each style, all of which are
+ *  summarized below and are described in detail in the following
+ *  sections.
+ *
+ *  @subsection compile-time Compile-time
+ *
+ *  The [compile-time modality interfaces](@ref compile-time-interfaces)
+ *  in this package are simpler and come in a single family with a
+ *  couple of variants.
+ *
+ *  @section run-time-interfaces Run-time Interfaces
+ *
+ *  @subsection triggers Behavior Triggers
+ *
+ *  Unlike the traditional C Standard Library
+ *  [assert()](http://pubs.opengroup.org/onlinepubs/009695399/functions/assert.html)
+ *  or other assertion checking packages, this package offers the
+ *  ability to enable and customize one or more of a few triggers that
+ *  run when an assertion fires, including:
+ *
+ *     * [Abort](@ref abort-behavior)
+ *     * [Backtrace](@ref backtrace-behavior)
+ *     * [Log](@ref log-behavior)
+ *     * [Trap](@ref trap-behavior)
+ *
+ *  @subsubsection abort-behavior Abort
+ *
+ *  The abort behavior trigger allows, on an assertion firing, to
+ *  execute a trigger that terminates overall program or system
+ *  execution.
+ *
+ *  Note, however, the abort behavior trigger is only available in
+ *  some styles of the [assertion-family](@ref run-time-assertions) of
+ *  interfaces.
+ *
+ *  Please see #NL_ASSERT_ABORT() and @ref customization for more
+ *  information about this behavior trigger.
+ *
+ *  @subsubsection backtrace-behavior Backtrace
+ *
+ *  The backtrace behavior trigger allows, on an assertion firing, to
+ *  execute a trigger that generates a stack backtrace.
+ *
+ *  This style of assertion is available, when configured, on all
+ *  interface families.
+ *
+ *  Please see #NL_ASSERT_BACKTRACE() and @ref customization for more
+ *  information about this behavior trigger.
+ *
+ *  @subsubsection log-behavior Log
+ *
+ *  The log behavior trigger allows, on an assertion firing, to
+ *  execute a trigger that logs a message summarizing the assertion
+ *  that fired.
+ *
+ *  This style of assertion is available, when configured, on all
+ *  interface families.
+ *
+ *  Please see #NL_ASSERT_LOG() and @ref customization for more
+ *  information about this behavior trigger.
+ *
+ *  @subsubsection trap-behavior Trap
+ *
+ *  The log behavior trigger allows, on an assertion firing, to
+ *  execute a trigger that generates a debugger trap or exception.
+ *
+ *  This style of assertion is available, when configured, on all
+ *  interface families.
+ *
+ *  Please see #NL_ASSERT_TRAP() and @ref customization for more
+ *  information about this behavior trigger.
+ *
+ *  @subsection run-time-assertions Assertion Interfaces
+ *
+ *  The assertion interfaces are similar to the traditional C
+ *  Standard Library
+ *  [assert()](http://pubs.opengroup.org/onlinepubs/009695399/functions/assert.html).
+ *
+ *  These interfaces include the following styles:
+ *
+ *    * [Assert](@ref run-time-assert)
+ *    * [Abort](@ref run-time-abort)
+ *    * [Check](@ref run-time-check)
+ *    * [Verify](@ref run-time-verify)
+ *
+ *  The following table summarizes the relationship and features among
+ *  the styles:
+
+ *  <table>
+ *      <tr>
+ *          <th rowspan="2">Style</th>
+ *          <th colspan="4">Behaviors</th>
+ *          <th colspan="2">Availability</th>
+ *      </tr>
+ *      <tr>
+ *          <th>Abort</th>
+ *          <th>Backtrace</th>
+ *          <th>Log</th>
+ *          <th>Trap</th>
+ *          <th>Non-production</th>
+ *          <th>Production</th>
+ *      </tr>
+ *      <tr>
+ *          <td>Assert</td>
+ *          <td align="center">Non-production</td>
+ *          <td align="center">Non-production</td>
+ *          <td align="center">Non-production</td>
+ *          <td align="center"></td>
+ *          <td align="center">X</td>
+ *          <td align="center"></td>
+ *      </tr>
+ *      <tr>
+ *          <td>Abort</td>
+ *          <td align="center">X</td>
+ *          <td align="center">X</td>
+ *          <td align="center">X</td>
+ *          <td align="center"></td>
+ *          <td align="center">X</td>
+ *          <td align="center">X</td>
+ *      </tr>
+ *      <tr>
+ *          <td>Check</td>
+ *          <td align="center"></td>
+ *          <td align="center">Non-production</td>
+ *          <td align="center">Non-production</td>
+ *          <td align="center">Non-production</td>
+ *          <td align="center">X</td>
+ *          <td align="center"></td>
+ *      </tr>
+ *      <tr>
+ *          <td>Verify</td>
+ *          <td align="center"></td>
+ *          <td align="center">X</td>
+ *          <td align="center">X</td>
+ *          <td align="center">Non-production</td>
+ *          <td align="center">X</td>
+ *          <td align="center">X</td>
+ *      </tr>
+ *  </table>
+ *
+ *  @note The above described behaviors are only in effect when
+ *        #NL_ASSERT_USE_FLAGS_DEFAULT to 1. See @ref customization
+ *        for more information on configuring and customizing the
+ *        trigger behaviors.
+ *
+ *  @subsubsection run-time-assert Assert
+ *
+ *  These assertions are identical to the traditional C Standard
+ *  Library-style assertion (see
+ *  [assert()](http://pubs.opengroup.org/onlinepubs/009695399/functions/assert.html))
+ *  except that side-effects, if any, in the asserted expression will be
+ *  produced even when the assertion is made inactive, as in production build
+ *  configurations, by setting #NL_ASSERT_PRODUCTION to true.
+ *
+ *  Like the C Standard Library assertion, a trigger of this style of
+ *  assertion interface will invoke #NL_ASSERT_ABORT().
+ *
+ *  @subsubsection run-time-abort Abort
+ *
+ *  These assertions are identical to the @ref run-time-assert style
+ *  assertions; however, they are active in __both__ non-production
+ *  __and__ production build configurations.
+ *
+ *  A trigger of this style of assertion interface will invoke #NL_ASSERT_ABORT().
+ *
+ *  @subsubsection run-time-check Check
+ *
+ *  These assertions are similar to the @ref run-time-assert style; however,
+ *  this style __does not__ abort. Normal program flow and execution
+ *  will continue past this assertion.
+ *
+ *  Side-effects, if any, in the asserted expression will be produced even when
+ *  the assertion is made inactive, as in production build configurations, by
+ *  setting #NL_ASSERT_PRODUCTION to true.
+ *
+ *  @subsubsection run-time-verify Verify
+ *
+ *  These assertions are similar to the @ref run-time-abort style; however,
+ *  this style __does not__ abort. Normal program flow and execution
+ *  will continue past this assertion.
+ *
+ *  These are active in __both__ non-production __and__ production
+ *  build configurations.
+ *
+ *  @subsection preconditions Precondition Interfaces
+ *
+ *  These assertions are designed to be placed at the head of an
+ *  interface or method to check incoming parameters.
+ *
+ *  These assertions implicitly return, either void or a specified
+ *  value for non-void interfaces or methods.
+ *
+ *  @note This family of interfaces may be in violation of your site's
+ *  or project's coding style and best practices by virtue of its
+ *  implicit return. If so, please consider using the
+ *  [exception-style](@ref exceptions) interfaces instead.
+ *
+ *  The following table summarizes the features for this family of interfaces:
+ *
+ *  <table>
+ *      <tr>
+ *          <th rowspan="2">Style</th>
+ *          <th colspan="4">Behaviors</th>
+ *          <th colspan="2">Availability</th>
+ *      </tr>
+ *      <tr>
+ *          <th>Abort</th>
+ *          <th>Backtrace</th>
+ *          <th>Log</th>
+ *          <th>Trap</th>
+ *          <th>Non-production</th>
+ *          <th>Production</th>
+ *      </tr>
+ *      <tr>
+ *          <td>Precondition</td>
+ *          <td align="center"></td>
+ *          <td align="center">X</td>
+ *          <td align="center">X</td>
+ *          <td align="center"></td>
+ *          <td align="center">X</td>
+ *          <td align="center">X</td>
+ *      </tr>
+ *  </table>
+ *
+ *  @note The above described behaviors are only in effect when
+ *        #NL_ASSERT_USE_FLAGS_DEFAULT to 1. See @ref customization
+ *        for more information on configuring and customizing the
+ *        trigger behaviors.
+ *
+ *  @subsection exceptions Exception Interfaces
+ *
+ *  This family of interfaces is designed to support the method of
+ *  error and exception handling that advocates a single function or
+ *  method return site and, by extension, consolidated points of
+ *  exception and error handling as well as resource clean-up.
+ *
+ *  A general example usage of this family of interfaces is:
+ *
+ *  @code
+ *  int Bar(uint8_t **aBuffer, const Foo *aParameter)
+ *  {
+ *      const size_t size   = 1024;
+ *      int          retval = 0;
+ *
+ *      nlREQUIRE(aBuffer != NULL, exit, retval = -EINVAL);
+ *
+ *      *aBuffer = (uint8_t *)malloc(size);
+ *      nlREQUIRE(*aBuffer != NULL, exit, retval = -ENOMEM);
+ *
+ *      memset(*aBuffer, 0, size);
+ *
+ *  exit:
+ *      return retval;
+ *  }
+ *  @endcode
+ *
+ *  As shown in the example, this family checks for the specified
+ *  condition, which is expected to commonly be true, and branches to
+ *  the specified label if the condition is false.
+ *
+ *    * [Expect](@ref expect)
+ *    * [Desire](@ref desire)
+ *    * [Require](@ref require)
+ *
+ *  This family of interfaces are all identical across the styles and
+ *  all styles support an identical set of variants. The only
+ *  difference among them is the default configured trigger action
+ *  behavior, as summarized in the table below:
+ *
+ *  <table>
+ *      <tr>
+ *          <th rowspan="2">Style</th>
+ *          <th colspan="3">Behaviors</th>
+ *          <th colspan="2">Availability</th>
+ *      </tr>
+ *      <tr>
+ *          <th>Backtrace</th>
+ *          <th>Log</th>
+ *          <th>Trap</th>
+ *          <th>Non-production</th>
+ *          <th>Production</th>
+ *      </tr>
+ *      <tr>
+ *          <td>Expect</td>
+ *          <td></td>
+ *          <td></td>
+ *          <td></td>
+ *          <td align="center">X</td>
+ *          <td align="center">X</td>
+ *      </tr>
+ *      <tr>
+ *          <td>Desire</td>
+ *          <td></td>
+ *          <td align="center">Non-production</td>
+ *          <td></td>
+ *          <td align="center">X</td>
+ *          <td align="center">X</td>
+ *      </tr>
+ *      <tr>
+ *          <td>Require</td>
+ *          <td align="center">X</td>
+ *          <td align="center">X</td>
+ *          <td align="center">Non-production</td>
+ *          <td align="center">X</td>
+ *          <td align="center">X</td>
+ *      </tr>
+ *  </table>
+ *
+ *  @note The above described behaviors are only in effect when
+ *        #NL_ASSERT_USE_FLAGS_DEFAULT to 1. See @ref customization
+ *        for more information on configuring and customizing the
+ *        trigger behaviors.
+ *
+ *  @subsubsection expect Expect
+ *
+ *  These assertions are designed to be placed anywhere an exceptional
+ *  condition might occur where handling needs to locally jump to
+ *  error-handling code.
+ *
+ *  These checks are always present and do nothing beyond branching to
+ *  the named exception label. Consequently, they are simply mnemonics
+ *  or syntactic sugar.
+ *
+ *  This style of check should be used where either true or false
+ *  evaluation of the assertion expression are equally likely since
+ *  there is no default configured trigger behavior.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @subsubsection desire Desire
+ *
+ *  These are identical to the @ref expect style checks; except for
+ *  their non-production and production configured behavior.
+ *
+ *  This style of check should be used where false evaluation of the
+ *  assertion expression is expected to be occasional.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @subsubsection require Require
+ *
+ *  These are identical to the @ref expect style checks; except for
+ *  their non-production and production configured behavior.
+ *
+ *  This style of check should be used where false evaluation of the
+ *  assertion expression is expected to be rare.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ * @subsection variants Variants
+ *
+ * The three families of run-time interface are available in one of several
+ * variants, as summarized below. <em>&lt;STYLE&gt;</em> may be replaced with one of (see [Run-time Availability](@ref run-time-availability) for details):
+ *
+ *   * ASSERT
+ *   * ABORT
+ *   * CHECK
+ *   * VERIFY
+ *   * PRECONDITION
+ *   * EXPECT
+ *   * DESIRE
+ *   * REQUIRE
+ *
+ * to form an actual interface name.
+ *
+ * | Interface Variant                              | Description                                                                                                  |
+ * |:---------------------------------------------- |:------------------------------------------------------------------------------------------------------------ |
+ * | nl<em>&lt;STYLE&gt;</em>                       | Base variant; execute the check.                                                                             |
+ * | nl<em>&lt;STYLE&gt;</em>\_ACTION               | Execute the base check and execute the action if the check fails.                                            |
+ * | nl<em>&lt;STYLE&gt;</em>\_PRINT                | Execute the base check and print the descriptive string if the check fails.                                  |
+ * | nl<em>&lt;STYLE&gt;</em>\_ACTION_PRINT         | Execute the base check and both execute the action and print the descriptive string if the check fails.      |
+ * | nl<em>&lt;STYLE&gt;</em>\_SUCCESS              | Adds a check against zero (0) as the logical condition to assert.                                            |
+ * | nl<em>&lt;STYLE&gt;</em>\_SUCCESS_ACTION       | Execute the success check and execute the action if the check fails.                                         |
+ * | nl<em>&lt;STYLE&gt;</em>\_SUCCESS_PRINT        | Execute the success check and print the descriptive string if the check fails.                               |
+ * | nl<em>&lt;STYLE&gt;</em>\_SUCCESS_ACTION_PRINT | Execute the success check and both execute the action and print the descriptive string if the check fails.   |
+ * | nlN<em>&lt;STYLE&gt;</em>                      | Inverts the logical sense of the base check; execute the check.                                              |
+ * | nlN<em>&lt;STYLE&gt;</em>\_ACTION              | Execute the inversion check and execute the action if the check fails.                                       |
+ * | nlN<em>&lt;STYLE&gt;</em>\_PRINT               | Execute the inversion check and print the descriptive string if the check fails.                             |
+ * | nlN<em>&lt;STYLE&gt;</em>\_ACTION_PRINT        | Execute the inversion check and both execute the action and print the descriptive string if the check fails. |
+ *
+ * @section run-time-availability Run-time Availability
+ *
+ * The following table indicates the availability of the run-time interface
+ * variants for each style.
+ *
+ * <table>
+ *     <tr>
+ *         <th rowspan="2">Interface Variant</th>
+ *         <th colspan="8">Style</th>
+ *     </tr>
+ *     <tr>
+ *         <th>Assert</th>
+ *         <th>Abort</th>
+ *         <th>Check</th>
+ *         <th>Verify</th>
+ *         <th>Precondition</th>
+ *         <th>Expect</th>
+ *         <th>Desire</th>
+ *         <th>Require</th>
+ *     </tr>
+ *     <tr>
+ *         <td>nl<em>&lt;STYLE&gt;</em></td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ *     <tr>
+ *         <td>nl<em>&lt;STYLE&gt;</em>\_ACTION</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ *     <tr>
+ *         <td>nl<em>&lt;STYLE&gt;</em>\_PRINT</td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ *     <tr>
+ *         <td>nl<em>&lt;STYLE&gt;</em>\_ACTION_PRINT</td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ *     <tr>
+ *         <td>nl<em>&lt;STYLE&gt;</em>\_SUCCESS</td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ *     <tr>
+ *         <td>nl<em>&lt;STYLE&gt;</em>\_SUCCESS_ACTION</td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ *     <tr>
+ *         <td>nl<em>&lt;STYLE&gt;</em>\_SUCCESS_PRINT</td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ *     <tr>
+ *         <td>nl<em>&lt;STYLE&gt;</em>\_SUCCESS_ACTION_PRINT</td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ *     <tr>
+ *         <td>nlN<em>&lt;STYLE&gt;</em></td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ *     <tr>
+ *         <td>nlN<em>&lt;STYLE&gt;</em>\_ACTION</td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ *     <tr>
+ *         <td>nlN<em>&lt;STYLE&gt;</em>\_PRINT</td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ *     <tr>
+ *         <td>nlN<em>&lt;STYLE&gt;</em>\_ACTION_PRINT</td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ * </table>
+ *
+ * @section customization Customization
+ *
+ * The Nest Labs Assertion library is designed "out of the box" to
+ * provide a high degree of utility. However, there are a number of
+ * aspects that can be tuned on a per-module, -project, or -site basis
+ * to customize the appearance and behavior through user-definable
+ * attributes via the C preprocessor.
+ *
+ * @subsection userattrs User-definable Attributes
+ *
+ * The following attributes may be defined by the user before
+ * the nlassert.h header is included by the preprocessor, overriding
+ * the default behavior:
+ *
+ *   * #NL_ASSERT_PRODUCTION
+ *   * #NL_ASSERT_PREFIX_STRING
+ *   * #NL_ASSERT_COMPONENT_STRING
+ *   * #NL_ASSERT_FILE
+ *   * #NL_ASSERT_ABORT
+ *   * #NL_ASSERT_BACKTRACE
+ *   * #NL_ASSERT_LOG
+ *   * #NL_ASSERT_TRAP
+ *
+ * Without any customization, all of the interface styles are set to
+ * use __no__ trigger behaviors (i.e. #NL_ASSERT_FLAG_NONE). However, a
+ * set of default trigger behaviors (as documented in the tables
+ * above) may be enabled by setting #NL_ASSERT_USE_FLAGS_DEFAULT to 1
+ * before nlassert.h is included by the preprocessor.
+ *
+ * Otherwise, the following attributes may be overridden, customizing
+ * the trigger behavior of each assertion interface family for both
+ * non-production and production configurations:
+ *
+ *   * #NL_ASSERT_EXPECT_FLAGS
+ *
+ *   * #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS
+ *   * #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS
+ *   * #NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS
+ *   * #NL_ASSERT_ABORT_NONPRODUCTION_FLAGS
+ *   * #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *   * #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *   * #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *
+ *   * #NL_ASSERT_VERIFY_PRODUCTION_FLAGS
+ *   * #NL_ASSERT_ABORT_PRODUCTION_FLAGS
+ *   * #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *   * #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *   * #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @section compile-time-interfaces Compile-time Interfaces
+ *
+ *  The compile-time interfaces are a limited subset of their run-time
+ *  counterparts. Rather than altering run-time execution on assertion
+ *  firing against a dynamically-checked run-time condition, these
+ *  interfaces terminate compilation against a statically-checked
+ *  compile-time condition.
+ *
+ *  @subsection compile-time-assertions Assertion Interfaces
+ *
+ *  These interfaces have only one style:
+ *
+ *    * [Assert](@ref compile-time-assert)
+ *
+ *  <table>
+ *      <tr>
+ *          <th rowspan="2">Style</th>
+ *          <th colspan="2">Availability</th>
+ *      </tr>
+ *      <tr>
+ *          <th>Non-production</th>
+ *          <th>Production</th>
+ *      </tr>
+ *      <tr>
+ *          <td>Assert</td>
+ *          <td align="center">X</td>
+ *          <td align="center">X</td>
+ *      </tr>
+ *  </table>
+ *
+ *  @subsubsection compile-time-assert Assert
+ *
+ *  These assertions are active in __both__ non-production
+ *  __and__ production build configurations. This behavior
+ *  is unconventional with respect to the [run-time assert-style assertions](@ref run-time-assert)
+ *  but very conventional with respect to the similar
+ *  C11/C++11 static-assertion standards.
+ *
+ * @subsection compile-time-variants Variants
+ *
+ * The compile-time interfaces are available in two variants:
+ *
+ * | Interface Variant                              | Description                                                                                                  |
+ * |:---------------------------------------------- |:------------------------------------------------------------------------------------------------------------ |
+ * | nlSTATIC\_ASSERT                               | Base variant; execute the check.                                                                             |
+ * | nlSTATIC\_ASSERT\_PRINT                        | Execute the base check with a descriptive string. Note, this string is not actually emitted in any meaningful way. It serves to simply comment or annotate the assertion and to provide interface parallelism with the run-time assertion interfaces.                                  |
+ *
+ * @section compile-time-availability Compile-time Availability
+ *
+ * The following table indicates the availability of the compile-time interface
+ * variants.
+ *
+ * <table>
+ *     <tr>
+ *         <th rowspan="2">Interface Variant</th>
+ *         <th colspan="2">Availability</th>
+ *     </tr>
+ *     <tr>
+ *         <th>Non-Production</th>
+ *         <th>Production</th>
+ *     </tr>
+ *     <tr>
+ *         <td>nlSTATIC\_ASSERT</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ *     <tr>
+ *         <td>nlSTATIC\_ASSERT\_PRINT</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ * </table>
+ *
+ * @section compatibility Standard C Library Compatibility
+ *
+ * This package also provides an ISO/IEC 9899:1999-, C89-, and
+ * C99-compatible Standard C Library header (via assert.h) and
+ * assertion interface definition (assert()), implemented atop Nest
+ * Labs assertion checking and runtime exception interfaces such that
+ * consistent platform and system capabilities, behavior, and output
+ * may be implemented and enforced across the two interfaces.
+ *
+ * Systems wishing to use this compatibility header and interface in
+ * lieu of their Standard C Library header of the same name should
+ * ensure that their toolchain is configured to either ignore or
+ * deprioritize standard search paths while placing the directory this
+ * header is contained in among the preferred header search paths.
+ *
+ */
+
+#ifndef NLCORE_NLASSERT_H
+#define NLCORE_NLASSERT_H
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+/**
+ *  @name Behavioral Control Flags
+ *
+ *  @brief
+ *    These flags are used to influence the behavior of the various
+ *    classes and styles of assertion macros.
+ *
+ *  @{
+ *
+ */
+
+/**
+ *  @def NL_ASSERT_FLAG_NONE
+ *
+ *  @brief
+ *    Perform no actions when an assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ */
+#define NL_ASSERT_FLAG_NONE             0x00000000
+
+/**
+ *  @def NL_ASSERT_FLAG_BACKTRACE
+ *
+ *  @brief
+ *    Invoke #NL_ASSERT_BACKTRACE() when an assertion expression
+ *    evaluates to false.
+ *
+ *  @note For the *_ACTION*-style assertion variants,
+ *        #NL_ASSERT_BACKTRACE() is a pre-action trigger and will run
+ *        before the specified action.
+ *
+ *  @sa #NL_ASSERT_FLAG_NONE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ *  @sa #NL_ASSERT_BACKTRACE
+ *
+ */
+#define NL_ASSERT_FLAG_BACKTRACE        0x00000001
+
+/**
+ *  @def NL_ASSERT_FLAG_LOG
+ *
+ *  @brief
+ *    Invoke #NL_ASSERT_LOG() when an assertion expression evaluates
+ *    to false.
+ *
+ *  @note For the *_ACTION*-style assertion variants,
+ *        #NL_ASSERT_LOG() is a pre-action trigger and will run
+ *        before the specified action.
+ *
+ *  @sa #NL_ASSERT_FLAG_NONE
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ *  @sa #NL_ASSERT_LOG
+ *
+ */
+#define NL_ASSERT_FLAG_LOG              0x00000002
+
+/**
+ *  @def NL_ASSERT_FLAG_TRAP
+ *
+ *  @brief
+ *    Invoke #NL_ASSERT_TRAP() when an assertion expression evaluates
+ *    to false.
+ *
+ *  @note For the *_ACTION*-style assertion variants,
+ *        #NL_ASSERT_TRAP() is a post-action trigger and will run
+ *        after the specified action.
+ *
+ *  @sa #NL_ASSERT_FLAG_NONE
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *
+ *  @sa #NL_ASSERT_TRAP
+ *
+ */
+#define NL_ASSERT_FLAG_TRAP             0x00000004
+
+/**
+ *  @}
+ *
+ */
+
+/**
+ *  @def NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    Enable (1) or disable (0) use of the default trigger behavior flags.
+ *
+ *  This enables or disables the use of the default trigger behavior
+ *  flags as specified by:
+ *
+ *   * #NL_ASSERT_EXPECT_FLAGS_DEFAULT
+ *
+ *   * #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS_DEFAULT
+ *   * #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS_DEFAULT
+ *   * #NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS_DEFAULT
+ *   * #NL_ASSERT_ABORT_NONPRODUCTION_FLAGS_DEFAULT
+ *   * #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS_DEFAULT
+ *   * #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS_DEFAULT
+ *   * #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *   * #NL_ASSERT_VERIFY_PRODUCTION_FLAGS_DEFAULT
+ *   * #NL_ASSERT_ABORT_PRODUCTION_FLAGS_DEFAULT
+ *   * #NL_ASSERT_DESIRE_PRODUCTION_FLAGS_DEFAULT
+ *   * #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS_DEFAULT
+ *   * #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS_DEFAULT
+ *
+ *  Setting this to 1, effectively does the following:
+ *
+ *  @code
+ *  #define NL_ASSERT_<STYLE>_<CONFIGURATION>_FLAGS NL_ASSERT_<STYLE>_<CONFIGURATION>_FLAGS_DEFAULT
+ *  @endcode
+ *
+ *  for each assertion interface <em>&lt;STYLE&gt;</em> for both
+ *  non-production and production (see #NL_ASSERT_PRODUCTION) <em>&lt;CONFIGURATION&gt;</em> .
+ *
+ */
+#if !defined(NL_ASSERT_USE_FLAGS_DEFAULT)
+#define NL_ASSERT_USE_FLAGS_DEFAULT     0
+#endif /* !defined(NL_ASSERT_USE_FLAGS_DEFAULT) */
+
+/**
+ *  @def NL_ASSERT_PRODUCTION
+ *
+ *  @brief
+ *    Enable (1) or disable (0) when production (or non-production)
+ *    assertion behavior is desired.
+ *
+ *  When production behavior is asserted, a number of interface
+ *  families are elided entirely and for others, the default behavior
+ *  changes (default: ((defined(NDEBUG) && NDEBUG) || (defined(DEBUG)
+ *  && !DEBUG) || 1)).
+ *
+ */
+#if !defined(NL_ASSERT_PRODUCTION)
+#if defined(NDEBUG)
+#define NL_ASSERT_PRODUCTION            NDEBUG
+#elif defined(DEBUG)
+#define NL_ASSERT_PRODUCTION            !DEBUG
+#else
+#define NL_ASSERT_PRODUCTION            1
+#endif /* defined(NDEBUG) */
+#endif /* !defined(NL_ASSERT_PRODUCTION) */
+
+/**
+ *  @name Log Output Definitions
+ *
+ *  @brief
+ *    These definitions control how the output of assertion log
+ *    messages appear, when so configured, on assertion expression
+ *    failure evaluation.
+ *
+ *  @{
+ *
+ */
+
+/**
+ *  @def NL_ASSERT_PREFIX_STRING
+ *
+ *  @brief
+ *    This is the string printed at the beginning of the assertion
+ *    printed (default: 'ASSERT: ').
+ *
+ *    Developers may, but are generally not encouraged to, override
+ *    this by defining #NL_ASSERT_PREFIX_STRING before nlassert.h is
+ *    included by the preprocessor, as shown in the following example:
+ *
+ *  @code
+ *    #define NL_ASSERT_PREFIX_STRING   "assertion: "
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_PREFIX_STRING
+ */
+#if !defined(NL_ASSERT_PREFIX_STRING)
+#define NL_ASSERT_PREFIX_STRING         "ASSERT: "
+#endif /* !defined(NL_ASSERT_PREFIX_STRING) */
+
+/**
+ *  @def NL_ASSERT_COMPONENT_STRING
+ *
+ *  @brief
+ *    This is the string printed following the prefix string (see
+ *    #NL_ASSERT_PREFIX_STRING) that indicates what module, program,
+ *    application or subsystem the assertion occurred in (default:
+ *    '').
+ *
+ *    Developers may override this by defining
+ *    #NL_ASSERT_COMPONENT_STRING before nlassert.h is included by the
+ *    preprocessor, as shown in the following example:
+ *
+ *  @code
+ *    #define NL_ASSERT_COMPONENT_STRING   "nlbar"
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_PREFIX_STRING
+ *
+ */
+#if !defined(NL_ASSERT_COMPONENT_STRING)
+#define NL_ASSERT_COMPONENT_STRING      ""
+#endif  /* !defined(NL_ASSERT_COMPONENT_STRING) */
+
+/**
+ *  @}
+ *
+ */
+
+/**
+ *  @def NL_ASSERT_ABORT()
+ *
+ *  @brief
+ *    This macro is invoked when an nlASSERT- or nlABORT-style
+ *    assertion expression evaluates to false.
+ *
+ *    By default, this is defined to the C Standard Library
+ *    [abort()](http://pubs.opengroup.org/onlinepubs/009695399/functions/abort.html). When
+ *    overridden, this should generally provide similar functionality,
+ *    terminating the overall process or system execution.
+ *
+ *    Developers may override and customize this by defining
+ *    #NL_ASSERT_ABORT() before nlassert.h is included by the
+ *    preprocessor.
+ *
+ */
+#if !defined(NL_ASSERT_ABORT)
+#define NL_ASSERT_ABORT()               abort()
+#endif /* !defined(NL_ASSERT_ABORT) */
+
+/**
+ *  @def NL_ASSERT_BACKTRACE()
+ *
+ *  @brief
+ *    This macro is invoked when an assertion expression evaluates to
+ *    false when the macro has been configured with / passed
+ *    #NL_ASSERT_FLAG_BACKTRACE.
+ *
+ *  By default, this is defined to do nothing. However, when defined,
+ *  this should generally generate a stack back trace when invoked.
+ *
+ *  Developers may override and customize this by defining
+ *  #NL_ASSERT_BACKTRACE() before nlassert.h is included by the
+ *  preprocessor.
+ *
+ *  @note For the *_ACTION*-style assertion variants,
+ *        #NL_ASSERT_BACKTRACE() is a pre-action trigger and will run
+ *        before the specified action.
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *
+ */
+#if !defined(NL_ASSERT_BACKTRACE)
+#define NL_ASSERT_BACKTRACE()
+#endif /* !defined(NL_ASSERT_BACKTRACE) */
+
+/**
+ *  @def NL_ASSERT_TRAP()
+ *
+ *  @brief
+ *    This macro is invoked when an assertion expression evaluates to
+ *    false when the macro has been configured with / passed
+ *    #NL_ASSERT_FLAG_TRAP.
+ *
+ *  By default, this is defined to do nothing. However, when defined,
+ *  this should generally generate a debug trap or breakpoint such that
+ *  when the assertion expression evaluates to false an attached
+ *  debugger will stop at the assertion point.
+ *
+ *  Developers may override and customize this by defining
+ *  #NL_ASSERT_TRAP() before nlassert.h is included by the
+ *  preprocessor, as shown in the following example:
+ *
+ *  @code
+ *    #if defined(__i386__) || defined(__x86_64__)
+ *    #define DEBUGGER_TRAP    __asm__ __volatile__("int3")
+ *    #elif defined(__arm__)
+ *    #define DEBUGGER_TRAP    __asm__ __volatile__("bkpt")
+ *    #endif
+ *
+ *    #define NL_ASSERT_TRAP()                               \
+ *        do                                                 \
+ *        {                                                  \
+ *            if (IsDebuggerAttached())                      \
+ *            {                                              \
+ *                DEBUGGER_TRAP;                             \
+ *            }                                              \
+ *        } while (0)
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @note For the *_ACTION*-style assertion variants,
+ *        #NL_ASSERT_TRAP() is a post-action trigger and will run
+ *        after the specified action.
+ *
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ */
+#if !defined(NL_ASSERT_TRAP)
+#define NL_ASSERT_TRAP()
+#endif /* !defined(NL_ASSERT_TRAP) */
+
+/**
+ *  @def NL_ASSERT_LOG_FORMAT_DEFAULT
+ *
+ *  @brief
+ *    This is the NULL-terminated C string literal with C Standard
+ *    Library-style format specifiers used by #NL_ASSERT_LOG_DEFAULT.
+ *
+ *  This may be used by overrides to #NL_ASSERT_LOG that want to use a
+ *  consistent output formatting.
+ *
+ *  @sa #NL_ASSERT_LOG_DEFAULT
+ *
+ */
+#define NL_ASSERT_LOG_FORMAT_DEFAULT                           "%s%s%s%s, %s%sfile: %s, line: %d\n"
+
+/**
+ *  @def NL_ASSERT_LOG_DEFAULT(aPrefix, aName, aCondition, aLabel, aFile, aLine, aMessage)
+ *
+ *  @brief
+ *    This macro conforms to #NL_ASSERT_LOG and may be assigned to
+ *    #NL_ASSERT_LOG, as shown in the following example, to display an
+ *    assertion message when the assertion triggers, via the C
+ *    Standard I/O Library error stream.
+ *
+ *  @code
+ *    #define NL_ASSERT_LOG(aPrefix, aName, aCondition, aLabel, aFile, aLine, aMessage) \
+ *        NL_ASSERT_LOG_DEFAULT(aPrefix, aName, aCondition, aLabel, aFile, aLine, aMessage)
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @param[in]  aPrefix     A pointer to a NULL-terminated C string printed
+ *                          at the beginning of the logged assertion
+ *                          message. Typically this is and should be
+ *                          #NL_ASSERT_PREFIX_STRING.
+ *  @param[in]  aName       A pointer to a NULL-terminated C string printed
+ *                          following @p aPrefix that indicates what
+ *                          module, program, application or subsystem
+ *                          the assertion occurred in Typically this
+ *                          is and should be
+ *                          #NL_ASSERT_COMPONENT_STRING.
+ *  @param[in]  aCondition  A pointer to a NULL-terminated C string indicating
+ *                          the expression that evaluated to false in
+ *                          the assertion. Typically this is a
+ *                          stringified version of the actual
+ *                          assertion expression.
+ *  @param[in]  aLabel      An optional pointer to a NULL-terminated C string
+ *                          indicating, for exception-style
+ *                          assertions, the label that will be
+ *                          branched to when the assertion expression
+ *                          evaluates to false.
+ *  @param[in]  aFile       A pointer to a NULL-terminated C string indicating
+ *                          the file in which the exception
+ *                          occurred. Typically this is and should be
+ *                          \_\_FILE\_\_ from the C preprocessor or
+ *                          #NL_ASSERT_FILE.
+ *  @param[in]  aLine       The line number in @p aFile on which the assertion
+ *                          expression evaluated to false. Typically
+ *                          this is and should be \_\_LINE\_\_ from the C
+ *                          preprocessor.
+ *  @param[in]  aMessage    An optional pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_LOG
+ *
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *
+ *  @sa #NL_ASSERT_PREFIX_STRING
+ *  @sa #NL_ASSERT_COMPONENT_STRING
+ *  @sa #NL_ASSERT_LOG_FORMAT_DEFAULT
+ *
+ *  @sa #NL_ASSERT_FILE
+ *
+ */
+#define NL_ASSERT_LOG_DEFAULT(aPrefix, aName, aCondition, aLabel, aFile, aLine, aMessage) \
+    do                                                                                    \
+    {                                                                                     \
+        fprintf(stderr,                                                                   \
+                NL_ASSERT_LOG_FORMAT_DEFAULT,                                             \
+                aPrefix,                                                                  \
+                (((aName) == 0) || (*(aName) == '\0')) ? "" : aName,                      \
+                (((aName) == 0) || (*(aName) == '\0')) ? "" : ": ",                       \
+                aCondition,                                                               \
+                ((aMessage == 0) ? "" : aMessage),                                        \
+                ((aMessage == 0) ? "" : ", "),                                            \
+                aFile,                                                                    \
+                aLine);                                                                   \
+    } while (0)
+
+/**
+ *  @def NL_ASSERT_LOG(aPrefix, aName, aCondition, aLabel, aFile, aLine, aMessage)
+ *
+ *  @brief
+ *    This macro is invoked when an assertion expression evaluates to
+ *    false when the macro has been configured with / passed
+ *    #NL_ASSERT_FLAG_LOG.
+ *
+ *  This is intended to display a message, to an appropriate log stream, informing the developer where the assertion was and what expression failed, similar to:
+ *
+ *      "ASSERT: MyComponent: aPointer != NULL, bad pointer, file: foo.c, line: 453"
+ *
+ *  Developers may override and customize this by defining
+ *  #NL_ASSERT_LOG() before nlassert.h is included by the
+ *  preprocessor.
+ *
+ *  @note For the *_ACTION*-style assertion variants, #NL_ASSERT_LOG()
+ *        is a pre-action trigger and will run before the specified action.
+ *
+ *  @param[in]  aPrefix     A pointer to a NULL-terminated C string printed
+ *                          at the beginning of the logged assertion
+ *                          message. Typically this is and should be
+ *                          #NL_ASSERT_PREFIX_STRING.
+ *  @param[in]  aName       A pointer to a NULL-terminated C string printed
+ *                          following @p aPrefix that indicates what
+ *                          module, program, application or subsystem
+ *                          the assertion occurred in Typically this
+ *                          is and should be
+ *                          #NL_ASSERT_COMPONENT_STRING.
+ *  @param[in]  aCondition  A pointer to a NULL-terminated C string indicating
+ *                          the expression that evaluated to false in
+ *                          the assertion. Typically this is a
+ *                          stringified version of the actual
+ *                          assertion expression.
+ *  @param[in]  aLabel      An optional pointer to a NULL-terminated C string
+ *                          indicating, for exception-style
+ *                          assertions, the label that will be
+ *                          branched to when the assertion expression
+ *                          evaluates to false.
+ *  @param[in]  aFile       A pointer to a NULL-terminated C string indicating
+ *                          the file in which the exception
+ *                          occurred. Typically this is and should be
+ *                          \_\_FILE\_\_ from the C preprocessor or
+ *                          #NL_ASSERT_FILE.
+ *  @param[in]  aLine       The line number in @p aFile on which the assertion
+ *                          expression evaluated to false. Typically
+ *                          this is and should be \_\_LINE\_\_ from the C
+ *                          preprocessor.
+ *  @param[in]  aMessage    An optional pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_LOG_DEFAULT
+ *
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *
+ *  @sa #NL_ASSERT_PREFIX_STRING
+ *  @sa #NL_ASSERT_COMPONENT_STRING
+ *
+ *  @sa #NL_ASSERT_FILE
+ *
+ */
+#if !defined(NL_ASSERT_LOG)
+#define NL_ASSERT_LOG(aPrefix, aName, aCondition, aLabel, aFile, aLine, aMessage)
+#endif /* !defined(NL_ASSERT_LOG) */
+
+/**
+ *  @def NL_ASSERT_FILE
+ *
+ *  @brief
+ *    This is the NULL-terminated C string literal with the fully-,
+ *    partially-, or non-qualified path of the file name in which an
+ *    assertion occurred (default \_\_FILE\_\_).
+ *
+ *  This may be used by developers to override the C preprocessor default,
+ *  potentially shortening the size of string literals used for
+ *  assertion file names and, consequently, decreasing the size of a
+ *  particular target image.
+ *
+ */
+#if !defined(NL_ASSERT_FILE)
+#define NL_ASSERT_FILE __FILE__
+#endif /* !defined(NL_ASSERT_FILE) */
+
+/**
+ *  @defgroup static-modality Static
+ *  @defgroup assert-style Assert
+ *  @defgroup abort-style Abort
+ *  @defgroup check-style Check
+ *  @defgroup verify-style Verify
+ *  @defgroup precondition-style Precondition
+ *  @defgroup expect-style Expect
+ *  @defgroup desire-style Desire
+ *  @defgroup require-style Require
+ *
+ */
+
+/**
+ *  @ingroup static-modality
+ *
+ *  @{
+ *
+ */
+
+/**
+ *  @def nlSTATIC_ASSERT(aCondition)
+ *
+ *  @brief
+ *    This checks, at compile-time, for the specified condition, which
+ *    is expected to commonly be true, and terminates compilation if
+ *    the condition is false.
+ *
+ *  @note Unlike the runtime assert macros, this compile-time macro is active
+ *        regardless of the state of #NL_ASSERT_PRODUCTION.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *
+ *  @sa #nlSTATIC_ASSERT_PRINT
+ *
+ */
+#define nlSTATIC_ASSERT(aCondition)                                             _nlSTATIC_ASSERT(aCondition, #aCondition)
+
+/**
+ *  @def nlSTATIC_ASSERT_PRINT(aCondition, aMessage)
+ *
+ *  @brief
+ *    This checks, at compile-time, for the specified condition, which
+ *    is expected to commonly be true, and terminates compilation if
+ *    the condition is false.
+ *
+ *  @note Unlike the runtime assert macros, this compile-time macro is active
+ *        regardless of the state of #NL_ASSERT_PRODUCTION.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion
+ *                          failure. Note, this message is not
+ *                          actually emitted in any meaningful way for
+ *                          non-C11 or -C++11 code. It serves to
+ *                          simply comment or annotate the assertion
+ *                          and to provide interface parallelism with
+ *                          the run-time assertion interfaces.
+ *
+ *  @sa #nlSTATIC_ASSERT
+ *
+ */
+#define nlSTATIC_ASSERT_PRINT(aCondition, aMessage)                             _nlSTATIC_ASSERT(aCondition, aMessage)
+
+/**
+ *  @}
+ *
+ */
+
+/**
+ *  @ingroup expect-style
+ *
+ *  @{
+ *
+ */
+
+/**
+ *  @def NL_ASSERT_EXPECT_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for expect-style
+ *    exception family assertions.
+ *
+ *  This may be used to override #NL_ASSERT_EXPECT_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_EXPECT_FLAGS NL_ASSERT_EXPECT_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ */
+#define NL_ASSERT_EXPECT_FLAGS_DEFAULT                                          (NL_ASSERT_FLAG_NONE)
+
+/**
+ *  @def NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags that govern the behavior for
+ *    expect-style exception family assertions when the assertion
+ *    expression evaluates to false.
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_EXPECT_FLAGS                                                  NL_ASSERT_EXPECT_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_EXPECT_FLAGS)
+#define NL_ASSERT_EXPECT_FLAGS                                                  (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @def nlEXPECT(aCondition, aLabel)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and branches to @p aLabel if the condition is
+ *    false.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #nlDESIRE
+ *  @sa #nlREQUIRE
+ *
+ */
+#define nlEXPECT(aCondition, aLabel)                                            __nlEXPECT(NL_ASSERT_EXPECT_FLAGS, aCondition, aLabel)
+
+/**
+ *  @def nlEXPECT_PRINT(aCondition, aLabel, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and both prints @p aMessage and then branches
+ *    to @p aLabel if the condition is false.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #nlDESIRE_PRINT
+ *  @sa #nlREQUIRE_PRINT
+ *
+ */
+#define nlEXPECT_PRINT(aCondition, aLabel, aMessage)                            __nlEXPECT_PRINT(NL_ASSERT_EXPECT_FLAGS, aCondition, aLabel, aMessage)
+
+/**
+ *  @def nlEXPECT_ACTION(aCondition, aLabel, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and both executes @p anAction and branches to
+ *    @p aLabel if the condition is false.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #nlDESIRE_ACTION
+ *  @sa #nlREQUIRE_ACTION
+ *
+ */
+#define nlEXPECT_ACTION(aCondition, aLabel, anAction)                           __nlEXPECT_ACTION(NL_ASSERT_EXPECT_FLAGS, aCondition, aLabel, anAction)
+
+/**
+ *  @def nlEXPECT_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, prints @p aMessage, executes @p anAction, and
+ *    branches to @p aLabel if the condition is false.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #nlDESIRE_ACTION_PRINT
+ *  @sa #nlREQUIRE_ACTION_PRINT
+ *
+ */
+#define nlEXPECT_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)           __nlEXPECT_ACTION_PRINT(NL_ASSERT_EXPECT_FLAGS, aCondition, aLabel, anAction, aMessage)
+
+/**
+ *  @def nlEXPECT_SUCCESS(aStatus, aLabel)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and branches to @p
+ *    aLabel if the status is unsuccessful.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aStatus does not evaluate to zero
+ *                          (0).
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #nlDESIRE_SUCCESS
+ *  @sa #nlREQUIRE_SUCCESS
+ *
+ */
+#define nlEXPECT_SUCCESS(aStatus, aLabel)                                       __nlEXPECT_SUCCESS(NL_ASSERT_EXPECT_FLAGS, aStatus, aLabel)
+
+/**
+ *  @def nlEXPECT_SUCCESS_PRINT(aStatus, aLabel, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and both prints @p
+ *    aMessage and then branches to @p aLabel if the status is
+ *    unsuccessful.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aStatus does not evaluate to zero
+ *                          (0).
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #nlDESIRE_SUCCESS_PRINT
+ *  @sa #nlREQUIRE_SUCCESS_PRINT
+ *
+ */
+#define nlEXPECT_SUCCESS_PRINT(aStatus, aLabel, aMessage)                       __nlEXPECT_SUCCESS_PRINT(NL_ASSERT_EXPECT_FLAGS, aStatus, aLabel, aMessage)
+
+/**
+ *  @def nlEXPECT_SUCCESS_ACTION(aStatus, aLabel, anAction)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and both executes @p
+ *    anAction and branches to @p aLabel if the status is unsuccessful.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aStatus does not evaluate to zero
+ *                          (0).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #nlDESIRE_SUCCESS_ACTION
+ *  @sa #nlREQUIRE_SUCCESS_ACTION
+ *
+ */
+#define nlEXPECT_SUCCESS_ACTION(aStatus, aLabel, anAction)                      __nlEXPECT_SUCCESS_ACTION(NL_ASSERT_EXPECT_FLAGS, aStatus, aLabel, anAction)
+
+/**
+ *  @def nlEXPECT_SUCCESS_ACTION_PRINT(aStatus, aLabel, anAction, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), prints @p aMessage,
+ *    executes @p anAction, and branches to @p aLabel if the status is
+ *    unsuccessful.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aStatus does not evaluate to zero
+ *                          (0).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #nlDESIRE_SUCCESS_ACTION_PRINT
+ *  @sa #nlREQUIRE_SUCCESS_ACTION_PRINT
+ *
+ */
+#define nlEXPECT_SUCCESS_ACTION_PRINT(aStatus, aLabel, anAction, aMessage)      __nlEXPECT_SUCCESS_ACTION_PRINT(NL_ASSERT_EXPECT_FLAGS, aStatus, aLabel, anAction, aMessage)
+
+/**
+ *  @def nlNEXPECT(aCondition, aLabel)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and branches to @p aLabel if the condition is
+ *    true.
+ *
+ *  @note This is the logical inverse of #nlEXPECT.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #nlEXPECT
+ *  @sa #nlNDESIRE
+ *  @sa #nlNREQUIRE
+ *
+ */
+#define nlNEXPECT(aCondition, aLabel)                                           __nlNEXPECT(NL_ASSERT_EXPECT_FLAGS, aCondition, aLabel)
+
+/**
+ *  @def nlNEXPECT_PRINT(aCondition, aLabel, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and both prints @p aMessage and then branches
+ *    to @p aLabel if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlEXPECT_PRINT.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #nlEXPECT_PRINT
+ *  @sa #nlNDESIRE_PRINT
+ *  @sa #nlNREQUIRE_PRINT
+ *
+ */
+#define nlNEXPECT_PRINT(aCondition, aLabel, aMessage)                           __nlNEXPECT_PRINT(NL_ASSERT_EXPECT_FLAGS, aCondition, aLabel, aMessage)
+
+/**
+ *  @def nlNEXPECT_ACTION(aCondition, aLabel, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and both executes @p anAction and branches to
+ *    @p aLabel if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlEXPECT_ACTION.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #nlEXPECT_ACTION
+ *  @sa #nlNDESIRE_ACTION
+ *  @sa #nlNREQUIRE_ACTION
+ *
+ */
+#define nlNEXPECT_ACTION(aCondition, aLabel, anAction)                          __nlNEXPECT_ACTION(NL_ASSERT_EXPECT_FLAGS, aCondition, aLabel, anAction)
+
+/**
+ *  @def nlNEXPECT_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, prints @p aMessage, executes @p anAction, and
+ *    branches to @p aLabel if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlEXPECT_ACTION_PRINT.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #nlEXPECT_ACTION_PRINT
+ *  @sa #nlNDESIRE_ACTION_PRINT
+ *  @sa #nlNREQUIRE_ACTION_PRINT
+ *
+ */
+#define nlNEXPECT_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)          __nlNEXPECT_ACTION_PRINT(NL_ASSERT_EXPECT_FLAGS, aCondition, aLabel, anAction, aMessage)
+
+/**
+ *  @}
+ *
+ */
+
+#if !NL_ASSERT_PRODUCTION
+#include "nlassert-nonproduction.h"
+#else
+#include "nlassert-production.h"
+#endif /* !NL_ASSERT_PRODUCTION */
+
+#endif /* NLCORE_NLASSERT_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/nlbyteorder-big.h b/cores/nRF5/nordic/config/nrf52840/config/nlbyteorder-big.h
new file mode 100644
index 000000000..db13462d8
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/nlbyteorder-big.h
@@ -0,0 +1,247 @@
+/**
+ *    Copyright (c) 2020 nlio Authors. All Rights Reserved.
+ *    Copyright 2012-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines defines functions for performing by value
+ *      byte reordering for 16-, 32-, and 64-bit quantities both
+ *      to-and-from the target system (i.e. host) byte ordering
+ *      to-and-from both little and big endian byte ordering,
+ *      specifically for big endian target systems.
+ */
+
+#ifndef NLBYTEORDER_BIG_H
+#define NLBYTEORDER_BIG_H
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 16-bit value, presumed to
+ * be in little endian byte ordering to the target system (i.e. host)
+ * byte ordering.
+ *
+ * Consequently, on little endian target systems, this is a no-op and
+ * on big endian target systems, this performs a reordering.
+ *
+ * @param[in]  inValue  The 16-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint16_t nlByteOrderSwap16LittleToHost(uint16_t inValue)
+{
+    return nlByteOrderValueSwap16(inValue);
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 32-bit value, presumed to
+ * be in little endian byte ordering to the target system (i.e. host)
+ * byte ordering.
+ *
+ * Consequently, on little endian target systems, this is a no-op and
+ * on big endian target systems, this performs a reordering.
+ *
+ * @param[in]  inValue  The 32-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint32_t nlByteOrderSwap32LittleToHost(uint32_t inValue)
+{
+    return nlByteOrderValueSwap32(inValue);
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 64-bit value, presumed to
+ * be in little endian byte ordering to the target system (i.e. host)
+ * byte ordering.
+ *
+ * Consequently, on little endian target systems, this is a no-op and
+ * on big endian target systems, this performs a reordering.
+ *
+ * @param[in]  inValue  The 64-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint64_t nlByteOrderSwap64LittleToHost(uint64_t inValue)
+{
+    return nlByteOrderValueSwap64(inValue);
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 16-bit value, presumed to
+ * be in target system (i.e. host) byte ordering to little endian byte
+ * ordering.
+ *
+ * Consequently, on little endian target systems, this is a no-op and
+ * on big endian target systems, this performs a reordering.
+ *
+ * @param[in]  inValue  The 16-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint16_t nlByteOrderSwap16HostToLittle(uint16_t inValue)
+{
+    return nlByteOrderValueSwap16(inValue);
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 32-bit value, presumed to
+ * be in target system (i.e. host) byte ordering to little endian byte
+ * ordering.
+ *
+ * Consequently, on little endian target systems, this is a no-op and
+ * on big endian target systems, this performs a reordering.
+ *
+ * @param[in]  inValue  The 32-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint32_t nlByteOrderSwap32HostToLittle(uint32_t inValue)
+{
+    return nlByteOrderValueSwap32(inValue);
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 64-bit value, presumed to
+ * be in target system (i.e. host) byte ordering to little endian byte
+ * ordering.
+ *
+ * Consequently, on little endian target systems, this is a no-op and
+ * on big endian target systems, this performs a reordering.
+ *
+ * @param[in]  inValue  The 64-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint64_t nlByteOrderSwap64HostToLittle(uint64_t inValue)
+{
+    return nlByteOrderValueSwap64(inValue);
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 16-bit value, presumed to
+ * be in big endian byte ordering to the target system (i.e. host)
+ * byte ordering.
+ *
+ * Consequently, on little endian target systems, this performs a
+ * reordering and on big endian target systems, this is a no-op.
+ *
+ * @param[in]  inValue  The 16-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint16_t nlByteOrderSwap16BigToHost(uint16_t inValue)
+{
+    return inValue;
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 32-bit value, presumed to
+ * be in big endian byte ordering to the target system (i.e. host)
+ * byte ordering.
+ *
+ * Consequently, on little endian target systems, this performs a
+ * reordering and on big endian target systems, this is a no-op.
+ *
+ * @param[in]  inValue  The 32-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint32_t nlByteOrderSwap32BigToHost(uint32_t inValue)
+{
+    return inValue;
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 64-bit value, presumed to
+ * be in big endian byte ordering to the target system (i.e. host)
+ * byte ordering.
+ *
+ * Consequently, on little endian target systems, this performs a
+ * reordering and on big endian target systems, this is a no-op.
+ *
+ * @param[in]  inValue  The 64-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint64_t nlByteOrderSwap64BigToHost(uint64_t inValue)
+{
+    return inValue;
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 16-bit value, presumed to
+ * be in target system (i.e. host) byte ordering to big endian byte
+ * ordering.
+ *
+ * Consequently, on little endian target systems, this performs a
+ * reordering and on big endian target systems, this is a no-op.
+ *
+ * @param[in]  inValue  The 16-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint16_t nlByteOrderSwap16HostToBig(uint16_t inValue)
+{
+    return inValue;
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 32-bit value, presumed to
+ * be in target system (i.e. host) byte ordering to big endian byte
+ * ordering.
+ *
+ * Consequently, on little endian target systems, this performs a
+ * reordering and on big endian target systems, this is a no-op.
+ *
+ * @param[in]  inValue  The 32-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint32_t nlByteOrderSwap32HostToBig(uint32_t inValue)
+{
+    return inValue;
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 64-bit value, presumed to
+ * be in target system (i.e. host) byte ordering to big endian byte
+ * ordering.
+ *
+ * Consequently, on little endian target systems, this performs a
+ * reordering and on big endian target systems, this is a no-op.
+ *
+ * @param[in]  inValue  The 64-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint64_t nlByteOrderSwap64HostToBig(uint64_t inValue)
+{
+    return inValue;
+}
+
+#endif /* NLBYTEORDER_BIG_H */
+
diff --git a/cores/nRF5/nordic/config/nrf52840/config/nlbyteorder-little.h b/cores/nRF5/nordic/config/nrf52840/config/nlbyteorder-little.h
new file mode 100644
index 000000000..72236ba5e
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/nlbyteorder-little.h
@@ -0,0 +1,246 @@
+/**
+ *    Copyright 2012-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines defines functions for performing by value
+ *      byte reordering for 16-, 32-, and 64-bit quantities both
+ *      to-and-from the target system (i.e. host) byte ordering
+ *      to-and-from both little and big endian byte ordering,
+ *      specifically for little endian target systems.
+ */
+
+#ifndef NLBYTEORDER_LITTLE_H
+#define NLBYTEORDER_LITTLE_H
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 16-bit value, presumed to
+ * be in little endian byte ordering to the target system (i.e. host)
+ * byte ordering.
+ *
+ * Consequently, on little endian target systems, this is a no-op and
+ * on big endian target systems, this performs a reordering.
+ *
+ * @param[in]  inValue  The 16-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint16_t nlByteOrderSwap16LittleToHost(uint16_t inValue)
+{
+    return inValue;
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 32-bit value, presumed to
+ * be in little endian byte ordering to the target system (i.e. host)
+ * byte ordering.
+ *
+ * Consequently, on little endian target systems, this is a no-op and
+ * on big endian target systems, this performs a reordering.
+ *
+ * @param[in]  inValue  The 32-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint32_t nlByteOrderSwap32LittleToHost(uint32_t inValue)
+{
+    return inValue;
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 64-bit value, presumed to
+ * be in little endian byte ordering to the target system (i.e. host)
+ * byte ordering.
+ *
+ * Consequently, on little endian target systems, this is a no-op and
+ * on big endian target systems, this performs a reordering.
+ *
+ * @param[in]  inValue  The 64-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint64_t nlByteOrderSwap64LittleToHost(uint64_t inValue)
+{
+    return inValue;
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 16-bit value, presumed to
+ * be in target system (i.e. host) byte ordering to little endian byte
+ * ordering.
+ *
+ * Consequently, on little endian target systems, this is a no-op and
+ * on big endian target systems, this performs a reordering.
+ *
+ * @param[in]  inValue  The 16-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint16_t nlByteOrderSwap16HostToLittle(uint16_t inValue)
+{
+    return inValue;
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 32-bit value, presumed to
+ * be in target system (i.e. host) byte ordering to little endian byte
+ * ordering.
+ *
+ * Consequently, on little endian target systems, this is a no-op and
+ * on big endian target systems, this performs a reordering.
+ *
+ * @param[in]  inValue  The 32-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint32_t nlByteOrderSwap32HostToLittle(uint32_t inValue)
+{
+    return inValue;
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 64-bit value, presumed to
+ * be in target system (i.e. host) byte ordering to little endian byte
+ * ordering.
+ *
+ * Consequently, on little endian target systems, this is a no-op and
+ * on big endian target systems, this performs a reordering.
+ *
+ * @param[in]  inValue  The 64-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint64_t nlByteOrderSwap64HostToLittle(uint64_t inValue)
+{
+    return inValue;
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 16-bit value, presumed to
+ * be in big endian byte ordering to the target system (i.e. host)
+ * byte ordering.
+ *
+ * Consequently, on little endian target systems, this performs a
+ * reordering and on big endian target systems, this is a no-op.
+ *
+ * @param[in]  inValue  The 16-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint16_t nlByteOrderSwap16BigToHost(uint16_t inValue)
+{
+    return nlByteOrderValueSwap16(inValue);
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 32-bit value, presumed to
+ * be in big endian byte ordering to the target system (i.e. host)
+ * byte ordering.
+ *
+ * Consequently, on little endian target systems, this performs a
+ * reordering and on big endian target systems, this is a no-op.
+ *
+ * @param[in]  inValue  The 32-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint32_t nlByteOrderSwap32BigToHost(uint32_t inValue)
+{
+    return nlByteOrderValueSwap32(inValue);
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 64-bit value, presumed to
+ * be in big endian byte ordering to the target system (i.e. host)
+ * byte ordering.
+ *
+ * Consequently, on little endian target systems, this performs a
+ * reordering and on big endian target systems, this is a no-op.
+ *
+ * @param[in]  inValue  The 64-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint64_t nlByteOrderSwap64BigToHost(uint64_t inValue)
+{
+    return nlByteOrderValueSwap64(inValue);
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 16-bit value, presumed to
+ * be in target system (i.e. host) byte ordering to big endian byte
+ * ordering.
+ *
+ * Consequently, on little endian target systems, this performs a
+ * reordering and on big endian target systems, this is a no-op.
+ *
+ * @param[in]  inValue  The 16-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint16_t nlByteOrderSwap16HostToBig(uint16_t inValue)
+{
+    return nlByteOrderValueSwap16(inValue);
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 32-bit value, presumed to
+ * be in target system (i.e. host) byte ordering to big endian byte
+ * ordering.
+ *
+ * Consequently, on little endian target systems, this performs a
+ * reordering and on big endian target systems, this is a no-op.
+ *
+ * @param[in]  inValue  The 32-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint32_t nlByteOrderSwap32HostToBig(uint32_t inValue)
+{
+    return nlByteOrderValueSwap32(inValue);
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 64-bit value, presumed to
+ * be in target system (i.e. host) byte ordering to big endian byte
+ * ordering.
+ *
+ * Consequently, on little endian target systems, this performs a
+ * reordering and on big endian target systems, this is a no-op.
+ *
+ * @param[in]  inValue  The 64-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint64_t nlByteOrderSwap64HostToBig(uint64_t inValue)
+{
+    return nlByteOrderValueSwap64(inValue);
+}
+
+#endif /* NLBYTEORDER_LITTLE_H */
+
diff --git a/cores/nRF5/nordic/config/nrf52840/config/nlbyteorder.h b/cores/nRF5/nordic/config/nrf52840/config/nlbyteorder.h
new file mode 100644
index 000000000..f4ba9bf9a
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/nlbyteorder.h
@@ -0,0 +1,329 @@
+/**
+ *    Copyright (c) 2020 nlio Authors. All Rights Reserved.
+ *    Copyright 2012-2017 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines macros for performing in place byte-
+ *      swapping of compile-time constants via the C preprocessor as
+ *      well as functions for performing byte-swapping by value and in
+ *      place by pointer for 16-, 32-, and 64-bit types.
+ */
+
+#ifndef NLBYTEORDER_H
+#define NLBYTEORDER_H
+
+#include <nlio-private.h>
+
+#include <stdint.h>
+
+/*
+ * If we are compiling under clang, GCC, or any such compatible
+ * compiler, in which -fno-builtins or -ffreestanding might be
+ * asserted, thereby eliminating built-in function optimization, we
+ * STILL want to leverage built-in bswap{16,32,64}, if available. We
+ * want this because it allows the compiler to use
+ * architecture-specific machine instructions or inline code
+ * generation to optimize an otherwise-generic and non-optimized code
+ * for byte reordering, which is exactly the kind of efficiency that
+ * would be expected of nlByteOrder.
+ */
+
+#if __nlIOHasBuiltin(__builtin_bswap16)
+#define __nlBYTEORDER_BSWAP16 __builtin_bswap16
+#else
+#define __nlBYTEORDER_BSWAP16 nlByteOrderConstantSwap16
+#endif
+
+#if __nlIOHasBuiltin(__builtin_bswap32)
+#define __nlBYTEORDER_BSWAP32 __builtin_bswap32
+#else
+#define __nlBYTEORDER_BSWAP32 nlByteOrderConstantSwap32
+#endif
+
+#if __nlIOHasBuiltin(__builtin_bswap64)
+#define __nlBYTEORDER_BSWAP64 __builtin_bswap64
+#else
+#define __nlBYTEORDER_BSWAP64 nlByteOrderConstantSwap64
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ *  @def nlByteOrderConstantSwap16
+ *
+ *  @brief
+ *     Performs a preprocessor-compatible in place byte swap of the
+ *     provided 16-bit value.
+ *
+ */
+#define nlByteOrderConstantSwap16(c)                                 \
+    ((uint16_t)                                                      \
+        ((((uint16_t)(c) & (uint16_t)0x00ffU) << 8) |                \
+         (((uint16_t)(c) & (uint16_t)0xff00U) >> 8)))
+
+/**
+ *  @def nlByteOrderConstantSwap32
+ *
+ *  @brief
+ *     Performs a preprocessor-compatible in place byte swap of the
+ *     provided 32-bit value.
+ *
+ */
+#define nlByteOrderConstantSwap32(c)                                 \
+    ((uint32_t)                                                      \
+        ((((uint32_t)(c) & (uint32_t)0x000000ffUL) << 24) |          \
+         (((uint32_t)(c) & (uint32_t)0x0000ff00UL) <<  8) |          \
+         (((uint32_t)(c) & (uint32_t)0x00ff0000UL) >>  8) |          \
+         (((uint32_t)(c) & (uint32_t)0xff000000UL) >> 24)))
+
+/**
+ *  @def nlByteOrderConstantSwap64
+ *
+ *  @brief
+ *     Performs a preprocessor-compatible in place byte swap of the
+ *     provided 64-bit value.
+ *
+ */
+#define nlByteOrderConstantSwap64(c)                                 \
+    ((uint64_t)                                                      \
+        ((((uint64_t)(c) & (uint64_t)0x00000000000000ffULL) << 56) | \
+         (((uint64_t)(c) & (uint64_t)0x000000000000ff00ULL) << 40) | \
+         (((uint64_t)(c) & (uint64_t)0x0000000000ff0000ULL) << 24) | \
+         (((uint64_t)(c) & (uint64_t)0x00000000ff000000ULL) <<  8) | \
+         (((uint64_t)(c) & (uint64_t)0x000000ff00000000ULL) >>  8) | \
+         (((uint64_t)(c) & (uint64_t)0x0000ff0000000000ULL) >> 24) | \
+         (((uint64_t)(c) & (uint64_t)0x00ff000000000000ULL) >> 40) | \
+         (((uint64_t)(c) & (uint64_t)0xff00000000000000ULL) >> 56)))
+
+/**
+ *  @def NLBYTEORDER_LITTLE_ENDIAN
+ *
+ *  @brief
+ *     Constant preprocessor definition used to test #NLBYTEORDER
+ *     against to determine whether the target system uses little
+ *     endian byte ordering.
+ *
+ *  @code
+ *  #if NLBYTEORDER == NLBYTEORDER_LITTLE_ENDIAN
+ *  
+ *      Do something that is little endian byte ordering-specific.
+ *
+ *  #endif
+ *  @endcode
+ *
+ */
+#define NLBYTEORDER_LITTLE_ENDIAN       0x1234
+
+/**
+ *  @def NLBYTEORDER_BIG_ENDIAN
+ *
+ *  @brief
+ *     Constant preprocessor definition used to test #NLBYTEORDER
+ *     against to determine whether the target system uses big
+ *     endian byte ordering.
+ *
+ *  @code
+ *  #if NLBYTEORDER == NLBYTEORDER_BIG_ENDIAN
+ *  
+ *      Do something that is little endian byte ordering-specific.
+ *
+ *  #endif
+ *  @endcode
+ *
+ */
+#define NLBYTEORDER_BIG_ENDIAN          0x4321
+
+/**
+ *  @def NLBYTEORDER_UNKNOWN_ENDIAN
+ *
+ *  @brief
+ *     Constant preprocessor definition used to test #NLBYTEORDER
+ *     against to determine whether the target system uses unknown
+ *     byte ordering.
+ *
+ *  @code
+ *  #elif NLBYTEORDER == NLBYTEORDER_UNKNOWN_ENDIAN
+ *  #error "Unknown byte ordering!"
+ *  #endif
+ *  @endcode
+ *
+ */
+#define NLBYTEORDER_UNKNOWN_ENDIAN      0xFFFF
+
+/**
+ *  @def NLBYTEORDER
+ *
+ *  @brief
+ *     Constant preprocessor definition containing the target system
+ *     byte ordering. May be one of:
+ *
+ *       - NLBYTEORDER_BIG_ENDIAN
+ *       - NLBYTEORDER_LITTLE_ENDIAN
+ *       - NLBYTEORDER_UNKNOWN_ENDIAN
+ *
+ */
+#if defined(__BYTE_ORDER__)
+# if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+#  define NLBYTEORDER NLBYTEORDER_LITTLE_ENDIAN
+# elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+#  define NLBYTEORDER NLBYTEORDER_BIG_ENDIAN
+# endif /* __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ */
+#elif defined(__LITTLE_ENDIAN__) && (__LITTLE_ENDIAN__ == 1)
+#define NLBYTEORDER NLBYTEORDER_LITTLE_ENDIAN
+#elif defined(__BIG_ENDIAN__) && (__BIG_ENDIAN__ == 1)
+#define NLBYTEORDER NLBYTEORDER_BIG_ENDIAN
+#else
+#error "Endianness undefined!"
+#define NLBYTEORDER NLBYTEORDER_UNKNOWN_ENDIAN
+#endif /* defined(__BYTE_ORDER__) */
+
+enum {
+    nlByteOrderUnknown	    = NLBYTEORDER_UNKNOWN_ENDIAN,
+    nlByteOrderLittleEndian = NLBYTEORDER_LITTLE_ENDIAN,
+    nlByteOrderBigEndian    = NLBYTEORDER_BIG_ENDIAN
+};
+
+/**
+ * This represents a type for a byte ordering.
+ */
+typedef uint16_t nlByteOrder;
+
+/**
+ * This returns the byte order of the current system.
+ *
+ * @return The byte order of the current system.
+ */
+static inline nlByteOrder nlByteOrderGetCurrent(void)
+{
+#if (NLBYTEORDER == NLBYTEORDER_LITTLE_ENDIAN)
+    return nlByteOrderLittleEndian;
+#elif (NLBYTEORDER == NLBYTEORDER_BIG_ENDIAN)
+    return nlByteOrderBigEndian;
+#else
+    return nlByteOrderUnknown;
+#endif
+}
+
+/**
+ * This unconditionally performs a byte order swap by value of the
+ * specified 16-bit value.
+ *
+ * @param[in]  inValue  The 16-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint16_t nlByteOrderValueSwap16(uint16_t inValue)
+{
+    return __nlBYTEORDER_BSWAP16(inValue);
+}
+
+/**
+ * This unconditionally performs a byte order swap by value of the
+ * specified 32-bit value.
+ *
+ * @param[in]  inValue  The 32-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint32_t nlByteOrderValueSwap32(uint32_t inValue)
+{
+    return __nlBYTEORDER_BSWAP32(inValue);
+}
+
+/**
+ * This unconditionally performs a byte order swap by value of the
+ * specified 64-bit value.
+ *
+ * @param[in]  inValue  The 64-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint64_t nlByteOrderValueSwap64(uint64_t inValue)
+{
+    return __nlBYTEORDER_BSWAP64(inValue);
+}
+
+/**
+ * This unconditionally performs a byte order swap by pointer in place
+ * of the specified 16-bit value.
+ *
+ * @warning  The input value is assumed to be on a natural alignment
+ * boundary for the target system. It is the responsibility of the
+ * caller to perform any necessary alignment to avoid system faults
+ * for systems that do not support unaligned accesses.
+ *
+ * @param[inout]  inValue  A pointer to the 16-bit value to be byte
+ *                         order swapped.
+ */
+static inline void nlByteOrderPointerSwap16(uint16_t *inValue)
+{
+    *inValue = nlByteOrderValueSwap16(*inValue);
+}
+
+/**
+ * This unconditionally performs a byte order swap by pointer in place
+ * of the specified 32-bit value.
+ *
+ * @warning  The input value is assumed to be on a natural alignment
+ * boundary for the target system. It is the responsibility of the
+ * caller to perform any necessary alignment to avoid system faults
+ * for systems that do not support unaligned accesses.
+ *
+ * @param[inout]  inValue  A pointer to the 32-bit value to be byte
+ *                         order swapped.
+ */
+static inline void nlByteOrderPointerSwap32(uint32_t *inValue)
+{
+    *inValue = nlByteOrderValueSwap32(*inValue);
+}
+
+/**
+ * This unconditionally performs a byte order swap by pointer in place
+ * of the specified 64-bit value.
+ *
+ * @warning  The input value is assumed to be on a natural alignment
+ * boundary for the target system. It is the responsibility of the
+ * caller to perform any necessary alignment to avoid system faults
+ * for systems that do not support unaligned accesses.
+ *
+ * @param[inout]  inValue  A pointer to the 64-bit value to be byte
+ *                         order swapped.
+ */
+static inline void nlByteOrderPointerSwap64(uint64_t *inValue)
+{
+    *inValue = nlByteOrderValueSwap64(*inValue);
+}
+
+#if (NLBYTEORDER == NLBYTEORDER_LITTLE_ENDIAN)
+#include <nlbyteorder-little.h>
+#elif (NLBYTEORDER == NLBYTEORDER_BIG_ENDIAN)
+#include <nlbyteorder-big.h>
+#endif /* (NLBYTEORDER == NLBYTEORDER_LITTLE_ENDIAN) */
+
+#ifdef __cplusplus
+}
+#endif
+
+#undef __nlBYTEORDER_BSWAP16
+#undef __nlBYTEORDER_BSWAP32
+#undef __nlBYTEORDER_BSWAP64
+
+#endif /* NLBYTEORDER_H */
+
+
diff --git a/cores/nRF5/nordic/config/nrf52840/config/nlbyteorder.hpp b/cores/nRF5/nordic/config/nrf52840/config/nlbyteorder.hpp
new file mode 100644
index 000000000..7ce41ff53
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/nlbyteorder.hpp
@@ -0,0 +1,378 @@
+/**
+ *    Copyright 2012-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines C++ functions for performing byte-swapping
+ *      by value and in place by pointer for 16-, 32-, and 64-bit
+ *      types.
+ *
+ */
+
+#ifndef NLBYTEORDER_HPP
+#define NLBYTEORDER_HPP
+
+#include <nlbyteorder.h>
+
+namespace nl
+{
+
+    namespace ByteOrder
+    {
+        enum {
+            Unknown	 = nlByteOrderUnknown,
+            LittleEndian = nlByteOrderLittleEndian,
+            BigEndian    = nlByteOrderBigEndian    
+        };
+
+        /**
+         * This represents a type for a byte ordering.
+         */
+        typedef nlByteOrder ByteOrder;
+
+        /**
+         * This returns the byte order of the current system.
+         *
+         * @return The byte order of the current system.
+         */
+        inline ByteOrder GetCurrent(void)
+        {
+            return nlByteOrderGetCurrent();
+        }
+
+        /**
+         * This unconditionally performs a byte order swap by value of the
+         * specified 16-bit value.
+         *
+         * @param[in]  inValue  The 16-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint16_t Swap16(uint16_t inValue)
+        {
+            return nlByteOrderValueSwap16(inValue);
+        }
+
+        /**
+         * This unconditionally performs a byte order swap by value of the
+         * specified 32-bit value.
+         *
+         * @param[in]  inValue  The 32-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint32_t Swap32(uint32_t inValue)
+        {
+            return nlByteOrderValueSwap32(inValue);
+        }
+
+        /**
+         * This unconditionally performs a byte order swap by value of the
+         * specified 64-bit value.
+         *
+         * @param[in]  inValue  The 64-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint64_t Swap64(uint64_t inValue)
+        {
+            return nlByteOrderValueSwap64(inValue);
+        }
+
+        /**
+         * This unconditionally performs a byte order swap by pointer in place
+         * of the specified 16-bit value.
+         *
+         * @warning  The input value is assumed to be on a natural alignment
+         * boundary for the target system. It is the responsibility of the
+         * caller to perform any necessary alignment to avoid system faults
+         * for systems that do not support unaligned accesses.
+         *
+         * @param[inout]  inValue  A pointer to the 16-bit value to be byte
+         *                         order swapped.
+         */
+        inline void Swap16(uint16_t *inValue)
+        {
+            nlByteOrderPointerSwap16(inValue);
+        }
+
+        /**
+         * This unconditionally performs a byte order swap by pointer in place
+         * of the specified 32-bit value.
+         *
+         * @warning  The input value is assumed to be on a natural alignment
+         * boundary for the target system. It is the responsibility of the
+         * caller to perform any necessary alignment to avoid system faults
+         * for systems that do not support unaligned accesses.
+         *
+         * @param[inout]  inValue  A pointer to the 32-bit value to be byte
+         *                         order swapped.
+         */
+        inline void Swap32(uint32_t *inValue)
+        {
+            nlByteOrderPointerSwap32(inValue);
+        }
+
+        /**
+         * This unconditionally performs a byte order swap by pointer in place
+         * of the specified 64-bit value.
+         *
+         * @warning  The input value is assumed to be on a natural alignment
+         * boundary for the target system. It is the responsibility of the
+         * caller to perform any necessary alignment to avoid system faults
+         * for systems that do not support unaligned accesses.
+         *
+         * @param[inout]  inValue  A pointer to the 64-bit value to be byte
+         *                         order swapped.
+         */
+        inline void Swap64(uint64_t *inValue)
+        {
+            nlByteOrderPointerSwap64(inValue);
+        }
+
+        /**
+         * This conditionally performs, as necessary for the target system, a
+         * byte order swap by value of the specified 16-bit value, presumed to
+         * be in little endian byte ordering to the target system (i.e. host)
+         * byte ordering.
+         *
+         * Consequently, on little endian target systems, this is a no-op and
+         * on big endian target systems, this performs a reordering.
+         *
+         * @param[in]  inValue  The 16-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint16_t Swap16LittleToHost(uint16_t inValue)
+        {
+            return nlByteOrderSwap16LittleToHost(inValue);
+        }
+
+        /**
+         * This conditionally performs, as necessary for the target system, a
+         * byte order swap by value of the specified 32-bit value, presumed to
+         * be in little endian byte ordering to the target system (i.e. host)
+         * byte ordering.
+         *
+         * Consequently, on little endian target systems, this is a no-op and
+         * on big endian target systems, this performs a reordering.
+         *
+         * @param[in]  inValue  The 32-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint32_t Swap32LittleToHost(uint32_t inValue)
+        {
+            return nlByteOrderSwap32LittleToHost(inValue);
+        }
+
+        /**
+         * This conditionally performs, as necessary for the target system, a
+         * byte order swap by value of the specified 64-bit value, presumed to
+         * be in little endian byte ordering to the target system (i.e. host)
+         * byte ordering.
+         *
+         * Consequently, on little endian target systems, this is a no-op and
+         * on big endian target systems, this performs a reordering.
+         *
+         * @param[in]  inValue  The 64-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint64_t Swap64LittleToHost(uint64_t inValue)
+        {
+            return nlByteOrderSwap64LittleToHost(inValue);
+        }
+
+        /**
+         * This conditionally performs, as necessary for the target system, a
+         * byte order swap by value of the specified 16-bit value, presumed to
+         * be in target system (i.e. host) byte ordering to little endian byte
+         * ordering.
+         *
+         * Consequently, on little endian target systems, this is a no-op and
+         * on big endian target systems, this performs a reordering.
+         *
+         * @param[in]  inValue  The 16-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint16_t Swap16HostToLittle(uint16_t inValue)
+        {
+            return nlByteOrderSwap16HostToLittle(inValue);
+        }
+
+        /**
+         * This conditionally performs, as necessary for the target system, a
+         * byte order swap by value of the specified 32-bit value, presumed to
+         * be in target system (i.e. host) byte ordering to little endian byte
+         * ordering.
+         *
+         * Consequently, on little endian target systems, this is a no-op and
+         * on big endian target systems, this performs a reordering.
+         *
+         * @param[in]  inValue  The 32-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint32_t Swap32HostToLittle(uint32_t inValue)
+        {
+            return nlByteOrderSwap32HostToLittle(inValue);
+        }
+
+        /**
+         * This conditionally performs, as necessary for the target system, a
+         * byte order swap by value of the specified 64-bit value, presumed to
+         * be in target system (i.e. host) byte ordering to little endian byte
+         * ordering.
+         *
+         * Consequently, on little endian target systems, this is a no-op and
+         * on big endian target systems, this performs a reordering.
+         *
+         * @param[in]  inValue  The 64-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint64_t Swap64HostToLittle(uint64_t inValue)
+        {
+            return nlByteOrderSwap64HostToLittle(inValue);
+        }
+
+        /**
+         * This conditionally performs, as necessary for the target system, a
+         * byte order swap by value of the specified 16-bit value, presumed to
+         * be in big endian byte ordering to the target system (i.e. host)
+         * byte ordering.
+         *
+         * Consequently, on little endian target systems, this performs a
+         * reordering and on big endian target systems, this is a no-op.
+         *
+         * @param[in]  inValue  The 16-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint16_t Swap16BigToHost(uint16_t inValue)
+        {
+            return nlByteOrderSwap16BigToHost(inValue);
+        }
+
+        /**
+         * This conditionally performs, as necessary for the target system, a
+         * byte order swap by value of the specified 32-bit value, presumed to
+         * be in big endian byte ordering to the target system (i.e. host)
+         * byte ordering.
+         *
+         * Consequently, on little endian target systems, this performs a
+         * reordering and on big endian target systems, this is a no-op.
+         *
+         * @param[in]  inValue  The 32-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint32_t Swap32BigToHost(uint32_t inValue)
+        {
+            return nlByteOrderSwap32BigToHost(inValue);
+        }
+
+        /**
+         * This conditionally performs, as necessary for the target system, a
+         * byte order swap by value of the specified 64-bit value, presumed to
+         * be in big endian byte ordering to the target system (i.e. host)
+         * byte ordering.
+         *
+         * Consequently, on little endian target systems, this performs a
+         * reordering and on big endian target systems, this is a no-op.
+         *
+         * @param[in]  inValue  The 64-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint64_t Swap64BigToHost(uint64_t inValue)
+        {
+            return nlByteOrderSwap64BigToHost(inValue);
+        }
+
+        /**
+         * This conditionally performs, as necessary for the target system, a
+         * byte order swap by value of the specified 16-bit value, presumed to
+         * be in target system (i.e. host) byte ordering to big endian byte
+         * ordering.
+         *
+         * Consequently, on little endian target systems, this performs a
+         * reordering and on big endian target systems, this is a no-op.
+         *
+         * @param[in]  inValue  The 16-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint16_t Swap16HostToBig(uint16_t inValue)
+        {
+            return nlByteOrderSwap16HostToBig(inValue);
+        }
+
+        /**
+         * This conditionally performs, as necessary for the target system, a
+         * byte order swap by value of the specified 32-bit value, presumed to
+         * be in target system (i.e. host) byte ordering to big endian byte
+         * ordering.
+         *
+         * Consequently, on little endian target systems, this performs a
+         * reordering and on big endian target systems, this is a no-op.
+         *
+         * @param[in]  inValue  The 32-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint32_t Swap32HostToBig(uint32_t inValue)
+        {
+            return nlByteOrderSwap32HostToBig(inValue);
+        }
+
+        /**
+         * This conditionally performs, as necessary for the target system, a
+         * byte order swap by value of the specified 64-bit value, presumed to
+         * be in target system (i.e. host) byte ordering to big endian byte
+         * ordering.
+         *
+         * Consequently, on little endian target systems, this performs a
+         * reordering and on big endian target systems, this is a no-op.
+         *
+         * @param[in]  inValue  The 64-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint64_t Swap64HostToBig(uint64_t inValue)
+        {
+            return nlByteOrderSwap64HostToBig(inValue);
+        }
+
+    } // namespace ByteOrder
+
+} // namespace nl
+
+#endif // NLBYTEORDER_HPP
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/cores/nRF5/nordic/config/nrf52840/config/nlio-base.h b/cores/nRF5/nordic/config/nrf52840/config/nlio-base.h
new file mode 100644
index 000000000..f24a51e49
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/nlio-base.h
@@ -0,0 +1,1108 @@
+/**
+ *    Copyright 2013-2017 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines C functions for safely performing simple,
+ *      memory-mapped accesses, potentially to unaligned memory
+ *      locations.
+ */
+
+#ifndef NLIO_BASE_H
+#define NLIO_BASE_H
+
+#include <nlio-private.h>
+
+#include <stdbool.h>
+#include <stdint.h>
+#include <string.h>
+
+/*
+ * If we are compiling under clang, GCC, or any such compatible
+ * compiler, in which -fno-builtins or -ffreestanding might be
+ * asserted, thereby eliminating built-in function optimization, we
+ * STILL want built-in memcpy. We want this because it allows the
+ * compiler to use architecture-specific machine instructions or
+ * inline code generation to optimize an otherwise-expensive memcpy
+ * for unaligned reads and writes, which is exactly the kind of
+ * efficiency that would be expected of nlIO.
+ */
+#if __nlIOHasBuiltin(__builtin_memcpy)
+#define __nlIO_MEMCPY __builtin_memcpy
+#else
+#define __nlIO_MEMCPY memcpy
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * This determines whether the specified pointer is aligned on the
+ * indicated size boundary.
+ *
+ * @note The size should be a power of 2 (e.g. 1, 2, 4, 8, 16, etc.).
+ *
+ * @param[in]  p     The pointer to check the alignment of.
+ * @param[in]  size  The size, in bytes, boundary to check
+ *                   the alignment against.
+ *
+ * @return True if the pointer is aligned to the specified size;
+ *         otherwise, false.
+ */
+static inline bool nlIOIsAligned(const void *p, size_t size)
+{
+    const uintptr_t value = (uintptr_t)(p);
+    const uintptr_t mask  = size - 1;
+
+    return ((value & mask) == 0);
+}
+
+/**
+ * Perform an aligned memory read of the 8-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 8-bit value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOGetAligned8(const void *p)
+{
+    return *(const uint8_t *)(p);
+}
+
+/**
+ * Perform an aligned memory read of the 16-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 16-bit value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOGetAligned16(const void *p)
+{
+    return *(const uint16_t *)(p);
+}
+
+/**
+ * Perform an aligned memory read of the 32-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 32-bit value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOGetAligned32(const void *p)
+{
+    return *(const uint32_t *)(p);
+}
+
+/**
+ * Perform an aligned memory read of the 64-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 64-bit value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOGetAligned64(const void *p)
+{
+    return *(const uint64_t *)(p);
+}
+
+/**
+ * Perform an unaligned memory read of the 8-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 8-bit value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOGetUnaligned8(const void *p)
+{
+    return nlIOGetAligned8(p);
+}
+
+/**
+ * Perform an unaligned memory read of the 16-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 16-bit value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOGetUnaligned16(const void *p)
+{
+    uint16_t temp;
+
+    __nlIO_MEMCPY(&temp, p, sizeof(uint16_t));
+
+    return temp;
+}
+
+/**
+ * Perform an unaligned memory read of the 32-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 32-bit value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOGetUnaligned32(const void *p)
+{
+    uint32_t temp;
+
+    __nlIO_MEMCPY(&temp, p, sizeof(uint32_t));
+
+    return temp;
+}
+
+/**
+ * Perform an unaligned memory read of the 64-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 64-bit value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOGetUnaligned64(const void *p)
+{
+    uint64_t temp;
+
+    __nlIO_MEMCPY(&temp, p, sizeof(uint64_t));
+
+    return temp;
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 8-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 8-bit value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOGetMaybeAligned8(const void *p)
+{
+    return nlIOGetAligned8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 16-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 16-bit value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOGetMaybeAligned16(const void *p)
+{
+    if (nlIOIsAligned(p, sizeof (uint16_t)))
+        return nlIOGetAligned16(p);
+    else
+        return nlIOGetUnaligned16(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 32-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 32-bit value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOGetMaybeAligned32(const void *p)
+{
+    if (nlIOIsAligned(p, sizeof (uint32_t)))
+        return nlIOGetAligned32(p);
+    else
+        return nlIOGetUnaligned32(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 64-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 64-bit value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOGetMaybeAligned64(const void *p)
+{
+    if (nlIOIsAligned(p, sizeof (uint64_t)))
+        return nlIOGetAligned64(p);
+    else
+        return nlIOGetUnaligned64(p);
+}
+
+/**
+ * Perform an aligned memory write of the 8-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 8-bit value to.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOPutAligned8(void *p, const uint8_t v)
+{
+    *(uint8_t *)(p) = v;
+}
+
+/**
+ * Perform an aligned memory write of the 16-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 16-bit value to.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOPutAligned16(void *p, const uint16_t v)
+{
+    *(uint16_t *)(p) = v;
+}
+
+/**
+ * Perform an aligned memory write of the 32-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 32-bit value to.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOPutAligned32(void *p, const uint32_t v)
+{
+    *(uint32_t *)(p) = v;
+}
+
+/**
+ * Perform an aligned memory write of the 64-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 64-bit value to.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOPutAligned64(void *p, const uint64_t v)
+{
+    *(uint64_t *)(p) = v;
+}
+
+/**
+ * Perform an unaligned memory write of the 8-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 8-bit value to.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOPutUnaligned8(void *p, const uint8_t v)
+{
+    nlIOPutAligned8(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the 16-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 16-bit value to.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOPutUnaligned16(void *p, const uint16_t v)
+{
+    __nlIO_MEMCPY(p, &v, sizeof(uint16_t));
+}
+
+/**
+ * Perform an unaligned memory write of the 32-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 32-bit value to.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOPutUnaligned32(void *p, const uint32_t v)
+{
+    __nlIO_MEMCPY(p, &v, sizeof(uint32_t));
+}
+
+/**
+ * Perform an unaligned memory write of the 64-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 64-bit value to.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOPutUnaligned64(void *p, const uint64_t v)
+{
+    __nlIO_MEMCPY(p, &v, sizeof(uint64_t));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 8-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 8-bit value to.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOPutMaybeAligned8(void *p, const uint8_t v)
+{
+    nlIOPutAligned8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 16-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 16-bit value to.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOPutMaybeAligned16(void *p, const uint16_t v)
+{
+    if (nlIOIsAligned(p, sizeof (uint16_t)))
+        nlIOPutAligned16(p, v);
+    else
+        nlIOPutUnaligned16(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 32-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 32-bit value to.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOPutMaybeAligned32(void *p, const uint32_t v)
+{
+    if (nlIOIsAligned(p, sizeof (uint32_t)))
+        nlIOPutAligned32(p, v);
+    else
+        nlIOPutUnaligned32(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 64-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 64-bit value to.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOPutMaybeAligned64(void *p, const uint64_t v)
+{
+    if (nlIOIsAligned(p, sizeof (uint64_t)))
+        nlIOPutAligned64(p, v);
+    else
+        nlIOPutUnaligned64(p, v);
+}
+
+/**
+ * Perform an aligned memory read of the 8-bit value at the specified
+ * pointer address and increment the pointer by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the
+ *                    8-bit value from and to then increment by
+ *                    8-bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOReadAligned8(const void **p)
+{
+    const uint8_t temp = nlIOGetAligned8(*p);
+
+    *(const uint8_t **)(p) += sizeof (uint8_t);
+
+    return temp;
+}
+
+/**
+ * Perform an aligned memory read of the 16-bit value at the specified
+ * pointer address and increment the pointer by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the
+ *                    16-bit value from and to then increment by
+ *                    16-bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOReadAligned16(const void **p)
+{
+    const uint16_t temp = nlIOGetAligned16(*p);
+
+    *(const uint8_t **)(p) += sizeof (uint16_t);
+
+    return temp;
+}
+
+/**
+ * Perform an aligned memory read of the 32-bit value at the specified
+ * pointer address and increment the pointer by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the
+ *                    32-bit value from and to then increment by
+ *                    32-bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOReadAligned32(const void **p)
+{
+    const uint32_t temp = nlIOGetAligned32(*p);
+
+    *(const uint8_t **)(p) += sizeof (uint32_t);
+
+    return temp;
+}
+
+/**
+ * Perform an aligned memory read of the 64-bit value at the specified
+ * pointer address and increment the pointer by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the
+ *                    64-bit value from and to then increment by
+ *                    64-bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOReadAligned64(const void **p)
+{
+    const uint64_t temp = nlIOGetAligned64(*p);
+
+    *(const uint8_t **)(p) += sizeof (uint64_t);
+
+    return temp;
+}
+
+/**
+ * Perform an unaligned memory read of the 8-bit value at the specified
+ * pointer address and increment the pointer by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the
+ *                    8-bit value from and to then increment by
+ *                    8-bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t nlIOReadUnaligned8(const void **p)
+{
+    const uint8_t temp = nlIOGetUnaligned8(*p);
+
+    *(const uint8_t **)(p) += sizeof (uint8_t);
+
+    return temp;
+}
+
+/**
+ * Perform an unaligned memory read of the 16-bit value at the specified
+ * pointer address and increment the pointer by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the
+ *                    16-bit value from and to then increment by
+ *                    16-bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOReadUnaligned16(const void **p)
+{
+    const uint16_t temp = nlIOGetUnaligned16(*p);
+
+    *(const uint8_t **)(p) += sizeof (uint16_t);
+
+    return temp;
+}
+
+/**
+ * Perform an aligned memory read of the 32-bit value at the specified
+ * pointer address and increment the pointer by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the
+ *                    32-bit value from and to then increment by
+ *                    32-bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOReadUnaligned32(const void **p)
+{
+    const uint32_t temp = nlIOGetUnaligned32(*p);
+
+    *(const uint8_t **)(p) += sizeof (uint32_t);
+
+    return temp;
+}
+
+/**
+ * Perform an unaligned memory read of the 64-bit value at the specified
+ * pointer address and increment the pointer by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the
+ *                    64-bit value from and to then increment by
+ *                    64-bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOReadUnaligned64(const void **p)
+{
+    const uint64_t temp = nlIOGetUnaligned64(*p);
+
+    *(const uint8_t **)(p) += sizeof (uint64_t);
+
+    return temp;
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 8-bit value
+ * from the specified pointer address and increment the pointer by
+ * 8-bits (1 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 8-bit value from and to
+ *                    then increment by 8-bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOReadMaybeAligned8(const void **p)
+{
+    const uint8_t temp = nlIOGetMaybeAligned8(*p);
+
+    *(const uint8_t **)(p) += sizeof (uint8_t);
+
+    return temp;
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 16-bit value
+ * from the specified pointer address and increment the pointer by
+ * 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 16-bit value from and to
+ *                    then increment by 16-bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOReadMaybeAligned16(const void **p)
+{
+    const uint16_t temp = nlIOGetMaybeAligned16(*p);
+
+    *(const uint8_t **)(p) += sizeof (uint16_t);
+
+    return temp;
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 32-bit value
+ * from the specified pointer address and increment the pointer by
+ * 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 32-bit value from and to
+ *                    then increment by 32-bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOReadMaybeAligned32(const void **p)
+{
+    const uint32_t temp = nlIOGetMaybeAligned32(*p);
+
+    *(const uint8_t **)(p) += sizeof (uint32_t);
+
+    return temp;
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 64-bit value
+ * from the specified pointer address and increment the pointer by
+ * 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 64-bit value from and to
+ *                    then increment by 64-bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOReadMaybeAligned64(const void **p)
+{
+    const uint64_t temp = nlIOGetMaybeAligned64(*p);
+
+    *(const uint8_t **)(p) += sizeof (uint64_t);
+
+    return temp;
+}
+
+/**
+ * Perform an aligned memory write of the 8-bit value to the specified
+ * pointer address and increment the pointer by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the 8-bit
+ *                    value from and to then increment by 8-bits (1 byte).
+ *
+ * @param[in]     v   The 8-bit value to write.
+ *
+ */
+static inline void     nlIOWriteAligned8(void **p, const uint8_t v)
+{
+    nlIOPutAligned8(*p, v);       *(const uint8_t **)(p) += sizeof (uint8_t);
+}
+
+/**
+ * Perform an aligned memory write of the 16-bit value to the specified
+ * pointer address and increment the pointer by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the 16-bit
+ *                    value from and to then increment by 16-bits (2 bytes).
+ *
+ * @param[in]     v   The 16-bit value to write.
+ *
+ */
+static inline void     nlIOWriteAligned16(void **p, const uint16_t v)
+{
+    nlIOPutAligned16(*p, v);      *(const uint8_t **)(p) += sizeof (uint16_t);
+}
+
+/**
+ * Perform an aligned memory write of the 32-bit value to the specified
+ * pointer address and increment the pointer by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the 32-bit
+ *                    value from and to then increment by 32-bits (4 bytes).
+ *
+ * @param[in]     v   The 32-bit value to write.
+ *
+ */
+static inline void     nlIOWriteAligned32(void **p, const uint32_t v)
+{
+    nlIOPutAligned32(*p, v);      *(const uint8_t **)(p) += sizeof (uint32_t);
+}
+
+/**
+ * Perform an aligned memory write of the 64-bit value to the specified
+ * pointer address and increment the pointer by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the 64-bit
+ *                    value from and to then increment by 64-bits (8 bytes).
+ *
+ * @param[in]     v   The 64-bit value to write.
+ *
+ */
+static inline void     nlIOWriteAligned64(void **p, const uint64_t v)
+{
+    nlIOPutAligned64(*p, v);      *(const uint8_t **)(p) += sizeof (uint64_t);
+}
+
+/**
+ * Perform an unaligned memory write of the 8-bit value to the specified
+ * pointer address and increment the pointer by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the 8-bit
+ *                    value from and to then increment by 8-bits (1 byte).
+ *
+ * @param[in]     v   The 8-bit value to write.
+ *
+ */
+static inline void     nlIOWriteUnaligned8(void **p, const uint8_t v)
+{
+    nlIOPutUnaligned8(*p, v);     *(const uint8_t **)(p) += sizeof (uint8_t);
+}
+
+/**
+ * Perform an unaligned memory write of the 16-bit value to the specified
+ * pointer address and increment the pointer by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the 16-bit
+ *                    value from and to then increment by 16-bits (2 bytes).
+ *
+ * @param[in]     v   The 16-bit value to write.
+ *
+ */
+static inline void     nlIOWriteUnaligned16(void **p, const uint16_t v)
+{
+    nlIOPutUnaligned16(*p, v);    *(const uint8_t **)(p) += sizeof (uint16_t);
+}
+
+/**
+ * Perform an unaligned memory write of the 32-bit value to the specified
+ * pointer address and increment the pointer by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the 32-bit
+ *                    value from and to then increment by 32-bits (4 bytes).
+ *
+ * @param[in]     v   The 32-bit value to write.
+ *
+ */
+static inline void     nlIOWriteUnaligned32(void **p, const uint32_t v)
+{
+    nlIOPutUnaligned32(*p, v);    *(const uint8_t **)(p) += sizeof (uint32_t);
+}
+
+/**
+ * Perform an unaligned memory write of the 64-bit value to the specified
+ * pointer address and increment the pointer by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the 64-bit
+ *                    value from and to then increment by 64-bits (8 bytes).
+ *
+ * @param[in]     v   The 64-bit value to write.
+ *
+ */
+static inline void     nlIOWriteUnaligned64(void **p, const uint64_t v)
+{
+    nlIOPutUnaligned64(*p, v);    *(const uint8_t **)(p) += sizeof (uint64_t);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 8-bit value
+ * to the specified pointer address and increment the pointer by
+ * 8-bits (2 byte).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 8-bit value from and to
+ *                    then increment by 8-bits (1 byte).
+ *
+ * @param[in]     v   The 8-bit value to write.
+ *
+ */
+static inline void     nlIOWriteMaybeAligned8(void **p, const uint8_t v)
+{
+    nlIOPutMaybeAligned8(*p, v);  *(const uint8_t **)(p) += sizeof (uint8_t);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 16-bit value
+ * to the specified pointer address and increment the pointer by
+ * 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 16-bit value from and to
+ *                    then increment by 16-bits (2 bytes).
+ *
+ * @param[in]     v   The 16-bit value to write.
+ *
+ */
+static inline void     nlIOWriteMaybeAligned16(void **p, const uint16_t v)
+{
+    nlIOPutMaybeAligned16(*p, v); *(const uint8_t **)(p) += sizeof (uint16_t);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 32-bit value
+ * to the specified pointer address and increment the pointer by
+ * 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 32-bit value from and to
+ *                    then increment by 32-bits (4 bytes).
+ *
+ * @param[in]     v   The 32-bit value to write.
+ *
+ */
+static inline void     nlIOWriteMaybeAligned32(void **p, const uint32_t v)
+{
+    nlIOPutMaybeAligned32(*p, v); *(const uint8_t **)(p) += sizeof (uint32_t);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 64-bit value
+ * to the specified pointer address and increment the pointer by
+ * 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 64-bit value from and to
+ *                    then increment by 64-bits (8 bytes).
+ *
+ * @param[in]     v   The 64-bit value to write.
+ *
+ */
+static inline void     nlIOWriteMaybeAligned64(void **p, const uint64_t v)
+{
+    nlIOPutMaybeAligned64(*p, v); *(const uint8_t **)(p) += sizeof (uint64_t);
+}
+
+/**
+ * Perform a memory read of the 8-bit value at the specified pointer
+ * address.
+ *
+ * @param[in]  p      A pointer address to read the 8-bit value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t nlIOGet8(const void *p)
+{
+    return nlIOGetAligned8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 16-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 16-bit value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOGet16(const void *p)
+{
+    return nlIOGetMaybeAligned16(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 32-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 32-bit value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOGet32(const void *p)
+{
+    return nlIOGetMaybeAligned32(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 64-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 64-bit value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOGet64(const void *p)
+{
+    return nlIOGetMaybeAligned64(p);
+}
+
+/**
+ * Perform a memory write of the 8-bit value to the specified pointer
+ * address.
+ *
+ * @param[in]  p      A pointer address to write the 8-bit value to.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void nlIOPut8(void *p, uint8_t v)
+{
+    nlIOPutAligned8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 16-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 16-bit value to.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void nlIOPut16(void *p, uint16_t v)
+{
+    nlIOPutMaybeAligned16(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 32-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 32-bit value to.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void nlIOPut32(void *p, uint32_t v)
+{
+    nlIOPutMaybeAligned32(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 64-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 64-bit value to.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void nlIOPut64(void *p, uint64_t v)
+{
+    nlIOPutMaybeAligned64(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 16-bit value
+ * from the specified pointer address and increment the pointer by
+ * 8-bits (1 byte).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 8-bit value from and to
+ *                    then increment by 8-bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIORead8(const void **p)
+{
+    return nlIOReadAligned8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 16-bit value
+ * from the specified pointer address and increment the pointer by
+ * 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 16-bit value from and to
+ *                    then increment by 16-bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIORead16(const void **p)
+{
+    return nlIOReadMaybeAligned16(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 32-bit value
+ * from the specified pointer address and increment the pointer by
+ * 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 32-bit value from and to
+ *                    then increment by 32-bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIORead32(const void **p)
+{
+    return nlIOReadMaybeAligned32(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 64-bit value
+ * from the specified pointer address and increment the pointer by
+ * 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 64-bit value from and to
+ *                    then increment by 64-bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIORead64(const void **p)
+{
+    return nlIOReadMaybeAligned64(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 8-bit value
+ * to the specified pointer address and increment the pointer by
+ * 8-bits (1 byte).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 8-bit value from and to
+ *                    then increment by 8-bits (1 byte).
+ *
+ * @param[in]     v   The 8-bit value to write.
+ *
+ */
+static inline void nlIOWrite8(void **p, uint8_t v)
+{
+    nlIOWriteAligned8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 16-bit value
+ * to the specified pointer address and increment the pointer by
+ * 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 16-bit value from and to
+ *                    then increment by 16-bits (2 bytes).
+ *
+ * @param[in]     v   The 16-bit value to write.
+ *
+ */
+static inline void nlIOWrite16(void **p, uint16_t v)
+{
+    nlIOWriteMaybeAligned16(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 32-bit value
+ * to the specified pointer address and increment the pointer by
+ * 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 32-bit value from and to
+ *                    then increment by 32-bits (4 bytes).
+ *
+ * @param[in]     v   The 32-bit value to write.
+ *
+ */
+static inline void nlIOWrite32(void **p, uint32_t v)
+{
+    nlIOWriteMaybeAligned32(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 64-bit value
+ * to the specified pointer address and increment the pointer by
+ * 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 64-bit value from and to
+ *                    then increment by 64-bits (8 bytes).
+ *
+ * @param[in]     v   The 64-bit value to write.
+ *
+ */
+static inline void nlIOWrite64(void **p, uint64_t v)
+{
+    nlIOWriteMaybeAligned64(p, v);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#undef __nlIO_MEMCPY
+
+#endif /* NLIO_BASE_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/nlio-base.hpp b/cores/nRF5/nordic/config/nrf52840/config/nlio-base.hpp
new file mode 100644
index 000000000..e176c353a
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/nlio-base.hpp
@@ -0,0 +1,1025 @@
+/**
+ *    Copyright 2013-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines C++ functions for safely performing simple,
+ *      memory-mapped accesses, potentially to unaligned memory
+ *      locations.
+ */
+
+#ifndef NLIO_BASE_HPP
+#define NLIO_BASE_HPP
+
+#include <nlio-base.h>
+
+namespace nl
+{
+
+namespace IO
+{
+
+/**
+ * This determines whether the specified pointer is aligned on the
+ * indicated size boundary.
+ *
+ * @note The size should be a power of 2 (e.g. 1, 2, 4, 8, 16, etc.).
+ *
+ * @param[in]  p     The pointer to check the alignment of.
+ * @param[in]  size  The size, in bytes, boundary to check
+ *                   the alignment against.
+ *
+ * @return True if the pointer is aligned to the specified size;
+ *         otherwise, false.
+ */
+static inline bool IsAligned(const void *p, size_t size)
+{
+    return nlIOIsAligned(p, size);
+}
+
+/**
+ * This determines whether the specified pointer is aligned on the
+ * size boundary for the template type, T.
+ *
+ * @tparam     T     The type of pointer to check the alignment of.
+ *
+ * @param[in]  p     The pointer to check the alignment of.
+ *
+ * @return True if the pointer is aligned to size of the type;
+ *         otherwise, false.
+ */
+template <typename T>
+static inline bool IsAligned(const T *p)
+{
+    return nlIOIsAligned(p, sizeof(T));
+}
+
+/**
+ * Perform an aligned memory read of the 8-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 8-bit value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  GetAligned8(const void *p)
+{
+    return nlIOGetAligned8(p);
+}
+
+/**
+ * Perform an aligned memory read of the 16-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 16-bit value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t GetAligned16(const void *p)
+{
+    return nlIOGetAligned16(p);
+}
+
+/**
+ * Perform an aligned memory read of the 32-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 32-bit value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t GetAligned32(const void *p)
+{
+    return nlIOGetAligned32(p);
+}
+
+/**
+ * Perform an aligned memory read of the 64-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 64-bit value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t GetAligned64(const void *p)
+{
+    return nlIOGetAligned64(p);
+}
+
+/**
+ * Perform an unaligned memory read of the 8-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 8-bit value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  GetUnaligned8(const void *p)
+{
+    return nlIOGetUnaligned8(p);
+}
+
+/**
+ * Perform an unaligned memory read of the 16-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 16-bit value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t GetUnaligned16(const void *p)
+{
+    return nlIOGetUnaligned16(p);
+}
+
+/**
+ * Perform an unaligned memory read of the 32-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 32-bit value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t GetUnaligned32(const void *p)
+{
+    return nlIOGetUnaligned32(p);
+}
+
+/**
+ * Perform an unaligned memory read of the 64-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 64-bit value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t GetUnaligned64(const void *p)
+{
+    return nlIOGetUnaligned64(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 8-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 8-bit value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  GetMaybeAligned8(const void *p)
+{
+    return nlIOGetMaybeAligned8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 16-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 16-bit value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t GetMaybeAligned16(const void *p)
+{
+    return nlIOGetMaybeAligned16(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 32-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 32-bit value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t GetMaybeAligned32(const void *p)
+{
+    return nlIOGetMaybeAligned32(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 64-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 64-bit value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t GetMaybeAligned64(const void *p)
+{
+    return nlIOGetMaybeAligned64(p);
+}
+
+/**
+ * Perform an aligned memory write of the 8-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 8-bit value to.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     PutAligned8(void *p, const uint8_t v)
+{
+    nlIOPutAligned8(p, v);
+}
+
+/**
+ * Perform an aligned memory write of the 16-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 16-bit value to.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     PutAligned16(void *p, const uint16_t v)
+{
+    nlIOPutAligned16(p, v);
+}
+
+/**
+ * Perform an aligned memory write of the 32-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 32-bit value to.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     PutAligned32(void *p, const uint32_t v)
+{
+    nlIOPutAligned32(p, v);
+}
+
+/**
+ * Perform an aligned memory write of the 64-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 64-bit value to.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     PutAligned64(void *p, const uint64_t v)
+{
+    nlIOPutAligned64(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the 8-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 8-bit value to.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     PutUnaligned8(void *p, const uint8_t v)
+{
+    nlIOPutUnaligned8(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the 16-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 16-bit value to.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     PutUnaligned16(void *p, const uint16_t v)
+{
+    nlIOPutUnaligned16(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the 32-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 32-bit value to.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     PutUnaligned32(void *p, const uint32_t v)
+{
+    nlIOPutUnaligned32(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the 64-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 64-bit value to.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     PutUnaligned64(void *p, const uint64_t v)
+{
+    nlIOPutUnaligned64(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 8-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 8-bit value to.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     PutMaybeAligned8(void *p, const uint8_t v)
+{
+    nlIOPutMaybeAligned8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 16-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 16-bit value to.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     PutMaybeAligned16(void *p, const uint16_t v)
+{
+    nlIOPutMaybeAligned16(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 32-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 32-bit value to.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     PutMaybeAligned32(void *p, const uint32_t v)
+{
+    nlIOPutMaybeAligned32(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 64-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 64-bit value to.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     PutMaybeAligned64(void *p, const uint64_t v)
+{
+    nlIOPutMaybeAligned64(p, v);
+}
+
+/**
+ * Perform an aligned memory read of the 8-bit value at the specified
+ * pointer address and increment the pointer by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the
+ *                    8-bit value from and to then increment by
+ *                    8-bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  ReadAligned8(const void *&p)
+{
+    return nlIOReadAligned8(&p);
+}
+
+/**
+ * Perform an aligned memory read of the 16-bit value at the specified
+ * pointer address and increment the pointer by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the
+ *                    16-bit value from and to then increment by
+ *                    16-bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t ReadAligned16(const void *&p)
+{
+    return nlIOReadAligned16(&p);
+}
+
+/**
+ * Perform an aligned memory read of the 32-bit value at the specified
+ * pointer address and increment the pointer by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the
+ *                    32-bit value from and to then increment by
+ *                    32-bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t ReadAligned32(const void *&p)
+{
+    return nlIOReadAligned32(&p);
+}
+
+/**
+ * Perform an aligned memory read of the 64-bit value at the specified
+ * pointer address and increment the pointer by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the
+ *                    64-bit value from and to then increment by
+ *                    64-bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t ReadAligned64(const void *&p)
+{
+    return nlIOReadAligned64(&p);
+}
+
+/**
+ * Perform an unaligned memory read of the 8-bit value at the specified
+ * pointer address and increment the pointer by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the
+ *                    8-bit value from and to then increment by
+ *                    8-bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t ReadUnaligned8(const void *&p)
+{
+    return nlIOReadUnaligned8(&p);
+}
+
+/**
+ * Perform an unaligned memory read of the 16-bit value at the specified
+ * pointer address and increment the pointer by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the
+ *                    16-bit value from and to then increment by
+ *                    16-bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t ReadUnaligned16(const void *&p)
+{
+    return nlIOReadUnaligned16(&p);
+}
+
+/**
+ * Perform an aligned memory read of the 32-bit value at the specified
+ * pointer address and increment the pointer by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the
+ *                    32-bit value from and to then increment by
+ *                    32-bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t ReadUnaligned32(const void *&p)
+{
+    return nlIOReadUnaligned32(&p);
+}
+
+/**
+ * Perform an unaligned memory read of the 64-bit value at the specified
+ * pointer address and increment the pointer by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the
+ *                    64-bit value from and to then increment by
+ *                    64-bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t ReadUnaligned64(const void *&p)
+{
+    return nlIOReadUnaligned64(&p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 8-bit value
+ * from the specified pointer address and increment the pointer by
+ * 8-bits (1 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 8-bit value from and to
+ *                    then increment by 8-bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  ReadMaybeAligned8(const void *&p)
+{
+    return nlIOReadMaybeAligned8(&p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 16-bit value
+ * from the specified pointer address and increment the pointer by
+ * 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 16-bit value from and to
+ *                    then increment by 16-bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t ReadMaybeAligned16(const void *&p)
+{
+    return nlIOReadMaybeAligned16(&p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 32-bit value
+ * from the specified pointer address and increment the pointer by
+ * 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 32-bit value from and to
+ *                    then increment by 32-bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t ReadMaybeAligned32(const void *&p)
+{
+    return nlIOReadMaybeAligned32(&p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 64-bit value
+ * from the specified pointer address and increment the pointer by
+ * 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 64-bit value from and to
+ *                    then increment by 64-bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t ReadMaybeAligned64(const void *&p)
+{
+    return nlIOReadMaybeAligned64(&p);
+}
+
+/**
+ * Perform an aligned memory write of the 8-bit value to the specified
+ * pointer address and increment the pointer by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the 8-bit
+ *                    value from and to then increment by 8-bits (1 byte).
+ *
+ * @param[in]     v   The 8-bit value to write.
+ *
+ */
+static inline void     WriteAligned8(void *&p, const uint8_t v)
+{
+    nlIOWriteAligned8(&p, v);
+}
+
+/**
+ * Perform an aligned memory write of the 16-bit value to the specified
+ * pointer address and increment the pointer by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the 16-bit
+ *                    value from and to then increment by 16-bits (2 bytes).
+ *
+ * @param[in]     v   The 16-bit value to write.
+ *
+ */
+static inline void     WriteAligned16(void *&p, const uint16_t v)
+{
+    nlIOWriteAligned16(&p, v);
+}
+
+/**
+ * Perform an aligned memory write of the 32-bit value to the specified
+ * pointer address and increment the pointer by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the 32-bit
+ *                    value from and to then increment by 32-bits (4 bytes).
+ *
+ * @param[in]     v   The 32-bit value to write.
+ *
+ */
+static inline void     WriteAligned32(void *&p, const uint32_t v)
+{
+    nlIOWriteAligned32(&p, v);
+}
+
+/**
+ * Perform an aligned memory write of the 64-bit value to the specified
+ * pointer address and increment the pointer by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the 64-bit
+ *                    value from and to then increment by 64-bits (8 bytes).
+ *
+ * @param[in]     v   The 64-bit value to write.
+ *
+ */
+static inline void     WriteAligned64(void *&p, const uint64_t v)
+{
+    nlIOWriteAligned64(&p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the 8-bit value to the specified
+ * pointer address and increment the pointer by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the 8-bit
+ *                    value from and to then increment by 8-bits (1 byte).
+ *
+ * @param[in]     v   The 8-bit value to write.
+ *
+ */
+static inline void     WriteUnaligned8(void *&p, const uint8_t v)
+{
+    nlIOWriteUnaligned8(&p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the 16-bit value to the specified
+ * pointer address and increment the pointer by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the 16-bit
+ *                    value from and to then increment by 16-bits (2 bytes).
+ *
+ * @param[in]     v   The 16-bit value to write.
+ *
+ */
+static inline void     WriteUnaligned16(void *&p, const uint16_t v)
+{
+    nlIOWriteUnaligned16(&p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the 32-bit value to the specified
+ * pointer address and increment the pointer by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the 32-bit
+ *                    value from and to then increment by 32-bits (4 bytes).
+ *
+ * @param[in]     v   The 32-bit value to write.
+ *
+ */
+static inline void     WriteUnaligned32(void *&p, const uint32_t v)
+{
+    nlIOWriteUnaligned32(&p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the 64-bit value to the specified
+ * pointer address and increment the pointer by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the 64-bit
+ *                    value from and to then increment by 64-bits (8 bytes).
+ *
+ * @param[in]     v   The 64-bit value to write.
+ *
+ */
+static inline void     WriteUnaligned64(void *&p, const uint64_t v)
+{
+    nlIOWriteUnaligned64(&p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 8-bit value
+ * to the specified pointer address and increment the pointer by
+ * 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 8-bit value from and to
+ *                    then increment by 8-bits (1 byte).
+ *
+ * @param[in]     v   The 8-bit value to write.
+ *
+ */
+static inline void     WriteMaybeAligned8(void *&p, const uint8_t v)
+{
+    nlIOWriteMaybeAligned8(&p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 16-bit value
+ * to the specified pointer address and increment the pointer by
+ * 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 16-bit value from and to
+ *                    then increment by 16-bits (2 bytes).
+ *
+ * @param[in]     v   The 16-bit value to write.
+ *
+ */
+static inline void     WriteMaybeAligned16(void *&p, const uint16_t v)
+{
+    nlIOWriteMaybeAligned16(&p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 32-bit value
+ * to the specified pointer address and increment the pointer by
+ * 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 32-bit value from and to
+ *                    then increment by 32-bits (4 bytes).
+ *
+ * @param[in]     v   The 32-bit value to write.
+ *
+ */
+static inline void     WriteMaybeAligned32(void *&p, const uint32_t v)
+{
+    nlIOWriteMaybeAligned32(&p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 64-bit value
+ * to the specified pointer address and increment the pointer by
+ * 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 64-bit value from and to
+ *                    then increment by 64-bits (8 bytes).
+ *
+ * @param[in]     v   The 64-bit value to write.
+ *
+ */
+static inline void     WriteMaybeAligned64(void *&p, const uint64_t v)
+{
+    nlIOWriteMaybeAligned64(&p, v);
+}
+
+/**
+ * Perform a memory read of the 8-bit value at the specified pointer
+ * address.
+ *
+ * @param[in]  p      A pointer address to read the 8-bit value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  Get8(const void *p)
+{
+    return nlIOGet8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 16-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 16-bit value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t Get16(const void *p)
+{
+    return nlIOGet16(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 32-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 32-bit value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t Get32(const void *p)
+{
+    return nlIOGet32(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 64-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 64-bit value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t Get64(const void *p)
+{
+    return nlIOGet64(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 8-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 8-bit value to.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void Put8(void *p, const uint8_t v)
+{
+    nlIOPut8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 16-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 16-bit value to.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void Put16(void *p, const uint16_t v)
+{
+    nlIOPut16(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 32-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 32-bit value to.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void Put32(void *p, const uint32_t v)
+{
+    nlIOPut32(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 64-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 64-bit value to.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void Put64(void *p, const uint64_t v)
+{
+    nlIOPut64(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 16-bit value
+ * from the specified pointer address and increment the pointer by
+ * 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 8-bit value from and to
+ *                    then increment by 8-bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  Read8(const void *&p)
+{
+    return nlIORead8(&p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 16-bit value
+ * from the specified pointer address and increment the pointer by
+ * 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 16-bit value from and to
+ *                    then increment by 16-bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t Read16(const void *&p)
+{
+    return nlIORead16(&p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 32-bit value
+ * from the specified pointer address and increment the pointer by
+ * 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 32-bit value from and to
+ *                    then increment by 32-bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t Read32(const void *&p)
+{
+    return nlIORead32(&p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 64-bit value
+ * from the specified pointer address and increment the pointer by
+ * 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 64-bit value from and to
+ *                    then increment by 64-bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t Read64(const void *&p)
+{
+    return nlIORead64(&p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 8-bit value
+ * to the specified pointer address and increment the pointer by
+ * 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 8-bit value from and to
+ *                    then increment by 8-bits (1 byte).
+ *
+ * @param[in]     v   The 8-bit value to write.
+ *
+ */
+static inline void Write8(void *&p, const uint8_t v)
+{
+    nlIOWrite8(&p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 16-bit value
+ * to the specified pointer address and increment the pointer by
+ * 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 16-bit value from and to
+ *                    then increment by 16-bits (2 bytes).
+ *
+ * @param[in]     v   The 16-bit value to write.
+ *
+ */
+static inline void Write16(void *&p, const uint16_t v)
+{
+    nlIOWrite16(&p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 32-bit value
+ * to the specified pointer address and increment the pointer by
+ * 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 32-bit value from and to
+ *                    then increment by 32-bits (4 bytes).
+ *
+ * @param[in]     v   The 32-bit value to write.
+ *
+ */
+static inline void Write32(void *&p, const uint32_t v)
+{
+    nlIOWrite32(&p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 64-bit value
+ * to the specified pointer address and increment the pointer by
+ * 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 64-bit value from and to
+ *                    then increment by 64-bits (8 bytes).
+ *
+ * @param[in]     v   The 64-bit value to write.
+ *
+ */
+static inline void Write64(void *&p, const uint64_t v)
+{
+    nlIOWrite64(&p, v);
+}
+
+} // namespace IO
+
+} // namespace nl
+
+#endif // NLIO_BASE_HPP
diff --git a/cores/nRF5/nordic/config/nrf52840/config/nlio-byteorder-big.h b/cores/nRF5/nordic/config/nrf52840/config/nlio-byteorder-big.h
new file mode 100644
index 000000000..a9ab69c36
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/nlio-byteorder-big.h
@@ -0,0 +1,915 @@
+/**
+ *    Copyright 2013-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines C functions for safely performing simple,
+ *      memory-mapped accesses, potentially to unaligned, aligned, and
+ *      unaligned memory locations with byte reordering, specifically
+ *      for big endian target systems.
+ */
+
+#ifndef NLIO_BYTEORDER_BIG_H
+#define NLIO_BYTEORDER_BIG_H
+
+#include <nlio-base.h>
+#include <nlbyteorder.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 8-bit big endian byte ordered value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOBigEndianGet8(const void *p)
+{
+    return nlIOGet8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 16-bit big endian byte ordered value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOBigEndianGet16(const void *p)
+{
+    return nlByteOrderSwap16BigToHost(nlIOGet16(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 32-bit big endian byte ordered value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOBigEndianGet32(const void *p)
+{
+    return nlByteOrderSwap32BigToHost(nlIOGet32(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 64-bit big endian byte ordered value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOBigEndianGet64(const void *p)
+{
+    return nlByteOrderSwap64BigToHost(nlIOGet64(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 8-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianPut8(void *p, uint8_t v)
+{
+    nlIOPut8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 16-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianPut16(void *p, uint16_t v)
+{
+    nlIOPut16(p, nlByteOrderSwap16HostToBig(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 32-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianPut32(void *p, uint32_t v)
+{
+    nlIOPut32(p, nlByteOrderSwap32HostToBig(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 64-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianPut64(void *p, uint64_t v)
+{
+    nlIOPut64(p, nlByteOrderSwap64HostToBig(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 8-bit big endian byte
+ *                    ordered value from and to then increment by 8-
+ *                    bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOBigEndianRead8(const void **p)
+{
+    return nlIORead8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 16-bit big endian byte
+ *                    ordered value from and to then increment by 16-
+ *                    bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOBigEndianRead16(const void **p)
+{
+    return nlByteOrderSwap16BigToHost(nlIORead16(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 32-bit big endian byte
+ *                    ordered value from and to then increment by 32-
+ *                    bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOBigEndianRead32(const void **p)
+{
+    return nlByteOrderSwap32BigToHost(nlIORead32(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 64-bit big endian byte
+ *                    ordered value from and to then increment by 64-
+ *                    bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOBigEndianRead64(const void **p)
+{
+    return nlByteOrderSwap64BigToHost(nlIORead64(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A pointer to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 8-bit value to in big endian byte
+ *                    ordering and to then increment by 8-bits (1
+ *                    byte).
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianWrite8(void **p, uint8_t v)
+{
+    nlIOWrite8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A pointer to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 16-bit value to in big endian byte
+ *                    ordering and to then increment by 16-bits (2
+ *                    bytes).
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianWrite16(void **p, uint16_t v)
+{
+    nlIOWrite16(p, nlByteOrderSwap16HostToBig(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A pointer to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 32-bit value to in big endian byte
+ *                    ordering and to then increment by 16-bits (4
+ *                    bytes).
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianWrite32(void **p, uint32_t v)
+{
+    nlIOWrite32(p, nlByteOrderSwap32HostToBig(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A pointer to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 64-bit value to in big endian byte
+ *                    ordering and to then increment by 64-bits (8
+ *                    bytes).
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianWrite64(void **p, uint64_t v)
+{
+    nlIOWrite64(p, nlByteOrderSwap64HostToBig(v));
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 8-bit big endian byte ordered value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOBigEndianGetAligned8(const void *p)
+{
+    return nlIOGetAligned8(p);
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 16-bit big endian byte ordered value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOBigEndianGetAligned16(const void *p)
+{
+    return nlByteOrderSwap16BigToHost(nlIOGetAligned16(p));
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 32-bit big endian byte ordered value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOBigEndianGetAligned32(const void *p)
+{
+    return nlByteOrderSwap32BigToHost(nlIOGetAligned32(p));
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 64-bit big endian byte ordered value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOBigEndianGetAligned64(const void *p)
+{
+    return nlByteOrderSwap64BigToHost(nlIOGetAligned64(p));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 8-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianPutAligned8(void *p, uint8_t v)
+{
+    nlIOPutAligned8(p, v);
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 16-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianPutAligned16(void *p, uint16_t v)
+{
+    nlIOPutAligned16(p, nlByteOrderSwap16HostToBig(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 32-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianPutAligned32(void *p, uint32_t v)
+{
+    nlIOPutAligned32(p, nlByteOrderSwap32HostToBig(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 64-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianPutAligned64(void *p, uint64_t v)
+{
+    nlIOPutAligned64(p, nlByteOrderSwap64HostToBig(v));
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to read the 8-bit big endian byte
+ *                    ordered value from and to then increment by 8-
+ *                    bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOBigEndianReadAligned8(const void **p)
+{
+    return nlIOReadAligned8(p);
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to read the 16-bit big endian byte
+ *                    ordered value from and to then increment by 16-
+ *                    bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOBigEndianReadAligned16(const void **p)
+{
+    return nlByteOrderSwap16BigToHost(nlIOReadAligned16(p));
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to read the 32-bit big endian byte
+ *                    ordered value from and to then increment by 32-
+ *                    bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOBigEndianReadAligned32(const void **p)
+{
+    return nlByteOrderSwap32BigToHost(nlIOReadAligned32(p));
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to read the 64-bit big endian byte
+ *                    ordered value from and to then increment by 64-
+ *                    bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOBigEndianReadAligned64(const void **p)
+{
+    return nlByteOrderSwap64BigToHost(nlIOReadAligned64(p));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to write the target system byte
+ *                    ordered 8-bit value to in big endian byte
+ *                    ordering and to then increment by 8-bits (1
+ *                    byte).
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianWriteAligned8(void **p, uint8_t v)
+{
+    nlIOWriteAligned8(p, v);
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to write the target system byte
+ *                    ordered 16-bit value to in big endian byte
+ *                    ordering and to then increment by 16-bits (2
+ *                    bytes).
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianWriteAligned16(void **p, uint16_t v)
+{
+    nlIOWriteAligned16(p, nlByteOrderSwap16HostToBig(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to write the target system byte
+ *                    ordered 32-bit value to in big endian byte
+ *                    ordering and to then increment by 16-bits (4
+ *                    bytes).
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianWriteAligned32(void **p, uint32_t v)
+{
+    nlIOWriteAligned32(p, nlByteOrderSwap32HostToBig(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to write the target system byte
+ *                    ordered 64-bit value to in big endian byte
+ *                    ordering and to then increment by 64-bits (8
+ *                    bytes).
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianWriteAligned64(void **p, uint64_t v)
+{
+    nlIOWriteAligned64(p, nlByteOrderSwap64HostToBig(v));
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 8-bit big endian byte ordered value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOBigEndianGetUnaligned8(const void *p)
+{
+    return nlIOGetUnaligned8(p);
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 16-bit big endian byte ordered value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOBigEndianGetUnaligned16(const void *p)
+{
+    return nlByteOrderSwap16BigToHost(nlIOGetUnaligned16(p));
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 32-bit big endian byte ordered value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOBigEndianGetUnaligned32(const void *p)
+{
+    return nlByteOrderSwap32BigToHost(nlIOGetUnaligned32(p));
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 64-bit big endian byte ordered value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOBigEndianGetUnaligned64(const void *p)
+{
+    return nlByteOrderSwap64BigToHost(nlIOGetUnaligned64(p));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 8-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianPutUnaligned8(void *p, uint8_t v)
+{
+    nlIOPutUnaligned8(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 16-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianPutUnaligned16(void *p, uint16_t v)
+{
+    nlIOPutUnaligned16(p, nlByteOrderSwap16HostToBig(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 32-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianPutUnaligned32(void *p, uint32_t v)
+{
+    nlIOPutUnaligned32(p, nlByteOrderSwap32HostToBig(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 64-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianPutUnaligned64(void *p, uint64_t v)
+{
+    nlIOPutUnaligned64(p, nlByteOrderSwap64HostToBig(v));
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to read the 8-bit big endian byte
+ *                    ordered value from and to then increment by 8-
+ *                    bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOBigEndianReadUnaligned8(const void **p)
+{
+    return nlIOReadUnaligned8(p);
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to read the 16-bit big endian byte
+ *                    ordered value from and to then increment by 16-
+ *                    bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOBigEndianReadUnaligned16(const void **p)
+{
+    return nlByteOrderSwap16BigToHost(nlIOReadUnaligned16(p));
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to read the 32-bit big endian byte
+ *                    ordered value from and to then increment by 32-
+ *                    bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOBigEndianReadUnaligned32(const void **p)
+{
+    return nlByteOrderSwap32BigToHost(nlIOReadUnaligned32(p));
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to read the 64-bit big endian byte
+ *                    ordered value from and to then increment by 64-
+ *                    bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOBigEndianReadUnaligned64(const void **p)
+{
+    return nlByteOrderSwap64BigToHost(nlIOReadUnaligned64(p));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to write the target system byte
+ *                    ordered 8-bit value to in big endian byte
+ *                    ordering and to then increment by 8-bits (1
+ *                    byte).
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianWriteUnaligned8(void **p, uint8_t v)
+{
+    nlIOWriteUnaligned8(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to write the target system byte
+ *                    ordered 16-bit value to in big endian byte
+ *                    ordering and to then increment by 16-bits (2
+ *                    bytes).
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianWriteUnaligned16(void **p, uint16_t v)
+{
+    nlIOWriteUnaligned16(p, nlByteOrderSwap16HostToBig(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to write the target system byte
+ *                    ordered 32-bit value to in big endian byte
+ *                    ordering and to then increment by 32-bits (4
+ *                    bytes).
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianWriteUnaligned32(void **p, uint32_t v)
+{
+    nlIOWriteUnaligned32(p, nlByteOrderSwap32HostToBig(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to write the target system byte
+ *                    ordered 64-bit value to in big endian byte
+ *                    ordering and to then increment by 64-bits (8
+ *                    bytes).
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianWriteUnaligned64(void **p, uint64_t v)
+{
+    nlIOWriteUnaligned64(p, nlByteOrderSwap64HostToBig(v));
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NLIO_BYTEORDER_BIG_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/nlio-byteorder-big.hpp b/cores/nRF5/nordic/config/nrf52840/config/nlio-byteorder-big.hpp
new file mode 100644
index 000000000..0d1e96f10
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/nlio-byteorder-big.hpp
@@ -0,0 +1,922 @@
+/**
+ *    Copyright 2013-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines C++ functions for safely performing simple,
+ *      memory-mapped accesses, potentially to unaligned, aligned, and
+ *      unaligned memory locations with byte reordering, specifically
+ *      for big endian target systems.
+ */
+
+#ifndef NLIO_BYTEORDER_BIG_HPP
+#define NLIO_BYTEORDER_BIG_HPP
+
+#include <nlio-base.hpp>
+#include <nlbyteorder.hpp>
+
+namespace nl
+{
+
+namespace IO
+{
+
+namespace BigEndian
+{
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 8-bit big endian byte ordered value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  Get8(const void *p)
+{
+    return IO::Get8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 16-bit big endian byte ordered value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t Get16(const void *p)
+{
+    return ByteOrder::Swap16BigToHost(IO::Get16(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 32-bit big endian byte ordered value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t Get32(const void *p)
+{
+    return ByteOrder::Swap32BigToHost(IO::Get32(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 64-bit big endian byte ordered value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t Get64(const void *p)
+{
+    return ByteOrder::Swap64BigToHost(IO::Get64(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 8-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     Put8(void *p, uint8_t v)
+{
+    IO::Put8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 16-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     Put16(void *p, uint16_t v)
+{
+    IO::Put16(p, ByteOrder::Swap16HostToBig(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 32-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     Put32(void *p, uint32_t v)
+{
+    IO::Put32(p, ByteOrder::Swap32HostToBig(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 64-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     Put64(void *p, uint64_t v)
+{
+    IO::Put64(p, ByteOrder::Swap64HostToBig(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 8-bit big endian byte
+ *                    ordered value from and to then increment by 8-
+ *                    bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  Read8(const void *&p)
+{
+    return IO::Read8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 16-bit big endian byte
+ *                    ordered value from and to then increment by 16-
+ *                    bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t Read16(const void *&p)
+{
+    return ByteOrder::Swap16BigToHost(IO::Read16(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 32-bit big endian byte
+ *                    ordered value from and to then increment by 32-
+ *                    bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t Read32(const void *&p)
+{
+    return ByteOrder::Swap32BigToHost(IO::Read32(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 64-bit big endian byte
+ *                    ordered value from and to then increment by 64-
+ *                    bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t Read64(const void *&p)
+{
+    return ByteOrder::Swap64BigToHost(IO::Read64(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A reference to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 8-bit value to in big endian byte
+ *                    ordering and to then increment by 8-bits (1
+ *                    byte).
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     Write8(void *&p, uint8_t v)
+{
+    IO::Write8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A reference to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 16-bit value to in big endian byte
+ *                    ordering and to then increment by 16-bits (2
+ *                    bytes).
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     Write16(void *&p, uint16_t v)
+{
+    IO::Write16(p, ByteOrder::Swap16HostToBig(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A reference to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 32-bit value to in big endian byte
+ *                    ordering and to then increment by 16-bits (4
+ *                    bytes).
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     Write32(void *&p, uint32_t v)
+{
+    IO::Write32(p, ByteOrder::Swap32HostToBig(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A reference to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 64-bit value to in big endian byte
+ *                    ordering and to then increment by 64-bits (8
+ *                    bytes).
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     Write64(void *&p, uint64_t v)
+{
+    IO::Write64(p, ByteOrder::Swap64HostToBig(v));
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 8-bit big endian byte ordered value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  GetAligned8(const void *p)
+{
+    return IO::GetAligned8(p);
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 16-bit big endian byte ordered value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t GetAligned16(const void *p)
+{
+    return ByteOrder::Swap16BigToHost(IO::GetAligned16(p));
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 32-bit big endian byte ordered value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t GetAligned32(const void *p)
+{
+    return ByteOrder::Swap32BigToHost(IO::GetAligned32(p));
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 64-bit big endian byte ordered value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t GetAligned64(const void *p)
+{
+    return ByteOrder::Swap64BigToHost(IO::GetAligned64(p));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 8-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     PutAligned8(void *p, uint8_t v)
+{
+    IO::PutAligned8(p, v);
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 16-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     PutAligned16(void *p, uint16_t v)
+{
+    IO::PutAligned16(p, ByteOrder::Swap16HostToBig(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 32-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     PutAligned32(void *p, uint32_t v)
+{
+    IO::PutAligned32(p, ByteOrder::Swap32HostToBig(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 64-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     PutAligned64(void *p, uint64_t v)
+{
+    IO::PutAligned64(p, ByteOrder::Swap64HostToBig(v));
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to read the 8-bit big endian byte
+ *                    ordered value from and to then increment by 8-
+ *                    bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  ReadAligned8(const void *&p)
+{
+    return IO::ReadAligned8(p);
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to read the 16-bit big endian byte
+ *                    ordered value from and to then increment by 16-
+ *                    bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t ReadAligned16(const void *&p)
+{
+    return ByteOrder::Swap16BigToHost(IO::ReadAligned16(p));
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to read the 32-bit big endian byte
+ *                    ordered value from and to then increment by 32-
+ *                    bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t ReadAligned32(const void *&p)
+{
+    return ByteOrder::Swap32BigToHost(IO::ReadAligned32(p));
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to read the 64-bit big endian byte
+ *                    ordered value from and to then increment by 64-
+ *                    bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t ReadAligned64(const void *&p)
+{
+    return ByteOrder::Swap64BigToHost(IO::ReadAligned64(p));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to write the target system byte
+ *                    ordered 8-bit value to in big endian byte
+ *                    ordering and to then increment by 8-bits (1
+ *                    byte).
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     WriteAligned8(void *&p, uint8_t v)
+{
+    IO::WriteAligned8(p, v);
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to write the target system byte
+ *                    ordered 16-bit value to in big endian byte
+ *                    ordering and to then increment by 16-bits (2
+ *                    bytes).
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     WriteAligned16(void *&p, uint16_t v)
+{
+    IO::WriteAligned16(p, ByteOrder::Swap16HostToBig(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to write the target system byte
+ *                    ordered 32-bit value to in big endian byte
+ *                    ordering and to then increment by 16-bits (4
+ *                    bytes).
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     WriteAligned32(void *&p, uint32_t v)
+{
+    IO::WriteAligned32(p, ByteOrder::Swap32HostToBig(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to write the target system byte
+ *                    ordered 64-bit value to in big endian byte
+ *                    ordering and to then increment by 64-bits (8
+ *                    bytes).
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     WriteAligned64(void *&p, uint64_t v)
+{
+    IO::WriteAligned64(p, ByteOrder::Swap64HostToBig(v));
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 8-bit big endian byte ordered value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  GetUnaligned8(const void *p)
+{
+    return IO::GetUnaligned8(p);
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 16-bit big endian byte ordered value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t GetUnaligned16(const void *p)
+{
+    return ByteOrder::Swap16BigToHost(IO::GetUnaligned16(p));
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 32-bit big endian byte ordered value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t GetUnaligned32(const void *p)
+{
+    return ByteOrder::Swap32BigToHost(IO::GetUnaligned32(p));
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 64-bit big endian byte ordered value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t GetUnaligned64(const void *p)
+{
+    return ByteOrder::Swap64BigToHost(IO::GetUnaligned64(p));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 8-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     PutUnaligned8(void *p, uint8_t v)
+{
+    IO::PutUnaligned8(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 16-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     PutUnaligned16(void *p, uint16_t v)
+{
+    IO::PutUnaligned16(p, ByteOrder::Swap16HostToBig(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 32-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     PutUnaligned32(void *p, uint32_t v)
+{
+    IO::PutUnaligned32(p, ByteOrder::Swap32HostToBig(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 64-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     PutUnaligned64(void *p, uint64_t v)
+{
+    IO::PutUnaligned64(p, ByteOrder::Swap64HostToBig(v));
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to read the 8-bit big endian byte
+ *                    ordered value from and to then increment by 8-
+ *                    bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  ReadUnaligned8(const void *&p)
+{
+    return IO::ReadUnaligned8(p);
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to read the 16-bit big endian byte
+ *                    ordered value from and to then increment by 16-
+ *                    bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t ReadUnaligned16(const void *&p)
+{
+    return ByteOrder::Swap16BigToHost(IO::ReadUnaligned16(p));
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to read the 32-bit big endian byte
+ *                    ordered value from and to then increment by 32-
+ *                    bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t ReadUnaligned32(const void *&p)
+{
+    return ByteOrder::Swap32BigToHost(IO::ReadUnaligned32(p));
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to read the 64-bit big endian byte
+ *                    ordered value from and to then increment by 64-
+ *                    bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t ReadUnaligned64(const void *&p)
+{
+    return ByteOrder::Swap64BigToHost(IO::ReadUnaligned64(p));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to write the target system byte
+ *                    ordered 8-bit value to in big endian byte
+ *                    ordering and to then increment by 8-bits (1
+ *                    byte).
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     WriteUnaligned8(void *&p, uint8_t v)
+{
+    IO::WriteUnaligned8(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to write the target system byte
+ *                    ordered 16-bit value to in big endian byte
+ *                    ordering and to then increment by 16-bits (2
+ *                    bytes).
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     WriteUnaligned16(void *&p, uint16_t v)
+{
+    IO::WriteUnaligned16(p, ByteOrder::Swap16HostToBig(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to write the target system byte
+ *                    ordered 32-bit value to in big endian byte
+ *                    ordering and to then increment by 16-bits (4
+ *                    bytes).
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     WriteUnaligned32(void *&p, uint32_t v)
+{
+    IO::WriteUnaligned32(p, ByteOrder::Swap32HostToBig(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to write the target system byte
+ *                    ordered 64-bit value to in big endian byte
+ *                    ordering and to then increment by 64-bits (8
+ *                    bytes).
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     WriteUnaligned64(void *&p, uint64_t v)
+{
+    IO::WriteUnaligned64(p, ByteOrder::Swap64HostToBig(v));
+}
+
+} // namespace BigEndian
+
+} // namespace IO
+
+} // namespace nl
+
+#endif // NLIO_BYTEORDER_BIG_HPP
diff --git a/cores/nRF5/nordic/config/nrf52840/config/nlio-byteorder-little.h b/cores/nRF5/nordic/config/nrf52840/config/nlio-byteorder-little.h
new file mode 100644
index 000000000..06c477e16
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/nlio-byteorder-little.h
@@ -0,0 +1,915 @@
+/**
+ *    Copyright 2013-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines C functions for safely performing simple,
+ *      memory-mapped accesses, potentially to unaligned, aligned, and
+ *      unaligned memory locations with byte reordering, specifically
+ *      for little endian target systems.
+ */
+
+#ifndef NLIO_BYTEORDER_LITTLE_H
+#define NLIO_BYTEORDER_LITTLE_H
+
+#include <nlio-base.h>
+#include <nlbyteorder.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 8-bit little endian byte ordered value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOLittleEndianGet8(const void *p)
+{
+    return nlIOGet8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 16-bit little endian byte ordered value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOLittleEndianGet16(const void *p)
+{
+    return nlByteOrderSwap16LittleToHost(nlIOGet16(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 32-bit little endian byte ordered value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOLittleEndianGet32(const void *p)
+{
+    return nlByteOrderSwap32LittleToHost(nlIOGet32(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 64-bit little endian byte ordered value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOLittleEndianGet64(const void *p)
+{
+    return nlByteOrderSwap64LittleToHost(nlIOGet64(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 8-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianPut8(void *p, uint8_t v)
+{
+    nlIOPut8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 16-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianPut16(void *p, uint16_t v)
+{
+    nlIOPut16(p, nlByteOrderSwap16HostToLittle(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 32-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianPut32(void *p, uint32_t v)
+{
+    nlIOPut32(p, nlByteOrderSwap32HostToLittle(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 64-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianPut64(void *p, uint64_t v)
+{
+    nlIOPut64(p, nlByteOrderSwap64HostToLittle(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 8-bit little endian byte
+ *                    ordered value from and to then increment by 8-
+ *                    bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOLittleEndianRead8(const void **p)
+{
+    return nlIORead8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 16-bit little endian byte
+ *                    ordered value from and to then increment by 16-
+ *                    bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOLittleEndianRead16(const void **p)
+{
+    return nlByteOrderSwap16LittleToHost(nlIORead16(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 32-bit little endian byte
+ *                    ordered value from and to then increment by 32-
+ *                    bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOLittleEndianRead32(const void **p)
+{
+    return nlByteOrderSwap32LittleToHost(nlIORead32(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 64-bit little endian byte
+ *                    ordered value from and to then increment by 64-
+ *                    bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOLittleEndianRead64(const void **p)
+{
+    return nlByteOrderSwap64LittleToHost(nlIORead64(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A pointer to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 8-bit value to in little endian byte
+ *                    ordering and to then increment by 8-bits (1
+ *                    byte).
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianWrite8(void **p, uint8_t v)
+{
+    nlIOWrite8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A pointer to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 16-bit value to in little endian byte
+ *                    ordering and to then increment by 16-bits (2
+ *                    bytes).
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianWrite16(void **p, uint16_t v)
+{
+    nlIOWrite16(p, nlByteOrderSwap16HostToLittle(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A pointer to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 32-bit value to in little endian byte
+ *                    ordering and to then increment by 16-bits (4
+ *                    bytes).
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianWrite32(void **p, uint32_t v)
+{
+    nlIOWrite32(p, nlByteOrderSwap32HostToLittle(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A pointer to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 64-bit value to in little endian byte
+ *                    ordering and to then increment by 64-bits (8
+ *                    bytes).
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianWrite64(void **p, uint64_t v)
+{
+    nlIOWrite64(p, nlByteOrderSwap64HostToLittle(v));
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 8-bit little endian byte ordered value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOLittleEndianGetAligned8(const void *p)
+{
+    return nlIOGetAligned8(p);
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 16-bit little endian byte ordered value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOLittleEndianGetAligned16(const void *p)
+{
+    return nlByteOrderSwap16LittleToHost(nlIOGetAligned16(p));
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 32-bit little endian byte ordered value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOLittleEndianGetAligned32(const void *p)
+{
+    return nlByteOrderSwap32LittleToHost(nlIOGetAligned32(p));
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 64-bit little endian byte ordered value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOLittleEndianGetAligned64(const void *p)
+{
+    return nlByteOrderSwap64LittleToHost(nlIOGetAligned64(p));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 8-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianPutAligned8(void *p, uint8_t v)
+{
+    nlIOPutAligned8(p, v);
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 16-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianPutAligned16(void *p, uint16_t v)
+{
+    nlIOPutAligned16(p, nlByteOrderSwap16HostToLittle(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 32-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianPutAligned32(void *p, uint32_t v)
+{
+    nlIOPutAligned32(p, nlByteOrderSwap32HostToLittle(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 64-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianPutAligned64(void *p, uint64_t v)
+{
+    nlIOPutAligned64(p, nlByteOrderSwap64HostToLittle(v));
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to read the 8-bit little endian byte
+ *                    ordered value from and to then increment by 8-
+ *                    bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOLittleEndianReadAligned8(const void **p)
+{
+    return nlIOReadAligned8(p);
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to read the 16-bit little endian byte
+ *                    ordered value from and to then increment by 16-
+ *                    bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOLittleEndianReadAligned16(const void **p)
+{
+    return nlByteOrderSwap16LittleToHost(nlIOReadAligned16(p));
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to read the 32-bit little endian byte
+ *                    ordered value from and to then increment by 32-
+ *                    bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOLittleEndianReadAligned32(const void **p)
+{
+    return nlByteOrderSwap32LittleToHost(nlIOReadAligned32(p));
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to read the 64-bit little endian byte
+ *                    ordered value from and to then increment by 64-
+ *                    bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOLittleEndianReadAligned64(const void **p)
+{
+    return nlByteOrderSwap64LittleToHost(nlIOReadAligned64(p));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to write the target system byte
+ *                    ordered 8-bit value to in little endian byte
+ *                    ordering and to then increment by 8-bits (1
+ *                    byte).
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianWriteAligned8(void **p, uint8_t v)
+{
+    nlIOWriteAligned8(p, v);
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to write the target system byte
+ *                    ordered 16-bit value to in little endian byte
+ *                    ordering and to then increment by 16-bits (2
+ *                    bytes).
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianWriteAligned16(void **p, uint16_t v)
+{
+    nlIOWriteAligned16(p, nlByteOrderSwap16HostToLittle(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to write the target system byte
+ *                    ordered 32-bit value to in little endian byte
+ *                    ordering and to then increment by 16-bits (4
+ *                    bytes).
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianWriteAligned32(void **p, uint32_t v)
+{
+    nlIOWriteAligned32(p, nlByteOrderSwap32HostToLittle(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to write the target system byte
+ *                    ordered 64-bit value to in little endian byte
+ *                    ordering and to then increment by 64-bits (8
+ *                    bytes).
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianWriteAligned64(void **p, uint64_t v)
+{
+    nlIOWriteAligned64(p, nlByteOrderSwap64HostToLittle(v));
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 8-bit little endian byte ordered value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOLittleEndianGetUnaligned8(const void *p)
+{
+    return nlIOGetUnaligned8(p);
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 16-bit little endian byte ordered value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOLittleEndianGetUnaligned16(const void *p)
+{
+    return nlByteOrderSwap16LittleToHost(nlIOGetUnaligned16(p));
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 32-bit little endian byte ordered value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOLittleEndianGetUnaligned32(const void *p)
+{
+    return nlByteOrderSwap32LittleToHost(nlIOGetUnaligned32(p));
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 64-bit little endian byte ordered value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOLittleEndianGetUnaligned64(const void *p)
+{
+    return nlByteOrderSwap64LittleToHost(nlIOGetUnaligned64(p));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 8-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianPutUnaligned8(void *p, uint8_t v)
+{
+    nlIOPutUnaligned8(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 16-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianPutUnaligned16(void *p, uint16_t v)
+{
+    nlIOPutUnaligned16(p, nlByteOrderSwap16HostToLittle(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 32-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianPutUnaligned32(void *p, uint32_t v)
+{
+    nlIOPutUnaligned32(p, nlByteOrderSwap32HostToLittle(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 64-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianPutUnaligned64(void *p, uint64_t v)
+{
+    nlIOPutUnaligned64(p, nlByteOrderSwap64HostToLittle(v));
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to read the 8-bit little endian byte
+ *                    ordered value from and to then increment by 8-
+ *                    bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOLittleEndianReadUnaligned8(const void **p)
+{
+    return nlIOReadUnaligned8(p);
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to read the 16-bit little endian byte
+ *                    ordered value from and to then increment by 16-
+ *                    bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOLittleEndianReadUnaligned16(const void **p)
+{
+    return nlByteOrderSwap16LittleToHost(nlIOReadUnaligned16(p));
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to read the 32-bit little endian byte
+ *                    ordered value from and to then increment by 32-
+ *                    bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOLittleEndianReadUnaligned32(const void **p)
+{
+    return nlByteOrderSwap32LittleToHost(nlIOReadUnaligned32(p));
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to read the 64-bit little endian byte
+ *                    ordered value from and to then increment by 64-
+ *                    bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOLittleEndianReadUnaligned64(const void **p)
+{
+    return nlByteOrderSwap64LittleToHost(nlIOReadUnaligned64(p));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to write the target system byte
+ *                    ordered 8-bit value to in little endian byte
+ *                    ordering and to then increment by 8-bits (1
+ *                    byte).
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianWriteUnaligned8(void **p, uint8_t v)
+{
+    nlIOWriteUnaligned8(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to write the target system byte
+ *                    ordered 16-bit value to in little endian byte
+ *                    ordering and to then increment by 16-bits (2
+ *                    bytes).
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianWriteUnaligned16(void **p, uint16_t v)
+{
+    nlIOWriteUnaligned16(p, nlByteOrderSwap16HostToLittle(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to write the target system byte
+ *                    ordered 32-bit value to in little endian byte
+ *                    ordering and to then increment by 32-bits (4
+ *                    bytes).
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianWriteUnaligned32(void **p, uint32_t v)
+{
+    nlIOWriteUnaligned32(p, nlByteOrderSwap32HostToLittle(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to write the target system byte
+ *                    ordered 64-bit value to in little endian byte
+ *                    ordering and to then increment by 64-bits (8
+ *                    bytes).
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianWriteUnaligned64(void **p, uint64_t v)
+{
+    nlIOWriteUnaligned64(p, nlByteOrderSwap64HostToLittle(v));
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NLIO_BYTEORDER_LITTLE_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/nlio-byteorder-little.hpp b/cores/nRF5/nordic/config/nrf52840/config/nlio-byteorder-little.hpp
new file mode 100644
index 000000000..47d8fce65
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/nlio-byteorder-little.hpp
@@ -0,0 +1,922 @@
+/**
+ *    Copyright 2013-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines C++ functions for safely performing simple,
+ *      memory-mapped accesses, potentially to unaligned, aligned, and
+ *      unaligned memory locations with byte reordering, specifically
+ *      for little endian target systems.
+ */
+
+#ifndef NLIO_BYTEORDER_LITTLE_HPP
+#define NLIO_BYTEORDER_LITTLE_HPP
+
+#include <nlio-base.hpp>
+#include <nlbyteorder.hpp>
+
+namespace nl
+{
+
+namespace IO
+{
+
+namespace LittleEndian
+{
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 8-bit little endian byte ordered value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  Get8(const void *p)
+{
+    return IO::Get8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 16-bit little endian byte ordered value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t Get16(const void *p)
+{
+    return ByteOrder::Swap16LittleToHost(IO::Get16(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 32-bit little endian byte ordered value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t Get32(const void *p)
+{
+    return ByteOrder::Swap32LittleToHost(IO::Get32(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 64-bit little endian byte ordered value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t Get64(const void *p)
+{
+    return ByteOrder::Swap64LittleToHost(IO::Get64(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 8-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     Put8(void *p, uint8_t v)
+{
+    IO::Put8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 16-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     Put16(void *p, uint16_t v)
+{
+    IO::Put16(p, ByteOrder::Swap16HostToLittle(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 32-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     Put32(void *p, uint32_t v)
+{
+    IO::Put32(p, ByteOrder::Swap32HostToLittle(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 64-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     Put64(void *p, uint64_t v)
+{
+    IO::Put64(p, ByteOrder::Swap64HostToLittle(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 8-bit little endian byte
+ *                    ordered value from and to then increment by 8-
+ *                    bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  Read8(const void *&p)
+{
+    return IO::Read8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 16-bit little endian byte
+ *                    ordered value from and to then increment by 16-
+ *                    bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t Read16(const void *&p)
+{
+    return ByteOrder::Swap16LittleToHost(IO::Read16(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 32-bit little endian byte
+ *                    ordered value from and to then increment by 32-
+ *                    bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t Read32(const void *&p)
+{
+    return ByteOrder::Swap32LittleToHost(IO::Read32(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 64-bit little endian byte
+ *                    ordered value from and to then increment by 64-
+ *                    bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t Read64(const void *&p)
+{
+    return ByteOrder::Swap64LittleToHost(IO::Read64(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A reference to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 8-bit value to in little endian byte
+ *                    ordering and to then increment by 8-bits (1
+ *                    byte).
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     Write8(void *&p, uint8_t v)
+{
+    IO::Write8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A reference to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 16-bit value to in little endian byte
+ *                    ordering and to then increment by 16-bits (2
+ *                    bytes).
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     Write16(void *&p, uint16_t v)
+{
+    IO::Write16(p, ByteOrder::Swap16HostToLittle(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A reference to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 32-bit value to in little endian byte
+ *                    ordering and to then increment by 16-bits (4
+ *                    bytes).
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     Write32(void *&p, uint32_t v)
+{
+    IO::Write32(p, ByteOrder::Swap32HostToLittle(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A reference to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 64-bit value to in little endian byte
+ *                    ordering and to then increment by 64-bits (8
+ *                    bytes).
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     Write64(void *&p, uint64_t v)
+{
+    IO::Write64(p, ByteOrder::Swap64HostToLittle(v));
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 8-bit little endian byte ordered value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  GetAligned8(const void *p)
+{
+    return IO::GetAligned8(p);
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 16-bit little endian byte ordered value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t GetAligned16(const void *p)
+{
+    return ByteOrder::Swap16LittleToHost(IO::GetAligned16(p));
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 32-bit little endian byte ordered value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t GetAligned32(const void *p)
+{
+    return ByteOrder::Swap32LittleToHost(IO::GetAligned32(p));
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 64-bit little endian byte ordered value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t GetAligned64(const void *p)
+{
+    return ByteOrder::Swap64LittleToHost(IO::GetAligned64(p));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 8-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     PutAligned8(void *p, uint8_t v)
+{
+    IO::PutAligned8(p, v);
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 16-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     PutAligned16(void *p, uint16_t v)
+{
+    IO::PutAligned16(p, ByteOrder::Swap16HostToLittle(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 32-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     PutAligned32(void *p, uint32_t v)
+{
+    IO::PutAligned32(p, ByteOrder::Swap32HostToLittle(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 64-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     PutAligned64(void *p, uint64_t v)
+{
+    IO::PutAligned64(p, ByteOrder::Swap64HostToLittle(v));
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to read the 8-bit little endian byte
+ *                    ordered value from and to then increment by 8-
+ *                    bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  ReadAligned8(const void *&p)
+{
+    return IO::ReadAligned8(p);
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to read the 16-bit little endian byte
+ *                    ordered value from and to then increment by 16-
+ *                    bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t ReadAligned16(const void *&p)
+{
+    return ByteOrder::Swap16LittleToHost(IO::ReadAligned16(p));
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to read the 32-bit little endian byte
+ *                    ordered value from and to then increment by 32-
+ *                    bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t ReadAligned32(const void *&p)
+{
+    return ByteOrder::Swap32LittleToHost(IO::ReadAligned32(p));
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to read the 64-bit little endian byte
+ *                    ordered value from and to then increment by 64-
+ *                    bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t ReadAligned64(const void *&p)
+{
+    return ByteOrder::Swap64LittleToHost(IO::ReadAligned64(p));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to write the target system byte
+ *                    ordered 8-bit value to in little endian byte
+ *                    ordering and to then increment by 8-bits (1
+ *                    byte).
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     WriteAligned8(void *&p, uint8_t v)
+{
+    IO::WriteAligned8(p, v);
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to write the target system byte
+ *                    ordered 16-bit value to in little endian byte
+ *                    ordering and to then increment by 16-bits (2
+ *                    bytes).
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     WriteAligned16(void *&p, uint16_t v)
+{
+    IO::WriteAligned16(p, ByteOrder::Swap16HostToLittle(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to write the target system byte
+ *                    ordered 32-bit value to in little endian byte
+ *                    ordering and to then increment by 16-bits (4
+ *                    bytes).
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     WriteAligned32(void *&p, uint32_t v)
+{
+    IO::WriteAligned32(p, ByteOrder::Swap32HostToLittle(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to write the target system byte
+ *                    ordered 64-bit value to in little endian byte
+ *                    ordering and to then increment by 64-bits (8
+ *                    bytes).
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     WriteAligned64(void *&p, uint64_t v)
+{
+    IO::WriteAligned64(p, ByteOrder::Swap64HostToLittle(v));
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 8-bit little endian byte ordered value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  GetUnaligned8(const void *p)
+{
+    return IO::GetUnaligned8(p);
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 16-bit little endian byte ordered value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t GetUnaligned16(const void *p)
+{
+    return ByteOrder::Swap16LittleToHost(IO::GetUnaligned16(p));
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 32-bit little endian byte ordered value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t GetUnaligned32(const void *p)
+{
+    return ByteOrder::Swap32LittleToHost(IO::GetUnaligned32(p));
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 64-bit little endian byte ordered value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t GetUnaligned64(const void *p)
+{
+    return ByteOrder::Swap64LittleToHost(IO::GetUnaligned64(p));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 8-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     PutUnaligned8(void *p, uint8_t v)
+{
+    IO::PutUnaligned8(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 16-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     PutUnaligned16(void *p, uint16_t v)
+{
+    IO::PutUnaligned16(p, ByteOrder::Swap16HostToLittle(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 32-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     PutUnaligned32(void *p, uint32_t v)
+{
+    IO::PutUnaligned32(p, ByteOrder::Swap32HostToLittle(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 64-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     PutUnaligned64(void *p, uint64_t v)
+{
+    IO::PutUnaligned64(p, ByteOrder::Swap64HostToLittle(v));
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to read the 8-bit little endian byte
+ *                    ordered value from and to then increment by 8-
+ *                    bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  ReadUnaligned8(const void *&p)
+{
+    return IO::ReadUnaligned8(p);
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to read the 16-bit little endian byte
+ *                    ordered value from and to then increment by 16-
+ *                    bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t ReadUnaligned16(const void *&p)
+{
+    return ByteOrder::Swap16LittleToHost(IO::ReadUnaligned16(p));
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to read the 32-bit little endian byte
+ *                    ordered value from and to then increment by 32-
+ *                    bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t ReadUnaligned32(const void *&p)
+{
+    return ByteOrder::Swap32LittleToHost(IO::ReadUnaligned32(p));
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to read the 64-bit little endian byte
+ *                    ordered value from and to then increment by 64-
+ *                    bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t ReadUnaligned64(const void *&p)
+{
+    return ByteOrder::Swap64LittleToHost(IO::ReadUnaligned64(p));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to write the target system byte
+ *                    ordered 8-bit value to in little endian byte
+ *                    ordering and to then increment by 8-bits (1
+ *                    byte).
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     WriteUnaligned8(void *&p, uint8_t v)
+{
+    IO::WriteUnaligned8(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to write the target system byte
+ *                    ordered 16-bit value to in little endian byte
+ *                    ordering and to then increment by 16-bits (2
+ *                    bytes).
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     WriteUnaligned16(void *&p, uint16_t v)
+{
+    IO::WriteUnaligned16(p, ByteOrder::Swap16HostToLittle(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to write the target system byte
+ *                    ordered 32-bit value to in little endian byte
+ *                    ordering and to then increment by 16-bits (4
+ *                    bytes).
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     WriteUnaligned32(void *&p, uint32_t v)
+{
+    IO::WriteUnaligned32(p, ByteOrder::Swap32HostToLittle(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to write the target system byte
+ *                    ordered 64-bit value to in little endian byte
+ *                    ordering and to then increment by 64-bits (8
+ *                    bytes).
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     WriteUnaligned64(void *&p, uint64_t v)
+{
+    IO::WriteUnaligned64(p, ByteOrder::Swap64HostToLittle(v));
+}
+
+} // namespace LittleEndian
+
+} // namespace IO
+
+} // namespace nl
+
+#endif // NLIO_BYTEORDER_LITTLE_HPP
diff --git a/cores/nRF5/nordic/config/nrf52840/config/nlio-byteorder.h b/cores/nRF5/nordic/config/nrf52840/config/nlio-byteorder.h
new file mode 100644
index 000000000..9e6700121
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/nlio-byteorder.h
@@ -0,0 +1,33 @@
+/**
+ *    Copyright 2013-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines C functions for safely performing simple,
+ *      memory-mapped accesses, potentially to unaligned memory
+ *      locations with byte reordering.
+ */
+
+#ifndef NLIO_BYTEORDER_H
+#define NLIO_BYTEORDER_H
+
+#include <nlio-base.h>
+#include <nlbyteorder.h>
+
+#include <nlio-byteorder-big.h>
+#include <nlio-byteorder-little.h>
+
+#endif /* NLIO_BYTEORDER_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/nlio-byteorder.hpp b/cores/nRF5/nordic/config/nrf52840/config/nlio-byteorder.hpp
new file mode 100644
index 000000000..e44256ba4
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/nlio-byteorder.hpp
@@ -0,0 +1,33 @@
+/**
+ *    Copyright 2013-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines C++ functions for safely performing simple,
+ *      memory-mapped accesses, potentially to unaligned memory
+ *      locations with byte reordering.
+ */
+
+#ifndef NLIO_BYTEORDER_HPP
+#define NLIO_BYTEORDER_HPP
+
+#include <nlio-base.hpp>
+#include <nlbyteorder.hpp>
+
+#include <nlio-byteorder-big.hpp>
+#include <nlio-byteorder-little.hpp>
+
+#endif // NLIO_BYTEORDER_HPP
diff --git a/cores/nRF5/nordic/config/nrf52840/config/nlio-config.h.in b/cores/nRF5/nordic/config/nrf52840/config/nlio-config.h.in
new file mode 100644
index 000000000..06cf75832
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/nlio-config.h.in
@@ -0,0 +1,133 @@
+/* include/nlio-config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if your C++ compiler doesn't accept -c and -o together. */
+#undef CXX_NO_MINUS_C_MINUS_O
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you have the <endian.h> header file. */
+#undef HAVE_ENDIAN_H
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the <machine/endian.h> header file. */
+#undef HAVE_MACHINE_ENDIAN_H
+
+/* Define to 1 if you have the `memcpy' function. */
+#undef HAVE_MEMCPY
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the <nlunit-test.h> header file. */
+#undef HAVE_NLUNIT_TEST_H
+
+/* Define to 1 if stdbool.h conforms to C99. */
+#undef HAVE_STDBOOL_H
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define to 1 if the system has the type `_Bool'. */
+#undef HAVE__BOOL
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#undef LT_OBJDIR
+
+/* Define to 1 if your C compiler doesn't accept -c and -o together. */
+#undef NO_MINUS_C_MINUS_O
+
+/* Name of package */
+#undef PACKAGE
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the home page for this package. */
+#undef PACKAGE_URL
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* Version number of package */
+#undef VERSION
+
+/* Define for Solaris 2.5.1 so the uint32_t typedef from <sys/synch.h>,
+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
+   #define below would cause a syntax error. */
+#undef _UINT32_T
+
+/* Define for Solaris 2.5.1 so the uint64_t typedef from <sys/synch.h>,
+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
+   #define below would cause a syntax error. */
+#undef _UINT64_T
+
+/* Define for Solaris 2.5.1 so the uint8_t typedef from <sys/synch.h>,
+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
+   #define below would cause a syntax error. */
+#undef _UINT8_T
+
+/* Define to the type of a signed integer type of width exactly 16 bits if
+   such a type exists and the standard includes do not define it. */
+#undef int16_t
+
+/* Define to the type of a signed integer type of width exactly 32 bits if
+   such a type exists and the standard includes do not define it. */
+#undef int32_t
+
+/* Define to the type of a signed integer type of width exactly 64 bits if
+   such a type exists and the standard includes do not define it. */
+#undef int64_t
+
+/* Define to the type of a signed integer type of width exactly 8 bits if such
+   a type exists and the standard includes do not define it. */
+#undef int8_t
+
+/* Define to the type of an unsigned integer type of width exactly 16 bits if
+   such a type exists and the standard includes do not define it. */
+#undef uint16_t
+
+/* Define to the type of an unsigned integer type of width exactly 32 bits if
+   such a type exists and the standard includes do not define it. */
+#undef uint32_t
+
+/* Define to the type of an unsigned integer type of width exactly 64 bits if
+   such a type exists and the standard includes do not define it. */
+#undef uint64_t
+
+/* Define to the type of an unsigned integer type of width exactly 8 bits if
+   such a type exists and the standard includes do not define it. */
+#undef uint8_t
diff --git a/cores/nRF5/nordic/config/nrf52840/config/nlio-private.h b/cores/nRF5/nordic/config/nrf52840/config/nlio-private.h
new file mode 100644
index 000000000..22dc4d0de
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/nlio-private.h
@@ -0,0 +1,50 @@
+/**
+ *    Copyright 2017 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines private macros and interfaces.
+ */
+
+#ifndef NLIO_PRIVATE_H
+#define NLIO_PRIVATE_H
+
+/*
+ * If we are compiling under clang, GCC, or any such compatible
+ * compiler, in which -fno-builtins or -ffreestanding might be
+ * asserted, thereby eliminating built-in function optimization, we
+ * may STILL want to leverage built-ins.
+ *
+ * Provide an internal convenience macro to do so.
+ */
+
+/**
+ *  @def __nlIOHasBuiltin
+ *
+ *  @brief
+ *     Determines whether or not the compiler in effect has support
+ *     for the specified built-in function.
+ *
+ */
+#ifdef __clang__
+#define __nlIOHasBuiltin(...) __has_builtin(__VA_ARGS__)
+#elif defined __GNUC__
+#define __nlIOHasBuiltin(...) 1
+#else
+#define __nlIOHasBuiltin(...) 0
+#endif /* __clang__ */
+
+#endif /* NLIO_PRIVATE_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/config/nlio.h b/cores/nRF5/nordic/config/nrf52840/config/nlio.h
new file mode 100644
index 000000000..b7068265b
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/nlio.h
@@ -0,0 +1,38 @@
+/**
+ *    Copyright 2013-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file is an umbrella header for the C language definitions
+ *      of functions for safely performing simple, memory-mapped
+ *      accesses, potentially to unaligned memory locations, with or
+ *      without byte reordering.
+ */
+
+#ifndef NLIO_H
+#define NLIO_H
+
+#include <nlio-base.h>
+#include <nlio-byteorder.h>
+
+#endif /* NLIO_H */
+
+
+
+
+
+
+
diff --git a/cores/nRF5/nordic/config/nrf52840/config/nlio.hpp b/cores/nRF5/nordic/config/nrf52840/config/nlio.hpp
new file mode 100644
index 000000000..47487f373
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/nlio.hpp
@@ -0,0 +1,38 @@
+/**
+ *    Copyright 2013-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file is an umbrella header for the C++ language
+ *      definitions of functions for safely performing simple,
+ *      memory-mapped accesses, potentially to unaligned memory
+ *      locations, with or without byte reordering.
+ */
+
+#ifndef NLIO_HPP
+#define NLIO_HPP
+
+#include <nlio-base.hpp>
+#include <nlio-byteorder.hpp>
+
+#endif // NLIO_HPP
+
+
+
+
+
+
+
diff --git a/cores/nRF5/nordic/config/nrf52840/config/protocols/interaction_model/Constants.h b/cores/nRF5/nordic/config/nrf52840/config/protocols/interaction_model/Constants.h
new file mode 100644
index 000000000..80fcbf3b0
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/protocols/interaction_model/Constants.h
@@ -0,0 +1,125 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *    All rights reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      The defines constants for the CHIP Interaction Model Protocol, present in
+ *      every CHIP device.
+ *
+ */
+
+#pragma once
+
+#include <protocols/Protocols.h>
+
+/**
+ *   @namespace chip::Protocols::InteractionModel
+ *
+ *   @brief
+ *     This namespace includes all interfaces within CHIP for the
+ *     CHIP InteractionModel protocol.
+ *
+ *     The interfaces define message types.
+ */
+
+namespace chip {
+namespace Protocols {
+namespace InteractionModel {
+
+/**
+ * Version of the Interaction Model used by the node.
+ */
+constexpr uint16_t kVersion = 0;
+
+/**
+ * SecureChannel Protocol Message Types
+ */
+enum class MsgType : uint8_t
+{
+    ReadRequest           = 0x02,
+    SubscribeRequest      = 0x03,
+    SubscribeResponse     = 0x04,
+    ReportData            = 0x05,
+    WriteRequest          = 0x06,
+    WriteResponse         = 0x07,
+    InvokeCommandRequest  = 0x08,
+    InvokeCommandResponse = 0x09,
+    TimedRequest          = 0x0a,
+};
+
+// This table comes from the IM's "Status Code Table" section from the Interaction Model spec.
+enum class ProtocolCode : uint16_t
+{
+    Success                = 0x0,
+    Failure                = 0x01,
+    InvalidSubscription    = 0x7d,
+    UnsupportedAccess      = 0x7e,
+    UnsupportedEndpoint    = 0x7f,
+    InvalidAction          = 0x80,
+    UnsupportedCommand     = 0x81,
+    Reserved82             = 0x82,
+    Reserved83             = 0x83,
+    Reserved84             = 0x84,
+    InvalidCommand         = 0x85,
+    UnsupportedAttribute   = 0x86,
+    InvalidValue           = 0x87,
+    UnsupportedWrite       = 0x88,
+    ResourceExhausted      = 0x89,
+    Reserved8a             = 0x8a,
+    NotFound               = 0x8b,
+    UnreportableAttribute  = 0x8c,
+    InvalidDataType        = 0x8d,
+    Reserved8e             = 0x8e,
+    UnsupportedRead        = 0x8f,
+    Reserved90             = 0x90,
+    Reserved91             = 0x91,
+    Reserved92             = 0x92,
+    Reserved93             = 0x93,
+    Timeout                = 0x94,
+    Reserved95             = 0x95,
+    Reserved96             = 0x96,
+    Reserved97             = 0x97,
+    Reserved98             = 0x98,
+    Reserved99             = 0x99,
+    Reserved9a             = 0x9a,
+    ConstraintError        = 0x9b,
+    Busy                   = 0x9c,
+    Reservedc0             = 0xc0,
+    Reservedc1             = 0xc1,
+    Reservedc2             = 0xc2,
+    UnsupportedCluster     = 0xc3,
+    Reservedc4             = 0xc4,
+    NoUpstreamSubscription = 0xc5,
+    InvalidArgument        = 0xc6,
+};
+
+inline uint16_t ToUint16(ProtocolCode aProtocolCode)
+{
+    static_assert(std::is_same<uint16_t, std::underlying_type_t<ProtocolCode>>::value, "Cast might not be right");
+    return static_cast<uint16_t>(aProtocolCode);
+}
+} // namespace InteractionModel
+
+template <>
+struct MessageTypeTraits<InteractionModel::MsgType>
+{
+    static constexpr const Protocols::Id & ProtocolId() { return InteractionModel::Id; }
+};
+
+} // namespace Protocols
+} // namespace chip
diff --git a/cores/nRF5/nordic/config/nrf52840/config/protocols/secure_channel/Constants.h b/cores/nRF5/nordic/config/nrf52840/config/protocols/secure_channel/Constants.h
new file mode 100644
index 000000000..303244cec
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/config/protocols/secure_channel/Constants.h
@@ -0,0 +1,123 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *    All rights reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      The defines constants for the CHIP Secure Channel Protocol, present in
+ *      every CHIP device.
+ *
+ */
+
+#pragma once
+
+#include <protocols/Protocols.h>
+#include <support/CodeUtils.h>
+
+/**
+ *   @namespace chip::Protocols::SecureChannel
+ *
+ *   @brief
+ *     This namespace includes all interfaces within CHIP for the
+ *     CHIP SecureChannel protocol.
+ *
+ *     The interfaces define message types and status codes.
+ */
+
+namespace chip {
+namespace Protocols {
+namespace SecureChannel {
+
+/**
+ * SecureChannel Protocol Message Types
+ */
+enum class MsgType : uint8_t
+{
+    // Message Counter Synchronization Protocol Message Types
+    MsgCounterSyncReq = 0x00,
+    MsgCounterSyncRsp = 0x01,
+
+    // Reliable Messaging Protocol Message Types
+    StandaloneAck = 0x10,
+
+    // Password-based session establishment Message Types
+    PBKDFParamRequest  = 0x20,
+    PBKDFParamResponse = 0x21,
+    PASE_Spake2p1      = 0x22,
+    PASE_Spake2p2      = 0x23,
+    PASE_Spake2p3      = 0x24,
+    PASE_Spake2pError  = 0x2F,
+
+    // Certificate-based session establishment Message Types
+    CASE_SigmaR1  = 0x30,
+    CASE_SigmaR2  = 0x31,
+    CASE_SigmaR3  = 0x32,
+    CASE_SigmaErr = 0x3F,
+
+    StatusReport = 0x40,
+};
+
+// Placeholder value for the ProtocolCode field when the GeneralCode is Success or Continue.
+constexpr uint16_t kProtocolCodeSuccess = 0x0000;
+
+// Placeholder value for the ProtocolCode field when there is no additional protocol-specific code to provide more information.
+constexpr uint16_t kProtocolCodeGeneralFailure = 0xFFFF;
+
+/**
+ * Status Report - General Status Codes used to convey protocol-agnostic status info.
+ */
+enum class GeneralStatusCode : uint16_t
+{
+    kSuccess           = 0,  /**< Operation completed successfully. */
+    kFailure           = 1,  /**< Generic failure, additional details may be included in the protocol specific status. */
+    kBadPrecondition   = 2,  /**< Operation was rejected by the system because the system is in an invalid state. */
+    kOutOfRange        = 3,  /**< A value was out of a required range. */
+    kBadRequest        = 4,  /**< A request was unrecognized or malformed. */
+    kUnsupported       = 5,  /**< An unrecognized or unsupported request was received. */
+    kUnexpected        = 6,  /**< A request was not expected at this time. */
+    kResourceExhausted = 7,  /**< Insufficient resources to process the given request. */
+    kBusy              = 8,  /**< Device is busy and cannot handle this request at this time. */
+    kTimeout           = 9,  /**< A timeout occurred. */
+    kContinue          = 10, /**< Context-specific signal to proceed. */
+    kAborted           = 11, /**< Failure, often due to a concurrency error. */
+    kInvalidArgument   = 12, /**< An invalid/unsupported argument was provided. */
+    kNotFound          = 13, /**< Some requested entity was not found. */
+    kAlreadyExists     = 14, /**< The caller attempted to create something that already exists. */
+    kPermissionDenied  = 15, /**< Caller does not have sufficient permissions to execute the requested operations. */
+    kDataLoss          = 16, /**< Unrecoverable data loss or corruption has occurred. */
+};
+
+/**
+ * Status Report - Status Codes specific only to the SecureChannel Protocol
+ */
+enum class StatusCode
+{
+    AlreadyMemberOfFabric = 1, /**< The recipient is already a member of a fabric. */
+    NotMemberOfFabric     = 2, /**< The recipient is not a member of a fabric. */
+    InvalidFabricConfig   = 3  /**< The specified fabric configuration was invalid. */
+};
+
+} // namespace SecureChannel
+
+template <>
+struct MessageTypeTraits<SecureChannel::MsgType>
+{
+    static constexpr const Protocols::Id & ProtocolId() { return SecureChannel::Id; }
+};
+
+} // namespace Protocols
+} // namespace chip
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/SEGGER_RTT_BuildConfig.h b/cores/nRF5/nordic/config/nrf52840/configxx/SEGGER_RTT_BuildConfig.h
new file mode 100644
index 000000000..6573f2b67
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/SEGGER_RTT_BuildConfig.h
@@ -0,0 +1,13 @@
+// Generated by write_buildconfig_header.py
+// From "//third_party/connectedhomeip/third_party/jlink/segger_rtt/RTT:gen_rtt_buildconfig"
+
+#ifndef RTT_SEGGER_RTT_BUILDCONFIG_H_
+#define RTT_SEGGER_RTT_BUILDCONFIG_H_
+
+#define RTT_USE_ASM 1
+#define BUFFER_SIZE_UP 4096
+#define SEGGER_RTT_MAX_NUM_UP_BUFFERS 2
+#define SEGGER_RTT_MAX_NUM_UP_BUFFERS 2
+#define SEGGER_RTT_MODE_DEFAULT SEGGER_RTT_MODE_NO_BLOCK_TRIM
+
+#endif  // RTT_SEGGER_RTT_BUILDCONFIG_H_
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/app/AppBuildConfig.h b/cores/nRF5/nordic/config/nrf52840/configxx/app/AppBuildConfig.h
new file mode 100644
index 000000000..e28dfaae0
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/app/AppBuildConfig.h
@@ -0,0 +1,9 @@
+// Generated by write_buildconfig_header.py
+// From "//third_party/connectedhomeip/src/app:gen_app_buildconfig"
+
+#ifndef APP_APPBUILDCONFIG_H_
+#define APP_APPBUILDCONFIG_H_
+
+#define CHIP_CONFIG_IM_ENABLE_SCHEMA_CHECK 0
+
+#endif  // APP_APPBUILDCONFIG_H_
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/arch/cc.h b/cores/nRF5/nordic/config/nrf52840/configxx/arch/cc.h
new file mode 100644
index 000000000..292118fe9
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/arch/cc.h
@@ -0,0 +1,99 @@
+/*
+ *    Copyright (c) 2020 Project CHIP Authors
+ *    Copyright (c) 2018-2019 Google LLC.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/*
+ *
+ *    Description:
+ *      This file defines processor-architecture- and toolchain-
+ *      specific constants and types required for building
+ *      LwIP against FreeRTOS.
+ *
+ */
+
+#ifndef CHIP_LWIP_FREERTOS_ARCH_CC_H
+#define CHIP_LWIP_FREERTOS_ARCH_CC_H
+
+#include <errno.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#if CHIP_CONFIG_MEMORY_MGMT_MALLOC
+#include <malloc.h>
+#endif
+
+#include <sys/time.h>
+
+#include "app_error.h"
+
+#if __cplusplus
+extern "C" {
+#endif
+
+#ifndef LWIP_NOASSERT
+#ifdef DEBUG
+#define LWIP_PLATFORM_ASSERT(MSG) APP_ERROR_HANDLER(0)
+#else
+#define LWIP_PLATFORM_ASSERT(MSG) APP_ERROR_HANDLER(0)
+#endif
+#else
+#define LWIP_PLATFORM_ASSERT(message)
+#endif
+
+#ifndef BYTE_ORDER
+#if defined(__LITTLE_ENDIAN__)
+#define BYTE_ORDER LITTLE_ENDIAN
+#elif defined(__BIG_ENDIAN__)
+#define BYTE_ORDER BIG_ENDIAN
+#elif defined(__BYTE_ORDER__)
+#define BYTE_ORDER __BYTE_ORDER__
+#endif
+#endif // BYTE_ORDER
+
+#define PACK_STRUCT_STRUCT __attribute__((__packed__))
+#define PACK_STRUCT_FIELD(x) x
+
+extern void LwIPLog(const char * fmt, ...);
+#define LWIP_PLATFORM_DIAG(x)                                                                                                      \
+    do                                                                                                                             \
+    {                                                                                                                              \
+        LwIPLog x;                                                                                                                 \
+    } while (0)
+
+// Place LwIP pools into their own subsections of .bss to make it easier to see
+// their sizes in the linker map file.
+extern uint8_t __attribute__((section(".bss.lwip_ND6_QUEUE"))) memp_memory_ND6_QUEUE_base[];
+extern uint8_t __attribute__((section(".bss.lwip_IP6_REASSDATA"))) memp_memory_IP6_REASSDATA_base[];
+extern uint8_t __attribute__((section(".bss.lwip_RAW_PCB"))) memp_memory_RAW_PCB_base[];
+extern uint8_t __attribute__((section(".bss.lwip_TCP_SEG"))) memp_memory_TCP_SEG_base[];
+extern uint8_t __attribute__((section(".bss.lwip_PBUF_POOL"))) memp_memory_PBUF_POOL_base[];
+extern uint8_t __attribute__((section(".bss.lwip_FRAG_PBUF"))) memp_memory_FRAG_PBUF_base[];
+extern uint8_t __attribute__((section(".bss.lwip_PBUF"))) memp_memory_PBUF_base[];
+extern uint8_t __attribute__((section(".bss.lwip_TCP_PCB_LISTEN"))) memp_memory_TCP_PCB_LISTEN_base[];
+extern uint8_t __attribute__((section(".bss.lwip_REASSDATA"))) memp_memory_REASSDATA_base[];
+extern uint8_t __attribute__((section(".bss.lwip_UDP_PCB"))) memp_memory_UDP_PCB_base[];
+extern uint8_t __attribute__((section(".bss.lwip_MLD6_GROUP"))) memp_memory_MLD6_GROUP_base[];
+extern uint8_t __attribute__((section(".bss.lwip_IGMP_GROUP"))) memp_memory_IGMP_GROUP_base[];
+extern uint8_t __attribute__((section(".bss.lwip_TCP_PCB"))) memp_memory_TCP_PCB_base[];
+extern uint8_t __attribute__((section(".bss.lwip_SYS_TIMEOUT"))) memp_memory_SYS_TIMEOUT_base[];
+
+#if __cplusplus
+}
+#endif
+
+#endif /* CHIP_LWIP_FREERTOS_ARCH_CC_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/arch/perf.h b/cores/nRF5/nordic/config/nrf52840/configxx/arch/perf.h
new file mode 100644
index 000000000..5c1594273
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/arch/perf.h
@@ -0,0 +1,33 @@
+/*
+ *    Copyright (c) 2020 Project CHIP Authors
+ *    Copyright (c) 2018-2019 Google LLC.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/*
+ *
+ *    Description:
+ *      This file defines processor-architecture-specific constants,
+ *      interfaces and types required for LwIP performance
+ *      measurement.
+ *
+ */
+
+#ifndef CHIP_LWIP_FREERTOS_ARCH_PERF_H
+#define CHIP_LWIP_FREERTOS_ARCH_PERF_H
+
+#define PERF_START
+#define PERF_STOP(s)
+
+#endif /* CHIP_LWIP_FREERTOS_ARCH_PERF_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/arch/sys_arch.h b/cores/nRF5/nordic/config/nrf52840/configxx/arch/sys_arch.h
new file mode 100644
index 000000000..e69de29bb
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/asn1/ASN1OID.h b/cores/nRF5/nordic/config/nrf52840/configxx/asn1/ASN1OID.h
new file mode 100644
index 000000000..093fed163
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/asn1/ASN1OID.h
@@ -0,0 +1,252 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *    Copyright (c) 2019 Google LLC.
+ *    Copyright (c) 2013-2017 Nest Labs, Inc.
+ *    All rights reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ *
+ */
+
+/**
+ *    @file
+ *      ASN.1 Object ID Definitions
+ *
+ *      !!! WARNING !!! WARNING !!! WARNING !!!
+ *
+ *      DO NOT EDIT THIS FILE! This file is generated by the
+ *      gen-oid-table.py script.
+ *
+ *      To make changes, edit the script and re-run it to generate
+ *      this file.
+ *
+ */
+
+#pragma once
+
+enum OIDCategory
+{
+    kOIDCategory_PubKeyAlgo = 0x0100,
+    kOIDCategory_SigAlgo = 0x0200,
+    kOIDCategory_AttributeType = 0x0300,
+    kOIDCategory_EllipticCurve = 0x0400,
+    kOIDCategory_Extension = 0x0500,
+    kOIDCategory_KeyPurpose = 0x0600,
+
+    kOIDCategory_NotSpecified = 0,
+    kOIDCategory_Unknown = 0x0F00,
+    kOIDCategory_Mask = 0x0F00
+};
+
+typedef uint16_t OID;
+
+enum
+{
+    kOID_PubKeyAlgo_ECPublicKey = 0x0101,
+
+    kOID_SigAlgo_ECDSAWithSHA256 = 0x0201,
+
+    kOID_AttributeType_CommonName = 0x0301,
+    kOID_AttributeType_Surname = 0x0302,
+    kOID_AttributeType_SerialNumber = 0x0303,
+    kOID_AttributeType_CountryName = 0x0304,
+    kOID_AttributeType_LocalityName = 0x0305,
+    kOID_AttributeType_StateOrProvinceName = 0x0306,
+    kOID_AttributeType_OrganizationName = 0x0307,
+    kOID_AttributeType_OrganizationalUnitName = 0x0308,
+    kOID_AttributeType_Title = 0x0309,
+    kOID_AttributeType_Name = 0x030A,
+    kOID_AttributeType_GivenName = 0x030B,
+    kOID_AttributeType_Initials = 0x030C,
+    kOID_AttributeType_GenerationQualifier = 0x030D,
+    kOID_AttributeType_DNQualifier = 0x030E,
+    kOID_AttributeType_Pseudonym = 0x030F,
+    kOID_AttributeType_DomainComponent = 0x0310,
+    kOID_AttributeType_ChipNodeId = 0x0311,
+    kOID_AttributeType_ChipFirmwareSigningId = 0x0312,
+    kOID_AttributeType_ChipICAId = 0x0313,
+    kOID_AttributeType_ChipRootId = 0x0314,
+    kOID_AttributeType_ChipFabricId = 0x0315,
+    kOID_AttributeType_ChipAuthTag1 = 0x0316,
+    kOID_AttributeType_ChipAuthTag2 = 0x0317,
+
+    kOID_EllipticCurve_prime256v1 = 0x0401,
+
+    kOID_Extension_BasicConstraints = 0x0501,
+    kOID_Extension_KeyUsage = 0x0502,
+    kOID_Extension_ExtendedKeyUsage = 0x0503,
+    kOID_Extension_SubjectKeyIdentifier = 0x0504,
+    kOID_Extension_AuthorityKeyIdentifier = 0x0505,
+
+    kOID_KeyPurpose_ServerAuth = 0x0601,
+    kOID_KeyPurpose_ClientAuth = 0x0602,
+    kOID_KeyPurpose_CodeSigning = 0x0603,
+    kOID_KeyPurpose_EmailProtection = 0x0604,
+    kOID_KeyPurpose_TimeStamping = 0x0605,
+    kOID_KeyPurpose_OCSPSigning = 0x0606,
+
+    kOID_NotSpecified = 0,
+    kOID_Unknown = 0xFFFF,
+    kOID_EnumMask = 0x00FF
+};
+
+struct OIDTableEntry
+{
+    OID EnumVal;
+    const uint8_t *EncodedOID;
+    uint16_t EncodedOIDLen;
+};
+
+struct OIDNameTableEntry
+{
+    OID EnumVal;
+    const char *Name;
+};
+
+extern const OIDTableEntry sOIDTable[];
+extern const OIDNameTableEntry sOIDNameTable[];
+extern const size_t sOIDTableSize;
+
+#ifdef ASN1_DEFINE_OID_TABLE
+
+static const uint8_t sOID_PubKeyAlgo_ECPublicKey[] = { 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x02, 0x01 };
+static const uint8_t sOID_SigAlgo_ECDSAWithSHA256[] = { 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x04, 0x03, 0x02 };
+static const uint8_t sOID_AttributeType_CommonName[] = { 0x55, 0x04, 0x03 };
+static const uint8_t sOID_AttributeType_Surname[] = { 0x55, 0x04, 0x04 };
+static const uint8_t sOID_AttributeType_SerialNumber[] = { 0x55, 0x04, 0x05 };
+static const uint8_t sOID_AttributeType_CountryName[] = { 0x55, 0x04, 0x06 };
+static const uint8_t sOID_AttributeType_LocalityName[] = { 0x55, 0x04, 0x07 };
+static const uint8_t sOID_AttributeType_StateOrProvinceName[] = { 0x55, 0x04, 0x08 };
+static const uint8_t sOID_AttributeType_OrganizationName[] = { 0x55, 0x04, 0x0A };
+static const uint8_t sOID_AttributeType_OrganizationalUnitName[] = { 0x55, 0x04, 0x0B };
+static const uint8_t sOID_AttributeType_Title[] = { 0x55, 0x04, 0x0C };
+static const uint8_t sOID_AttributeType_Name[] = { 0x55, 0x04, 0x29 };
+static const uint8_t sOID_AttributeType_GivenName[] = { 0x55, 0x04, 0x2A };
+static const uint8_t sOID_AttributeType_Initials[] = { 0x55, 0x04, 0x2B };
+static const uint8_t sOID_AttributeType_GenerationQualifier[] = { 0x55, 0x04, 0x2C };
+static const uint8_t sOID_AttributeType_DNQualifier[] = { 0x55, 0x04, 0x2E };
+static const uint8_t sOID_AttributeType_Pseudonym[] = { 0x55, 0x04, 0x41 };
+static const uint8_t sOID_AttributeType_DomainComponent[] = { 0x09, 0x92, 0x26, 0x89, 0x93, 0xF2, 0x2C, 0x64, 0x01, 0x19 };
+static const uint8_t sOID_AttributeType_ChipNodeId[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0xA2, 0x7C, 0x01, 0x01 };
+static const uint8_t sOID_AttributeType_ChipFirmwareSigningId[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0xA2, 0x7C, 0x01, 0x02 };
+static const uint8_t sOID_AttributeType_ChipICAId[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0xA2, 0x7C, 0x01, 0x03 };
+static const uint8_t sOID_AttributeType_ChipRootId[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0xA2, 0x7C, 0x01, 0x04 };
+static const uint8_t sOID_AttributeType_ChipFabricId[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0xA2, 0x7C, 0x01, 0x05 };
+static const uint8_t sOID_AttributeType_ChipAuthTag1[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0xA2, 0x7C, 0x01, 0x06 };
+static const uint8_t sOID_AttributeType_ChipAuthTag2[] = { 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0xA2, 0x7C, 0x01, 0x07 };
+static const uint8_t sOID_EllipticCurve_prime256v1[] = { 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07 };
+static const uint8_t sOID_Extension_BasicConstraints[] = { 0x55, 0x1D, 0x13 };
+static const uint8_t sOID_Extension_KeyUsage[] = { 0x55, 0x1D, 0x0F };
+static const uint8_t sOID_Extension_ExtendedKeyUsage[] = { 0x55, 0x1D, 0x25 };
+static const uint8_t sOID_Extension_SubjectKeyIdentifier[] = { 0x55, 0x1D, 0x0E };
+static const uint8_t sOID_Extension_AuthorityKeyIdentifier[] = { 0x55, 0x1D, 0x23 };
+static const uint8_t sOID_KeyPurpose_ServerAuth[] = { 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x01 };
+static const uint8_t sOID_KeyPurpose_ClientAuth[] = { 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x02 };
+static const uint8_t sOID_KeyPurpose_CodeSigning[] = { 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x03 };
+static const uint8_t sOID_KeyPurpose_EmailProtection[] = { 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x04 };
+static const uint8_t sOID_KeyPurpose_TimeStamping[] = { 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x08 };
+static const uint8_t sOID_KeyPurpose_OCSPSigning[] = { 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x09 };
+
+
+const OIDTableEntry sOIDTable[] =
+{
+    { kOID_PubKeyAlgo_ECPublicKey, sOID_PubKeyAlgo_ECPublicKey, sizeof(sOID_PubKeyAlgo_ECPublicKey) },
+    { kOID_SigAlgo_ECDSAWithSHA256, sOID_SigAlgo_ECDSAWithSHA256, sizeof(sOID_SigAlgo_ECDSAWithSHA256) },
+    { kOID_AttributeType_CommonName, sOID_AttributeType_CommonName, sizeof(sOID_AttributeType_CommonName) },
+    { kOID_AttributeType_Surname, sOID_AttributeType_Surname, sizeof(sOID_AttributeType_Surname) },
+    { kOID_AttributeType_SerialNumber, sOID_AttributeType_SerialNumber, sizeof(sOID_AttributeType_SerialNumber) },
+    { kOID_AttributeType_CountryName, sOID_AttributeType_CountryName, sizeof(sOID_AttributeType_CountryName) },
+    { kOID_AttributeType_LocalityName, sOID_AttributeType_LocalityName, sizeof(sOID_AttributeType_LocalityName) },
+    { kOID_AttributeType_StateOrProvinceName, sOID_AttributeType_StateOrProvinceName, sizeof(sOID_AttributeType_StateOrProvinceName) },
+    { kOID_AttributeType_OrganizationName, sOID_AttributeType_OrganizationName, sizeof(sOID_AttributeType_OrganizationName) },
+    { kOID_AttributeType_OrganizationalUnitName, sOID_AttributeType_OrganizationalUnitName, sizeof(sOID_AttributeType_OrganizationalUnitName) },
+    { kOID_AttributeType_Title, sOID_AttributeType_Title, sizeof(sOID_AttributeType_Title) },
+    { kOID_AttributeType_Name, sOID_AttributeType_Name, sizeof(sOID_AttributeType_Name) },
+    { kOID_AttributeType_GivenName, sOID_AttributeType_GivenName, sizeof(sOID_AttributeType_GivenName) },
+    { kOID_AttributeType_Initials, sOID_AttributeType_Initials, sizeof(sOID_AttributeType_Initials) },
+    { kOID_AttributeType_GenerationQualifier, sOID_AttributeType_GenerationQualifier, sizeof(sOID_AttributeType_GenerationQualifier) },
+    { kOID_AttributeType_DNQualifier, sOID_AttributeType_DNQualifier, sizeof(sOID_AttributeType_DNQualifier) },
+    { kOID_AttributeType_Pseudonym, sOID_AttributeType_Pseudonym, sizeof(sOID_AttributeType_Pseudonym) },
+    { kOID_AttributeType_DomainComponent, sOID_AttributeType_DomainComponent, sizeof(sOID_AttributeType_DomainComponent) },
+    { kOID_AttributeType_ChipNodeId, sOID_AttributeType_ChipNodeId, sizeof(sOID_AttributeType_ChipNodeId) },
+    { kOID_AttributeType_ChipFirmwareSigningId, sOID_AttributeType_ChipFirmwareSigningId, sizeof(sOID_AttributeType_ChipFirmwareSigningId) },
+    { kOID_AttributeType_ChipICAId, sOID_AttributeType_ChipICAId, sizeof(sOID_AttributeType_ChipICAId) },
+    { kOID_AttributeType_ChipRootId, sOID_AttributeType_ChipRootId, sizeof(sOID_AttributeType_ChipRootId) },
+    { kOID_AttributeType_ChipFabricId, sOID_AttributeType_ChipFabricId, sizeof(sOID_AttributeType_ChipFabricId) },
+    { kOID_AttributeType_ChipAuthTag1, sOID_AttributeType_ChipAuthTag1, sizeof(sOID_AttributeType_ChipAuthTag1) },
+    { kOID_AttributeType_ChipAuthTag2, sOID_AttributeType_ChipAuthTag2, sizeof(sOID_AttributeType_ChipAuthTag2) },
+    { kOID_EllipticCurve_prime256v1, sOID_EllipticCurve_prime256v1, sizeof(sOID_EllipticCurve_prime256v1) },
+    { kOID_Extension_BasicConstraints, sOID_Extension_BasicConstraints, sizeof(sOID_Extension_BasicConstraints) },
+    { kOID_Extension_KeyUsage, sOID_Extension_KeyUsage, sizeof(sOID_Extension_KeyUsage) },
+    { kOID_Extension_ExtendedKeyUsage, sOID_Extension_ExtendedKeyUsage, sizeof(sOID_Extension_ExtendedKeyUsage) },
+    { kOID_Extension_SubjectKeyIdentifier, sOID_Extension_SubjectKeyIdentifier, sizeof(sOID_Extension_SubjectKeyIdentifier) },
+    { kOID_Extension_AuthorityKeyIdentifier, sOID_Extension_AuthorityKeyIdentifier, sizeof(sOID_Extension_AuthorityKeyIdentifier) },
+    { kOID_KeyPurpose_ServerAuth, sOID_KeyPurpose_ServerAuth, sizeof(sOID_KeyPurpose_ServerAuth) },
+    { kOID_KeyPurpose_ClientAuth, sOID_KeyPurpose_ClientAuth, sizeof(sOID_KeyPurpose_ClientAuth) },
+    { kOID_KeyPurpose_CodeSigning, sOID_KeyPurpose_CodeSigning, sizeof(sOID_KeyPurpose_CodeSigning) },
+    { kOID_KeyPurpose_EmailProtection, sOID_KeyPurpose_EmailProtection, sizeof(sOID_KeyPurpose_EmailProtection) },
+    { kOID_KeyPurpose_TimeStamping, sOID_KeyPurpose_TimeStamping, sizeof(sOID_KeyPurpose_TimeStamping) },
+    { kOID_KeyPurpose_OCSPSigning, sOID_KeyPurpose_OCSPSigning, sizeof(sOID_KeyPurpose_OCSPSigning) },
+    { kOID_NotSpecified, NULL, 0 }
+};
+
+const size_t sOIDTableSize = sizeof(sOIDTable) / sizeof(OIDTableEntry);
+
+#endif // ASN1_DEFINE_OID_TABLE
+
+#ifdef ASN1_DEFINE_OID_NAME_TABLE
+
+const OIDNameTableEntry sOIDNameTable[] =
+{
+    { kOID_PubKeyAlgo_ECPublicKey, "ECPublicKey" },
+    { kOID_SigAlgo_ECDSAWithSHA256, "ECDSAWithSHA256" },
+    { kOID_AttributeType_CommonName, "CommonName" },
+    { kOID_AttributeType_Surname, "Surname" },
+    { kOID_AttributeType_SerialNumber, "SerialNumber" },
+    { kOID_AttributeType_CountryName, "CountryName" },
+    { kOID_AttributeType_LocalityName, "LocalityName" },
+    { kOID_AttributeType_StateOrProvinceName, "StateOrProvinceName" },
+    { kOID_AttributeType_OrganizationName, "OrganizationName" },
+    { kOID_AttributeType_OrganizationalUnitName, "OrganizationalUnitName" },
+    { kOID_AttributeType_Title, "Title" },
+    { kOID_AttributeType_Name, "Name" },
+    { kOID_AttributeType_GivenName, "GivenName" },
+    { kOID_AttributeType_Initials, "Initials" },
+    { kOID_AttributeType_GenerationQualifier, "GenerationQualifier" },
+    { kOID_AttributeType_DNQualifier, "DNQualifier" },
+    { kOID_AttributeType_Pseudonym, "Pseudonym" },
+    { kOID_AttributeType_DomainComponent, "DomainComponent" },
+    { kOID_AttributeType_ChipNodeId, "ChipNodeId" },
+    { kOID_AttributeType_ChipFirmwareSigningId, "ChipFirmwareSigningId" },
+    { kOID_AttributeType_ChipICAId, "ChipICAId" },
+    { kOID_AttributeType_ChipRootId, "ChipRootId" },
+    { kOID_AttributeType_ChipFabricId, "ChipFabricId" },
+    { kOID_AttributeType_ChipAuthTag1, "ChipAuthTag1" },
+    { kOID_AttributeType_ChipAuthTag2, "ChipAuthTag2" },
+    { kOID_EllipticCurve_prime256v1, "prime256v1" },
+    { kOID_Extension_BasicConstraints, "BasicConstraints" },
+    { kOID_Extension_KeyUsage, "KeyUsage" },
+    { kOID_Extension_ExtendedKeyUsage, "ExtendedKeyUsage" },
+    { kOID_Extension_SubjectKeyIdentifier, "SubjectKeyIdentifier" },
+    { kOID_Extension_AuthorityKeyIdentifier, "AuthorityKeyIdentifier" },
+    { kOID_KeyPurpose_ServerAuth, "ServerAuth" },
+    { kOID_KeyPurpose_ClientAuth, "ClientAuth" },
+    { kOID_KeyPurpose_CodeSigning, "CodeSigning" },
+    { kOID_KeyPurpose_EmailProtection, "EmailProtection" },
+    { kOID_KeyPurpose_TimeStamping, "TimeStamping" },
+    { kOID_KeyPurpose_OCSPSigning, "OCSPSigning" },
+    { kOID_NotSpecified, NULL }
+};
+
+#endif // ASN1_DEFINE_OID_NAME_TABLE
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/api.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/api.h
new file mode 100644
index 000000000..516bd163d
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/api.h
@@ -0,0 +1,400 @@
+/**
+ * @file
+ * netconn API (to be used from non-TCPIP threads)
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_API_H
+#define LWIP_HDR_API_H
+
+#include "lwip/opt.h"
+
+#if LWIP_NETCONN || LWIP_SOCKET /* don't build if not configured for use in lwipopts.h */
+/* Note: Netconn API is always available when sockets are enabled -
+ * sockets are implemented on top of them */
+
+#include "lwip/arch.h"
+#include "lwip/netbuf.h"
+#include "lwip/sys.h"
+#include "lwip/ip_addr.h"
+#include "lwip/err.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Throughout this file, IP addresses and port numbers are expected to be in
+ * the same byte order as in the corresponding pcb.
+ */
+
+/* Flags for netconn_write (u8_t) */
+#define NETCONN_NOFLAG    0x00
+#define NETCONN_NOCOPY    0x00 /* Only for source code compatibility */
+#define NETCONN_COPY      0x01
+#define NETCONN_MORE      0x02
+#define NETCONN_DONTBLOCK 0x04
+
+/* Flags for struct netconn.flags (u8_t) */
+/** Should this netconn avoid blocking? */
+#define NETCONN_FLAG_NON_BLOCKING             0x02
+/** Was the last connect action a non-blocking one? */
+#define NETCONN_FLAG_IN_NONBLOCKING_CONNECT   0x04
+/** If a nonblocking write has been rejected before, poll_tcp needs to
+    check if the netconn is writable again */
+#define NETCONN_FLAG_CHECK_WRITESPACE         0x10
+#if LWIP_IPV6
+/** If this flag is set then only IPv6 communication is allowed on the
+    netconn. As per RFC#3493 this features defaults to OFF allowing
+    dual-stack usage by default. */
+#define NETCONN_FLAG_IPV6_V6ONLY              0x20
+#endif /* LWIP_IPV6 */
+
+
+/* Helpers to process several netconn_types by the same code */
+#define NETCONNTYPE_GROUP(t)         ((t)&0xF0)
+#define NETCONNTYPE_DATAGRAM(t)      ((t)&0xE0)
+#if LWIP_IPV6
+#define NETCONN_TYPE_IPV6            0x08
+#define NETCONNTYPE_ISIPV6(t)        (((t)&NETCONN_TYPE_IPV6) != 0)
+#define NETCONNTYPE_ISUDPLITE(t)     (((t)&0xF3) == NETCONN_UDPLITE)
+#define NETCONNTYPE_ISUDPNOCHKSUM(t) (((t)&0xF3) == NETCONN_UDPNOCHKSUM)
+#else /* LWIP_IPV6 */
+#define NETCONNTYPE_ISIPV6(t)        (0)
+#define NETCONNTYPE_ISUDPLITE(t)     ((t) == NETCONN_UDPLITE)
+#define NETCONNTYPE_ISUDPNOCHKSUM(t) ((t) == NETCONN_UDPNOCHKSUM)
+#endif /* LWIP_IPV6 */
+
+/** @ingroup netconn_common
+ * Protocol family and type of the netconn
+ */
+enum netconn_type {
+  NETCONN_INVALID     = 0,
+  /** TCP IPv4 */
+  NETCONN_TCP         = 0x10,
+#if LWIP_IPV6
+  /** TCP IPv6 */
+  NETCONN_TCP_IPV6    = NETCONN_TCP | NETCONN_TYPE_IPV6 /* 0x18 */,
+#endif /* LWIP_IPV6 */
+  /** UDP IPv4 */
+  NETCONN_UDP         = 0x20,
+  /** UDP IPv4 lite */
+  NETCONN_UDPLITE     = 0x21,
+  /** UDP IPv4 no checksum */
+  NETCONN_UDPNOCHKSUM = 0x22,
+
+#if LWIP_IPV6
+  /** UDP IPv6 (dual-stack by default, unless you call @ref netconn_set_ipv6only) */
+  NETCONN_UDP_IPV6         = NETCONN_UDP | NETCONN_TYPE_IPV6 /* 0x28 */,
+  /** UDP IPv6 lite (dual-stack by default, unless you call @ref netconn_set_ipv6only) */
+  NETCONN_UDPLITE_IPV6     = NETCONN_UDPLITE | NETCONN_TYPE_IPV6 /* 0x29 */,
+  /** UDP IPv6 no checksum (dual-stack by default, unless you call @ref netconn_set_ipv6only) */
+  NETCONN_UDPNOCHKSUM_IPV6 = NETCONN_UDPNOCHKSUM | NETCONN_TYPE_IPV6 /* 0x2a */,
+#endif /* LWIP_IPV6 */
+
+  /** Raw connection IPv4 */
+  NETCONN_RAW         = 0x40
+#if LWIP_IPV6
+  /** Raw connection IPv6 (dual-stack by default, unless you call @ref netconn_set_ipv6only) */
+  , NETCONN_RAW_IPV6    = NETCONN_RAW | NETCONN_TYPE_IPV6 /* 0x48 */
+#endif /* LWIP_IPV6 */
+};
+
+/** Current state of the netconn. Non-TCP netconns are always
+ * in state NETCONN_NONE! */
+enum netconn_state {
+  NETCONN_NONE,
+  NETCONN_WRITE,
+  NETCONN_LISTEN,
+  NETCONN_CONNECT,
+  NETCONN_CLOSE
+};
+
+/** Used to inform the callback function about changes
+ * 
+ * Event explanation:
+ * 
+ * In the netconn implementation, there are three ways to block a client:
+ * 
+ * - accept mbox (sys_arch_mbox_fetch(&conn->acceptmbox, &accept_ptr, 0); in netconn_accept())
+ * - receive mbox (sys_arch_mbox_fetch(&conn->recvmbox, &buf, 0); in netconn_recv_data())
+ * - send queue is full (sys_arch_sem_wait(LWIP_API_MSG_SEM(msg), 0); in lwip_netconn_do_write())
+ * 
+ * The events have to be seen as events signaling the state of these mboxes/semaphores. For non-blocking
+ * connections, you need to know in advance whether a call to a netconn function call would block or not,
+ * and these events tell you about that.
+ * 
+ * RCVPLUS events say: Safe to perform a potentially blocking call call once more. 
+ * They are counted in sockets - three RCVPLUS events for accept mbox means you are safe
+ * to call netconn_accept 3 times without being blocked.
+ * Same thing for receive mbox.
+ * 
+ * RCVMINUS events say: Your call to to a possibly blocking function is "acknowledged".
+ * Socket implementation decrements the counter.
+ * 
+ * For TX, there is no need to count, its merely a flag. SENDPLUS means you may send something.
+ * SENDPLUS occurs when enough data was delivered to peer so netconn_send() can be called again.
+ * A SENDMINUS event occurs when the next call to a netconn_send() would be blocking.
+ */
+enum netconn_evt {
+  NETCONN_EVT_RCVPLUS,
+  NETCONN_EVT_RCVMINUS,
+  NETCONN_EVT_SENDPLUS,
+  NETCONN_EVT_SENDMINUS,
+  NETCONN_EVT_ERROR
+};
+
+#if LWIP_IGMP || (LWIP_IPV6 && LWIP_IPV6_MLD)
+/** Used for netconn_join_leave_group() */
+enum netconn_igmp {
+  NETCONN_JOIN,
+  NETCONN_LEAVE
+};
+#endif /* LWIP_IGMP || (LWIP_IPV6 && LWIP_IPV6_MLD) */
+
+#if LWIP_DNS
+/* Used for netconn_gethostbyname_addrtype(), these should match the DNS_ADDRTYPE defines in dns.h */
+#define NETCONN_DNS_DEFAULT   NETCONN_DNS_IPV4_IPV6
+#define NETCONN_DNS_IPV4      0
+#define NETCONN_DNS_IPV6      1
+#define NETCONN_DNS_IPV4_IPV6 2 /* try to resolve IPv4 first, try IPv6 if IPv4 fails only */
+#define NETCONN_DNS_IPV6_IPV4 3 /* try to resolve IPv6 first, try IPv4 if IPv6 fails only */
+#endif /* LWIP_DNS */
+
+/* forward-declare some structs to avoid to include their headers */
+struct ip_pcb;
+struct tcp_pcb;
+struct udp_pcb;
+struct raw_pcb;
+struct netconn;
+struct api_msg;
+
+/** A callback prototype to inform about events for a netconn */
+typedef void (* netconn_callback)(struct netconn *, enum netconn_evt, u16_t len);
+
+/** A netconn descriptor */
+struct netconn {
+  /** type of the netconn (TCP, UDP or RAW) */
+  enum netconn_type type;
+  /** current state of the netconn */
+  enum netconn_state state;
+  /** the lwIP internal protocol control block */
+  union {
+    struct ip_pcb  *ip;
+    struct tcp_pcb *tcp;
+    struct udp_pcb *udp;
+    struct raw_pcb *raw;
+  } pcb;
+  /** the last error this netconn had */
+  err_t last_err;
+#if !LWIP_NETCONN_SEM_PER_THREAD
+  /** sem that is used to synchronously execute functions in the core context */
+  sys_sem_t op_completed;
+#endif
+  /** mbox where received packets are stored until they are fetched
+      by the netconn application thread (can grow quite big) */
+  sys_mbox_t recvmbox;
+#if LWIP_TCP
+  /** mbox where new connections are stored until processed
+      by the application thread */
+  sys_mbox_t acceptmbox;
+#endif /* LWIP_TCP */
+  /** only used for socket layer */
+#if LWIP_SOCKET
+  int socket;
+#endif /* LWIP_SOCKET */
+#if LWIP_SO_SNDTIMEO
+  /** timeout to wait for sending data (which means enqueueing data for sending
+      in internal buffers) in milliseconds */
+  s32_t send_timeout;
+#endif /* LWIP_SO_RCVTIMEO */
+#if LWIP_SO_RCVTIMEO
+  /** timeout in milliseconds to wait for new data to be received
+      (or connections to arrive for listening netconns) */
+  int recv_timeout;
+#endif /* LWIP_SO_RCVTIMEO */
+#if LWIP_SO_RCVBUF
+  /** maximum amount of bytes queued in recvmbox
+      not used for TCP: adjust TCP_WND instead! */
+  int recv_bufsize;
+  /** number of bytes currently in recvmbox to be received,
+      tested against recv_bufsize to limit bytes on recvmbox
+      for UDP and RAW, used for FIONREAD */
+  int recv_avail;
+#endif /* LWIP_SO_RCVBUF */
+#if LWIP_SO_LINGER
+   /** values <0 mean linger is disabled, values > 0 are seconds to linger */
+  s16_t linger;
+#endif /* LWIP_SO_LINGER */
+  /** flags holding more netconn-internal state, see NETCONN_FLAG_* defines */
+  u8_t flags;
+#if LWIP_TCP
+  /** TCP: when data passed to netconn_write doesn't fit into the send buffer,
+      this temporarily stores how much is already sent. */
+  size_t write_offset;
+  /** TCP: when data passed to netconn_write doesn't fit into the send buffer,
+      this temporarily stores the message.
+      Also used during connect and close. */
+  struct api_msg *current_msg;
+#endif /* LWIP_TCP */
+  /** A callback function that is informed about events for this netconn */
+  netconn_callback callback;
+};
+
+/** Register an Network connection event */
+#define API_EVENT(c,e,l) if (c->callback) {         \
+                           (*c->callback)(c, e, l); \
+                         }
+
+/** Set conn->last_err to err but don't overwrite fatal errors */
+#define NETCONN_SET_SAFE_ERR(conn, err) do { if ((conn) != NULL) { \
+  SYS_ARCH_DECL_PROTECT(netconn_set_safe_err_lev); \
+  SYS_ARCH_PROTECT(netconn_set_safe_err_lev); \
+  if (!ERR_IS_FATAL((conn)->last_err)) { \
+    (conn)->last_err = err; \
+  } \
+  SYS_ARCH_UNPROTECT(netconn_set_safe_err_lev); \
+}} while(0);
+
+/* Network connection functions: */
+
+/** @ingroup netconn_common
+ * Create new netconn connection
+ * @param t @ref netconn_type */
+#define netconn_new(t)                  netconn_new_with_proto_and_callback(t, 0, NULL)
+#define netconn_new_with_callback(t, c) netconn_new_with_proto_and_callback(t, 0, c)
+struct netconn *netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto,
+                                             netconn_callback callback);
+err_t   netconn_delete(struct netconn *conn);
+/** Get the type of a netconn (as enum netconn_type). */
+#define netconn_type(conn) (conn->type)
+
+err_t   netconn_getaddr(struct netconn *conn, ip_addr_t *addr,
+                        u16_t *port, u8_t local);
+/** @ingroup netconn_common */
+#define netconn_peer(c,i,p) netconn_getaddr(c,i,p,0)
+/** @ingroup netconn_common */
+#define netconn_addr(c,i,p) netconn_getaddr(c,i,p,1)
+
+err_t   netconn_bind(struct netconn *conn, const ip_addr_t *addr, u16_t port);
+err_t   netconn_connect(struct netconn *conn, const ip_addr_t *addr, u16_t port);
+err_t   netconn_disconnect (struct netconn *conn);
+err_t   netconn_listen_with_backlog(struct netconn *conn, u8_t backlog);
+/** @ingroup netconn_tcp */
+#define netconn_listen(conn) netconn_listen_with_backlog(conn, TCP_DEFAULT_LISTEN_BACKLOG)
+err_t   netconn_accept(struct netconn *conn, struct netconn **new_conn);
+err_t   netconn_recv(struct netconn *conn, struct netbuf **new_buf);
+err_t   netconn_recv_tcp_pbuf(struct netconn *conn, struct pbuf **new_buf);
+err_t   netconn_sendto(struct netconn *conn, struct netbuf *buf,
+                             const ip_addr_t *addr, u16_t port);
+err_t   netconn_send(struct netconn *conn, struct netbuf *buf);
+err_t   netconn_write_partly(struct netconn *conn, const void *dataptr, size_t size,
+                             u8_t apiflags, size_t *bytes_written);
+/** @ingroup netconn_tcp */
+#define netconn_write(conn, dataptr, size, apiflags) \
+          netconn_write_partly(conn, dataptr, size, apiflags, NULL)
+err_t   netconn_close(struct netconn *conn);
+err_t   netconn_shutdown(struct netconn *conn, u8_t shut_rx, u8_t shut_tx);
+
+#if LWIP_IGMP || (LWIP_IPV6 && LWIP_IPV6_MLD)
+err_t   netconn_join_leave_group(struct netconn *conn, const ip_addr_t *multiaddr,
+                             const ip_addr_t *netif_addr, enum netconn_igmp join_or_leave);
+#endif /* LWIP_IGMP || (LWIP_IPV6 && LWIP_IPV6_MLD) */
+#if LWIP_DNS
+#if LWIP_IPV4 && LWIP_IPV6
+err_t   netconn_gethostbyname_addrtype(const char *name, ip_addr_t *addr, u8_t dns_addrtype);
+#define netconn_gethostbyname(name, addr) netconn_gethostbyname_addrtype(name, addr, NETCONN_DNS_DEFAULT)
+#else /* LWIP_IPV4 && LWIP_IPV6 */
+err_t   netconn_gethostbyname(const char *name, ip_addr_t *addr);
+#define netconn_gethostbyname_addrtype(name, addr, dns_addrtype) netconn_gethostbyname(name, addr)
+#endif /* LWIP_IPV4 && LWIP_IPV6 */
+#endif /* LWIP_DNS */
+
+#define netconn_err(conn)               ((conn)->last_err)
+#define netconn_recv_bufsize(conn)      ((conn)->recv_bufsize)
+
+/** Set the blocking status of netconn calls (@todo: write/send is missing) */
+#define netconn_set_nonblocking(conn, val)  do { if(val) { \
+  (conn)->flags |= NETCONN_FLAG_NON_BLOCKING; \
+} else { \
+  (conn)->flags &= ~ NETCONN_FLAG_NON_BLOCKING; }} while(0)
+/** Get the blocking status of netconn calls (@todo: write/send is missing) */
+#define netconn_is_nonblocking(conn)        (((conn)->flags & NETCONN_FLAG_NON_BLOCKING) != 0)
+
+#if LWIP_IPV6
+/** @ingroup netconn_common
+ * TCP: Set the IPv6 ONLY status of netconn calls (see NETCONN_FLAG_IPV6_V6ONLY)
+ */
+#define netconn_set_ipv6only(conn, val)  do { if(val) { \
+  (conn)->flags |= NETCONN_FLAG_IPV6_V6ONLY; \
+} else { \
+  (conn)->flags &= ~ NETCONN_FLAG_IPV6_V6ONLY; }} while(0)
+/** @ingroup netconn_common
+ * TCP: Get the IPv6 ONLY status of netconn calls (see NETCONN_FLAG_IPV6_V6ONLY)
+ */
+#define netconn_get_ipv6only(conn)        (((conn)->flags & NETCONN_FLAG_IPV6_V6ONLY) != 0)
+#endif /* LWIP_IPV6 */
+
+#if LWIP_SO_SNDTIMEO
+/** Set the send timeout in milliseconds */
+#define netconn_set_sendtimeout(conn, timeout)      ((conn)->send_timeout = (timeout))
+/** Get the send timeout in milliseconds */
+#define netconn_get_sendtimeout(conn)               ((conn)->send_timeout)
+#endif /* LWIP_SO_SNDTIMEO */
+#if LWIP_SO_RCVTIMEO
+/** Set the receive timeout in milliseconds */
+#define netconn_set_recvtimeout(conn, timeout)      ((conn)->recv_timeout = (timeout))
+/** Get the receive timeout in milliseconds */
+#define netconn_get_recvtimeout(conn)               ((conn)->recv_timeout)
+#endif /* LWIP_SO_RCVTIMEO */
+#if LWIP_SO_RCVBUF
+/** Set the receive buffer in bytes */
+#define netconn_set_recvbufsize(conn, recvbufsize)  ((conn)->recv_bufsize = (recvbufsize))
+/** Get the receive buffer in bytes */
+#define netconn_get_recvbufsize(conn)               ((conn)->recv_bufsize)
+#endif /* LWIP_SO_RCVBUF*/
+
+#if LWIP_NETCONN_SEM_PER_THREAD
+void netconn_thread_init(void);
+void netconn_thread_cleanup(void);
+#else /* LWIP_NETCONN_SEM_PER_THREAD */
+#define netconn_thread_init()
+#define netconn_thread_cleanup()
+#endif /* LWIP_NETCONN_SEM_PER_THREAD */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_NETCONN || LWIP_SOCKET */
+
+#endif /* LWIP_HDR_API_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/FILES b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/FILES
new file mode 100644
index 000000000..adfc0f334
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/FILES
@@ -0,0 +1,2 @@
+This directory contains application headers.
+Every application shall provide one api file APP.h and optionally one options file APP_opts.h
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/fs.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/fs.h
new file mode 100644
index 000000000..bb176fa01
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/fs.h
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_APPS_FS_H
+#define LWIP_HDR_APPS_FS_H
+
+#include "httpd_opts.h"
+#include "lwip/err.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define FS_READ_EOF     -1
+#define FS_READ_DELAYED -2
+
+#if HTTPD_PRECALCULATED_CHECKSUM
+struct fsdata_chksum {
+  u32_t offset;
+  u16_t chksum;
+  u16_t len;
+};
+#endif /* HTTPD_PRECALCULATED_CHECKSUM */
+
+#define FS_FILE_FLAGS_HEADER_INCLUDED     0x01
+#define FS_FILE_FLAGS_HEADER_PERSISTENT   0x02
+
+struct fs_file {
+  const char *data;
+  int len;
+  int index;
+  void *pextension;
+#if HTTPD_PRECALCULATED_CHECKSUM
+  const struct fsdata_chksum *chksum;
+  u16_t chksum_count;
+#endif /* HTTPD_PRECALCULATED_CHECKSUM */
+  u8_t flags;
+#if LWIP_HTTPD_CUSTOM_FILES
+  u8_t is_custom_file;
+#endif /* LWIP_HTTPD_CUSTOM_FILES */
+#if LWIP_HTTPD_FILE_STATE
+  void *state;
+#endif /* LWIP_HTTPD_FILE_STATE */
+};
+
+#if LWIP_HTTPD_FS_ASYNC_READ
+typedef void (*fs_wait_cb)(void *arg);
+#endif /* LWIP_HTTPD_FS_ASYNC_READ */
+
+err_t fs_open(struct fs_file *file, const char *name);
+void fs_close(struct fs_file *file);
+#if LWIP_HTTPD_DYNAMIC_FILE_READ
+#if LWIP_HTTPD_FS_ASYNC_READ
+int fs_read_async(struct fs_file *file, char *buffer, int count, fs_wait_cb callback_fn, void *callback_arg);
+#else /* LWIP_HTTPD_FS_ASYNC_READ */
+int fs_read(struct fs_file *file, char *buffer, int count);
+#endif /* LWIP_HTTPD_FS_ASYNC_READ */
+#endif /* LWIP_HTTPD_DYNAMIC_FILE_READ */
+#if LWIP_HTTPD_FS_ASYNC_READ
+int fs_is_file_ready(struct fs_file *file, fs_wait_cb callback_fn, void *callback_arg);
+#endif /* LWIP_HTTPD_FS_ASYNC_READ */
+int fs_bytes_left(struct fs_file *file);
+
+#if LWIP_HTTPD_FILE_STATE
+/** This user-defined function is called when a file is opened. */
+void *fs_state_init(struct fs_file *file, const char *name);
+/** This user-defined function is called when a file is closed. */
+void fs_state_free(struct fs_file *file, void *state);
+#endif /* #if LWIP_HTTPD_FILE_STATE */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_APPS_FS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/httpd.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/httpd.h
new file mode 100644
index 000000000..40f1811e5
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/httpd.h
@@ -0,0 +1,236 @@
+/**
+ * @file
+ * HTTP server
+ */
+
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ * This version of the file has been modified by Texas Instruments to offer
+ * simple server-side-include (SSI) and Common Gateway Interface (CGI)
+ * capability.
+ */
+
+#ifndef LWIP_HDR_APPS_HTTPD_H
+#define LWIP_HDR_APPS_HTTPD_H
+
+#include "httpd_opts.h"
+#include "lwip/err.h"
+#include "lwip/pbuf.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_HTTPD_CGI
+
+/*
+ * Function pointer for a CGI script handler.
+ *
+ * This function is called each time the HTTPD server is asked for a file
+ * whose name was previously registered as a CGI function using a call to
+ * http_set_cgi_handler. The iIndex parameter provides the index of the
+ * CGI within the ppcURLs array passed to http_set_cgi_handler. Parameters
+ * pcParam and pcValue provide access to the parameters provided along with
+ * the URI. iNumParams provides a count of the entries in the pcParam and
+ * pcValue arrays. Each entry in the pcParam array contains the name of a
+ * parameter with the corresponding entry in the pcValue array containing the
+ * value for that parameter. Note that pcParam may contain multiple elements
+ * with the same name if, for example, a multi-selection list control is used
+ * in the form generating the data.
+ *
+ * The function should return a pointer to a character string which is the
+ * path and filename of the response that is to be sent to the connected
+ * browser, for example "/thanks.htm" or "/response/error.ssi".
+ *
+ * The maximum number of parameters that will be passed to this function via
+ * iNumParams is defined by LWIP_HTTPD_MAX_CGI_PARAMETERS. Any parameters in the incoming
+ * HTTP request above this number will be discarded.
+ *
+ * Requests intended for use by this CGI mechanism must be sent using the GET
+ * method (which encodes all parameters within the URI rather than in a block
+ * later in the request). Attempts to use the POST method will result in the
+ * request being ignored.
+ *
+ */
+typedef const char *(*tCGIHandler)(int iIndex, int iNumParams, char *pcParam[],
+                             char *pcValue[]);
+
+/*
+ * Structure defining the base filename (URL) of a CGI and the associated
+ * function which is to be called when that URL is requested.
+ */
+typedef struct
+{
+    const char *pcCGIName;
+    tCGIHandler pfnCGIHandler;
+} tCGI;
+
+void http_set_cgi_handlers(const tCGI *pCGIs, int iNumHandlers);
+
+#endif /* LWIP_HTTPD_CGI */
+
+#if LWIP_HTTPD_CGI || LWIP_HTTPD_CGI_SSI
+
+#if LWIP_HTTPD_CGI_SSI
+/** Define this generic CGI handler in your application.
+ * It is called once for every URI with parameters.
+ * The parameters can be stored to 
+ */
+extern void httpd_cgi_handler(const char* uri, int iNumParams, char **pcParam, char **pcValue
+#if defined(LWIP_HTTPD_FILE_STATE) && LWIP_HTTPD_FILE_STATE
+                                     , void *connection_state
+#endif /* LWIP_HTTPD_FILE_STATE */
+                                     );
+#endif /* LWIP_HTTPD_CGI_SSI */
+
+#endif /* LWIP_HTTPD_CGI || LWIP_HTTPD_CGI_SSI */
+
+#if LWIP_HTTPD_SSI
+
+/*
+ * Function pointer for the SSI tag handler callback.
+ *
+ * This function will be called each time the HTTPD server detects a tag of the
+ * form <!--#name--> in a .shtml, .ssi or .shtm file where "name" appears as
+ * one of the tags supplied to http_set_ssi_handler in the ppcTags array.  The
+ * returned insert string, which will be appended after the the string
+ * "<!--#name-->" in file sent back to the client,should be written to pointer
+ * pcInsert.  iInsertLen contains the size of the buffer pointed to by
+ * pcInsert.  The iIndex parameter provides the zero-based index of the tag as
+ * found in the ppcTags array and identifies the tag that is to be processed.
+ *
+ * The handler returns the number of characters written to pcInsert excluding
+ * any terminating NULL or a negative number to indicate a failure (tag not
+ * recognized, for example).
+ *
+ * Note that the behavior of this SSI mechanism is somewhat different from the
+ * "normal" SSI processing as found in, for example, the Apache web server.  In
+ * this case, the inserted text is appended following the SSI tag rather than
+ * replacing the tag entirely.  This allows for an implementation that does not
+ * require significant additional buffering of output data yet which will still
+ * offer usable SSI functionality.  One downside to this approach is when
+ * attempting to use SSI within JavaScript.  The SSI tag is structured to
+ * resemble an HTML comment but this syntax does not constitute a comment
+ * within JavaScript and, hence, leaving the tag in place will result in
+ * problems in these cases.  To work around this, any SSI tag which needs to
+ * output JavaScript code must do so in an encapsulated way, sending the whole
+ * HTML <script>...</script> section as a single include.
+ */
+typedef u16_t (*tSSIHandler)(
+#if LWIP_HTTPD_SSI_RAW
+                             const char* ssi_tag_name,
+#else /* LWIP_HTTPD_SSI_RAW */
+                             int iIndex,
+#endif /* LWIP_HTTPD_SSI_RAW */
+                             char *pcInsert, int iInsertLen
+#if LWIP_HTTPD_SSI_MULTIPART
+                             , u16_t current_tag_part, u16_t *next_tag_part
+#endif /* LWIP_HTTPD_SSI_MULTIPART */
+#if defined(LWIP_HTTPD_FILE_STATE) && LWIP_HTTPD_FILE_STATE
+                             , void *connection_state
+#endif /* LWIP_HTTPD_FILE_STATE */
+                             );
+
+/** Set the SSI handler function
+ * (if LWIP_HTTPD_SSI_RAW==1, only the first argument is used)
+ */
+void http_set_ssi_handler(tSSIHandler pfnSSIHandler,
+                          const char **ppcTags, int iNumTags);
+
+/** For LWIP_HTTPD_SSI_RAW==1, return this to indicate the tag is unknown.
+ * In this case, the webserver writes a warning into the page.
+ * You can also just return 0 to write nothing for unknown tags.
+ */
+#define HTTPD_SSI_TAG_UNKNOWN 0xFFFF
+
+#endif /* LWIP_HTTPD_SSI */
+
+#if LWIP_HTTPD_SUPPORT_POST
+
+/* These functions must be implemented by the application */
+
+/** Called when a POST request has been received. The application can decide
+ * whether to accept it or not.
+ *
+ * @param connection Unique connection identifier, valid until httpd_post_end
+ *        is called.
+ * @param uri The HTTP header URI receiving the POST request.
+ * @param http_request The raw HTTP request (the first packet, normally).
+ * @param http_request_len Size of 'http_request'.
+ * @param content_len Content-Length from HTTP header.
+ * @param response_uri Filename of response file, to be filled when denying the
+ *        request
+ * @param response_uri_len Size of the 'response_uri' buffer.
+ * @param post_auto_wnd Set this to 0 to let the callback code handle window
+ *        updates by calling 'httpd_post_data_recved' (to throttle rx speed)
+ *        default is 1 (httpd handles window updates automatically)
+ * @return ERR_OK: Accept the POST request, data may be passed in
+ *         another err_t: Deny the POST request, send back 'bad request'.
+ */
+err_t httpd_post_begin(void *connection, const char *uri, const char *http_request,
+                       u16_t http_request_len, int content_len, char *response_uri,
+                       u16_t response_uri_len, u8_t *post_auto_wnd);
+
+/** Called for each pbuf of data that has been received for a POST.
+ * ATTENTION: The application is responsible for freeing the pbufs passed in!
+ *
+ * @param connection Unique connection identifier.
+ * @param p Received data.
+ * @return ERR_OK: Data accepted.
+ *         another err_t: Data denied, http_post_get_response_uri will be called.
+ */
+err_t httpd_post_receive_data(void *connection, struct pbuf *p);
+
+/** Called when all data is received or when the connection is closed.
+ * The application must return the filename/URI of a file to send in response
+ * to this POST request. If the response_uri buffer is untouched, a 404
+ * response is returned.
+ *
+ * @param connection Unique connection identifier.
+ * @param response_uri Filename of response file, to be filled when denying the request
+ * @param response_uri_len Size of the 'response_uri' buffer.
+ */
+void httpd_post_finished(void *connection, char *response_uri, u16_t response_uri_len);
+
+#if LWIP_HTTPD_POST_MANUAL_WND
+void httpd_post_data_recved(void *connection, u16_t recved_len);
+#endif /* LWIP_HTTPD_POST_MANUAL_WND */
+
+#endif /* LWIP_HTTPD_SUPPORT_POST */
+
+void httpd_init(void);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HTTPD_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/httpd_opts.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/httpd_opts.h
new file mode 100644
index 000000000..340db15f6
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/httpd_opts.h
@@ -0,0 +1,323 @@
+/**
+ * @file
+ * HTTP server options list
+ */
+
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ * This version of the file has been modified by Texas Instruments to offer
+ * simple server-side-include (SSI) and Common Gateway Interface (CGI)
+ * capability.
+ */
+
+#ifndef LWIP_HDR_APPS_HTTPD_OPTS_H
+#define LWIP_HDR_APPS_HTTPD_OPTS_H
+
+#include "lwip/opt.h"
+
+/**
+ * @defgroup httpd_opts Options
+ * @ingroup httpd
+ * @{
+ */
+
+/** Set this to 1 to support CGI (old style) */
+#if !defined LWIP_HTTPD_CGI || defined __DOXYGEN__
+#define LWIP_HTTPD_CGI            0
+#endif
+
+/** Set this to 1 to support CGI (new style) */
+#if !defined LWIP_HTTPD_CGI_SSI || defined __DOXYGEN__
+#define LWIP_HTTPD_CGI_SSI        0
+#endif
+
+/** Set this to 1 to support SSI (Server-Side-Includes) */
+#if !defined LWIP_HTTPD_SSI || defined __DOXYGEN__
+#define LWIP_HTTPD_SSI            0
+#endif
+
+/** Set this to 1 to implement an SSI tag handler callback that gets a const char*
+ * to the tag (instead of an index into a pre-registered array of known tags) */
+#if !defined LWIP_HTTPD_SSI_RAW || defined __DOXYGEN__
+#define LWIP_HTTPD_SSI_RAW        0
+#endif
+
+/** Set this to 1 to support HTTP POST */
+#if !defined LWIP_HTTPD_SUPPORT_POST || defined __DOXYGEN__
+#define LWIP_HTTPD_SUPPORT_POST   0
+#endif
+
+/* The maximum number of parameters that the CGI handler can be sent. */
+#if !defined LWIP_HTTPD_MAX_CGI_PARAMETERS || defined __DOXYGEN__
+#define LWIP_HTTPD_MAX_CGI_PARAMETERS 16
+#endif
+
+/** LWIP_HTTPD_SSI_MULTIPART==1: SSI handler function is called with 2 more
+ * arguments indicating a counter for insert string that are too long to be
+ * inserted at once: the SSI handler function must then set 'next_tag_part'
+ * which will be passed back to it in the next call. */
+#if !defined LWIP_HTTPD_SSI_MULTIPART || defined __DOXYGEN__
+#define LWIP_HTTPD_SSI_MULTIPART    0
+#endif
+
+/* The maximum length of the string comprising the tag name */
+#if !defined LWIP_HTTPD_MAX_TAG_NAME_LEN || defined __DOXYGEN__
+#define LWIP_HTTPD_MAX_TAG_NAME_LEN 8
+#endif
+
+/* The maximum length of string that can be returned to replace any given tag */
+#if !defined LWIP_HTTPD_MAX_TAG_INSERT_LEN || defined __DOXYGEN__
+#define LWIP_HTTPD_MAX_TAG_INSERT_LEN 192
+#endif
+
+#if !defined LWIP_HTTPD_POST_MANUAL_WND || defined __DOXYGEN__
+#define LWIP_HTTPD_POST_MANUAL_WND  0
+#endif
+
+/** This string is passed in the HTTP header as "Server: " */
+#if !defined HTTPD_SERVER_AGENT || defined __DOXYGEN__
+#define HTTPD_SERVER_AGENT "lwIP/" LWIP_VERSION_STRING " (http://savannah.nongnu.org/projects/lwip)"
+#endif
+
+/** Set this to 1 if you want to include code that creates HTTP headers
+ * at runtime. Default is off: HTTP headers are then created statically
+ * by the makefsdata tool. Static headers mean smaller code size, but
+ * the (readonly) fsdata will grow a bit as every file includes the HTTP
+ * header. */
+#if !defined LWIP_HTTPD_DYNAMIC_HEADERS || defined __DOXYGEN__
+#define LWIP_HTTPD_DYNAMIC_HEADERS 0
+#endif
+
+#if !defined HTTPD_DEBUG || defined __DOXYGEN__
+#define HTTPD_DEBUG         LWIP_DBG_OFF
+#endif
+
+/** Set this to 1 to use a memp pool for allocating 
+ * struct http_state instead of the heap.
+ */
+#if !defined HTTPD_USE_MEM_POOL || defined __DOXYGEN__
+#define HTTPD_USE_MEM_POOL  0
+#endif
+
+/** The server port for HTTPD to use */
+#if !defined HTTPD_SERVER_PORT || defined __DOXYGEN__
+#define HTTPD_SERVER_PORT                   80
+#endif
+
+/** Maximum retries before the connection is aborted/closed.
+ * - number of times pcb->poll is called -> default is 4*500ms = 2s;
+ * - reset when pcb->sent is called
+ */
+#if !defined HTTPD_MAX_RETRIES || defined __DOXYGEN__
+#define HTTPD_MAX_RETRIES                   4
+#endif
+
+/** The poll delay is X*500ms */
+#if !defined HTTPD_POLL_INTERVAL || defined __DOXYGEN__
+#define HTTPD_POLL_INTERVAL                 4
+#endif
+
+/** Priority for tcp pcbs created by HTTPD (very low by default).
+ *  Lower priorities get killed first when running out of memory.
+ */
+#if !defined HTTPD_TCP_PRIO || defined __DOXYGEN__
+#define HTTPD_TCP_PRIO                      TCP_PRIO_MIN
+#endif
+
+/** Set this to 1 to enable timing each file sent */
+#if !defined LWIP_HTTPD_TIMING || defined __DOXYGEN__
+#define LWIP_HTTPD_TIMING                   0
+#endif
+/** Set this to 1 to enable timing each file sent */
+#if !defined HTTPD_DEBUG_TIMING || defined __DOXYGEN__
+#define HTTPD_DEBUG_TIMING                  LWIP_DBG_OFF
+#endif
+
+/** Set this to one to show error pages when parsing a request fails instead
+    of simply closing the connection. */
+#if !defined LWIP_HTTPD_SUPPORT_EXTSTATUS || defined __DOXYGEN__
+#define LWIP_HTTPD_SUPPORT_EXTSTATUS        0
+#endif
+
+/** Set this to 0 to drop support for HTTP/0.9 clients (to save some bytes) */
+#if !defined LWIP_HTTPD_SUPPORT_V09 || defined __DOXYGEN__
+#define LWIP_HTTPD_SUPPORT_V09              1
+#endif
+
+/** Set this to 1 to enable HTTP/1.1 persistent connections.
+ * ATTENTION: If the generated file system includes HTTP headers, these must
+ * include the "Connection: keep-alive" header (pass argument "-11" to makefsdata).
+ */
+#if !defined LWIP_HTTPD_SUPPORT_11_KEEPALIVE || defined __DOXYGEN__
+#define LWIP_HTTPD_SUPPORT_11_KEEPALIVE     0
+#endif
+
+/** Set this to 1 to support HTTP request coming in in multiple packets/pbufs */
+#if !defined LWIP_HTTPD_SUPPORT_REQUESTLIST || defined __DOXYGEN__
+#define LWIP_HTTPD_SUPPORT_REQUESTLIST      1
+#endif
+
+#if LWIP_HTTPD_SUPPORT_REQUESTLIST
+/** Number of rx pbufs to enqueue to parse an incoming request (up to the first
+    newline) */
+#if !defined LWIP_HTTPD_REQ_QUEUELEN || defined __DOXYGEN__
+#define LWIP_HTTPD_REQ_QUEUELEN             5
+#endif
+
+/** Number of (TCP payload-) bytes (in pbufs) to enqueue to parse and incoming
+    request (up to the first double-newline) */
+#if !defined LWIP_HTTPD_REQ_BUFSIZE || defined __DOXYGEN__
+#define LWIP_HTTPD_REQ_BUFSIZE              LWIP_HTTPD_MAX_REQ_LENGTH
+#endif
+
+/** Defines the maximum length of a HTTP request line (up to the first CRLF,
+    copied from pbuf into this a global buffer when pbuf- or packet-queues
+    are received - otherwise the input pbuf is used directly) */
+#if !defined LWIP_HTTPD_MAX_REQ_LENGTH || defined __DOXYGEN__
+#define LWIP_HTTPD_MAX_REQ_LENGTH           LWIP_MIN(1023, (LWIP_HTTPD_REQ_QUEUELEN * PBUF_POOL_BUFSIZE))
+#endif
+#endif /* LWIP_HTTPD_SUPPORT_REQUESTLIST */
+
+/** This is the size of a static buffer used when URIs end with '/'.
+ * In this buffer, the directory requested is concatenated with all the
+ * configured default file names.
+ * Set to 0 to disable checking default filenames on non-root directories.
+ */
+#if !defined LWIP_HTTPD_MAX_REQUEST_URI_LEN || defined __DOXYGEN__
+#define LWIP_HTTPD_MAX_REQUEST_URI_LEN      63
+#endif
+
+/** Maximum length of the filename to send as response to a POST request,
+ * filled in by the application when a POST is finished.
+ */
+#if !defined LWIP_HTTPD_POST_MAX_RESPONSE_URI_LEN || defined __DOXYGEN__
+#define LWIP_HTTPD_POST_MAX_RESPONSE_URI_LEN 63
+#endif
+
+/** Set this to 0 to not send the SSI tag (default is on, so the tag will
+ * be sent in the HTML page */
+#if !defined LWIP_HTTPD_SSI_INCLUDE_TAG || defined __DOXYGEN__
+#define LWIP_HTTPD_SSI_INCLUDE_TAG           1
+#endif
+
+/** Set this to 1 to call tcp_abort when tcp_close fails with memory error.
+ * This can be used to prevent consuming all memory in situations where the
+ * HTTP server has low priority compared to other communication. */
+#if !defined LWIP_HTTPD_ABORT_ON_CLOSE_MEM_ERROR || defined __DOXYGEN__
+#define LWIP_HTTPD_ABORT_ON_CLOSE_MEM_ERROR  0
+#endif
+
+/** Set this to 1 to kill the oldest connection when running out of
+ * memory for 'struct http_state' or 'struct http_ssi_state'.
+ * ATTENTION: This puts all connections on a linked list, so may be kind of slow.
+ */
+#if !defined LWIP_HTTPD_KILL_OLD_ON_CONNECTIONS_EXCEEDED || defined __DOXYGEN__
+#define LWIP_HTTPD_KILL_OLD_ON_CONNECTIONS_EXCEEDED 0
+#endif
+
+/** Set this to 1 to send URIs without extension without headers
+ * (who uses this at all??) */
+#if !defined LWIP_HTTPD_OMIT_HEADER_FOR_EXTENSIONLESS_URI || defined __DOXYGEN__
+#define LWIP_HTTPD_OMIT_HEADER_FOR_EXTENSIONLESS_URI 0
+#endif
+
+/** Default: Tags are sent from struct http_state and are therefore volatile */
+#if !defined HTTP_IS_TAG_VOLATILE || defined __DOXYGEN__
+#define HTTP_IS_TAG_VOLATILE(ptr) TCP_WRITE_FLAG_COPY
+#endif
+
+/* By default, the httpd is limited to send 2*pcb->mss to keep resource usage low
+   when http is not an important protocol in the device. */
+#if !defined HTTPD_LIMIT_SENDING_TO_2MSS || defined __DOXYGEN__
+#define HTTPD_LIMIT_SENDING_TO_2MSS 1
+#endif
+
+/* Define this to a function that returns the maximum amount of data to enqueue.
+   The function have this signature: u16_t fn(struct tcp_pcb* pcb); */
+#if !defined HTTPD_MAX_WRITE_LEN || defined __DOXYGEN__
+#if HTTPD_LIMIT_SENDING_TO_2MSS
+#define HTTPD_MAX_WRITE_LEN(pcb)    (2 * tcp_mss(pcb))
+#endif
+#endif
+
+/*------------------- FS OPTIONS -------------------*/
+
+/** Set this to 1 and provide the functions:
+ * - "int fs_open_custom(struct fs_file *file, const char *name)"
+ *    Called first for every opened file to allow opening files
+ *    that are not included in fsdata(_custom).c
+ * - "void fs_close_custom(struct fs_file *file)"
+ *    Called to free resources allocated by fs_open_custom().
+ */
+#if !defined LWIP_HTTPD_CUSTOM_FILES || defined __DOXYGEN__
+#define LWIP_HTTPD_CUSTOM_FILES       0
+#endif
+
+/** Set this to 1 to support fs_read() to dynamically read file data.
+ * Without this (default=off), only one-block files are supported,
+ * and the contents must be ready after fs_open().
+ */
+#if !defined LWIP_HTTPD_DYNAMIC_FILE_READ || defined __DOXYGEN__
+#define LWIP_HTTPD_DYNAMIC_FILE_READ  0
+#endif
+
+/** Set this to 1 to include an application state argument per file
+ * that is opened. This allows to keep a state per connection/file.
+ */
+#if !defined LWIP_HTTPD_FILE_STATE || defined __DOXYGEN__
+#define LWIP_HTTPD_FILE_STATE         0
+#endif
+
+/** HTTPD_PRECALCULATED_CHECKSUM==1: include precompiled checksums for
+ * predefined (MSS-sized) chunks of the files to prevent having to calculate
+ * the checksums at runtime. */
+#if !defined HTTPD_PRECALCULATED_CHECKSUM || defined __DOXYGEN__
+#define HTTPD_PRECALCULATED_CHECKSUM  0
+#endif
+
+/** LWIP_HTTPD_FS_ASYNC_READ==1: support asynchronous read operations
+ * (fs_read_async returns FS_READ_DELAYED and calls a callback when finished).
+ */
+#if !defined LWIP_HTTPD_FS_ASYNC_READ || defined __DOXYGEN__
+#define LWIP_HTTPD_FS_ASYNC_READ      0
+#endif
+
+/** Set this to 1 to include "fsdata_custom.c" instead of "fsdata.c" for the
+ * file system (to prevent changing the file included in CVS) */
+#if !defined HTTPD_USE_CUSTOM_FSDATA || defined __DOXYGEN__
+#define HTTPD_USE_CUSTOM_FSDATA 0
+#endif
+
+/**
+ * @}
+ */
+
+#endif /* LWIP_HDR_APPS_HTTPD_OPTS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/lwiperf.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/lwiperf.h
new file mode 100644
index 000000000..7dbebb082
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/lwiperf.h
@@ -0,0 +1,84 @@
+/**
+ * @file
+ * lwIP iPerf server implementation
+ */
+
+/*
+ * Copyright (c) 2014 Simon Goldschmidt
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Simon Goldschmidt
+ *
+ */
+#ifndef LWIP_HDR_APPS_LWIPERF_H
+#define LWIP_HDR_APPS_LWIPERF_H
+
+#include "lwip/opt.h"
+#include "lwip/ip_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define LWIPERF_TCP_PORT_DEFAULT  5001
+
+/** lwIPerf test results */
+enum lwiperf_report_type
+{
+  /** The server side test is done */
+  LWIPERF_TCP_DONE_SERVER,
+  /** The client side test is done */
+  LWIPERF_TCP_DONE_CLIENT,
+  /** Local error lead to test abort */
+  LWIPERF_TCP_ABORTED_LOCAL,
+  /** Data check error lead to test abort */
+  LWIPERF_TCP_ABORTED_LOCAL_DATAERROR,
+  /** Transmit error lead to test abort */
+  LWIPERF_TCP_ABORTED_LOCAL_TXERROR,
+  /** Remote side aborted the test */
+  LWIPERF_TCP_ABORTED_REMOTE
+};
+
+/** Prototype of a report function that is called when a session is finished.
+    This report function can show the test results.
+    @param report_type contains the test result */
+typedef void (*lwiperf_report_fn)(void *arg, enum lwiperf_report_type report_type,
+  const ip_addr_t* local_addr, u16_t local_port, const ip_addr_t* remote_addr, u16_t remote_port,
+  u32_t bytes_transferred, u32_t ms_duration, u32_t bandwidth_kbitpsec);
+
+
+void* lwiperf_start_tcp_server(const ip_addr_t* local_addr, u16_t local_port,
+                               lwiperf_report_fn report_fn, void* report_arg);
+void* lwiperf_start_tcp_server_default(lwiperf_report_fn report_fn, void* report_arg);
+void  lwiperf_abort(void* lwiperf_session);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_APPS_LWIPERF_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/mdns.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/mdns.h
new file mode 100644
index 000000000..d03681611
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/mdns.h
@@ -0,0 +1,69 @@
+/**
+ * @file
+ * MDNS responder
+ */
+
+ /*
+ * Copyright (c) 2015 Verisure Innovation AB
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Erik Ekman <erik@kryo.se>
+ *
+ */
+#ifndef LWIP_HDR_MDNS_H
+#define LWIP_HDR_MDNS_H
+
+#include "lwip/apps/mdns_opts.h"
+#include "lwip/netif.h"
+
+#if LWIP_MDNS_RESPONDER
+
+enum mdns_sd_proto {
+  DNSSD_PROTO_UDP = 0,
+  DNSSD_PROTO_TCP = 1
+};
+
+#define MDNS_LABEL_MAXLEN  63
+
+struct mdns_host;
+struct mdns_service;
+
+/** Callback function to add text to a reply, called when generating the reply */
+typedef void (*service_get_txt_fn_t)(struct mdns_service *service, void *txt_userdata);
+
+void mdns_resp_init(void);
+
+err_t mdns_resp_add_netif(struct netif *netif, const char *hostname, u32_t dns_ttl);
+err_t mdns_resp_remove_netif(struct netif *netif);
+
+err_t mdns_resp_add_service(struct netif *netif, const char *name, const char *service, enum mdns_sd_proto proto, u16_t port, u32_t dns_ttl, service_get_txt_fn_t txt_fn, void *txt_userdata);
+err_t mdns_resp_add_service_txtitem(struct mdns_service *service, const char *txt, u8_t txt_len);
+void mdns_resp_netif_settings_changed(struct netif *netif);
+
+#endif /* LWIP_MDNS_RESPONDER */
+
+#endif /* LWIP_HDR_MDNS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/mdns_opts.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/mdns_opts.h
new file mode 100644
index 000000000..bf186bcce
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/mdns_opts.h
@@ -0,0 +1,74 @@
+/**
+ * @file
+ * MDNS responder
+ */
+
+ /*
+ * Copyright (c) 2015 Verisure Innovation AB
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Erik Ekman <erik@kryo.se>
+ *
+ */
+
+#ifndef LWIP_HDR_APPS_MDNS_OPTS_H
+#define LWIP_HDR_APPS_MDNS_OPTS_H
+
+#include "lwip/opt.h"
+
+/**
+ * @defgroup mdns_opts Options
+ * @ingroup mdns
+ * @{
+ */
+
+/**
+ * LWIP_MDNS_RESPONDER==1: Turn on multicast DNS module. UDP must be available for MDNS
+ * transport. IGMP is needed for IPv4 multicast.
+ */
+#ifndef LWIP_MDNS_RESPONDER
+#define LWIP_MDNS_RESPONDER             0
+#endif /* LWIP_MDNS_RESPONDER */
+
+/** The maximum number of services per netif */
+#ifndef MDNS_MAX_SERVICES
+#define MDNS_MAX_SERVICES               1
+#endif
+
+/**
+ * MDNS_DEBUG: Enable debugging for multicast DNS.
+ */
+#ifndef MDNS_DEBUG
+#define MDNS_DEBUG                       LWIP_DBG_OFF
+#endif
+
+/**
+ * @}
+ */
+
+#endif /* LWIP_HDR_APPS_MDNS_OPTS_H */
+
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/mdns_priv.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/mdns_priv.h
new file mode 100644
index 000000000..8ee6db86a
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/mdns_priv.h
@@ -0,0 +1,66 @@
+/**
+ * @file
+ * MDNS responder private definitions
+ */
+
+ /*
+ * Copyright (c) 2015 Verisure Innovation AB
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Erik Ekman <erik@kryo.se>
+ *
+ */
+#ifndef LWIP_HDR_MDNS_PRIV_H
+#define LWIP_HDR_MDNS_PRIV_H
+
+#include "lwip/apps/mdns_opts.h"
+#include "lwip/pbuf.h"
+
+#if LWIP_MDNS_RESPONDER
+
+/* Domain struct and methods - visible for unit tests */
+
+#define MDNS_DOMAIN_MAXLEN 256
+#define MDNS_READNAME_ERROR 0xFFFF
+
+struct mdns_domain {
+  /* Encoded domain name */
+  u8_t name[MDNS_DOMAIN_MAXLEN];
+  /* Total length of domain name, including zero */
+  u16_t length;
+  /* Set if compression of this domain is not allowed */
+  u8_t skip_compression;
+};
+
+err_t mdns_domain_add_label(struct mdns_domain *domain, const char *label, u8_t len);
+u16_t mdns_readname(struct pbuf *p, u16_t offset, struct mdns_domain *domain);
+int mdns_domain_eq(struct mdns_domain *a, struct mdns_domain *b);
+u16_t mdns_compress_domain(struct pbuf *pbuf, u16_t *offset, struct mdns_domain *domain);
+
+#endif /* LWIP_MDNS_RESPONDER */
+
+#endif /* LWIP_HDR_MDNS_PRIV_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/mqtt.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/mqtt.h
new file mode 100644
index 000000000..34b230b88
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/mqtt.h
@@ -0,0 +1,244 @@
+/**
+ * @file
+ * MQTT client
+ */
+
+/*
+ * Copyright (c) 2016 Erik Andersson
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Erik Andersson
+ *
+ */
+#ifndef LWIP_HDR_APPS_MQTT_CLIENT_H
+#define LWIP_HDR_APPS_MQTT_CLIENT_H
+
+#include "lwip/apps/mqtt_opts.h"
+#include "lwip/err.h"
+#include "lwip/ip_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct mqtt_client_t mqtt_client_t;
+
+/** @ingroup mqtt
+ * Default MQTT port */
+#define MQTT_PORT 1883
+
+/*---------------------------------------------------------------------------------------------- */
+/* Connection with server */
+
+/**
+ * @ingroup mqtt
+ * Client information and connection parameters */
+struct mqtt_connect_client_info_t {
+  /** Client identifier, must be set by caller */
+  const char *client_id;
+  /** User name and password, set to NULL if not used */
+  const char* client_user;
+  const char* client_pass;
+  /** keep alive time in seconds, 0 to disable keep alive functionality*/
+  u16_t keep_alive;
+  /** will topic, set to NULL if will is not to be used,
+      will_msg, will_qos and will retain are then ignored */
+  const char* will_topic;
+  const char* will_msg;
+  u8_t will_qos;
+  u8_t will_retain;
+};
+
+/**
+ * @ingroup mqtt
+ * Connection status codes */
+typedef enum
+{
+  MQTT_CONNECT_ACCEPTED                 = 0,
+  MQTT_CONNECT_REFUSED_PROTOCOL_VERSION = 1,
+  MQTT_CONNECT_REFUSED_IDENTIFIER       = 2,
+  MQTT_CONNECT_REFUSED_SERVER           = 3,
+  MQTT_CONNECT_REFUSED_USERNAME_PASS    = 4,
+  MQTT_CONNECT_REFUSED_NOT_AUTHORIZED_  = 5,
+  MQTT_CONNECT_DISCONNECTED             = 256,
+  MQTT_CONNECT_TIMEOUT                  = 257
+} mqtt_connection_status_t;
+
+/**
+ * @ingroup mqtt
+ * Function prototype for mqtt connection status callback. Called when
+ * client has connected to the server after initiating a mqtt connection attempt by
+ * calling mqtt_connect() or when connection is closed by server or an error
+ *
+ * @param client MQTT client itself
+ * @param arg Additional argument to pass to the callback function
+ * @param status Connect result code or disconnection notification @see mqtt_connection_status_t
+ *
+ */
+typedef void (*mqtt_connection_cb_t)(mqtt_client_t *client, void *arg, mqtt_connection_status_t status);
+
+
+/**
+ * @ingroup mqtt
+ * Data callback flags */
+enum {
+  /** Flag set when last fragment of data arrives in data callback */
+  MQTT_DATA_FLAG_LAST = 1
+};
+
+/** 
+ * @ingroup mqtt
+ * Function prototype for MQTT incoming publish data callback function. Called when data
+ * arrives to a subscribed topic @see mqtt_subscribe
+ *
+ * @param arg Additional argument to pass to the callback function
+ * @param data User data, pointed object, data may not be referenced after callback return,
+          NULL is passed when all publish data are delivered
+ * @param len Length of publish data fragment
+ * @param flags MQTT_DATA_FLAG_LAST set when this call contains the last part of data from publish message
+ *
+ */
+typedef void (*mqtt_incoming_data_cb_t)(void *arg, const u8_t *data, u16_t len, u8_t flags);
+
+
+/** 
+ * @ingroup mqtt
+ * Function prototype for MQTT incoming publish function. Called when an incoming publish
+ * arrives to a subscribed topic @see mqtt_subscribe
+ *
+ * @param arg Additional argument to pass to the callback function
+ * @param topic Zero terminated Topic text string, topic may not be referenced after callback return
+ * @param tot_len Total length of publish data, if set to 0 (no publish payload) data callback will not be invoked
+ */
+typedef void (*mqtt_incoming_publish_cb_t)(void *arg, const char *topic, u32_t tot_len);
+
+
+/**
+ * @ingroup mqtt
+ * Function prototype for mqtt request callback. Called when a subscribe, unsubscribe
+ * or publish request has completed
+ * @param arg Pointer to user data supplied when invoking request
+ * @param err ERR_OK on success
+ *            ERR_TIMEOUT if no response was received within timeout,
+ *            ERR_ABRT if (un)subscribe was denied
+ */
+typedef void (*mqtt_request_cb_t)(void *arg, err_t err);
+
+
+/**
+ * Pending request item, binds application callback to pending server requests
+ */
+struct mqtt_request_t
+{
+  /** Next item in list, NULL means this is the last in chain,
+      next pointing at itself means request is unallocated */
+  struct mqtt_request_t *next;
+  /** Callback to upper layer */
+  mqtt_request_cb_t cb;
+  void *arg;
+  /** MQTT packet identifier */
+  u16_t pkt_id;
+  /** Expire time relative to element before this  */
+  u16_t timeout_diff;
+};
+
+/** Ring buffer */
+struct mqtt_ringbuf_t {
+  u16_t put;
+  u16_t get;
+  u8_t buf[MQTT_OUTPUT_RINGBUF_SIZE];
+};
+
+/** MQTT client */
+struct mqtt_client_t
+{
+  /** Timers and timeouts */
+  u16_t cyclic_tick;
+  u16_t keep_alive;
+  u16_t server_watchdog;
+  /** Packet identifier generator*/
+  u16_t pkt_id_seq;
+  /** Packet identifier of pending incoming publish */
+  u16_t inpub_pkt_id;
+  /** Connection state */
+  u8_t conn_state;
+  struct tcp_pcb *conn;
+  /** Connection callback */
+  void *connect_arg;
+  mqtt_connection_cb_t connect_cb;
+  /** Pending requests to server */
+  struct mqtt_request_t *pend_req_queue;
+  struct mqtt_request_t req_list[MQTT_REQ_MAX_IN_FLIGHT];
+  void *inpub_arg;
+  /** Incoming data callback */
+  mqtt_incoming_data_cb_t data_cb;
+  mqtt_incoming_publish_cb_t pub_cb;
+  /** Input */
+  u32_t msg_idx;
+  u8_t rx_buffer[MQTT_VAR_HEADER_BUFFER_LEN];
+  /** Output ring-buffer */
+  struct mqtt_ringbuf_t output;
+};
+
+
+/** Connect to server */
+err_t mqtt_client_connect(mqtt_client_t *client, const ip_addr_t *ipaddr, u16_t port, mqtt_connection_cb_t cb, void *arg,
+                   const struct mqtt_connect_client_info_t *client_info);
+
+/** Disconnect from server */
+void mqtt_disconnect(mqtt_client_t *client);
+
+/** Create new client */
+mqtt_client_t *mqtt_client_new(void);
+
+/** Check connection status */
+u8_t mqtt_client_is_connected(mqtt_client_t *client);
+
+/** Set callback to call for incoming publish */
+void mqtt_set_inpub_callback(mqtt_client_t *client, mqtt_incoming_publish_cb_t,
+                             mqtt_incoming_data_cb_t data_cb, void *arg);
+
+/** Common function for subscribe and unsubscribe */
+err_t mqtt_sub_unsub(mqtt_client_t *client, const char *topic, u8_t qos, mqtt_request_cb_t cb, void *arg, u8_t sub);
+
+/** @ingroup mqtt
+ *Subscribe to topic */
+#define mqtt_subscribe(client, topic, qos, cb, arg) mqtt_sub_unsub(client, topic, qos, cb, arg, 1)
+/** @ingroup mqtt
+ *  Unsubscribe to topic */
+#define mqtt_unsubscribe(client, topic, cb, arg) mqtt_sub_unsub(client, topic, 0, cb, arg, 0)
+
+
+/** Publish data to topic */
+err_t mqtt_publish(mqtt_client_t *client, const char *topic, const void *payload, u16_t payload_length, u8_t qos, u8_t retain,
+                                    mqtt_request_cb_t cb, void *arg);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_APPS_MQTT_CLIENT_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/mqtt_opts.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/mqtt_opts.h
new file mode 100644
index 000000000..ffefacd25
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/mqtt_opts.h
@@ -0,0 +1,103 @@
+/**
+ * @file
+ * MQTT client options
+ */
+
+/*
+ * Copyright (c) 2016 Erik Andersson
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Erik Andersson
+ *
+ */
+#ifndef LWIP_HDR_APPS_MQTT_OPTS_H
+#define LWIP_HDR_APPS_MQTT_OPTS_H
+
+#include "lwip/opt.h"
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+/**
+ * @defgroup mqtt_opts Options
+ * @ingroup mqtt
+ * @{
+ */
+
+/**
+ * Output ring-buffer size, must be able to fit largest outgoing publish message topic+payloads
+ */
+#ifndef MQTT_OUTPUT_RINGBUF_SIZE
+#define MQTT_OUTPUT_RINGBUF_SIZE 256
+#endif
+
+/**
+ * Number of bytes in receive buffer, must be at least the size of the longest incoming topic + 8
+ * If one wants to avoid fragmented incoming publish, set length to max incoming topic length + max payload length + 8
+ */
+#ifndef MQTT_VAR_HEADER_BUFFER_LEN
+#define MQTT_VAR_HEADER_BUFFER_LEN 128
+#endif
+
+/**
+ * Maximum number of pending subscribe, unsubscribe and publish requests to server .
+ */
+#ifndef MQTT_REQ_MAX_IN_FLIGHT
+#define MQTT_REQ_MAX_IN_FLIGHT 4
+#endif
+
+/**
+ * Seconds between each cyclic timer call.
+ */
+#ifndef MQTT_CYCLIC_TIMER_INTERVAL
+#define MQTT_CYCLIC_TIMER_INTERVAL 5
+#endif
+
+/**
+ * Publish, subscribe and unsubscribe request timeout in seconds.
+ */
+#ifndef MQTT_REQ_TIMEOUT
+#define MQTT_REQ_TIMEOUT 30
+#endif
+
+/**
+ * Seconds for MQTT connect response timeout after sending connect request
+ */
+#ifndef MQTT_CONNECT_TIMOUT
+#define MQTT_CONNECT_TIMOUT 100
+#endif
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_APPS_MQTT_OPTS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/netbiosns.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/netbiosns.h
new file mode 100644
index 000000000..c9f68d8d1
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/netbiosns.h
@@ -0,0 +1,43 @@
+/**
+ * @file
+ * NETBIOS name service responder
+ */
+
+/*
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ */
+#ifndef LWIP_HDR_APPS_NETBIOS_H
+#define LWIP_HDR_APPS_NETBIOS_H
+
+#include "lwip/apps/netbiosns_opts.h"
+
+void netbiosns_init(void);
+#ifndef NETBIOS_LWIP_NAME
+void netbiosns_set_name(const char* hostname);
+#endif
+void netbiosns_stop(void);
+
+#endif /* LWIP_HDR_APPS_NETBIOS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/netbiosns_opts.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/netbiosns_opts.h
new file mode 100644
index 000000000..0909ef7b9
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/netbiosns_opts.h
@@ -0,0 +1,59 @@
+/**
+ * @file
+ * NETBIOS name service responder options
+ */
+
+/*
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ */
+#ifndef LWIP_HDR_APPS_NETBIOS_OPTS_H
+#define LWIP_HDR_APPS_NETBIOS_OPTS_H
+
+#include "lwip/opt.h"
+
+/**
+ * @defgroup netbiosns_opts Options
+ * @ingroup netbiosns
+ * @{
+ */
+
+/** NetBIOS name of lwip device
+ * This must be uppercase until NETBIOS_STRCMP() is defined to a string
+ * comparision function that is case insensitive.
+ * If you want to use the netif's hostname, use this (with LWIP_NETIF_HOSTNAME):
+ * (ip_current_netif() != NULL ? ip_current_netif()->hostname != NULL ? ip_current_netif()->hostname : "" : "")
+ *
+ * If this is not defined, netbiosns_set_name() can be called at runtime to change the name.
+ */
+#ifdef __DOXYGEN__
+#define NETBIOS_LWIP_NAME "NETBIOSLWIPDEV"
+#endif
+
+/**
+ * @}
+ */
+
+#endif /* LWIP_HDR_APPS_NETBIOS_OPTS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/snmp.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/snmp.h
new file mode 100644
index 000000000..10e8ff434
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/snmp.h
@@ -0,0 +1,128 @@
+/**
+ * @file
+ * SNMP server main API - start and basic configuration
+ */
+
+/*
+ * Copyright (c) 2001, 2002 Leon Woestenberg <leon.woestenberg@axon.tv>
+ * Copyright (c) 2001, 2002 Axon Digital Design B.V., The Netherlands.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Leon Woestenberg <leon.woestenberg@axon.tv>
+ *         Martin Hentschel <info@cl-soft.de>
+ *
+ */
+#ifndef LWIP_HDR_APPS_SNMP_H
+#define LWIP_HDR_APPS_SNMP_H
+
+#include "lwip/apps/snmp_opts.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_SNMP /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/err.h"
+#include "lwip/apps/snmp_core.h"
+
+/** SNMP variable binding descriptor (publically needed for traps) */
+struct snmp_varbind
+{
+  /** pointer to next varbind, NULL for last in list */
+  struct snmp_varbind *next;
+  /** pointer to previous varbind, NULL for first in list */
+  struct snmp_varbind *prev;
+
+  /** object identifier */
+  struct snmp_obj_id oid;
+
+  /** value ASN1 type */
+  u8_t type;
+  /** object value length */
+  u16_t value_len;
+  /** object value */
+  void *value;
+};
+
+/**
+ * @ingroup snmp_core
+ * Agent setup, start listening to port 161.
+ */
+void snmp_init(void);
+void snmp_set_mibs(const struct snmp_mib **mibs, u8_t num_mibs);
+
+void snmp_set_device_enterprise_oid(const struct snmp_obj_id* device_enterprise_oid);
+const struct snmp_obj_id* snmp_get_device_enterprise_oid(void);
+
+void snmp_trap_dst_enable(u8_t dst_idx, u8_t enable);
+void snmp_trap_dst_ip_set(u8_t dst_idx, const ip_addr_t *dst);
+
+/** Generic trap: cold start */
+#define SNMP_GENTRAP_COLDSTART 0
+/** Generic trap: warm start */
+#define SNMP_GENTRAP_WARMSTART 1
+/** Generic trap: link down */
+#define SNMP_GENTRAP_LINKDOWN 2
+/** Generic trap: link up */
+#define SNMP_GENTRAP_LINKUP 3
+/** Generic trap: authentication failure */
+#define SNMP_GENTRAP_AUTH_FAILURE 4
+/** Generic trap: EGP neighbor lost */
+#define SNMP_GENTRAP_EGP_NEIGHBOR_LOSS 5
+/** Generic trap: enterprise specific */
+#define SNMP_GENTRAP_ENTERPRISE_SPECIFIC 6
+
+err_t snmp_send_trap_generic(s32_t generic_trap);
+err_t snmp_send_trap_specific(s32_t specific_trap, struct snmp_varbind *varbinds);
+err_t snmp_send_trap(const struct snmp_obj_id* oid, s32_t generic_trap, s32_t specific_trap, struct snmp_varbind *varbinds);
+
+#define SNMP_AUTH_TRAPS_DISABLED 0
+#define SNMP_AUTH_TRAPS_ENABLED  1
+void snmp_set_auth_traps_enabled(u8_t enable);
+u8_t snmp_get_auth_traps_enabled(void);
+
+const char * snmp_get_community(void);
+const char * snmp_get_community_write(void);
+const char * snmp_get_community_trap(void);
+void snmp_set_community(const char * const community);
+void snmp_set_community_write(const char * const community);
+void snmp_set_community_trap(const char * const community);
+
+void snmp_coldstart_trap(void);
+void snmp_authfail_trap(void);
+
+typedef void (*snmp_write_callback_fct)(const u32_t* oid, u8_t oid_len, void* callback_arg);
+void snmp_set_write_callback(snmp_write_callback_fct write_callback, void* callback_arg);
+
+#endif /* LWIP_SNMP */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_APPS_SNMP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/snmp_core.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/snmp_core.h
new file mode 100644
index 000000000..e781c532b
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/snmp_core.h
@@ -0,0 +1,364 @@
+/**
+ * @file
+ * SNMP core API for implementing MIBs
+ */
+
+/*
+ * Copyright (c) 2006 Axon Digital Design B.V., The Netherlands.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * Author: Christiaan Simons <christiaan.simons@axon.tv>
+ *         Martin Hentschel <info@cl-soft.de>
+ */
+
+#ifndef LWIP_HDR_APPS_SNMP_CORE_H
+#define LWIP_HDR_APPS_SNMP_CORE_H
+
+#include "lwip/apps/snmp_opts.h"
+
+#if LWIP_SNMP /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/ip_addr.h"
+#include "lwip/err.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* basic ASN1 defines */
+#define SNMP_ASN1_CLASS_UNIVERSAL   0x00
+#define SNMP_ASN1_CLASS_APPLICATION 0x40
+#define SNMP_ASN1_CLASS_CONTEXT     0x80
+#define SNMP_ASN1_CLASS_PRIVATE     0xC0
+
+#define SNMP_ASN1_CONTENTTYPE_PRIMITIVE   0x00
+#define SNMP_ASN1_CONTENTTYPE_CONSTRUCTED 0x20
+
+/* universal tags (from ASN.1 spec.) */
+#define SNMP_ASN1_UNIVERSAL_END_OF_CONTENT  0
+#define SNMP_ASN1_UNIVERSAL_INTEGER         2
+#define SNMP_ASN1_UNIVERSAL_OCTET_STRING    4
+#define SNMP_ASN1_UNIVERSAL_NULL            5
+#define SNMP_ASN1_UNIVERSAL_OBJECT_ID       6
+#define SNMP_ASN1_UNIVERSAL_SEQUENCE_OF    16
+
+/* application specific (SNMP) tags (from SNMPv2-SMI) */
+#define SNMP_ASN1_APPLICATION_IPADDR    0  /* [APPLICATION 0] IMPLICIT OCTET STRING (SIZE (4)) */
+#define SNMP_ASN1_APPLICATION_COUNTER   1  /* [APPLICATION 1] IMPLICIT INTEGER (0..4294967295) => u32_t */
+#define SNMP_ASN1_APPLICATION_GAUGE     2  /* [APPLICATION 2] IMPLICIT INTEGER (0..4294967295) => u32_t */
+#define SNMP_ASN1_APPLICATION_TIMETICKS 3  /* [APPLICATION 3] IMPLICIT INTEGER (0..4294967295) => u32_t */
+#define SNMP_ASN1_APPLICATION_OPAQUE    4  /* [APPLICATION 4] IMPLICIT OCTET STRING */
+#define SNMP_ASN1_APPLICATION_COUNTER64 6  /* [APPLICATION 6] IMPLICIT INTEGER (0..18446744073709551615) */
+
+/* context specific (SNMP) tags (from RFC 1905) */
+#define SNMP_ASN1_CONTEXT_VARBIND_NO_SUCH_INSTANCE 1
+
+/* full ASN1 type defines */
+#define SNMP_ASN1_TYPE_END_OF_CONTENT (SNMP_ASN1_CLASS_UNIVERSAL | SNMP_ASN1_CONTENTTYPE_PRIMITIVE | SNMP_ASN1_UNIVERSAL_END_OF_CONTENT)
+#define SNMP_ASN1_TYPE_INTEGER        (SNMP_ASN1_CLASS_UNIVERSAL | SNMP_ASN1_CONTENTTYPE_PRIMITIVE | SNMP_ASN1_UNIVERSAL_INTEGER)
+#define SNMP_ASN1_TYPE_OCTET_STRING   (SNMP_ASN1_CLASS_UNIVERSAL | SNMP_ASN1_CONTENTTYPE_PRIMITIVE | SNMP_ASN1_UNIVERSAL_OCTET_STRING)
+#define SNMP_ASN1_TYPE_NULL           (SNMP_ASN1_CLASS_UNIVERSAL | SNMP_ASN1_CONTENTTYPE_PRIMITIVE | SNMP_ASN1_UNIVERSAL_NULL)
+#define SNMP_ASN1_TYPE_OBJECT_ID      (SNMP_ASN1_CLASS_UNIVERSAL | SNMP_ASN1_CONTENTTYPE_PRIMITIVE | SNMP_ASN1_UNIVERSAL_OBJECT_ID)
+#define SNMP_ASN1_TYPE_SEQUENCE       (SNMP_ASN1_CLASS_UNIVERSAL | SNMP_ASN1_CONTENTTYPE_CONSTRUCTED | SNMP_ASN1_UNIVERSAL_SEQUENCE_OF)
+#define SNMP_ASN1_TYPE_IPADDR         (SNMP_ASN1_CLASS_APPLICATION | SNMP_ASN1_CONTENTTYPE_PRIMITIVE | SNMP_ASN1_APPLICATION_IPADDR)
+#define SNMP_ASN1_TYPE_IPADDRESS      SNMP_ASN1_TYPE_IPADDR
+#define SNMP_ASN1_TYPE_COUNTER        (SNMP_ASN1_CLASS_APPLICATION | SNMP_ASN1_CONTENTTYPE_PRIMITIVE | SNMP_ASN1_APPLICATION_COUNTER)
+#define SNMP_ASN1_TYPE_COUNTER32      SNMP_ASN1_TYPE_COUNTER
+#define SNMP_ASN1_TYPE_GAUGE          (SNMP_ASN1_CLASS_APPLICATION | SNMP_ASN1_CONTENTTYPE_PRIMITIVE | SNMP_ASN1_APPLICATION_GAUGE)
+#define SNMP_ASN1_TYPE_GAUGE32        SNMP_ASN1_TYPE_GAUGE
+#define SNMP_ASN1_TYPE_UNSIGNED32     SNMP_ASN1_TYPE_GAUGE
+#define SNMP_ASN1_TYPE_TIMETICKS      (SNMP_ASN1_CLASS_APPLICATION | SNMP_ASN1_CONTENTTYPE_PRIMITIVE | SNMP_ASN1_APPLICATION_TIMETICKS)
+#define SNMP_ASN1_TYPE_OPAQUE         (SNMP_ASN1_CLASS_APPLICATION | SNMP_ASN1_CONTENTTYPE_PRIMITIVE | SNMP_ASN1_APPLICATION_OPAQUE)
+#define SNMP_ASN1_TYPE_COUNTER64      (SNMP_ASN1_CLASS_APPLICATION | SNMP_ASN1_CONTENTTYPE_PRIMITIVE | SNMP_ASN1_APPLICATION_COUNTER64)
+
+#define SNMP_VARBIND_EXCEPTION_OFFSET 0xF0
+#define SNMP_VARBIND_EXCEPTION_MASK   0x0F
+
+/** error codes predefined by SNMP prot. */
+typedef enum {
+  SNMP_ERR_NOERROR             = 0,
+/* 
+outdated v1 error codes. do not use anmore!
+#define SNMP_ERR_NOSUCHNAME 2  use SNMP_ERR_NOSUCHINSTANCE instead
+#define SNMP_ERR_BADVALUE   3  use SNMP_ERR_WRONGTYPE,SNMP_ERR_WRONGLENGTH,SNMP_ERR_WRONGENCODING or SNMP_ERR_WRONGVALUE instead
+#define SNMP_ERR_READONLY   4  use SNMP_ERR_NOTWRITABLE instead
+*/
+  SNMP_ERR_GENERROR            = 5,
+  SNMP_ERR_NOACCESS            = 6,
+  SNMP_ERR_WRONGTYPE           = 7,
+  SNMP_ERR_WRONGLENGTH         = 8,
+  SNMP_ERR_WRONGENCODING       = 9,
+  SNMP_ERR_WRONGVALUE          = 10,
+  SNMP_ERR_NOCREATION          = 11,
+  SNMP_ERR_INCONSISTENTVALUE   = 12,
+  SNMP_ERR_RESOURCEUNAVAILABLE = 13,
+  SNMP_ERR_COMMITFAILED        = 14,
+  SNMP_ERR_UNDOFAILED          = 15,
+  SNMP_ERR_NOTWRITABLE         = 17,
+  SNMP_ERR_INCONSISTENTNAME    = 18,
+
+  SNMP_ERR_NOSUCHINSTANCE      = SNMP_VARBIND_EXCEPTION_OFFSET + SNMP_ASN1_CONTEXT_VARBIND_NO_SUCH_INSTANCE
+} snmp_err_t;
+
+/** internal object identifier representation */
+struct snmp_obj_id
+{
+  u8_t len;
+  u32_t id[SNMP_MAX_OBJ_ID_LEN];
+};
+
+struct snmp_obj_id_const_ref
+{
+  u8_t len;
+  const u32_t* id;
+};
+
+extern const struct snmp_obj_id_const_ref snmp_zero_dot_zero; /* administrative identifier from SNMPv2-SMI */
+
+/** SNMP variant value, used as reference in struct snmp_node_instance and table implementation */
+union snmp_variant_value
+{
+  void* ptr;
+  const void* const_ptr;
+  u32_t u32;
+  s32_t s32;
+};
+
+
+/**
+SNMP MIB node types
+ tree node is the only node the stack can process in order to walk the tree,
+ all other nodes are assumed to be leaf nodes.
+ This cannot be an enum because users may want to define their own node types.
+*/
+#define SNMP_NODE_TREE         0x00
+/* predefined leaf node types */
+#define SNMP_NODE_SCALAR       0x01
+#define SNMP_NODE_SCALAR_ARRAY 0x02
+#define SNMP_NODE_TABLE        0x03
+#define SNMP_NODE_THREADSYNC   0x04
+
+/** node "base class" layout, the mandatory fields for a node  */
+struct snmp_node
+{
+  /** one out of SNMP_NODE_TREE or any leaf node type (like SNMP_NODE_SCALAR) */
+  u8_t node_type;
+  /** the number assigned to this node which used as part of the full OID */
+  u32_t oid;
+};
+
+/** SNMP node instance access types */
+typedef enum {
+  SNMP_NODE_INSTANCE_ACCESS_READ    = 1,
+  SNMP_NODE_INSTANCE_ACCESS_WRITE   = 2,
+  SNMP_NODE_INSTANCE_READ_ONLY      = SNMP_NODE_INSTANCE_ACCESS_READ,
+  SNMP_NODE_INSTANCE_READ_WRITE     = (SNMP_NODE_INSTANCE_ACCESS_READ | SNMP_NODE_INSTANCE_ACCESS_WRITE),
+  SNMP_NODE_INSTANCE_WRITE_ONLY     = SNMP_NODE_INSTANCE_ACCESS_WRITE,
+  SNMP_NODE_INSTANCE_NOT_ACCESSIBLE = 0
+} snmp_access_t;
+
+struct snmp_node_instance;
+
+typedef s16_t (*node_instance_get_value_method)(struct snmp_node_instance*, void*);
+typedef snmp_err_t (*node_instance_set_test_method)(struct snmp_node_instance*, u16_t, void*);
+typedef snmp_err_t (*node_instance_set_value_method)(struct snmp_node_instance*, u16_t, void*);
+typedef void (*node_instance_release_method)(struct snmp_node_instance*);
+
+#define SNMP_GET_VALUE_RAW_DATA 0x8000
+
+/** SNMP node instance */
+struct snmp_node_instance
+{
+  /** prefilled with the node, get_instance() is called on; may be changed by user to any value to pass an arbitrary node between calls to get_instance() and get_value/test_value/set_value */
+  const struct snmp_node* node;
+  /** prefilled with the instance id requested; for get_instance() this is the exact oid requested; for get_next_instance() this is the relative starting point, stack expects relative oid of next node here */
+  struct snmp_obj_id instance_oid;
+
+  /** ASN type for this object (see snmp_asn1.h for definitions) */
+  u8_t asn1_type;
+  /** one out of instance access types defined above (SNMP_NODE_INSTANCE_READ_ONLY,...) */
+  snmp_access_t access;
+
+  /** returns object value for the given object identifier. Return values <0 to indicate an error */
+  node_instance_get_value_method get_value;
+  /** tests length and/or range BEFORE setting */
+  node_instance_set_test_method set_test;
+  /** sets object value, only called when set_test() was successful */
+  node_instance_set_value_method set_value;
+  /** called in any case when the instance is not required anymore by stack (useful for freeing memory allocated in get_instance/get_next_instance methods) */
+  node_instance_release_method release_instance;
+
+  /** reference to pass arbitrary value between calls to get_instance() and get_value/test_value/set_value */
+  union snmp_variant_value reference;
+  /** see reference (if reference is a pointer, the length of underlying data may be stored here or anything else) */
+  u32_t reference_len;
+};
+
+
+/** SNMP tree node */
+struct snmp_tree_node
+{
+  /** inherited "base class" members */
+  struct snmp_node node;
+  u16_t subnode_count;
+  const struct snmp_node* const *subnodes;
+};
+
+#define SNMP_CREATE_TREE_NODE(oid, subnodes) \
+  {{ SNMP_NODE_TREE, (oid) }, \
+  (u16_t)LWIP_ARRAYSIZE(subnodes), (subnodes) }
+
+#define SNMP_CREATE_EMPTY_TREE_NODE(oid) \
+  {{ SNMP_NODE_TREE, (oid) }, \
+  0, NULL }
+
+/** SNMP leaf node */
+struct snmp_leaf_node
+{
+  /** inherited "base class" members */
+  struct snmp_node node;
+  snmp_err_t (*get_instance)(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance* instance);
+  snmp_err_t (*get_next_instance)(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance* instance);
+};
+
+/** represents a single mib with its base oid and root node */
+struct snmp_mib
+{
+  const u32_t *base_oid;
+  u8_t base_oid_len;
+  const struct snmp_node *root_node;
+};
+
+#define SNMP_MIB_CREATE(oid_list, root_node) { (oid_list), (u8_t)LWIP_ARRAYSIZE(oid_list), root_node }
+
+/** OID range structure */
+struct snmp_oid_range
+{
+  u32_t min;
+  u32_t max;
+};
+
+/** checks if incoming OID length and values are in allowed ranges */
+u8_t snmp_oid_in_range(const u32_t *oid_in, u8_t oid_len, const struct snmp_oid_range *oid_ranges, u8_t oid_ranges_len);
+
+typedef enum {
+  SNMP_NEXT_OID_STATUS_SUCCESS,
+  SNMP_NEXT_OID_STATUS_NO_MATCH,
+  SNMP_NEXT_OID_STATUS_BUF_TO_SMALL
+} snmp_next_oid_status_t;
+
+/** state for next_oid_init / next_oid_check functions */
+struct snmp_next_oid_state
+{
+  const u32_t* start_oid;
+  u8_t start_oid_len;
+
+  u32_t* next_oid;
+  u8_t next_oid_len;
+  u8_t next_oid_max_len;
+
+  snmp_next_oid_status_t status;
+  void* reference;
+};
+
+void snmp_next_oid_init(struct snmp_next_oid_state *state,
+  const u32_t *start_oid, u8_t start_oid_len,
+  u32_t *next_oid_buf, u8_t next_oid_max_len);
+u8_t snmp_next_oid_precheck(struct snmp_next_oid_state *state, const u32_t *oid, const u8_t oid_len);
+u8_t snmp_next_oid_check(struct snmp_next_oid_state *state, const u32_t *oid, const u8_t oid_len, void* reference);
+
+void snmp_oid_assign(struct snmp_obj_id* target, const u32_t *oid, u8_t oid_len);
+void snmp_oid_combine(struct snmp_obj_id* target, const u32_t *oid1, u8_t oid1_len, const u32_t *oid2, u8_t oid2_len);
+void snmp_oid_prefix(struct snmp_obj_id* target, const u32_t *oid, u8_t oid_len);
+void snmp_oid_append(struct snmp_obj_id* target, const u32_t *oid, u8_t oid_len);
+u8_t snmp_oid_equal(const u32_t *oid1, u8_t oid1_len, const u32_t *oid2, u8_t oid2_len);
+s8_t snmp_oid_compare(const u32_t *oid1, u8_t oid1_len, const u32_t *oid2, u8_t oid2_len);
+
+#if LWIP_IPV4
+u8_t snmp_oid_to_ip4(const u32_t *oid, ip4_addr_t *ip);
+void snmp_ip4_to_oid(const ip4_addr_t *ip, u32_t *oid);
+#endif /* LWIP_IPV4 */
+#if LWIP_IPV6
+u8_t snmp_oid_to_ip6(const u32_t *oid, ip6_addr_t *ip);
+void snmp_ip6_to_oid(const ip6_addr_t *ip, u32_t *oid);
+#endif /* LWIP_IPV6 */
+#if LWIP_IPV4 || LWIP_IPV6
+u8_t snmp_ip_to_oid(const ip_addr_t *ip, u32_t *oid);
+u8_t snmp_ip_port_to_oid(const ip_addr_t *ip, u16_t port, u32_t *oid);
+
+u8_t snmp_oid_to_ip(const u32_t *oid, u8_t oid_len, ip_addr_t *ip);
+u8_t snmp_oid_to_ip_port(const u32_t *oid, u8_t oid_len, ip_addr_t *ip, u16_t *port);
+#endif /* LWIP_IPV4 || LWIP_IPV6 */
+
+struct netif;
+u8_t netif_to_num(const struct netif *netif);
+
+snmp_err_t snmp_set_test_ok(struct snmp_node_instance* instance, u16_t value_len, void* value); /* generic function which can be used if test is always successful */
+
+err_t snmp_decode_bits(const u8_t *buf, u32_t buf_len, u32_t *bit_value);
+err_t snmp_decode_truthvalue(const s32_t *asn1_value, u8_t *bool_value);
+u8_t  snmp_encode_bits(u8_t *buf, u32_t buf_len, u32_t bit_value, u8_t bit_count);
+u8_t  snmp_encode_truthvalue(s32_t *asn1_value, u32_t bool_value);
+
+struct snmp_statistics
+{
+  u32_t inpkts;
+  u32_t outpkts;
+  u32_t inbadversions;
+  u32_t inbadcommunitynames;
+  u32_t inbadcommunityuses;
+  u32_t inasnparseerrs;
+  u32_t intoobigs;
+  u32_t innosuchnames;
+  u32_t inbadvalues;
+  u32_t inreadonlys;
+  u32_t ingenerrs;
+  u32_t intotalreqvars;
+  u32_t intotalsetvars;
+  u32_t ingetrequests;
+  u32_t ingetnexts;
+  u32_t insetrequests;
+  u32_t ingetresponses;
+  u32_t intraps;
+  u32_t outtoobigs;
+  u32_t outnosuchnames;
+  u32_t outbadvalues;
+  u32_t outgenerrs;
+  u32_t outgetrequests;
+  u32_t outgetnexts;
+  u32_t outsetrequests;
+  u32_t outgetresponses;
+  u32_t outtraps;
+};
+
+extern struct snmp_statistics snmp_stats;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_SNMP */
+
+#endif /* LWIP_HDR_APPS_SNMP_CORE_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/snmp_mib2.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/snmp_mib2.h
new file mode 100644
index 000000000..2f4a68935
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/snmp_mib2.h
@@ -0,0 +1,78 @@
+/**
+ * @file
+ * SNMP MIB2 API
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Dirk Ziegelmeier <dziegel@gmx.de>
+ *
+ */
+#ifndef LWIP_HDR_APPS_SNMP_MIB2_H
+#define LWIP_HDR_APPS_SNMP_MIB2_H
+
+#include "lwip/apps/snmp_opts.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_SNMP /* don't build if not configured for use in lwipopts.h */
+#if SNMP_LWIP_MIB2
+
+#include "lwip/apps/snmp_core.h"
+
+extern const struct snmp_mib mib2;
+
+#if SNMP_USE_NETCONN
+#include "lwip/apps/snmp_threadsync.h"
+void snmp_mib2_lwip_synchronizer(snmp_threadsync_called_fn fn, void* arg);
+extern struct snmp_threadsync_instance snmp_mib2_lwip_locks;
+#endif
+
+#ifndef SNMP_SYSSERVICES
+#define SNMP_SYSSERVICES ((1 << 6) | (1 << 3) | ((IP_FORWARD) << 2))
+#endif
+
+void snmp_mib2_set_sysdescr(const u8_t* str, const u16_t* len); /* read-only be defintion */
+void snmp_mib2_set_syscontact(u8_t *ocstr, u16_t *ocstrlen, u16_t bufsize);
+void snmp_mib2_set_syscontact_readonly(const u8_t *ocstr, const u16_t *ocstrlen);
+void snmp_mib2_set_sysname(u8_t *ocstr, u16_t *ocstrlen, u16_t bufsize);
+void snmp_mib2_set_sysname_readonly(const u8_t *ocstr, const u16_t *ocstrlen);
+void snmp_mib2_set_syslocation(u8_t *ocstr, u16_t *ocstrlen, u16_t bufsize);
+void snmp_mib2_set_syslocation_readonly(const u8_t *ocstr, const u16_t *ocstrlen);
+
+#endif /* SNMP_LWIP_MIB2 */
+#endif /* LWIP_SNMP */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_APPS_SNMP_MIB2_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/snmp_opts.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/snmp_opts.h
new file mode 100644
index 000000000..6c9ba7beb
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/snmp_opts.h
@@ -0,0 +1,293 @@
+/**
+ * @file
+ * SNMP server options list
+ */
+
+/*
+ * Copyright (c) 2015 Dirk Ziegelmeier
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Dirk Ziegelmeier
+ *
+ */
+#ifndef LWIP_HDR_SNMP_OPTS_H
+#define LWIP_HDR_SNMP_OPTS_H
+
+#include "lwip/opt.h"
+
+/**
+ * @defgroup snmp_opts Options
+ * @ingroup snmp
+ * @{
+ */
+
+/**
+ * LWIP_SNMP==1: This enables the lwIP SNMP agent. UDP must be available
+ * for SNMP transport.
+ * If you want to use your own SNMP agent, leave this disabled.
+ * To integrate MIB2 of an external agent, you need to enable
+ * LWIP_MIB2_CALLBACKS and MIB2_STATS. This will give you the callbacks
+ * and statistics counters you need to get MIB2 working.
+ */
+#if !defined LWIP_SNMP || defined __DOXYGEN__
+#define LWIP_SNMP                       0
+#endif
+
+/**
+ * SNMP_USE_NETCONN: Use netconn API instead of raw API.
+ * Makes SNMP agent run in a worker thread, so blocking operations
+ * can be done in MIB calls.
+ */
+#if !defined SNMP_USE_NETCONN || defined __DOXYGEN__
+#define SNMP_USE_NETCONN           0
+#endif
+
+/**
+ * SNMP_USE_RAW: Use raw API.
+ * SNMP agent does not run in a worker thread, so blocking operations
+ * should not be done in MIB calls.
+ */
+#if !defined SNMP_USE_RAW || defined __DOXYGEN__
+#define SNMP_USE_RAW               1
+#endif
+
+#if SNMP_USE_NETCONN && SNMP_USE_RAW
+#error SNMP stack can use only one of the APIs {raw, netconn}
+#endif
+
+#if LWIP_SNMP && !SNMP_USE_NETCONN && !SNMP_USE_RAW
+#error SNMP stack needs a receive API and UDP {raw, netconn}
+#endif
+
+#if SNMP_USE_NETCONN
+/**
+ * SNMP_STACK_SIZE: Stack size of SNMP netconn worker thread
+ */
+#if !defined SNMP_STACK_SIZE || defined __DOXYGEN__
+#define SNMP_STACK_SIZE            DEFAULT_THREAD_STACKSIZE
+#endif
+
+/**
+ * SNMP_THREAD_PRIO: SNMP netconn worker thread priority
+ */
+#if !defined SNMP_THREAD_PRIO || defined __DOXYGEN__
+#define SNMP_THREAD_PRIO           DEFAULT_THREAD_PRIO
+#endif
+#endif /* SNMP_USE_NETCONN */
+
+/**
+ * SNMP_TRAP_DESTINATIONS: Number of trap destinations. At least one trap
+ * destination is required
+ */
+#if !defined SNMP_TRAP_DESTINATIONS || defined __DOXYGEN__
+#define SNMP_TRAP_DESTINATIONS          1
+#endif
+
+/**
+ * Only allow SNMP write actions that are 'safe' (e.g. disabling netifs is not
+ * a safe action and disabled when SNMP_SAFE_REQUESTS = 1).
+ * Unsafe requests are disabled by default!
+ */
+#if !defined SNMP_SAFE_REQUESTS || defined __DOXYGEN__
+#define SNMP_SAFE_REQUESTS              1
+#endif
+
+/**
+ * The maximum length of strings used.
+ */
+#if !defined SNMP_MAX_OCTET_STRING_LEN || defined __DOXYGEN__
+#define SNMP_MAX_OCTET_STRING_LEN       127
+#endif
+
+/**
+ * The maximum number of Sub ID's inside an object identifier.
+ * Indirectly this also limits the maximum depth of SNMP tree.
+ */
+#if !defined SNMP_MAX_OBJ_ID_LEN || defined __DOXYGEN__
+#define SNMP_MAX_OBJ_ID_LEN             50
+#endif
+
+#if !defined SNMP_MAX_VALUE_SIZE || defined __DOXYGEN__
+/**
+ * The maximum size of a value.
+ */
+#define SNMP_MIN_VALUE_SIZE             (2 * sizeof(u32_t*)) /* size required to store the basic types (8 bytes for counter64) */
+/**
+ * The minimum size of a value.
+ */
+#define SNMP_MAX_VALUE_SIZE             LWIP_MAX(LWIP_MAX((SNMP_MAX_OCTET_STRING_LEN), sizeof(u32_t)*(SNMP_MAX_OBJ_ID_LEN)), SNMP_MIN_VALUE_SIZE)
+#endif
+
+/**
+ * The snmp read-access community. Used for write-access and traps, too
+ * unless SNMP_COMMUNITY_WRITE or SNMP_COMMUNITY_TRAP are enabled, respectively.
+ */
+#if !defined SNMP_COMMUNITY || defined __DOXYGEN__
+#define SNMP_COMMUNITY                  "public"
+#endif
+
+/**
+ * The snmp write-access community.
+ * Set this community to "" in order to disallow any write access.
+ */
+#if !defined SNMP_COMMUNITY_WRITE || defined __DOXYGEN__
+#define SNMP_COMMUNITY_WRITE            "private"
+#endif
+
+/**
+ * The snmp community used for sending traps.
+ */
+#if !defined SNMP_COMMUNITY_TRAP || defined __DOXYGEN__
+#define SNMP_COMMUNITY_TRAP             "public"
+#endif
+
+/**
+ * The maximum length of community string.
+ * If community names shall be adjusted at runtime via snmp_set_community() calls,
+ * enter here the possible maximum length (+1 for terminating null character).
+ */
+#if !defined SNMP_MAX_COMMUNITY_STR_LEN || defined __DOXYGEN__
+#define SNMP_MAX_COMMUNITY_STR_LEN LWIP_MAX(LWIP_MAX(sizeof(SNMP_COMMUNITY), sizeof(SNMP_COMMUNITY_WRITE)), sizeof(SNMP_COMMUNITY_TRAP))
+#endif
+
+/**
+ * The OID identifiying the device. This may be the enterprise OID itself or any OID located below it in tree.
+ */
+#if !defined SNMP_DEVICE_ENTERPRISE_OID || defined __DOXYGEN__
+#define SNMP_LWIP_ENTERPRISE_OID 26381
+/**
+ * IANA assigned enterprise ID for lwIP is 26381
+ * @see http://www.iana.org/assignments/enterprise-numbers
+ *
+ * @note this enterprise ID is assigned to the lwIP project,
+ * all object identifiers living under this ID are assigned
+ * by the lwIP maintainers!
+ * @note don't change this define, use snmp_set_device_enterprise_oid()
+ *
+ * If you need to create your own private MIB you'll need
+ * to apply for your own enterprise ID with IANA:
+ * http://www.iana.org/numbers.html
+ */
+#define SNMP_DEVICE_ENTERPRISE_OID {1, 3, 6, 1, 4, 1, SNMP_LWIP_ENTERPRISE_OID}
+/**
+ * Length of SNMP_DEVICE_ENTERPRISE_OID
+ */
+#define SNMP_DEVICE_ENTERPRISE_OID_LEN 7
+#endif
+
+/**
+ * SNMP_DEBUG: Enable debugging for SNMP messages.
+ */
+#if !defined SNMP_DEBUG || defined __DOXYGEN__
+#define SNMP_DEBUG                      LWIP_DBG_OFF
+#endif
+
+/**
+ * SNMP_MIB_DEBUG: Enable debugging for SNMP MIBs.
+ */
+#if !defined SNMP_MIB_DEBUG || defined __DOXYGEN__
+#define SNMP_MIB_DEBUG                  LWIP_DBG_OFF
+#endif
+
+/**
+ * Indicates if the MIB2 implementation of LWIP SNMP stack is used.
+ */
+#if !defined SNMP_LWIP_MIB2 || defined __DOXYGEN__
+#define SNMP_LWIP_MIB2                      LWIP_SNMP
+#endif
+
+/**
+ * Value return for sysDesc field of MIB2.
+ */
+#if !defined SNMP_LWIP_MIB2_SYSDESC || defined __DOXYGEN__
+#define SNMP_LWIP_MIB2_SYSDESC              "lwIP"
+#endif
+
+/**
+ * Value return for sysName field of MIB2.
+ * To make sysName field settable, call snmp_mib2_set_sysname() to provide the necessary buffers.
+ */
+#if !defined SNMP_LWIP_MIB2_SYSNAME || defined __DOXYGEN__
+#define SNMP_LWIP_MIB2_SYSNAME              "FQDN-unk"
+#endif
+
+/**
+ * Value return for sysContact field of MIB2.
+ * To make sysContact field settable, call snmp_mib2_set_syscontact() to provide the necessary buffers.
+ */
+#if !defined SNMP_LWIP_MIB2_SYSCONTACT || defined __DOXYGEN__
+#define SNMP_LWIP_MIB2_SYSCONTACT           ""
+#endif
+
+/**
+ * Value return for sysLocation field of MIB2.
+ * To make sysLocation field settable, call snmp_mib2_set_syslocation() to provide the necessary buffers.
+ */
+#if !defined SNMP_LWIP_MIB2_SYSLOCATION || defined __DOXYGEN__
+#define SNMP_LWIP_MIB2_SYSLOCATION          ""
+#endif
+
+/**
+ * This value is used to limit the repetitions processed in GetBulk requests (value == 0 means no limitation).
+ * This may be useful to limit the load for a single request.
+ * According to SNMP RFC 1905 it is allowed to not return all requested variables from a GetBulk request if system load would be too high.
+ * so the effect is that the client will do more requests to gather all data.
+ * For the stack this could be useful in case that SNMP processing is done in TCP/IP thread. In this situation a request with many
+ * repetitions could block the thread for a longer time. Setting limit here will keep the stack more responsive.
+ */
+#if !defined SNMP_LWIP_GETBULK_MAX_REPETITIONS || defined __DOXYGEN__
+#define SNMP_LWIP_GETBULK_MAX_REPETITIONS 0
+#endif
+
+/**
+ * @}
+ */
+
+/*
+   ------------------------------------
+   ---------- SNMPv3 options ----------
+   ------------------------------------
+*/
+
+/**
+ * LWIP_SNMP_V3==1: This enables EXPERIMENTAL SNMPv3 support. LWIP_SNMP must
+ * also be enabled.
+ * THIS IS UNDER DEVELOPMENT AND SHOULD NOT BE ENABLED IN PRODUCTS.
+ */
+#ifndef LWIP_SNMP_V3
+#define LWIP_SNMP_V3               0
+#endif
+
+#ifndef LWIP_SNMP_V3_CRYPTO
+#define LWIP_SNMP_V3_CRYPTO        LWIP_SNMP_V3
+#endif
+
+#ifndef LWIP_SNMP_V3_MBEDTLS
+#define LWIP_SNMP_V3_MBEDTLS       LWIP_SNMP_V3
+#endif
+
+#endif /* LWIP_HDR_SNMP_OPTS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/snmp_scalar.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/snmp_scalar.h
new file mode 100644
index 000000000..40a060c64
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/snmp_scalar.h
@@ -0,0 +1,113 @@
+/**
+ * @file
+ * SNMP server MIB API to implement scalar nodes
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Martin Hentschel <info@cl-soft.de>
+ *
+ */
+
+#ifndef LWIP_HDR_APPS_SNMP_SCALAR_H
+#define LWIP_HDR_APPS_SNMP_SCALAR_H
+
+#include "lwip/apps/snmp_opts.h"
+#include "lwip/apps/snmp_core.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_SNMP /* don't build if not configured for use in lwipopts.h */
+
+/** basic scalar node */
+struct snmp_scalar_node
+{
+  /** inherited "base class" members */
+  struct snmp_leaf_node node;
+  u8_t asn1_type;
+  snmp_access_t access;
+  node_instance_get_value_method get_value;
+  node_instance_set_test_method set_test;
+  node_instance_set_value_method set_value;
+};
+
+
+snmp_err_t snmp_scalar_get_instance(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance* instance);
+snmp_err_t snmp_scalar_get_next_instance(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance* instance);
+
+#define SNMP_SCALAR_CREATE_NODE(oid, access, asn1_type, get_value_method, set_test_method, set_value_method) \
+  {{{ SNMP_NODE_SCALAR, (oid) }, \
+    snmp_scalar_get_instance, \
+    snmp_scalar_get_next_instance }, \
+    (asn1_type), (access), (get_value_method), (set_test_method), (set_value_method) }
+
+#define SNMP_SCALAR_CREATE_NODE_READONLY(oid, asn1_type, get_value_method) SNMP_SCALAR_CREATE_NODE(oid, SNMP_NODE_INSTANCE_READ_ONLY, asn1_type, get_value_method, NULL, NULL)
+
+/** scalar array node - a tree node which contains scalars only as children */
+struct snmp_scalar_array_node_def
+{
+  u32_t         oid;
+  u8_t          asn1_type;
+  snmp_access_t access;
+};
+
+typedef s16_t (*snmp_scalar_array_get_value_method)(const struct snmp_scalar_array_node_def*, void*);
+typedef snmp_err_t (*snmp_scalar_array_set_test_method)(const struct snmp_scalar_array_node_def*, u16_t, void*);
+typedef snmp_err_t (*snmp_scalar_array_set_value_method)(const struct snmp_scalar_array_node_def*, u16_t, void*);
+
+/** basic scalar array node */
+struct snmp_scalar_array_node
+{
+  /** inherited "base class" members */
+  struct snmp_leaf_node node;
+  u16_t array_node_count;
+  const struct snmp_scalar_array_node_def* array_nodes;
+  snmp_scalar_array_get_value_method get_value;
+  snmp_scalar_array_set_test_method set_test;
+  snmp_scalar_array_set_value_method set_value;
+};
+
+snmp_err_t snmp_scalar_array_get_instance(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance* instance);
+snmp_err_t snmp_scalar_array_get_next_instance(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance* instance);
+
+#define SNMP_SCALAR_CREATE_ARRAY_NODE(oid, array_nodes, get_value_method, set_test_method, set_value_method) \
+  {{{ SNMP_NODE_SCALAR_ARRAY, (oid) }, \
+    snmp_scalar_array_get_instance, \
+    snmp_scalar_array_get_next_instance }, \
+    (u16_t)LWIP_ARRAYSIZE(array_nodes), (array_nodes), (get_value_method), (set_test_method), (set_value_method) }
+
+#endif /* LWIP_SNMP */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_APPS_SNMP_SCALAR_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/snmp_table.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/snmp_table.h
new file mode 100644
index 000000000..4988b51c2
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/snmp_table.h
@@ -0,0 +1,134 @@
+/**
+ * @file
+ * SNMP server MIB API to implement table nodes
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Martin Hentschel <info@cl-soft.de>
+ *
+ */
+
+#ifndef LWIP_HDR_APPS_SNMP_TABLE_H
+#define LWIP_HDR_APPS_SNMP_TABLE_H
+
+#include "lwip/apps/snmp_opts.h"
+#include "lwip/apps/snmp_core.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_SNMP /* don't build if not configured for use in lwipopts.h */
+
+/** default (customizable) read/write table */
+struct snmp_table_col_def
+{
+  u32_t index;
+  u8_t asn1_type;
+  snmp_access_t access;
+};
+
+/** table node */
+struct snmp_table_node
+{
+  /** inherited "base class" members */
+  struct snmp_leaf_node node;
+  u16_t column_count;
+  const struct snmp_table_col_def* columns;
+  snmp_err_t (*get_cell_instance)(const u32_t* column, const u32_t* row_oid, u8_t row_oid_len, struct snmp_node_instance* cell_instance);
+  snmp_err_t (*get_next_cell_instance)(const u32_t* column, struct snmp_obj_id* row_oid, struct snmp_node_instance* cell_instance);
+  /** returns object value for the given object identifier */
+  node_instance_get_value_method get_value;
+  /** tests length and/or range BEFORE setting */
+  node_instance_set_test_method set_test;
+  /** sets object value, only called when set_test() was successful */
+  node_instance_set_value_method set_value;
+};
+
+snmp_err_t snmp_table_get_instance(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance* instance);
+snmp_err_t snmp_table_get_next_instance(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance* instance);
+
+#define SNMP_TABLE_CREATE(oid, columns, get_cell_instance_method, get_next_cell_instance_method, get_value_method, set_test_method, set_value_method) \
+  {{{ SNMP_NODE_TABLE, (oid) }, \
+  snmp_table_get_instance, \
+  snmp_table_get_next_instance }, \
+  (u16_t)LWIP_ARRAYSIZE(columns), (columns), \
+  (get_cell_instance_method), (get_next_cell_instance_method), \
+  (get_value_method), (set_test_method), (set_value_method)}
+
+#define SNMP_TABLE_GET_COLUMN_FROM_OID(oid) ((oid)[1]) /* first array value is (fixed) row entry (fixed to 1) and 2nd value is column, follow3ed by instance */
+
+
+/** simple read-only table */
+typedef enum {
+  SNMP_VARIANT_VALUE_TYPE_U32,
+  SNMP_VARIANT_VALUE_TYPE_S32,
+  SNMP_VARIANT_VALUE_TYPE_PTR,
+  SNMP_VARIANT_VALUE_TYPE_CONST_PTR
+} snmp_table_column_data_type_t;
+
+struct snmp_table_simple_col_def
+{
+  u32_t index;
+  u8_t asn1_type;
+  snmp_table_column_data_type_t data_type; /* depending of what union member is used to store the value*/
+};
+
+/** simple read-only table node */
+struct snmp_table_simple_node
+{
+  /* inherited "base class" members */
+  struct snmp_leaf_node node;
+  u16_t column_count;
+  const struct snmp_table_simple_col_def* columns;
+  snmp_err_t (*get_cell_value)(const u32_t* column, const u32_t* row_oid, u8_t row_oid_len, union snmp_variant_value* value, u32_t* value_len);
+  snmp_err_t (*get_next_cell_instance_and_value)(const u32_t* column, struct snmp_obj_id* row_oid, union snmp_variant_value* value, u32_t* value_len);
+};
+
+snmp_err_t snmp_table_simple_get_instance(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance* instance);
+snmp_err_t snmp_table_simple_get_next_instance(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance* instance);
+
+#define SNMP_TABLE_CREATE_SIMPLE(oid, columns, get_cell_value_method, get_next_cell_instance_and_value_method) \
+  {{{ SNMP_NODE_TABLE, (oid) }, \
+  snmp_table_simple_get_instance, \
+  snmp_table_simple_get_next_instance }, \
+  (u16_t)LWIP_ARRAYSIZE(columns), (columns), (get_cell_value_method), (get_next_cell_instance_and_value_method) }
+
+s16_t snmp_table_extract_value_from_s32ref(struct snmp_node_instance* instance, void* value);
+s16_t snmp_table_extract_value_from_u32ref(struct snmp_node_instance* instance, void* value);
+s16_t snmp_table_extract_value_from_refconstptr(struct snmp_node_instance* instance, void* value);
+
+#endif /* LWIP_SNMP */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_APPS_SNMP_TABLE_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/snmp_threadsync.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/snmp_threadsync.h
new file mode 100644
index 000000000..a25dbf2d0
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/snmp_threadsync.h
@@ -0,0 +1,114 @@
+/**
+ * @file
+ * SNMP server MIB API to implement thread synchronization
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Dirk Ziegelmeier <dziegel@gmx.de>
+ *
+ */
+
+#ifndef LWIP_HDR_APPS_SNMP_THREADSYNC_H
+#define LWIP_HDR_APPS_SNMP_THREADSYNC_H
+
+#include "lwip/apps/snmp_opts.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_SNMP /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/apps/snmp_core.h"
+#include "lwip/sys.h"
+
+typedef void (*snmp_threadsync_called_fn)(void* arg);
+typedef void (*snmp_threadsync_synchronizer_fn)(snmp_threadsync_called_fn fn, void* arg);
+
+
+/** Thread sync runtime data. For internal usage only. */
+struct threadsync_data
+{
+  union {
+    snmp_err_t err;
+    s16_t s16;
+  } retval;
+  union {
+    const u32_t *root_oid;
+    void *value;
+  } arg1;
+  union {
+    u8_t root_oid_len;
+    u16_t len;
+  } arg2;
+  const struct snmp_threadsync_node *threadsync_node;
+  struct snmp_node_instance proxy_instance;
+};
+
+/** Thread sync instance. Needed EXCATLY once for every thread to be synced into. */
+struct snmp_threadsync_instance
+{
+  sys_sem_t                       sem;
+  sys_mutex_t                     sem_usage_mutex;
+  snmp_threadsync_synchronizer_fn sync_fn;
+  struct threadsync_data          data;
+};
+
+/** SNMP thread sync proxy leaf node */
+struct snmp_threadsync_node
+{
+  /* inherited "base class" members */
+  struct snmp_leaf_node           node;
+
+  const struct snmp_leaf_node     *target;
+  struct snmp_threadsync_instance *instance;
+};
+
+snmp_err_t snmp_threadsync_get_instance(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance* instance);
+snmp_err_t snmp_threadsync_get_next_instance(const u32_t *root_oid, u8_t root_oid_len, struct snmp_node_instance* instance);
+
+/** Create thread sync proxy node */
+#define SNMP_CREATE_THREAD_SYNC_NODE(oid, target_leaf_node, threadsync_instance) \
+  {{{ SNMP_NODE_THREADSYNC, (oid) }, \
+    snmp_threadsync_get_instance, \
+    snmp_threadsync_get_next_instance }, \
+    (target_leaf_node), \
+    (threadsync_instance) }
+
+/** Create thread sync instance data */
+void snmp_threadsync_init(struct snmp_threadsync_instance *instance, snmp_threadsync_synchronizer_fn sync_fn);
+
+#endif /* LWIP_SNMP */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_APPS_SNMP_THREADSYNC_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/snmpv3.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/snmpv3.h
new file mode 100644
index 000000000..c99fed4e1
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/snmpv3.h
@@ -0,0 +1,90 @@
+/**
+ * @file
+ * Additional SNMPv3 functionality RFC3414 and RFC3826.
+ */
+
+/*
+ * Copyright (c) 2016 Elias Oenal.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * Author: Elias Oenal <lwip@eliasoenal.com>
+ */
+
+#ifndef LWIP_HDR_APPS_SNMP_V3_H
+#define LWIP_HDR_APPS_SNMP_V3_H
+
+#include "lwip/apps/snmp_opts.h"
+#include "lwip/err.h"
+
+#if LWIP_SNMP && LWIP_SNMP_V3
+
+#define SNMP_V3_AUTH_ALGO_INVAL  0
+#define SNMP_V3_AUTH_ALGO_MD5    1
+#define SNMP_V3_AUTH_ALGO_SHA    2
+
+#define SNMP_V3_PRIV_ALGO_INVAL  0
+#define SNMP_V3_PRIV_ALGO_DES    1
+#define SNMP_V3_PRIV_ALGO_AES    2
+
+#define SNMP_V3_PRIV_MODE_DECRYPT  0
+#define SNMP_V3_PRIV_MODE_ENCRYPT  1
+
+/*
+ * The following callback functions must be implemented by the application.
+ * There is a dummy implementation in snmpv3_dummy.c.
+ */
+
+void snmpv3_get_engine_id(const char **id, u8_t *len);
+err_t snmpv3_set_engine_id(const char* id, u8_t len);
+
+u32_t snmpv3_get_engine_boots(void);
+void snmpv3_set_engine_boots(u32_t boots);
+
+u32_t snmpv3_get_engine_time(void);
+void snmpv3_reset_engine_time(void);
+
+err_t snmpv3_get_user(const char* username, u8_t *auth_algo, u8_t *auth_key, u8_t *priv_algo, u8_t *priv_key);
+
+/* The following functions are provided by the SNMPv3 agent */
+
+void snmpv3_engine_id_changed(void);
+
+void snmpv3_password_to_key_md5(
+    const u8_t *password,     /* IN */
+    u8_t        passwordlen,  /* IN */
+    const u8_t *engineID,     /* IN  - pointer to snmpEngineID  */
+    u8_t        engineLength, /* IN  - length of snmpEngineID */
+    u8_t       *key);         /* OUT - pointer to caller 16-octet buffer */
+
+void snmpv3_password_to_key_sha(
+    const u8_t *password,     /* IN */
+    u8_t        passwordlen,  /* IN */
+    const u8_t *engineID,     /* IN  - pointer to snmpEngineID  */
+    u8_t        engineLength, /* IN  - length of snmpEngineID */
+    u8_t       *key);         /* OUT - pointer to caller 20-octet buffer */
+
+#endif
+
+#endif /* LWIP_HDR_APPS_SNMP_V3_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/sntp.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/sntp.h
new file mode 100644
index 000000000..40df9cc59
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/sntp.h
@@ -0,0 +1,76 @@
+/**
+ * @file
+ * SNTP client API
+ */
+
+/*
+ * Copyright (c) 2007-2009 Frédéric Bernon, Simon Goldschmidt
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Frédéric Bernon, Simon Goldschmidt
+ *
+ */
+#ifndef LWIP_HDR_APPS_SNTP_H
+#define LWIP_HDR_APPS_SNTP_H
+
+#include "lwip/apps/sntp_opts.h"
+#include "lwip/ip_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* SNTP operating modes: default is to poll using unicast.
+   The mode has to be set before calling sntp_init(). */
+#define SNTP_OPMODE_POLL            0
+#define SNTP_OPMODE_LISTENONLY      1
+void sntp_setoperatingmode(u8_t operating_mode);
+u8_t sntp_getoperatingmode(void);
+
+void sntp_init(void);
+void sntp_stop(void);
+u8_t sntp_enabled(void);
+
+void sntp_setserver(u8_t idx, const ip_addr_t *addr);
+const ip_addr_t* sntp_getserver(u8_t idx);
+
+#if SNTP_SERVER_DNS
+void sntp_setservername(u8_t idx, char *server);
+char *sntp_getservername(u8_t idx);
+#endif /* SNTP_SERVER_DNS */
+
+#if SNTP_GET_SERVERS_FROM_DHCP
+void sntp_servermode_dhcp(int set_servers_from_dhcp);
+#else /* SNTP_GET_SERVERS_FROM_DHCP */
+#define sntp_servermode_dhcp(x)
+#endif /* SNTP_GET_SERVERS_FROM_DHCP */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_APPS_SNTP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/sntp_opts.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/sntp_opts.h
new file mode 100644
index 000000000..f3651f90e
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/sntp_opts.h
@@ -0,0 +1,173 @@
+/**
+ * @file
+ * SNTP client options list
+ */
+
+/*
+ * Copyright (c) 2007-2009 Frédéric Bernon, Simon Goldschmidt
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Frédéric Bernon, Simon Goldschmidt
+ *
+ */
+#ifndef LWIP_HDR_APPS_SNTP_OPTS_H
+#define LWIP_HDR_APPS_SNTP_OPTS_H
+
+#include "lwip/opt.h"
+
+/**
+ * @defgroup sntp_opts Options
+ * @ingroup sntp
+ * @{
+ */
+
+/** SNTP macro to change system time in seconds
+ * Define SNTP_SET_SYSTEM_TIME_US(sec, us) to set the time in microseconds instead of this one
+ * if you need the additional precision.
+ */
+#if !defined SNTP_SET_SYSTEM_TIME || defined __DOXYGEN__
+#define SNTP_SET_SYSTEM_TIME(sec)   LWIP_UNUSED_ARG(sec)
+#endif
+
+/** The maximum number of SNTP servers that can be set */
+#if !defined SNTP_MAX_SERVERS || defined __DOXYGEN__
+#define SNTP_MAX_SERVERS           LWIP_DHCP_MAX_NTP_SERVERS
+#endif
+
+/** Set this to 1 to implement the callback function called by dhcp when
+ * NTP servers are received. */
+#if !defined SNTP_GET_SERVERS_FROM_DHCP || defined __DOXYGEN__
+#define SNTP_GET_SERVERS_FROM_DHCP LWIP_DHCP_GET_NTP_SRV
+#endif
+
+/** Set this to 1 to support DNS names (or IP address strings) to set sntp servers
+ * One server address/name can be defined as default if SNTP_SERVER_DNS == 1:
+ * \#define SNTP_SERVER_ADDRESS "pool.ntp.org"
+ */
+#if !defined SNTP_SERVER_DNS || defined __DOXYGEN__
+#define SNTP_SERVER_DNS            0
+#endif
+
+/**
+ * SNTP_DEBUG: Enable debugging for SNTP.
+ */
+#if !defined SNTP_DEBUG || defined __DOXYGEN__
+#define SNTP_DEBUG                  LWIP_DBG_OFF
+#endif
+
+/** SNTP server port */
+#if !defined SNTP_PORT || defined __DOXYGEN__
+#define SNTP_PORT                   123
+#endif
+
+/** Set this to 1 to allow config of SNTP server(s) by DNS name */
+#if !defined SNTP_SERVER_DNS || defined __DOXYGEN__
+#define SNTP_SERVER_DNS             0
+#endif
+
+/** Sanity check:
+ * Define this to
+ * - 0 to turn off sanity checks (default; smaller code)
+ * - >= 1 to check address and port of the response packet to ensure the
+ *        response comes from the server we sent the request to.
+ * - >= 2 to check returned Originate Timestamp against Transmit Timestamp
+ *        sent to the server (to ensure response to older request).
+ * - >= 3 @todo: discard reply if any of the LI, Stratum, or Transmit Timestamp
+ *        fields is 0 or the Mode field is not 4 (unicast) or 5 (broadcast).
+ * - >= 4 @todo: to check that the Root Delay and Root Dispersion fields are each
+ *        greater than or equal to 0 and less than infinity, where infinity is
+ *        currently a cozy number like one second. This check avoids using a
+ *        server whose synchronization source has expired for a very long time.
+ */
+#if !defined SNTP_CHECK_RESPONSE || defined __DOXYGEN__
+#define SNTP_CHECK_RESPONSE         0
+#endif
+
+/** According to the RFC, this shall be a random delay
+ * between 1 and 5 minutes (in milliseconds) to prevent load peaks.
+ * This can be defined to a random generation function,
+ * which must return the delay in milliseconds as u32_t.
+ * Turned off by default.
+ */
+#if !defined SNTP_STARTUP_DELAY || defined __DOXYGEN__
+#define SNTP_STARTUP_DELAY          0
+#endif
+
+/** If you want the startup delay to be a function, define this
+ * to a function (including the brackets) and define SNTP_STARTUP_DELAY to 1.
+ */
+#if !defined SNTP_STARTUP_DELAY_FUNC || defined __DOXYGEN__
+#define SNTP_STARTUP_DELAY_FUNC     SNTP_STARTUP_DELAY
+#endif
+
+/** SNTP receive timeout - in milliseconds
+ * Also used as retry timeout - this shouldn't be too low.
+ * Default is 3 seconds.
+ */
+#if !defined SNTP_RECV_TIMEOUT || defined __DOXYGEN__
+#define SNTP_RECV_TIMEOUT           3000
+#endif
+
+/** SNTP update delay - in milliseconds
+ * Default is 1 hour. Must not be beolw 15 seconds by specification (i.e. 15000)
+ */
+#if !defined SNTP_UPDATE_DELAY || defined __DOXYGEN__
+#define SNTP_UPDATE_DELAY           3600000
+#endif
+
+/** SNTP macro to get system time, used with SNTP_CHECK_RESPONSE >= 2
+ * to send in request and compare in response.
+ */
+#if !defined SNTP_GET_SYSTEM_TIME || defined __DOXYGEN__
+#define SNTP_GET_SYSTEM_TIME(sec, us)     do { (sec) = 0; (us) = 0; } while(0)
+#endif
+
+/** Default retry timeout (in milliseconds) if the response
+ * received is invalid.
+ * This is doubled with each retry until SNTP_RETRY_TIMEOUT_MAX is reached.
+ */
+#if !defined SNTP_RETRY_TIMEOUT || defined __DOXYGEN__
+#define SNTP_RETRY_TIMEOUT          SNTP_RECV_TIMEOUT
+#endif
+
+/** Maximum retry timeout (in milliseconds). */
+#if !defined SNTP_RETRY_TIMEOUT_MAX || defined __DOXYGEN__
+#define SNTP_RETRY_TIMEOUT_MAX      (SNTP_RETRY_TIMEOUT * 10)
+#endif
+
+/** Increase retry timeout with every retry sent
+ * Default is on to conform to RFC.
+ */
+#if !defined SNTP_RETRY_TIMEOUT_EXP || defined __DOXYGEN__
+#define SNTP_RETRY_TIMEOUT_EXP      1
+#endif
+
+/**
+ * @}
+ */
+
+#endif /* LWIP_HDR_APPS_SNTP_OPTS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/tftp_opts.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/tftp_opts.h
new file mode 100644
index 000000000..6968a803b
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/tftp_opts.h
@@ -0,0 +1,105 @@
+/****************************************************************//**
+ *
+ * @file tftp_opts.h
+ *
+ * @author   Logan Gunthorpe <logang@deltatee.com>
+ *
+ * @brief    Trivial File Transfer Protocol (RFC 1350) implementation options
+ *
+ * Copyright (c) Deltatee Enterprises Ltd. 2013
+ * All rights reserved.
+ *
+ ********************************************************************/
+
+/* 
+ * Redistribution and use in source and binary forms, with or without
+ * modification,are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Author: Logan Gunthorpe <logang@deltatee.com>
+ *
+ */
+
+#ifndef LWIP_HDR_APPS_TFTP_OPTS_H
+#define LWIP_HDR_APPS_TFTP_OPTS_H
+
+#include "lwip/opt.h"
+
+/**
+ * @defgroup tftp_opts Options
+ * @ingroup tftp
+ * @{
+ */
+
+/**
+ * Enable TFTP debug messages
+ */
+#if !defined TFTP_DEBUG || defined __DOXYGEN__
+#define TFTP_DEBUG            LWIP_DBG_ON
+#endif
+
+/**
+ * TFTP server port
+ */
+#if !defined TFTP_PORT || defined __DOXYGEN__
+#define TFTP_PORT             69
+#endif
+
+/**
+ * TFTP timeout
+ */
+#if !defined TFTP_TIMEOUT_MSECS || defined __DOXYGEN__
+#define TFTP_TIMEOUT_MSECS    10000
+#endif
+
+/**
+ * Max. number of retries when a file is read from server
+ */
+#if !defined TFTP_MAX_RETRIES || defined __DOXYGEN__
+#define TFTP_MAX_RETRIES      5
+#endif
+
+/**
+ * TFTP timer cyclic interval
+ */
+#if !defined TFTP_TIMER_MSECS || defined __DOXYGEN__
+#define TFTP_TIMER_MSECS      50
+#endif
+
+/**
+ * Max. length of TFTP filename
+ */
+#if !defined TFTP_MAX_FILENAME_LEN || defined __DOXYGEN__
+#define TFTP_MAX_FILENAME_LEN 20
+#endif
+
+/**
+ * Max. length of TFTP mode
+ */
+#if !defined TFTP_MAX_MODE_LEN || defined __DOXYGEN__
+#define TFTP_MAX_MODE_LEN     7
+#endif
+
+/**
+ * @}
+ */
+
+#endif /* LWIP_HDR_APPS_TFTP_OPTS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/tftp_server.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/tftp_server.h
new file mode 100644
index 000000000..3fbe701e0
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/apps/tftp_server.h
@@ -0,0 +1,94 @@
+/****************************************************************//**
+ *
+ * @file tftp_server.h
+ *
+ * @author   Logan Gunthorpe <logang@deltatee.com>
+ *
+ * @brief    Trivial File Transfer Protocol (RFC 1350)
+ *
+ * Copyright (c) Deltatee Enterprises Ltd. 2013
+ * All rights reserved.
+ *
+ ********************************************************************/
+
+/* 
+ * Redistribution and use in source and binary forms, with or without
+ * modification,are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Author: Logan Gunthorpe <logang@deltatee.com>
+ *
+ */
+
+#ifndef LWIP_HDR_APPS_TFTP_SERVER_H
+#define LWIP_HDR_APPS_TFTP_SERVER_H
+
+#include "lwip/apps/tftp_opts.h"
+#include "lwip/err.h"
+#include "lwip/pbuf.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @ingroup tftp
+ * TFTP context containing callback functions for TFTP transfers
+ */
+struct tftp_context {
+  /**
+   * Open file for read/write.
+   * @param fname Filename
+   * @param mode Mode string from TFTP RFC 1350 (netascii, octet, mail)
+   * @param write Flag indicating read (0) or write (!= 0) access
+   * @returns File handle supplied to other functions
+   */
+  void* (*open)(const char* fname, const char* mode, u8_t write);
+  /**
+   * Close file handle
+   * @param handle File handle returned by open()
+   */
+  void (*close)(void* handle);
+  /**
+   * Read from file 
+   * @param handle File handle returned by open()
+   * @param buf Target buffer to copy read data to
+   * @param bytes Number of bytes to copy to buf
+   * @returns &gt;= 0: Success; &lt; 0: Error
+   */
+  int (*read)(void* handle, void* buf, int bytes);
+  /**
+   * Write to file
+   * @param handle File handle returned by open()
+   * @param pbuf PBUF adjusted such that payload pointer points
+   *             to the beginning of write data. In other words,
+   *             TFTP headers are stripped off.
+   * @returns &gt;= 0: Success; &lt; 0: Error
+   */
+  int (*write)(void* handle, struct pbuf* p);
+};
+
+err_t tftp_init(const struct tftp_context* ctx);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_APPS_TFTP_SERVER_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/arch.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/arch.h
new file mode 100644
index 000000000..1ab171ba6
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/arch.h
@@ -0,0 +1,323 @@
+/**
+ * @file
+ * Support for different processor and compiler architectures
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_ARCH_H
+#define LWIP_HDR_ARCH_H
+
+#if CHIP_HAVE_CONFIG_H
+#include <lwip/lwip_buildconfig.h>
+#endif
+
+#ifndef LITTLE_ENDIAN
+#define LITTLE_ENDIAN 1234
+#endif
+
+#ifndef BIG_ENDIAN
+#define BIG_ENDIAN 4321
+#endif
+
+#include "arch/cc.h"
+
+/**
+ * @defgroup compiler_abstraction Compiler/platform abstraction
+ * @ingroup sys_layer
+ * All defines related to this section must not be placed in lwipopts.h,
+ * but in arch/cc.h!
+ * These options cannot be \#defined in lwipopts.h since they are not options
+ * of lwIP itself, but options of the lwIP port to your system.
+ * @{
+ */
+
+/** Define the byte order of the system.
+ * Needed for conversion of network data to host byte order.
+ * Allowed values: LITTLE_ENDIAN and BIG_ENDIAN
+ */
+#ifndef BYTE_ORDER
+#define BYTE_ORDER LITTLE_ENDIAN
+#endif
+
+/** Define random number generator function of your system */
+#ifdef __DOXYGEN__
+#define LWIP_RAND() ((u32_t)rand())
+#endif
+
+/** Platform specific diagnostic output.\n
+ * Note the default implementation pulls in printf, which may
+ * in turn pull in a lot of standard libary code. In resource-constrained 
+ * systems, this should be defined to something less resource-consuming.
+ */
+#ifndef LWIP_PLATFORM_DIAG
+#define LWIP_PLATFORM_DIAG(x) do {printf x;} while(0)
+#include <stdio.h>
+#include <stdlib.h>
+#endif
+
+/** Platform specific assertion handling.\n
+ * Note the default implementation pulls in printf, fflush and abort, which may
+ * in turn pull in a lot of standard libary code. In resource-constrained 
+ * systems, this should be defined to something less resource-consuming.
+ */
+#ifndef LWIP_PLATFORM_ASSERT
+#define LWIP_PLATFORM_ASSERT(x) do {printf("Assertion \"%s\" failed at line %d in %s\n", \
+                                     x, __LINE__, __FILE__); fflush(NULL); abort();} while(0)
+#include <stdio.h>
+#include <stdlib.h>
+#endif
+
+/** Define this to 1 in arch/cc.h of your port if you do not want to
+ * include stddef.h header to get size_t. You need to typedef size_t
+ * by yourself in this case.
+ */
+#ifndef LWIP_NO_STDDEF_H
+#define LWIP_NO_STDDEF_H 0
+#endif
+
+#if !LWIP_NO_STDDEF_H
+#include <stddef.h> /* for size_t */
+#endif
+
+/** Define this to 1 in arch/cc.h of your port if your compiler does not provide
+ * the stdint.h header. You need to typedef the generic types listed in
+ * lwip/arch.h yourself in this case (u8_t, u16_t...).
+ */
+#ifndef LWIP_NO_STDINT_H
+#define LWIP_NO_STDINT_H 0
+#endif
+
+/* Define generic types used in lwIP */
+#if !LWIP_NO_STDINT_H
+#include <stdint.h>
+typedef uint8_t   u8_t;
+typedef int8_t    s8_t;
+typedef uint16_t  u16_t;
+typedef int16_t   s16_t;
+typedef uint32_t  u32_t;
+typedef int32_t   s32_t;
+typedef uintptr_t mem_ptr_t;
+#endif
+
+/** Define this to 1 in arch/cc.h of your port if your compiler does not provide
+ * the inttypes.h header. You need to define the format strings listed in
+ * lwip/arch.h yourself in this case (X8_F, U16_F...).
+ */
+#ifndef LWIP_NO_INTTYPES_H
+#define LWIP_NO_INTTYPES_H 0
+#endif
+
+/* Define (sn)printf formatters for these lwIP types */
+#if !LWIP_NO_INTTYPES_H
+#include <inttypes.h>
+#ifndef X8_F
+#define X8_F  "02" PRIx8
+#endif
+#ifndef U16_F
+#define U16_F PRIu16
+#endif
+#ifndef S16_F
+#define S16_F PRId16
+#endif
+#ifndef X16_F
+#define X16_F PRIx16
+#endif
+#ifndef U32_F
+#define U32_F PRIu32
+#endif
+#ifndef S32_F
+#define S32_F PRId32
+#endif
+#ifndef X32_F
+#define X32_F PRIx32
+#endif
+#ifndef SZT_F
+#define SZT_F PRIuPTR
+#endif
+#endif
+
+/** Define this to 1 in arch/cc.h of your port if your compiler does not provide
+ * the limits.h header. You need to define the type limits yourself in this case
+ * (e.g. INT_MAX).
+ */
+#ifndef LWIP_NO_LIMITS_H
+#define LWIP_NO_LIMITS_H 0
+#endif
+
+/* Include limits.h? */
+#if !LWIP_NO_LIMITS_H
+#include <limits.h>
+#endif
+
+/** C++ const_cast<target_type>(val) equivalent to remove constness from a value (GCC -Wcast-qual) */
+#ifndef LWIP_CONST_CAST
+#define LWIP_CONST_CAST(target_type, val) ((target_type)((ptrdiff_t)val))
+#endif
+
+/** Get rid of alignment cast warnings (GCC -Wcast-align) */
+#ifndef LWIP_ALIGNMENT_CAST
+#define LWIP_ALIGNMENT_CAST(target_type, val) LWIP_CONST_CAST(target_type, val)
+#endif
+
+/** Get rid of warnings related to pointer-to-numeric and vice-versa casts,
+ * e.g. "conversion from 'u8_t' to 'void *' of greater size"
+ */
+#ifndef LWIP_PTR_NUMERIC_CAST
+#define LWIP_PTR_NUMERIC_CAST(target_type, val) LWIP_CONST_CAST(target_type, val)
+#endif
+
+/** Allocates a memory buffer of specified size that is of sufficient size to align
+ * its start address using LWIP_MEM_ALIGN.
+ * You can declare your own version here e.g. to enforce alignment without adding
+ * trailing padding bytes (see LWIP_MEM_ALIGN_BUFFER) or your own section placement
+ * requirements.\n
+ * e.g. if you use gcc and need 32 bit alignment:\n
+ * \#define LWIP_DECLARE_MEMORY_ALIGNED(variable_name, size) u8_t variable_name[size] \_\_attribute\_\_((aligned(4)))\n
+ * or more portable:\n
+ * \#define LWIP_DECLARE_MEMORY_ALIGNED(variable_name, size) u32_t variable_name[(size + sizeof(u32_t) - 1) / sizeof(u32_t)]
+ */
+#ifndef LWIP_DECLARE_MEMORY_ALIGNED
+#define LWIP_DECLARE_MEMORY_ALIGNED(variable_name, size) u8_t variable_name[LWIP_MEM_ALIGN_BUFFER(size)]
+#endif
+
+/** Calculate memory size for an aligned buffer - returns the next highest
+ * multiple of MEM_ALIGNMENT (e.g. LWIP_MEM_ALIGN_SIZE(3) and
+ * LWIP_MEM_ALIGN_SIZE(4) will both yield 4 for MEM_ALIGNMENT == 4).
+ */
+#ifndef LWIP_MEM_ALIGN_SIZE
+#define LWIP_MEM_ALIGN_SIZE(size) (((size) + MEM_ALIGNMENT - 1U) & ~(MEM_ALIGNMENT-1U))
+#endif
+
+/** Calculate safe memory size for an aligned buffer when using an unaligned
+ * type as storage. This includes a safety-margin on (MEM_ALIGNMENT - 1) at the
+ * start (e.g. if buffer is u8_t[] and actual data will be u32_t*)
+ */
+#ifndef LWIP_MEM_ALIGN_BUFFER
+#define LWIP_MEM_ALIGN_BUFFER(size) (((size) + MEM_ALIGNMENT - 1U))
+#endif
+
+/** Align a memory pointer to the alignment defined by MEM_ALIGNMENT
+ * so that ADDR % MEM_ALIGNMENT == 0
+ */
+#ifndef LWIP_MEM_ALIGN
+#define LWIP_MEM_ALIGN(addr) ((void *)(((mem_ptr_t)(addr) + MEM_ALIGNMENT - 1) & ~(mem_ptr_t)(MEM_ALIGNMENT-1)))
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** Packed structs support.
+  * Placed BEFORE declaration of a packed struct.\n
+  * For examples of packed struct declarations, see include/lwip/prot/ subfolder.\n
+  * A port to GCC/clang is included in lwIP, if you use these compilers there is nothing to do here.
+  */
+#ifndef PACK_STRUCT_BEGIN
+#define PACK_STRUCT_BEGIN
+#endif /* PACK_STRUCT_BEGIN */
+
+/** Packed structs support.
+  * Placed AFTER declaration of a packed struct.\n
+  * For examples of packed struct declarations, see include/lwip/prot/ subfolder.\n
+  * A port to GCC/clang is included in lwIP, if you use these compilers there is nothing to do here.
+  */
+#ifndef PACK_STRUCT_END
+#define PACK_STRUCT_END
+#endif /* PACK_STRUCT_END */
+
+/** Packed structs support.
+  * Placed between end of declaration of a packed struct and trailing semicolon.\n
+  * For examples of packed struct declarations, see include/lwip/prot/ subfolder.\n
+  * A port to GCC/clang is included in lwIP, if you use these compilers there is nothing to do here.
+  */
+#ifndef PACK_STRUCT_STRUCT
+#if defined(__GNUC__) || defined(__clang__)
+#define PACK_STRUCT_STRUCT __attribute__((packed))
+#else
+#define PACK_STRUCT_STRUCT
+#endif
+#endif /* PACK_STRUCT_STRUCT */
+
+/** Packed structs support.
+  * Wraps u32_t and u16_t members.\n
+  * For examples of packed struct declarations, see include/lwip/prot/ subfolder.\n
+  * A port to GCC/clang is included in lwIP, if you use these compilers there is nothing to do here.
+  */
+#ifndef PACK_STRUCT_FIELD
+#define PACK_STRUCT_FIELD(x) x
+#endif /* PACK_STRUCT_FIELD */
+
+/** Packed structs support.
+  * Wraps u8_t members, where some compilers warn that packing is not necessary.\n
+  * For examples of packed struct declarations, see include/lwip/prot/ subfolder.\n
+  * A port to GCC/clang is included in lwIP, if you use these compilers there is nothing to do here.
+  */
+#ifndef PACK_STRUCT_FLD_8
+#define PACK_STRUCT_FLD_8(x) PACK_STRUCT_FIELD(x)
+#endif /* PACK_STRUCT_FLD_8 */
+
+/** Packed structs support.
+  * Wraps members that are packed structs themselves, where some compilers warn that packing is not necessary.\n
+  * For examples of packed struct declarations, see include/lwip/prot/ subfolder.\n
+  * A port to GCC/clang is included in lwIP, if you use these compilers there is nothing to do here.
+  */
+#ifndef PACK_STRUCT_FLD_S
+#define PACK_STRUCT_FLD_S(x) PACK_STRUCT_FIELD(x)
+#endif /* PACK_STRUCT_FLD_S */
+
+/** Packed structs support using \#include files before and after struct to be packed.\n
+ * The file included BEFORE the struct is "arch/bpstruct.h".\n
+ * The file included AFTER the struct is "arch/epstruct.h".\n
+ * This can be used to implement struct packing on MS Visual C compilers, see
+ * the Win32 port in the lwIP contrib repository for reference.
+ * For examples of packed struct declarations, see include/lwip/prot/ subfolder.\n
+ * A port to GCC/clang is included in lwIP, if you use these compilers there is nothing to do here.
+ */
+#ifdef __DOXYGEN__
+#define PACK_STRUCT_USE_INCLUDES
+#endif
+
+/** Eliminates compiler warning about unused arguments (GCC -Wextra -Wunused). */
+#ifndef LWIP_UNUSED_ARG
+#define LWIP_UNUSED_ARG(x) (void)x
+#endif /* LWIP_UNUSED_ARG */
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_ARCH_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/autoip.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/autoip.h
new file mode 100644
index 000000000..3a8ca35f8
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/autoip.h
@@ -0,0 +1,99 @@
+/**
+ * @file
+ *
+ * AutoIP Automatic LinkLocal IP Configuration
+ */
+
+/*
+ *
+ * Copyright (c) 2007 Dominik Spies <kontakt@dspies.de>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * Author: Dominik Spies <kontakt@dspies.de>
+ *
+ * This is a AutoIP implementation for the lwIP TCP/IP stack. It aims to conform
+ * with RFC 3927.
+ *
+ */
+
+#ifndef LWIP_HDR_AUTOIP_H
+#define LWIP_HDR_AUTOIP_H
+
+#include "lwip/opt.h"
+
+#if LWIP_IPV4 && LWIP_AUTOIP /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/netif.h"
+/* #include "lwip/udp.h" */
+#include "lwip/etharp.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** AutoIP Timing */
+#define AUTOIP_TMR_INTERVAL      100
+#define AUTOIP_TICKS_PER_SECOND (1000 / AUTOIP_TMR_INTERVAL)
+
+/** AutoIP state information per netif */
+struct autoip
+{
+  /** the currently selected, probed, announced or used LL IP-Address */
+  ip4_addr_t llipaddr;
+  /** current AutoIP state machine state */
+  u8_t state;
+  /** sent number of probes or announces, dependent on state */
+  u8_t sent_num;
+  /** ticks to wait, tick is AUTOIP_TMR_INTERVAL long */
+  u16_t ttw;
+  /** ticks until a conflict can be solved by defending */
+  u8_t lastconflict;
+  /** total number of probed/used Link Local IP-Addresses */
+  u8_t tried_llipaddr;
+};
+
+
+void autoip_set_struct(struct netif *netif, struct autoip *autoip);
+/** Remove a struct autoip previously set to the netif using autoip_set_struct() */
+#define autoip_remove_struct(netif) netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_AUTOIP, NULL)
+err_t autoip_start(struct netif *netif);
+err_t autoip_stop(struct netif *netif);
+void autoip_arp_reply(struct netif *netif, struct etharp_hdr *hdr);
+void autoip_tmr(void);
+void autoip_network_changed(struct netif *netif);
+u8_t autoip_supplied_address(const struct netif *netif);
+
+/* for lwIP internal use by ip4.c */
+u8_t autoip_accept_packet(struct netif *netif, const ip4_addr_t *addr);
+
+#define netif_autoip_data(netif) ((struct autoip*)netif_get_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_AUTOIP))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_IPV4 && LWIP_AUTOIP */
+
+#endif /* LWIP_HDR_AUTOIP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/debug.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/debug.h
new file mode 100644
index 000000000..a142f1cff
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/debug.h
@@ -0,0 +1,167 @@
+/**
+ * @file
+ * Debug messages infrastructure
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_DEBUG_H
+#define LWIP_HDR_DEBUG_H
+
+#include "lwip/arch.h"
+#include "lwip/opt.h"
+
+/**
+ * @defgroup debugging_levels LWIP_DBG_MIN_LEVEL and LWIP_DBG_TYPES_ON values
+ * @ingroup lwip_opts_debugmsg
+ * @{
+ */
+
+/** @name Debug level (LWIP_DBG_MIN_LEVEL)
+ * @{
+ */
+/** Debug level: ALL messages*/
+#define LWIP_DBG_LEVEL_ALL     0x00
+/** Debug level: Warnings. bad checksums, dropped packets, ... */
+#define LWIP_DBG_LEVEL_WARNING 0x01
+/** Debug level: Serious. memory allocation failures, ... */
+#define LWIP_DBG_LEVEL_SERIOUS 0x02
+/** Debug level: Severe */
+#define LWIP_DBG_LEVEL_SEVERE  0x03
+/**
+ * @}
+ */
+
+#define LWIP_DBG_MASK_LEVEL    0x03
+/* compatibility define only */
+#define LWIP_DBG_LEVEL_OFF     LWIP_DBG_LEVEL_ALL
+
+/** @name Enable/disable debug messages completely (LWIP_DBG_TYPES_ON)
+ * @{
+ */
+/** flag for LWIP_DEBUGF to enable that debug message */
+#define LWIP_DBG_ON            0x80U
+/** flag for LWIP_DEBUGF to disable that debug message */
+#define LWIP_DBG_OFF           0x00U
+/**
+ * @}
+ */
+
+/** @name Debug message types (LWIP_DBG_TYPES_ON)
+ * @{
+ */
+/** flag for LWIP_DEBUGF indicating a tracing message (to follow program flow) */
+#define LWIP_DBG_TRACE         0x40U
+/** flag for LWIP_DEBUGF indicating a state debug message (to follow module states) */
+#define LWIP_DBG_STATE         0x20U
+/** flag for LWIP_DEBUGF indicating newly added code, not thoroughly tested yet */
+#define LWIP_DBG_FRESH         0x10U
+/** flag for LWIP_DEBUGF to halt after printing this debug message */
+#define LWIP_DBG_HALT          0x08U
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+/**
+ * @defgroup lwip_assertions Assertion handling
+ * @ingroup lwip_opts_debug
+ * @{
+ */
+/**
+ * LWIP_NOASSERT: Disable LWIP_ASSERT checks:
+ * To disable assertions define LWIP_NOASSERT in arch/cc.h.
+ */
+#ifdef __DOXYGEN__
+#define LWIP_NOASSERT
+#undef LWIP_NOASSERT
+#endif
+/**
+ * @}
+ */
+
+#ifndef LWIP_NOASSERT
+#define LWIP_ASSERT(message, assertion) do { if (!(assertion)) { \
+  LWIP_PLATFORM_ASSERT(message); }} while(0)
+#ifndef LWIP_PLATFORM_ASSERT
+#error "If you want to use LWIP_ASSERT, LWIP_PLATFORM_ASSERT(message) needs to be defined in your arch/cc.h"
+#endif
+#else  /* LWIP_NOASSERT */
+#define LWIP_ASSERT(message, assertion)
+#endif /* LWIP_NOASSERT */
+
+#ifndef LWIP_ERROR
+#ifndef LWIP_NOASSERT
+#define LWIP_PLATFORM_ERROR(message) LWIP_PLATFORM_ASSERT(message)
+#elif defined LWIP_DEBUG
+#define LWIP_PLATFORM_ERROR(message) LWIP_PLATFORM_DIAG((message))
+#else
+#define LWIP_PLATFORM_ERROR(message)
+#endif
+
+/* if "expression" isn't true, then print "message" and execute "handler" expression */
+#define LWIP_ERROR(message, expression, handler) do { if (!(expression)) { \
+  LWIP_PLATFORM_ERROR(message); handler;}} while(0)
+#endif /* LWIP_ERROR */
+
+/** Enable debug message printing, but only if debug message type is enabled
+ *  AND is of correct type AND is at least LWIP_DBG_LEVEL.
+ */
+#ifdef __DOXYGEN__
+#define LWIP_DEBUG
+#undef LWIP_DEBUG
+#endif
+
+#ifdef LWIP_DEBUG
+#ifndef LWIP_PLATFORM_DIAG
+#error "If you want to use LWIP_DEBUG, LWIP_PLATFORM_DIAG(message) needs to be defined in your arch/cc.h"
+#endif
+#define LWIP_DEBUGF(debug, message) do { \
+                               if ( \
+                                   ((debug) & LWIP_DBG_ON) && \
+                                   ((debug) & LWIP_DBG_TYPES_ON) && \
+                                   ((s16_t)((debug) & LWIP_DBG_MASK_LEVEL) >= LWIP_DBG_MIN_LEVEL)) { \
+                                 LWIP_PLATFORM_DIAG(message); \
+                                 if ((debug) & LWIP_DBG_HALT) { \
+                                   while(1); \
+                                 } \
+                               } \
+                             } while(0)
+
+#else  /* LWIP_DEBUG */
+#define LWIP_DEBUGF(debug, message)
+#endif /* LWIP_DEBUG */
+
+#endif /* LWIP_HDR_DEBUG_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/def.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/def.h
new file mode 100644
index 000000000..82a9d896f
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/def.h
@@ -0,0 +1,141 @@
+/**
+ * @file
+ * various utility macros
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_DEF_H
+#define LWIP_HDR_DEF_H
+
+/* arch.h might define NULL already */
+#include "lwip/arch.h"
+#include "lwip/opt.h"
+#if LWIP_PERF
+#include "arch/perf.h"
+#else /* LWIP_PERF */
+#define PERF_START    /* null definition */
+#define PERF_STOP(x)  /* null definition */
+#endif /* LWIP_PERF */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define LWIP_MAX(x , y)  (((x) > (y)) ? (x) : (y))
+#define LWIP_MIN(x , y)  (((x) < (y)) ? (x) : (y))
+
+/* Get the number of entries in an array ('x' must NOT be a pointer!) */
+#define LWIP_ARRAYSIZE(x) (sizeof(x)/sizeof((x)[0]))
+
+/** Create u32_t value from bytes */
+#define LWIP_MAKEU32(a,b,c,d) (((u32_t)((a) & 0xff) << 24) | \
+                               ((u32_t)((b) & 0xff) << 16) | \
+                               ((u32_t)((c) & 0xff) << 8)  | \
+                                (u32_t)((d) & 0xff))
+
+#ifndef NULL
+#ifdef __cplusplus
+#define NULL 0
+#else
+#define NULL ((void *)0)
+#endif
+#endif
+
+#if BYTE_ORDER == BIG_ENDIAN
+#define lwip_htons(x) (x)
+#define lwip_ntohs(x) (x)
+#define lwip_htonl(x) (x)
+#define lwip_ntohl(x) (x)
+#define PP_HTONS(x) (x)
+#define PP_NTOHS(x) (x)
+#define PP_HTONL(x) (x)
+#define PP_NTOHL(x) (x)
+#else /* BYTE_ORDER != BIG_ENDIAN */
+#ifndef lwip_htons
+u16_t lwip_htons(u16_t x);
+#endif
+#define lwip_ntohs(x) lwip_htons(x)
+
+#ifndef lwip_htonl
+u32_t lwip_htonl(u32_t x);
+#endif
+#define lwip_ntohl(x) lwip_htonl(x)
+
+/* These macros should be calculated by the preprocessor and are used
+   with compile-time constants only (so that there is no little-endian
+   overhead at runtime). */
+#define PP_HTONS(x) ((((x) & 0x00ffUL) << 8) | (((x) & 0xff00UL) >> 8))
+#define PP_NTOHS(x) PP_HTONS(x)
+#define PP_HTONL(x) ((((x) & 0x000000ffUL) << 24) | \
+                     (((x) & 0x0000ff00UL) <<  8) | \
+                     (((x) & 0x00ff0000UL) >>  8) | \
+                     (((x) & 0xff000000UL) >> 24))
+#define PP_NTOHL(x) PP_HTONL(x)
+#endif /* BYTE_ORDER == BIG_ENDIAN */
+
+/* Provide usual function names as macros for users, but this can be turned off */
+#ifndef LWIP_DONT_PROVIDE_BYTEORDER_FUNCTIONS
+#define htons(x) lwip_htons(x)
+#define ntohs(x) lwip_ntohs(x)
+#define htonl(x) lwip_htonl(x)
+#define ntohl(x) lwip_ntohl(x)
+#endif
+
+/* Functions that are not available as standard implementations.
+ * In cc.h, you can #define these to implementations available on
+ * your platform to save some code bytes if you use these functions
+ * in your application, too.
+ */
+
+#ifndef lwip_itoa
+/* This can be #defined to itoa() or snprintf(result, bufsize, "%d", number) depending on your platform */
+void  lwip_itoa(char* result, size_t bufsize, int number);
+#endif
+#ifndef lwip_strnicmp
+/* This can be #defined to strnicmp() or strncasecmp() depending on your platform */
+int   lwip_strnicmp(const char* str1, const char* str2, size_t len);
+#endif
+#ifndef lwip_stricmp
+/* This can be #defined to stricmp() or strcasecmp() depending on your platform */
+int   lwip_stricmp(const char* str1, const char* str2);
+#endif
+#ifndef lwip_strnstr
+/* This can be #defined to strnstr() depending on your platform */
+char* lwip_strnstr(const char* buffer, const char* token, size_t n);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_DEF_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/dhcp.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/dhcp.h
new file mode 100644
index 000000000..df932afb5
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/dhcp.h
@@ -0,0 +1,143 @@
+/**
+ * @file
+ * DHCP client API
+ */
+
+/*
+ * Copyright (c) 2001-2004 Leon Woestenberg <leon.woestenberg@gmx.net>
+ * Copyright (c) 2001-2004 Axon Digital Design B.V., The Netherlands.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Leon Woestenberg <leon.woestenberg@gmx.net>
+ *
+ */
+#ifndef LWIP_HDR_DHCP_H
+#define LWIP_HDR_DHCP_H
+
+#include "lwip/opt.h"
+
+#if LWIP_DHCP /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/netif.h"
+#include "lwip/udp.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** period (in seconds) of the application calling dhcp_coarse_tmr() */
+#define DHCP_COARSE_TIMER_SECS  60
+/** period (in milliseconds) of the application calling dhcp_coarse_tmr() */
+#define DHCP_COARSE_TIMER_MSECS (DHCP_COARSE_TIMER_SECS * 1000UL)
+/** period (in milliseconds) of the application calling dhcp_fine_tmr() */
+#define DHCP_FINE_TIMER_MSECS   500
+
+#define DHCP_BOOT_FILE_LEN      128U
+
+/* AutoIP cooperation flags (struct dhcp.autoip_coop_state) */
+typedef enum {
+  DHCP_AUTOIP_COOP_STATE_OFF  = 0,
+  DHCP_AUTOIP_COOP_STATE_ON   = 1
+} dhcp_autoip_coop_state_enum_t;
+
+struct dhcp
+{
+  /** transaction identifier of last sent request */
+  u32_t xid;
+  /** incoming msg */
+  struct dhcp_msg *msg_in;
+  /** track PCB allocation state */
+  u8_t pcb_allocated;
+  /** current DHCP state machine state */
+  u8_t state;
+  /** retries of current request */
+  u8_t tries;
+#if LWIP_DHCP_AUTOIP_COOP
+  u8_t autoip_coop_state;
+#endif
+  u8_t subnet_mask_given;
+
+  struct pbuf *p_out; /* pbuf of outcoming msg */
+  struct dhcp_msg *msg_out; /* outgoing msg */
+  u16_t options_out_len; /* outgoing msg options length */
+  u16_t request_timeout; /* #ticks with period DHCP_FINE_TIMER_SECS for request timeout */
+  u16_t t1_timeout;  /* #ticks with period DHCP_COARSE_TIMER_SECS for renewal time */
+  u16_t t2_timeout;  /* #ticks with period DHCP_COARSE_TIMER_SECS for rebind time */
+  u16_t t1_renew_time;  /* #ticks with period DHCP_COARSE_TIMER_SECS until next renew try */
+  u16_t t2_rebind_time; /* #ticks with period DHCP_COARSE_TIMER_SECS until next rebind try */
+  u16_t lease_used; /* #ticks with period DHCP_COARSE_TIMER_SECS since last received DHCP ack */
+  u16_t t0_timeout; /* #ticks with period DHCP_COARSE_TIMER_SECS for lease time */
+  ip_addr_t server_ip_addr; /* dhcp server address that offered this lease (ip_addr_t because passed to UDP) */
+  ip4_addr_t offered_ip_addr;
+  ip4_addr_t offered_sn_mask;
+  ip4_addr_t offered_gw_addr;
+
+  u32_t offered_t0_lease; /* lease period (in seconds) */
+  u32_t offered_t1_renew; /* recommended renew time (usually 50% of lease period) */
+  u32_t offered_t2_rebind; /* recommended rebind time (usually 87.5 of lease period)  */
+#if LWIP_DHCP_BOOTP_FILE
+  ip4_addr_t offered_si_addr;
+  char boot_file_name[DHCP_BOOT_FILE_LEN];
+#endif /* LWIP_DHCP_BOOTPFILE */
+};
+
+
+void dhcp_set_struct(struct netif *netif, struct dhcp *dhcp);
+/** Remove a struct dhcp previously set to the netif using dhcp_set_struct() */
+#define dhcp_remove_struct(netif) netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_DHCP, NULL)
+void dhcp_cleanup(struct netif *netif);
+err_t dhcp_start(struct netif *netif);
+err_t dhcp_renew(struct netif *netif);
+err_t dhcp_release(struct netif *netif);
+void dhcp_stop(struct netif *netif);
+void dhcp_inform(struct netif *netif);
+void dhcp_network_changed(struct netif *netif);
+#if DHCP_DOES_ARP_CHECK
+void dhcp_arp_reply(struct netif *netif, const ip4_addr_t *addr);
+#endif
+u8_t dhcp_supplied_address(const struct netif *netif);
+/* to be called every minute */
+void dhcp_coarse_tmr(void);
+/* to be called every half second */
+void dhcp_fine_tmr(void);
+
+#if LWIP_DHCP_GET_NTP_SRV
+/** This function must exist, in other to add offered NTP servers to
+ * the NTP (or SNTP) engine.
+ * See LWIP_DHCP_MAX_NTP_SERVERS */
+extern void dhcp_set_ntp_servers(u8_t num_ntp_servers, const ip4_addr_t* ntp_server_addrs);
+#endif /* LWIP_DHCP_GET_NTP_SRV */
+
+#define netif_dhcp_data(netif) ((struct dhcp*)netif_get_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_DHCP))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_DHCP */
+
+#endif /*LWIP_HDR_DHCP_H*/
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/dhcp6.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/dhcp6.h
new file mode 100644
index 000000000..455336d37
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/dhcp6.h
@@ -0,0 +1,58 @@
+/**
+ * @file
+ *
+ * IPv6 address autoconfiguration as per RFC 4862.
+ */
+
+/*
+ * Copyright (c) 2010 Inico Technologies Ltd.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Ivan Delamer <delamer@inicotech.com>
+ *
+ * IPv6 address autoconfiguration as per RFC 4862.
+ *
+ * Please coordinate changes and requests with Ivan Delamer
+ * <delamer@inicotech.com>
+ */
+
+#ifndef LWIP_HDR_IP6_DHCP6_H
+#define LWIP_HDR_IP6_DHCP6_H
+
+#include "lwip/opt.h"
+
+#if LWIP_IPV6_DHCP6  /* don't build if not configured for use in lwipopts.h */
+
+
+struct dhcp6
+{
+  /*@todo: implement DHCP6*/
+};
+
+#endif /* LWIP_IPV6_DHCP6 */
+
+#endif /* LWIP_HDR_IP6_DHCP6_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/dns.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/dns.h
new file mode 100644
index 000000000..96d417b05
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/dns.h
@@ -0,0 +1,169 @@
+/**
+ * @file
+ * DNS API
+ */
+
+/**
+ * lwip DNS resolver header file.
+
+ * Author: Jim Pettinato
+ *   April 2007
+
+ * ported from uIP resolv.c Copyright (c) 2002-2003, Adam Dunkels.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef LWIP_HDR_DNS_H
+#define LWIP_HDR_DNS_H
+
+#include "lwip/opt.h"
+
+#if LWIP_DNS
+
+#include "lwip/ip_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** DNS timer period */
+#define DNS_TMR_INTERVAL          1000
+
+/* DNS resolve types: */
+#define LWIP_DNS_ADDRTYPE_IPV4      0
+#define LWIP_DNS_ADDRTYPE_IPV6      1
+#define LWIP_DNS_ADDRTYPE_IPV4_IPV6 2 /* try to resolve IPv4 first, try IPv6 if IPv4 fails only */
+#define LWIP_DNS_ADDRTYPE_IPV6_IPV4 3 /* try to resolve IPv6 first, try IPv4 if IPv6 fails only */
+#if LWIP_IPV4 && LWIP_IPV6
+#ifndef LWIP_DNS_ADDRTYPE_DEFAULT
+#define LWIP_DNS_ADDRTYPE_DEFAULT   LWIP_DNS_ADDRTYPE_IPV4_IPV6
+#endif
+#elif LWIP_IPV4
+#define LWIP_DNS_ADDRTYPE_DEFAULT   LWIP_DNS_ADDRTYPE_IPV4
+#else
+#define LWIP_DNS_ADDRTYPE_DEFAULT   LWIP_DNS_ADDRTYPE_IPV6
+#endif
+
+#if DNS_LOCAL_HOSTLIST
+/** struct used for local host-list */
+struct local_hostlist_entry {
+  /** static hostname */
+  const char *name;
+  /** static host address in network byteorder */
+  ip_addr_t addr;
+  struct local_hostlist_entry *next;
+};
+#define DNS_LOCAL_HOSTLIST_ELEM(name, addr_init) {name, addr_init, NULL}
+#if DNS_LOCAL_HOSTLIST_IS_DYNAMIC
+#ifndef DNS_LOCAL_HOSTLIST_MAX_NAMELEN
+#define DNS_LOCAL_HOSTLIST_MAX_NAMELEN  DNS_MAX_NAME_LENGTH
+#endif
+#define LOCALHOSTLIST_ELEM_SIZE ((sizeof(struct local_hostlist_entry) + DNS_LOCAL_HOSTLIST_MAX_NAMELEN + 1))
+#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
+#endif /* DNS_LOCAL_HOSTLIST */
+
+#if LWIP_IPV4
+extern const ip_addr_t dns_mquery_v4group;
+#endif /* LWIP_IPV4 */
+#if LWIP_IPV6
+extern const ip_addr_t dns_mquery_v6group;
+#endif /* LWIP_IPV6 */
+
+/** Callback which is invoked when a hostname is found.
+ * A function of this type must be implemented by the application using the DNS resolver.
+ * There is support for two types of callbacks, invoked when a hostname is found.
+ * @note dns_found_callbackX type is used as a catch-all type, that needs to be cast
+ * to either dns_found_callback or dns_found_callback_multi.
+ *
+ * dns_found_callback returns at most a single IP address, even if the DNS server response contained several addresses
+ *   (this callback is used to maintain backward compatibility with dns_gethostbyname)
+ * @param name pointer to the name that was looked up.
+ * @param ipaddr pointer to an ip_addr_t containing the IP address of the hostname,
+ *        or NULL if the name could not be found (or on any other error).
+ * @param callback_arg a user-specified callback argument passed to dns_gethostbyname.
+ *
+ * dns_found_callback_multi returns up to numipaddrs of all the IP addresses returned by the DSN server
+ *   (this callback is invoked by calling dns_gethostbyname_multi)
+ * @param name pointer to the name that was looked up.
+ * @param ipaddrs pointer to an ip_addr_t array containing the IP addresses of the hostname
+ * @note This pointer is never NULL, instead numipaddrs is set to zero.
+ * @param numipaddrs size of the ipaddrs array.
+ * @param callback_arg a user-specified callback argument passed to dns_gethostbyname_multi.
+*/
+
+typedef void (*dns_found_callback)(const char *name, const ip_addr_t *ipaddr, void *callback_arg);
+
+#if DNS_MAX_ADDRS_PER_NAME > 1
+typedef void (*dns_found_callbackX)(void);
+typedef void (*dns_found_callback_multi)(const char *name, const ip_addr_t *ipaddrs, u8_t numipaddrs, void *callback_arg);
+#define LWIP_DNS_FOUND_CALLBACK_TYPE    dns_found_callbackX
+#else // DNS_MAX_ADDRS_PER_NAME <= 1
+#define LWIP_DNS_FOUND_CALLBACK_TYPE    dns_found_callback
+#endif // DNS_MAX_ADDRS_PER_NAME <= 1
+
+void             dns_init(void);
+void             dns_tmr(void);
+void             dns_setserver(u8_t numdns, const ip_addr_t *dnsserver);
+const ip_addr_t* dns_getserver(u8_t numdns);
+err_t            dns_gethostbyname(const char *hostname, ip_addr_t *addr,
+                                   LWIP_DNS_FOUND_CALLBACK_TYPE found, void *callback_arg);
+err_t            dns_gethostbyname_addrtype(const char *hostname, ip_addr_t *addr,
+                                   LWIP_DNS_FOUND_CALLBACK_TYPE found, void *callback_arg,
+                                   u8_t dns_addrtype);
+
+#if DNS_LOCAL_HOSTLIST
+size_t         dns_local_iterate(dns_found_callback iterator_fn, void *iterator_arg);
+err_t          dns_local_lookup(const char *hostname, ip_addr_t *addr, u8_t dns_addrtype);
+#if DNS_LOCAL_HOSTLIST_IS_DYNAMIC
+
+void           dns_init(void);
+void           dns_tmr(void);
+void           dns_setserver(u8_t numdns, ip_addr_t *dnsserver);
+ip_addr_t      dns_getserver(u8_t numdns);
+
+#if DNS_MAX_ADDRS_PER_NAME > 1
+err_t          dns_gethostbyname_multi(const char *hostname, ip_addr_t *ipaddrs, u8_t *numipaddrs,
+                                 dns_found_callback_multi found, void *callback_arg);
+#endif // DNS_MAX_ADDRS_PER_NAME > 1
+
+int            dns_local_removehost(const char *hostname, const ip_addr_t *addr);
+err_t          dns_local_addhost(const char *hostname, const ip_addr_t *addr);
+#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
+#endif /* DNS_LOCAL_HOSTLIST */
+
+u8_t           dns_cancel(LWIP_DNS_FOUND_CALLBACK_TYPE found, void *callback_arg);
+
+#if LWIP_TEST_CODE
+u8_t           dns_expire_asking_entries(void);
+u8_t           dns_flush_cache(void);
+#endif // LWIP_TEST_CODE
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_DNS */
+#endif /* LWIP_HDR_DNS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/err.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/err.h
new file mode 100644
index 000000000..84e528d1e
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/err.h
@@ -0,0 +1,119 @@
+/**
+ * @file
+ * lwIP Error codes
+ */
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_ERR_H
+#define LWIP_HDR_ERR_H
+
+#include "lwip/opt.h"
+#include "lwip/arch.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @defgroup infrastructure_errors Error codes
+ * @ingroup infrastructure
+ * @{
+ */
+
+/** Define LWIP_ERR_T in cc.h if you want to use
+ *  a different type for your platform (must be signed). */
+#ifdef LWIP_ERR_T
+typedef LWIP_ERR_T err_t;
+#else /* LWIP_ERR_T */
+typedef s8_t err_t;
+#endif /* LWIP_ERR_T*/
+
+/** Definitions for error constants. */
+typedef enum {
+/** No error, everything OK. */
+  ERR_OK         = 0,
+/** Out of memory error.     */
+  ERR_MEM        = -1,
+/** Buffer error.            */
+  ERR_BUF        = -2,
+/** Timeout.                 */
+  ERR_TIMEOUT    = -3,
+/** Routing problem.         */
+  ERR_RTE        = -4,
+/** Operation in progress    */
+  ERR_INPROGRESS = -5,
+/** Illegal value.           */
+  ERR_VAL        = -6,
+/** Operation would block.   */
+  ERR_WOULDBLOCK = -7,
+/** Address in use.          */
+  ERR_USE        = -8,
+/** Already connecting.      */
+  ERR_ALREADY    = -9,
+/** Conn already established.*/
+  ERR_ISCONN     = -10,
+/** Not connected.           */
+  ERR_CONN       = -11,
+/** Low-level netif error    */
+  ERR_IF         = -12,
+
+/** Connection aborted.      */
+  ERR_ABRT       = -13,
+/** Connection reset.        */
+  ERR_RST        = -14,
+/** Connection closed.       */
+  ERR_CLSD       = -15,
+/** Illegal argument.        */
+  ERR_ARG        = -16
+} err_enum_t;
+
+#define ERR_IS_FATAL(e) ((e) <= ERR_ABRT)
+
+/**
+ * @}
+ */
+
+#ifdef LWIP_DEBUG
+extern const char *lwip_strerr(err_t err);
+#else
+#define lwip_strerr(x) ""
+#endif /* LWIP_DEBUG */
+
+#if !NO_SYS
+int err_to_errno(err_t err);
+#endif /* !NO_SYS */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_ERR_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/errno.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/errno.h
new file mode 100644
index 000000000..641cffb09
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/errno.h
@@ -0,0 +1,193 @@
+/**
+ * @file
+ * Posix Errno defines
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_ERRNO_H
+#define LWIP_HDR_ERRNO_H
+
+#include "lwip/opt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef LWIP_PROVIDE_ERRNO
+
+#define  EPERM            1  /* Operation not permitted */
+#define  ENOENT           2  /* No such file or directory */
+#define  ESRCH            3  /* No such process */
+#define  EINTR            4  /* Interrupted system call */
+#define  EIO              5  /* I/O error */
+#define  ENXIO            6  /* No such device or address */
+#define  E2BIG            7  /* Arg list too long */
+#define  ENOEXEC          8  /* Exec format error */
+#define  EBADF            9  /* Bad file number */
+#define  ECHILD          10  /* No child processes */
+#define  EAGAIN          11  /* Try again */
+#define  ENOMEM          12  /* Out of memory */
+#define  EACCES          13  /* Permission denied */
+#define  EFAULT          14  /* Bad address */
+#define  ENOTBLK         15  /* Block device required */
+#define  EBUSY           16  /* Device or resource busy */
+#define  EEXIST          17  /* File exists */
+#define  EXDEV           18  /* Cross-device link */
+#define  ENODEV          19  /* No such device */
+#define  ENOTDIR         20  /* Not a directory */
+#define  EISDIR          21  /* Is a directory */
+#define  EINVAL          22  /* Invalid argument */
+#define  ENFILE          23  /* File table overflow */
+#define  EMFILE          24  /* Too many open files */
+#define  ENOTTY          25  /* Not a typewriter */
+#define  ETXTBSY         26  /* Text file busy */
+#define  EFBIG           27  /* File too large */
+#define  ENOSPC          28  /* No space left on device */
+#define  ESPIPE          29  /* Illegal seek */
+#define  EROFS           30  /* Read-only file system */
+#define  EMLINK          31  /* Too many links */
+#define  EPIPE           32  /* Broken pipe */
+#define  EDOM            33  /* Math argument out of domain of func */
+#define  ERANGE          34  /* Math result not representable */
+#define  EDEADLK         35  /* Resource deadlock would occur */
+#define  ENAMETOOLONG    36  /* File name too long */
+#define  ENOLCK          37  /* No record locks available */
+#define  ENOSYS          38  /* Function not implemented */
+#define  ENOTEMPTY       39  /* Directory not empty */
+#define  ELOOP           40  /* Too many symbolic links encountered */
+#define  EWOULDBLOCK     EAGAIN  /* Operation would block */
+#define  ENOMSG          42  /* No message of desired type */
+#define  EIDRM           43  /* Identifier removed */
+#define  ECHRNG          44  /* Channel number out of range */
+#define  EL2NSYNC        45  /* Level 2 not synchronized */
+#define  EL3HLT          46  /* Level 3 halted */
+#define  EL3RST          47  /* Level 3 reset */
+#define  ELNRNG          48  /* Link number out of range */
+#define  EUNATCH         49  /* Protocol driver not attached */
+#define  ENOCSI          50  /* No CSI structure available */
+#define  EL2HLT          51  /* Level 2 halted */
+#define  EBADE           52  /* Invalid exchange */
+#define  EBADR           53  /* Invalid request descriptor */
+#define  EXFULL          54  /* Exchange full */
+#define  ENOANO          55  /* No anode */
+#define  EBADRQC         56  /* Invalid request code */
+#define  EBADSLT         57  /* Invalid slot */
+
+#define  EDEADLOCK       EDEADLK
+
+#define  EBFONT          59  /* Bad font file format */
+#define  ENOSTR          60  /* Device not a stream */
+#define  ENODATA         61  /* No data available */
+#define  ETIME           62  /* Timer expired */
+#define  ENOSR           63  /* Out of streams resources */
+#define  ENONET          64  /* Machine is not on the network */
+#define  ENOPKG          65  /* Package not installed */
+#define  EREMOTE         66  /* Object is remote */
+#define  ENOLINK         67  /* Link has been severed */
+#define  EADV            68  /* Advertise error */
+#define  ESRMNT          69  /* Srmount error */
+#define  ECOMM           70  /* Communication error on send */
+#define  EPROTO          71  /* Protocol error */
+#define  EMULTIHOP       72  /* Multihop attempted */
+#define  EDOTDOT         73  /* RFS specific error */
+#define  EBADMSG         74  /* Not a data message */
+#define  EOVERFLOW       75  /* Value too large for defined data type */
+#define  ENOTUNIQ        76  /* Name not unique on network */
+#define  EBADFD          77  /* File descriptor in bad state */
+#define  EREMCHG         78  /* Remote address changed */
+#define  ELIBACC         79  /* Can not access a needed shared library */
+#define  ELIBBAD         80  /* Accessing a corrupted shared library */
+#define  ELIBSCN         81  /* .lib section in a.out corrupted */
+#define  ELIBMAX         82  /* Attempting to link in too many shared libraries */
+#define  ELIBEXEC        83  /* Cannot exec a shared library directly */
+#define  EILSEQ          84  /* Illegal byte sequence */
+#define  ERESTART        85  /* Interrupted system call should be restarted */
+#define  ESTRPIPE        86  /* Streams pipe error */
+#define  EUSERS          87  /* Too many users */
+#define  ENOTSOCK        88  /* Socket operation on non-socket */
+#define  EDESTADDRREQ    89  /* Destination address required */
+#define  EMSGSIZE        90  /* Message too long */
+#define  EPROTOTYPE      91  /* Protocol wrong type for socket */
+#define  ENOPROTOOPT     92  /* Protocol not available */
+#define  EPROTONOSUPPORT 93  /* Protocol not supported */
+#define  ESOCKTNOSUPPORT 94  /* Socket type not supported */
+#define  EOPNOTSUPP      95  /* Operation not supported on transport endpoint */
+#define  EPFNOSUPPORT    96  /* Protocol family not supported */
+#define  EAFNOSUPPORT    97  /* Address family not supported by protocol */
+#define  EADDRINUSE      98  /* Address already in use */
+#define  EADDRNOTAVAIL   99  /* Cannot assign requested address */
+#define  ENETDOWN       100  /* Network is down */
+#define  ENETUNREACH    101  /* Network is unreachable */
+#define  ENETRESET      102  /* Network dropped connection because of reset */
+#define  ECONNABORTED   103  /* Software caused connection abort */
+#define  ECONNRESET     104  /* Connection reset by peer */
+#define  ENOBUFS        105  /* No buffer space available */
+#define  EISCONN        106  /* Transport endpoint is already connected */
+#define  ENOTCONN       107  /* Transport endpoint is not connected */
+#define  ESHUTDOWN      108  /* Cannot send after transport endpoint shutdown */
+#define  ETOOMANYREFS   109  /* Too many references: cannot splice */
+#define  ETIMEDOUT      110  /* Connection timed out */
+#define  ECONNREFUSED   111  /* Connection refused */
+#define  EHOSTDOWN      112  /* Host is down */
+#define  EHOSTUNREACH   113  /* No route to host */
+#define  EALREADY       114  /* Operation already in progress */
+#define  EINPROGRESS    115  /* Operation now in progress */
+#define  ESTALE         116  /* Stale NFS file handle */
+#define  EUCLEAN        117  /* Structure needs cleaning */
+#define  ENOTNAM        118  /* Not a XENIX named type file */
+#define  ENAVAIL        119  /* No XENIX semaphores available */
+#define  EISNAM         120  /* Is a named type file */
+#define  EREMOTEIO      121  /* Remote I/O error */
+#define  EDQUOT         122  /* Quota exceeded */
+
+#define  ENOMEDIUM      123  /* No medium found */
+#define  EMEDIUMTYPE    124  /* Wrong medium type */
+
+#ifndef errno
+extern int errno;
+#endif
+
+#else /* LWIP_PROVIDE_ERRNO */
+
+/* Define LWIP_ERRNO_INCLUDE to <errno.h> to include the error defines here */
+#ifdef LWIP_ERRNO_INCLUDE
+#include LWIP_ERRNO_INCLUDE
+#endif /* LWIP_ERRNO_INCLUDE */
+
+#endif /* LWIP_PROVIDE_ERRNO */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_ERRNO_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/etharp.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/etharp.h
new file mode 100644
index 000000000..7080a19d0
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/etharp.h
@@ -0,0 +1,106 @@
+/**
+ * @file
+ * Ethernet output function - handles OUTGOING ethernet level traffic, implements
+ * ARP resolving.
+ * To be used in most low-level netif implementations
+ */
+
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * Copyright (c) 2003-2004 Leon Woestenberg <leon.woestenberg@axon.tv>
+ * Copyright (c) 2003-2004 Axon Digital Design B.V., The Netherlands.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+#ifndef LWIP_HDR_NETIF_ETHARP_H
+#define LWIP_HDR_NETIF_ETHARP_H
+
+#include "lwip/opt.h"
+
+#if LWIP_ARP || LWIP_ETHERNET /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/pbuf.h"
+#include "lwip/ip4_addr.h"
+#include "lwip/netif.h"
+#include "lwip/ip4.h"
+#include "lwip/prot/ethernet.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_IPV4 && LWIP_ARP /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/prot/etharp.h"
+
+/** 1 seconds period */
+#define ARP_TMR_INTERVAL 1000
+
+#if ARP_QUEUEING
+/** struct for queueing outgoing packets for unknown address
+  * defined here to be accessed by memp.h
+  */
+struct etharp_q_entry {
+  struct etharp_q_entry *next;
+  struct pbuf *p;
+};
+#endif /* ARP_QUEUEING */
+
+#define etharp_init() /* Compatibility define, no init needed. */
+void etharp_tmr(void);
+s8_t etharp_find_addr(struct netif *netif, const ip4_addr_t *ipaddr,
+         struct eth_addr **eth_ret, const ip4_addr_t **ip_ret);
+u8_t etharp_get_entry(u8_t i, ip4_addr_t **ipaddr, struct netif **netif, struct eth_addr **eth_ret);
+err_t etharp_output(struct netif *netif, struct pbuf *q, const ip4_addr_t *ipaddr);
+err_t etharp_query(struct netif *netif, const ip4_addr_t *ipaddr, struct pbuf *q);
+err_t etharp_request(struct netif *netif, const ip4_addr_t *ipaddr);
+/** For Ethernet network interfaces, we might want to send "gratuitous ARP";
+ *  this is an ARP packet sent by a node in order to spontaneously cause other
+ *  nodes to update an entry in their ARP cache.
+ *  From RFC 3220 "IP Mobility Support for IPv4" section 4.6. */
+#define etharp_gratuitous(netif) etharp_request((netif), netif_ip4_addr(netif))
+void etharp_cleanup_netif(struct netif *netif);
+
+#if ETHARP_SUPPORT_STATIC_ENTRIES
+err_t etharp_add_static_entry(const ip4_addr_t *ipaddr, struct eth_addr *ethaddr);
+err_t etharp_remove_static_entry(const ip4_addr_t *ipaddr);
+#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
+
+#endif /* LWIP_IPV4 && LWIP_ARP */
+
+void etharp_input(struct pbuf *p, struct netif *netif);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_ARP || LWIP_ETHERNET */
+
+#endif /* LWIP_HDR_NETIF_ETHARP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ethip6.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ethip6.h
new file mode 100644
index 000000000..5e88dffd0
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ethip6.h
@@ -0,0 +1,68 @@
+/**
+ * @file
+ *
+ * Ethernet output for IPv6. Uses ND tables for link-layer addressing.
+ */
+
+/*
+ * Copyright (c) 2010 Inico Technologies Ltd.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Ivan Delamer <delamer@inicotech.com>
+ *
+ *
+ * Please coordinate changes and requests with Ivan Delamer
+ * <delamer@inicotech.com>
+ */
+
+#ifndef LWIP_HDR_ETHIP6_H
+#define LWIP_HDR_ETHIP6_H
+
+#include "lwip/opt.h"
+
+#if LWIP_IPV6 && LWIP_ETHERNET /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/pbuf.h"
+#include "lwip/ip6.h"
+#include "lwip/ip6_addr.h"
+#include "lwip/netif.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+err_t ethip6_output(struct netif *netif, struct pbuf *q, const ip6_addr_t *ip6addr);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_IPV6 && LWIP_ETHERNET */
+
+#endif /* LWIP_HDR_ETHIP6_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/icmp.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/icmp.h
new file mode 100644
index 000000000..f5a31fd4c
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/icmp.h
@@ -0,0 +1,110 @@
+/**
+ * @file
+ * ICMP API
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_ICMP_H
+#define LWIP_HDR_ICMP_H
+
+#include "lwip/opt.h"
+#include "lwip/pbuf.h"
+#include "lwip/ip_addr.h"
+#include "lwip/netif.h"
+#include "lwip/prot/icmp.h"
+
+#if LWIP_IPV6 && LWIP_ICMP6
+#include "lwip/icmp6.h"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** ICMP destination unreachable codes */
+enum icmp_dur_type {
+  /** net unreachable */
+  ICMP_DUR_NET   = 0,
+  /** host unreachable */
+  ICMP_DUR_HOST  = 1,
+  /** protocol unreachable */
+  ICMP_DUR_PROTO = 2,
+  /** port unreachable */
+  ICMP_DUR_PORT  = 3,
+  /** fragmentation needed and DF set */
+  ICMP_DUR_FRAG  = 4,
+  /** source route failed */
+  ICMP_DUR_SR    = 5
+};
+
+/** ICMP time exceeded codes */
+enum icmp_te_type {
+  /** time to live exceeded in transit */
+  ICMP_TE_TTL  = 0,
+  /** fragment reassembly time exceeded */
+  ICMP_TE_FRAG = 1
+};
+
+#if LWIP_IPV4 && LWIP_ICMP /* don't build if not configured for use in lwipopts.h */
+
+void icmp_input(struct pbuf *p, struct netif *inp);
+void icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t);
+void icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t);
+
+#endif /* LWIP_IPV4 && LWIP_ICMP */
+
+#if LWIP_IPV4 && LWIP_IPV6
+#if LWIP_ICMP && LWIP_ICMP6
+#define icmp_port_unreach(isipv6, pbuf) ((isipv6) ? \
+                                         icmp6_dest_unreach(pbuf, ICMP6_DUR_PORT) : \
+                                         icmp_dest_unreach(pbuf, ICMP_DUR_PORT))
+#elif LWIP_ICMP
+#define icmp_port_unreach(isipv6, pbuf) do{ if(!(isipv6)) { icmp_dest_unreach(pbuf, ICMP_DUR_PORT);}}while(0)
+#elif LWIP_ICMP6
+#define icmp_port_unreach(isipv6, pbuf) do{ if(isipv6) { icmp6_dest_unreach(pbuf, ICMP6_DUR_PORT);}}while(0)
+#else
+#define icmp_port_unreach(isipv6, pbuf)
+#endif
+#elif LWIP_IPV6 && LWIP_ICMP6
+#define icmp_port_unreach(isipv6, pbuf) icmp6_dest_unreach(pbuf, ICMP6_DUR_PORT)
+#elif LWIP_IPV4 && LWIP_ICMP
+#define icmp_port_unreach(isipv6, pbuf) icmp_dest_unreach(pbuf, ICMP_DUR_PORT)
+#else /* (LWIP_IPV6 && LWIP_ICMP6) || (LWIP_IPV4 && LWIP_ICMP) */
+#define icmp_port_unreach(isipv6, pbuf)
+#endif /* (LWIP_IPV6 && LWIP_ICMP6) || (LWIP_IPV4 && LWIP_ICMP) LWIP_IPV4*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_ICMP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/icmp6.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/icmp6.h
new file mode 100644
index 000000000..a29dc8c1c
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/icmp6.h
@@ -0,0 +1,70 @@
+/**
+ * @file
+ *
+ * IPv6 version of ICMP, as per RFC 4443.
+ */
+
+/*
+ * Copyright (c) 2010 Inico Technologies Ltd.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Ivan Delamer <delamer@inicotech.com>
+ *
+ *
+ * Please coordinate changes and requests with Ivan Delamer
+ * <delamer@inicotech.com>
+ */
+#ifndef LWIP_HDR_ICMP6_H
+#define LWIP_HDR_ICMP6_H
+
+#include "lwip/opt.h"
+#include "lwip/pbuf.h"
+#include "lwip/ip6_addr.h"
+#include "lwip/netif.h"
+#include "lwip/prot/icmp6.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_ICMP6 && LWIP_IPV6 /* don't build if not configured for use in lwipopts.h */
+
+void icmp6_input(struct pbuf *p, struct netif *inp);
+void icmp6_dest_unreach(struct pbuf *p, enum icmp6_dur_code c);
+void icmp6_packet_too_big(struct pbuf *p, u32_t mtu);
+void icmp6_time_exceeded(struct pbuf *p, enum icmp6_te_code c);
+void icmp6_param_problem(struct pbuf *p, enum icmp6_pp_code c, u32_t pointer);
+
+#endif /* LWIP_ICMP6 && LWIP_IPV6 */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* LWIP_HDR_ICMP6_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/if.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/if.h
new file mode 100644
index 000000000..5600479d8
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/if.h
@@ -0,0 +1,59 @@
+/**
+ * @file
+ * Interface Identification APIs from:
+ *              RFC 3493: Basic Socket Interface Extensions for IPv6
+ *                  Section 4: Interface Identification
+ */
+
+/*
+ * Copyright (c) 2017 Joel Cunningham <joel.cunningham@me.com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modificat
+ion,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO E
+VENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREM
+ENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARIS
+ING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILI
+TY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Joel Cunningham <joel.cunningham@me.com>
+ *
+ */
+#ifndef LWIP_HDR_IF_H
+#define LWIP_HDR_IF_H
+
+#include "lwip/opt.h"
+
+#define IF_NAMESIZE 6 /* 2 chars, 3 nums, 1 \0 */
+
+char * lwip_if_indextoname(unsigned ifindex, char *ifname);
+unsigned int lwip_if_nametoindex(const char *ifname);
+
+#if LWIP_COMPAT_SOCKETS
+#define if_indextoname(ifindex, ifname)  lwip_if_indextoname(ifindex,ifname)
+#define if_nametoindex(ifname)           lwip_if_nametoindex(ifname)
+#endif /* LWIP_COMPAT_SOCKETS */
+
+#endif /* LWIP_HDR_IF_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/igmp.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/igmp.h
new file mode 100644
index 000000000..9e3cb36c3
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/igmp.h
@@ -0,0 +1,118 @@
+/**
+ * @file
+ * IGMP API
+ */
+
+/*
+ * Copyright (c) 2002 CITEL Technologies Ltd.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of CITEL Technologies Ltd nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY CITEL TECHNOLOGIES AND CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL CITEL TECHNOLOGIES OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * This file is a contribution to the lwIP TCP/IP stack.
+ * The Swedish Institute of Computer Science and Adam Dunkels
+ * are specifically granted permission to redistribute this
+ * source code.
+*/
+
+#ifndef LWIP_HDR_IGMP_H
+#define LWIP_HDR_IGMP_H
+
+#include "lwip/opt.h"
+#include "lwip/ip_addr.h"
+#include "lwip/netif.h"
+#include "lwip/pbuf.h"
+
+#if LWIP_IPV4 && LWIP_IGMP /* don't build if not configured for use in lwipopts.h */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* IGMP timer */
+#define IGMP_TMR_INTERVAL              100 /* Milliseconds */
+#define IGMP_V1_DELAYING_MEMBER_TMR   (1000/IGMP_TMR_INTERVAL)
+#define IGMP_JOIN_DELAYING_MEMBER_TMR (500 /IGMP_TMR_INTERVAL)
+
+/* Compatibility defines (don't use for new code) */
+#define IGMP_DEL_MAC_FILTER            NETIF_DEL_MAC_FILTER
+#define IGMP_ADD_MAC_FILTER            NETIF_ADD_MAC_FILTER
+
+/**
+ * igmp group structure - there is
+ * a list of groups for each interface
+ * these should really be linked from the interface, but
+ * if we keep them separate we will not affect the lwip original code
+ * too much
+ *
+ * There will be a group for the all systems group address but this
+ * will not run the state machine as it is used to kick off reports
+ * from all the other groups
+ */
+struct igmp_group {
+  /** next link */
+  struct igmp_group *next;
+  /** multicast address */
+  ip4_addr_t         group_address;
+  /** signifies we were the last person to report */
+  u8_t               last_reporter_flag;
+  /** current state of the group */
+  u8_t               group_state;
+  /** timer for reporting, negative is OFF */
+  u16_t              timer;
+  /** counter of simultaneous uses */
+  u8_t               use;
+};
+
+/*  Prototypes */
+void   igmp_init(void);
+#ifdef LWIP_DEBUG
+void   igmp_dump_group_list(void);
+#endif
+err_t  igmp_start(struct netif *netif);
+err_t  igmp_stop(struct netif *netif);
+void   igmp_report_groups(struct netif *netif);
+struct igmp_group *igmp_lookfor_group(struct netif *ifp, const ip4_addr_t *addr);
+void   igmp_input(struct pbuf *p, struct netif *inp, const ip4_addr_t *dest);
+err_t  igmp_joingroup(const ip4_addr_t *ifaddr, const ip4_addr_t *groupaddr);
+err_t  igmp_joingroup_netif(struct netif *netif, const ip4_addr_t *groupaddr);
+err_t  igmp_leavegroup(const ip4_addr_t *ifaddr, const ip4_addr_t *groupaddr);
+err_t  igmp_leavegroup_netif(struct netif *netif, const ip4_addr_t *groupaddr);
+void   igmp_tmr(void);
+
+/** @ingroup igmp 
+ * Get list head of IGMP groups for netif.
+ * Note: The allsystems group IP is contained in the list as first entry.
+ * @see @ref netif_set_igmp_mac_filter()
+ */
+#define netif_igmp_data(netif) ((struct igmp_group *)netif_get_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_IGMP))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_IPV4 && LWIP_IGMP */
+
+#endif /* LWIP_HDR_IGMP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/inet.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/inet.h
new file mode 100644
index 000000000..4a34f0265
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/inet.h
@@ -0,0 +1,172 @@
+/**
+ * @file
+ * This file (together with sockets.h) aims to provide structs and functions from
+ * - arpa/inet.h
+ * - netinet/in.h
+ *
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_INET_H
+#define LWIP_HDR_INET_H
+
+#include "lwip/opt.h"
+#include "lwip/def.h"
+#include "lwip/ip_addr.h"
+#include "lwip/ip6_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* If your port already typedef's in_addr_t, define IN_ADDR_T_DEFINED
+   to prevent this code from redefining it. */
+#if !defined(in_addr_t) && !defined(IN_ADDR_T_DEFINED)
+typedef u32_t in_addr_t;
+#endif
+
+struct in_addr {
+  in_addr_t s_addr;
+};
+
+struct in6_addr {
+  union {
+    u32_t u32_addr[4];
+    u8_t  u8_addr[16];
+  } un;
+#define s6_addr  un.u8_addr
+};
+
+/** 255.255.255.255 */
+#define INADDR_NONE         IPADDR_NONE
+/** 127.0.0.1 */
+#define INADDR_LOOPBACK     IPADDR_LOOPBACK
+/** 0.0.0.0 */
+#define INADDR_ANY          IPADDR_ANY
+/** 255.255.255.255 */
+#define INADDR_BROADCAST    IPADDR_BROADCAST
+
+/** This macro can be used to initialize a variable of type struct in6_addr
+    to the IPv6 wildcard address. */
+#define IN6ADDR_ANY_INIT {{{0,0,0,0}}}
+/** This macro can be used to initialize a variable of type struct in6_addr
+    to the IPv6 loopback address. */
+#define IN6ADDR_LOOPBACK_INIT {{{0,0,0,PP_HTONL(1)}}}
+/** This variable is initialized by the system to contain the wildcard IPv6 address. */
+extern const struct in6_addr in6addr_any;
+
+/* Definitions of the bits in an (IPv4) Internet address integer.
+
+   On subnets, host and network parts are found according to
+   the subnet mask, not these masks.  */
+#define IN_CLASSA(a)        IP_CLASSA(a)
+#define IN_CLASSA_NET       IP_CLASSA_NET
+#define IN_CLASSA_NSHIFT    IP_CLASSA_NSHIFT
+#define IN_CLASSA_HOST      IP_CLASSA_HOST
+#define IN_CLASSA_MAX       IP_CLASSA_MAX
+
+#define IN_CLASSB(b)        IP_CLASSB(b)
+#define IN_CLASSB_NET       IP_CLASSB_NET
+#define IN_CLASSB_NSHIFT    IP_CLASSB_NSHIFT
+#define IN_CLASSB_HOST      IP_CLASSB_HOST
+#define IN_CLASSB_MAX       IP_CLASSB_MAX
+
+#define IN_CLASSC(c)        IP_CLASSC(c)
+#define IN_CLASSC_NET       IP_CLASSC_NET
+#define IN_CLASSC_NSHIFT    IP_CLASSC_NSHIFT
+#define IN_CLASSC_HOST      IP_CLASSC_HOST
+#define IN_CLASSC_MAX       IP_CLASSC_MAX
+
+#define IN_CLASSD(d)        IP_CLASSD(d)
+#define IN_CLASSD_NET       IP_CLASSD_NET     /* These ones aren't really */
+#define IN_CLASSD_NSHIFT    IP_CLASSD_NSHIFT  /*   net and host fields, but */
+#define IN_CLASSD_HOST      IP_CLASSD_HOST    /*   routing needn't know. */
+#define IN_CLASSD_MAX       IP_CLASSD_MAX
+
+#define IN_MULTICAST(a)     IP_MULTICAST(a)
+
+#define IN_EXPERIMENTAL(a)  IP_EXPERIMENTAL(a)
+#define IN_BADCLASS(a)      IP_BADCLASS(a)
+
+#define IN_LOOPBACKNET      IP_LOOPBACKNET
+
+
+#ifndef INET_ADDRSTRLEN
+#define INET_ADDRSTRLEN     IP4ADDR_STRLEN_MAX
+#endif
+#if LWIP_IPV6
+#ifndef INET6_ADDRSTRLEN
+#define INET6_ADDRSTRLEN    IP6ADDR_STRLEN_MAX
+#endif
+#endif
+
+#if LWIP_IPV4
+
+#define inet_addr_from_ip4addr(target_inaddr, source_ipaddr) ((target_inaddr)->s_addr = ip4_addr_get_u32(source_ipaddr))
+#define inet_addr_to_ip4addr(target_ipaddr, source_inaddr)   (ip4_addr_set_u32(target_ipaddr, (source_inaddr)->s_addr))
+/* ATTENTION: the next define only works because both s_addr and ip4_addr_t are an u32_t effectively! */
+#define inet_addr_to_ip4addr_p(target_ip4addr_p, source_inaddr)   ((target_ip4addr_p) = (ip4_addr_t*)&((source_inaddr)->s_addr))
+
+/* directly map this to the lwip internal functions */
+#define inet_addr(cp)                   ipaddr_addr(cp)
+#define inet_aton(cp, addr)             ip4addr_aton(cp, (ip4_addr_t*)addr)
+#define inet_ntoa(addr)                 ip4addr_ntoa((const ip4_addr_t*)&(addr))
+#define inet_ntoa_r(addr, buf, buflen)  ip4addr_ntoa_r((const ip4_addr_t*)&(addr), buf, buflen)
+
+#endif /* LWIP_IPV4 */
+
+#if LWIP_IPV6
+#define inet6_addr_from_ip6addr(target_in6addr, source_ip6addr) {(target_in6addr)->un.u32_addr[0] = (source_ip6addr)->addr[0]; \
+                                                                 (target_in6addr)->un.u32_addr[1] = (source_ip6addr)->addr[1]; \
+                                                                 (target_in6addr)->un.u32_addr[2] = (source_ip6addr)->addr[2]; \
+                                                                 (target_in6addr)->un.u32_addr[3] = (source_ip6addr)->addr[3];}
+#define inet6_addr_to_ip6addr(target_ip6addr, source_in6addr)   {(target_ip6addr)->addr[0] = (source_in6addr)->un.u32_addr[0]; \
+                                                                 (target_ip6addr)->addr[1] = (source_in6addr)->un.u32_addr[1]; \
+                                                                 (target_ip6addr)->addr[2] = (source_in6addr)->un.u32_addr[2]; \
+                                                                 (target_ip6addr)->addr[3] = (source_in6addr)->un.u32_addr[3];}
+/* ATTENTION: the next define only works because both in6_addr and ip6_addr_t are an u32_t[4] effectively! */
+#define inet6_addr_to_ip6addr_p(target_ip6addr_p, source_in6addr)   ((target_ip6addr_p) = (ip6_addr_t*)(source_in6addr))
+
+/* directly map this to the lwip internal functions */
+#define inet6_aton(cp, addr)            ip6addr_aton(cp, (ip6_addr_t*)addr)
+#define inet6_ntoa(addr)                ip6addr_ntoa((const ip6_addr_t*)&(addr))
+#define inet6_ntoa_r(addr, buf, buflen) ip6addr_ntoa_r((const ip6_addr_t*)&(addr), buf, buflen)
+
+#endif /* LWIP_IPV6 */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_INET_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/inet_chksum.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/inet_chksum.h
new file mode 100644
index 000000000..4e23d7f19
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/inet_chksum.h
@@ -0,0 +1,105 @@
+/**
+ * @file
+ * IP checksum calculation functions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_INET_CHKSUM_H
+#define LWIP_HDR_INET_CHKSUM_H
+
+#include "lwip/opt.h"
+
+#include "lwip/pbuf.h"
+#include "lwip/ip_addr.h"
+
+/** Swap the bytes in an u16_t: much like lwip_htons() for little-endian */
+#ifndef SWAP_BYTES_IN_WORD
+#define SWAP_BYTES_IN_WORD(w) (((w) & 0xff) << 8) | (((w) & 0xff00) >> 8)
+#endif /* SWAP_BYTES_IN_WORD */
+
+/** Split an u32_t in two u16_ts and add them up */
+#ifndef FOLD_U32T
+#define FOLD_U32T(u)          (((u) >> 16) + ((u) & 0x0000ffffUL))
+#endif
+
+#if LWIP_CHECKSUM_ON_COPY
+/** Function-like macro: same as MEMCPY but returns the checksum of copied data
+    as u16_t */
+# ifndef LWIP_CHKSUM_COPY
+#  define LWIP_CHKSUM_COPY(dst, src, len) lwip_chksum_copy(dst, src, len)
+#  ifndef LWIP_CHKSUM_COPY_ALGORITHM
+#   define LWIP_CHKSUM_COPY_ALGORITHM 1
+#  endif /* LWIP_CHKSUM_COPY_ALGORITHM */
+# else /* LWIP_CHKSUM_COPY */
+#  define LWIP_CHKSUM_COPY_ALGORITHM 0
+# endif /* LWIP_CHKSUM_COPY */
+#else /* LWIP_CHECKSUM_ON_COPY */
+# define LWIP_CHKSUM_COPY_ALGORITHM 0
+#endif /* LWIP_CHECKSUM_ON_COPY */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+u16_t inet_chksum(const void *dataptr, u16_t len);
+u16_t inet_chksum_pbuf(struct pbuf *p);
+#if LWIP_CHKSUM_COPY_ALGORITHM
+u16_t lwip_chksum_copy(void *dst, const void *src, u16_t len);
+#endif /* LWIP_CHKSUM_COPY_ALGORITHM */
+
+#if LWIP_IPV4
+u16_t inet_chksum_pseudo(struct pbuf *p, u8_t proto, u16_t proto_len,
+       const ip4_addr_t *src, const ip4_addr_t *dest);
+u16_t inet_chksum_pseudo_partial(struct pbuf *p, u8_t proto,
+       u16_t proto_len, u16_t chksum_len, const ip4_addr_t *src, const ip4_addr_t *dest);
+#endif /* LWIP_IPV4 */
+
+#if LWIP_IPV6
+u16_t ip6_chksum_pseudo(struct pbuf *p, u8_t proto, u16_t proto_len,
+       const ip6_addr_t *src, const ip6_addr_t *dest);
+u16_t ip6_chksum_pseudo_partial(struct pbuf *p, u8_t proto, u16_t proto_len,
+       u16_t chksum_len, const ip6_addr_t *src, const ip6_addr_t *dest);
+#endif /* LWIP_IPV6 */
+
+
+u16_t ip_chksum_pseudo(struct pbuf *p, u8_t proto, u16_t proto_len,
+       const ip_addr_t *src, const ip_addr_t *dest);
+u16_t ip_chksum_pseudo_partial(struct pbuf *p, u8_t proto, u16_t proto_len,
+       u16_t chksum_len, const ip_addr_t *src, const ip_addr_t *dest);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_INET_H */
+
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/init.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/init.h
new file mode 100644
index 000000000..3c234cb58
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/init.h
@@ -0,0 +1,100 @@
+/**
+ * @file
+ * lwIP initialization API
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_INIT_H
+#define LWIP_HDR_INIT_H
+
+#include "lwip/opt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @defgroup lwip_version Version
+ * @ingroup lwip
+ * @{
+ */
+
+/** X.x.x: Major version of the stack */
+#define LWIP_VERSION_MAJOR      2
+/** x.X.x: Minor version of the stack */
+#define LWIP_VERSION_MINOR      0
+/** x.x.X: Revision of the stack */
+#define LWIP_VERSION_REVISION   3
+/** For release candidates, this is set to 1..254
+  * For official releases, this is set to 255 (LWIP_RC_RELEASE)
+  * For development versions (Git), this is set to 0 (LWIP_RC_DEVELOPMENT) */
+#define LWIP_VERSION_RC         LWIP_RC_RELEASE
+
+/** LWIP_VERSION_RC is set to LWIP_RC_RELEASE for official releases */
+#define LWIP_RC_RELEASE         255
+/** LWIP_VERSION_RC is set to LWIP_RC_DEVELOPMENT for Git versions */
+#define LWIP_RC_DEVELOPMENT     0
+
+#define LWIP_VERSION_IS_RELEASE     (LWIP_VERSION_RC == LWIP_RC_RELEASE)
+#define LWIP_VERSION_IS_DEVELOPMENT (LWIP_VERSION_RC == LWIP_RC_DEVELOPMENT)
+#define LWIP_VERSION_IS_RC          ((LWIP_VERSION_RC != LWIP_RC_RELEASE) && (LWIP_VERSION_RC != LWIP_RC_DEVELOPMENT))
+
+/* Some helper defines to get a version string */
+#define LWIP_VERSTR2(x) #x
+#define LWIP_VERSTR(x) LWIP_VERSTR2(x)
+#if LWIP_VERSION_IS_RELEASE
+#define LWIP_VERSION_STRING_SUFFIX ""
+#elif LWIP_VERSION_IS_DEVELOPMENT
+#define LWIP_VERSION_STRING_SUFFIX "d"
+#else
+#define LWIP_VERSION_STRING_SUFFIX "rc" LWIP_VERSTR(LWIP_VERSION_RC)
+#endif
+
+/** Provides the version of the stack */
+#define LWIP_VERSION   (((u32_t)LWIP_VERSION_MAJOR) << 24   | ((u32_t)LWIP_VERSION_MINOR) << 16 | \
+                        ((u32_t)LWIP_VERSION_REVISION) << 8 | ((u32_t)LWIP_VERSION_RC))
+/** Provides the version of the stack as string */
+#define LWIP_VERSION_STRING     LWIP_VERSTR(LWIP_VERSION_MAJOR) "." LWIP_VERSTR(LWIP_VERSION_MINOR) "." LWIP_VERSTR(LWIP_VERSION_REVISION) LWIP_VERSION_STRING_SUFFIX
+
+/**
+ * @}
+ */
+
+/* Modules initialization */
+void lwip_init(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_INIT_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip.h
new file mode 100644
index 000000000..0413d541f
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip.h
@@ -0,0 +1,325 @@
+/**
+ * @file
+ * IP API
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_IP_H
+#define LWIP_HDR_IP_H
+
+#include "lwip/opt.h"
+
+#include "lwip/def.h"
+#include "lwip/pbuf.h"
+#include "lwip/ip_addr.h"
+#include "lwip/err.h"
+#include "lwip/netif.h"
+#include "lwip/ip4.h"
+#include "lwip/ip6.h"
+#include "lwip/prot/ip.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* This is passed as the destination address to ip_output_if (not
+   to ip_output), meaning that an IP header already is constructed
+   in the pbuf. This is used when TCP retransmits. */
+#define LWIP_IP_HDRINCL  NULL
+
+/** pbufs passed to IP must have a ref-count of 1 as their payload pointer
+    gets altered as the packet is passed down the stack */
+#ifndef LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX
+#define LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p) LWIP_ASSERT("p->ref == 1", (p)->ref == 1)
+#endif
+
+#if LWIP_NETIF_HWADDRHINT
+#define IP_PCB_ADDRHINT ;u8_t addr_hint
+#else
+#define IP_PCB_ADDRHINT
+#endif /* LWIP_NETIF_HWADDRHINT */
+
+/** This is the common part of all PCB types. It needs to be at the
+   beginning of a PCB type definition. It is located here so that
+   changes to this common part are made in one location instead of
+   having to change all PCB structs. */
+#define IP_PCB \
+  /* ip addresses in network byte order */ \
+  ip_addr_t local_ip; \
+  ip_addr_t remote_ip; \
+  /* Bound netif index */                  \
+  u8_t netif_idx;                          \
+  /* Socket options */                     \
+  u8_t so_options;      \
+   /* Type Of Service */ \
+  u8_t tos;              \
+  /* Time To Live */     \
+  u8_t ttl               \
+  /* link layer address resolution hint */ \
+  IP_PCB_ADDRHINT
+
+struct ip_pcb {
+/* Common members of all PCB types */
+  IP_PCB;
+};
+
+/*
+ * Option flags per-socket. These are the same like SO_XXX in sockets.h
+ */
+#define SOF_REUSEADDR     0x04U  /* allow local address reuse */
+#define SOF_KEEPALIVE     0x08U  /* keep connections alive */
+#define SOF_BROADCAST     0x20U  /* permit to send and to receive broadcast messages (see IP_SOF_BROADCAST option) */
+
+#if LWIP_MANAGEMENT_CHANNEL
+#define SOF_MANAGEMENT    0x40U  /* Indicates this socket is for management channel. */
+#endif
+
+/* These flags are inherited (e.g. from a listen-pcb to a connection-pcb): */
+#define SOF_INHERITED   (SOF_REUSEADDR|SOF_KEEPALIVE)
+
+/** Global variables of this module, kept in a struct for efficient access using base+index. */
+struct ip_globals
+{
+  /** The interface that accepted the packet for the current callback invocation. */
+  struct netif *current_netif;
+  /** The interface that received the packet for the current callback invocation. */
+  struct netif *current_input_netif;
+#if LWIP_IPV4
+  /** Header of the input packet currently being processed. */
+  struct ip_hdr *current_ip4_header;
+#endif /* LWIP_IPV4 */
+#if LWIP_IPV6
+  /** Header of the input IPv6 packet currently being processed. */
+  struct ip6_hdr *current_ip6_header;
+#endif /* LWIP_IPV6 */
+  /** Total header length of current_ip4/6_header (i.e. after this, the UDP/TCP header starts) */
+  u16_t current_ip_header_tot_len;
+  /** Source IP address of current_header */
+  ip_addr_t current_iphdr_src;
+  /** Destination IP address of current_header */
+  ip_addr_t current_iphdr_dest;
+};
+extern struct ip_globals ip_data;
+
+
+/** Get the interface that accepted the current packet.
+ * This may or may not be the receiving netif, depending on your netif/network setup.
+ * This function must only be called from a receive callback (udp_recv,
+ * raw_recv, tcp_accept). It will return NULL otherwise. */
+#define ip_current_netif()      (ip_data.current_netif)
+/** Get the interface that received the current packet.
+ * This function must only be called from a receive callback (udp_recv,
+ * raw_recv, tcp_accept). It will return NULL otherwise. */
+#define ip_current_input_netif() (ip_data.current_input_netif)
+/** Total header length of ip(6)_current_header() (i.e. after this, the UDP/TCP header starts) */
+#define ip_current_header_tot_len() (ip_data.current_ip_header_tot_len)
+/** Source IP address of current_header */
+#define ip_current_src_addr()   (&ip_data.current_iphdr_src)
+/** Destination IP address of current_header */
+#define ip_current_dest_addr()  (&ip_data.current_iphdr_dest)
+
+#if LWIP_IPV4 && LWIP_IPV6
+/** Get the IPv4 header of the current packet.
+ * This function must only be called from a receive callback (udp_recv,
+ * raw_recv, tcp_accept). It will return NULL otherwise. */
+#define ip4_current_header()     ((const struct ip_hdr*)(ip_data.current_ip4_header))
+/** Get the IPv6 header of the current packet.
+ * This function must only be called from a receive callback (udp_recv,
+ * raw_recv, tcp_accept). It will return NULL otherwise. */
+#define ip6_current_header()      ((const struct ip6_hdr*)(ip_data.current_ip6_header))
+/** Returns TRUE if the current IP input packet is IPv6, FALSE if it is IPv4 */
+#define ip_current_is_v6()        (ip6_current_header() != NULL)
+/** Source IPv6 address of current_header */
+#define ip6_current_src_addr()    (ip_2_ip6(&ip_data.current_iphdr_src))
+/** Destination IPv6 address of current_header */
+#define ip6_current_dest_addr()   (ip_2_ip6(&ip_data.current_iphdr_dest))
+/** Get the transport layer protocol */
+#define ip_current_header_proto() (ip_current_is_v6() ? \
+                                   IP6H_NEXTH(ip6_current_header()) :\
+                                   IPH_PROTO(ip4_current_header()))
+/** Get the transport layer header */
+#define ip_next_header_ptr()     ((const void*)((ip_current_is_v6() ? \
+  (const u8_t*)ip6_current_header() : (const u8_t*)ip4_current_header())  + ip_current_header_tot_len()))
+
+/** Source IP4 address of current_header */
+#define ip4_current_src_addr()     (ip_2_ip4(&ip_data.current_iphdr_src))
+/** Destination IP4 address of current_header */
+#define ip4_current_dest_addr()    (ip_2_ip4(&ip_data.current_iphdr_dest))
+
+#elif LWIP_IPV4 /* LWIP_IPV4 && LWIP_IPV6 */
+
+/** Get the IPv4 header of the current packet.
+ * This function must only be called from a receive callback (udp_recv,
+ * raw_recv, tcp_accept). It will return NULL otherwise. */
+#define ip4_current_header()     ((const struct ip_hdr*)(ip_data.current_ip4_header))
+/** Always returns FALSE when only supporting IPv4 only */
+#define ip_current_is_v6()        0
+/** Get the transport layer protocol */
+#define ip_current_header_proto() IPH_PROTO(ip4_current_header())
+/** Get the transport layer header */
+#define ip_next_header_ptr()     ((const void*)((const u8_t*)ip4_current_header() + ip_current_header_tot_len()))
+/** Source IP4 address of current_header */
+#define ip4_current_src_addr()     (&ip_data.current_iphdr_src)
+/** Destination IP4 address of current_header */
+#define ip4_current_dest_addr()    (&ip_data.current_iphdr_dest)
+
+#elif LWIP_IPV6 /* LWIP_IPV4 && LWIP_IPV6 */
+
+/** Get the IPv6 header of the current packet.
+ * This function must only be called from a receive callback (udp_recv,
+ * raw_recv, tcp_accept). It will return NULL otherwise. */
+#define ip6_current_header()      ((const struct ip6_hdr*)(ip_data.current_ip6_header))
+/** Always returns TRUE when only supporting IPv6 only */
+#define ip_current_is_v6()        1
+/** Get the transport layer protocol */
+#define ip_current_header_proto() IP6H_NEXTH(ip6_current_header())
+/** Get the transport layer header */
+#define ip_next_header_ptr()     ((const void*)((const u8_t*)ip6_current_header()))
+/** Source IP6 address of current_header */
+#define ip6_current_src_addr()    (&ip_data.current_iphdr_src)
+/** Destination IP6 address of current_header */
+#define ip6_current_dest_addr()   (&ip_data.current_iphdr_dest)
+
+#endif /* LWIP_IPV6 */
+
+/** Union source address of current_header */
+#define ip_current_src_addr()    (&ip_data.current_iphdr_src)
+/** Union destination address of current_header */
+#define ip_current_dest_addr()   (&ip_data.current_iphdr_dest)
+
+/** Gets an IP pcb option (SOF_* flags) */
+#define ip_get_option(pcb, opt)   ((pcb)->so_options & (opt))
+/** Sets an IP pcb option (SOF_* flags) */
+#define ip_set_option(pcb, opt)   ((pcb)->so_options |= (opt))
+/** Resets an IP pcb option (SOF_* flags) */
+#define ip_reset_option(pcb, opt) ((pcb)->so_options &= ~(opt))
+
+#if LWIP_IPV4 && LWIP_IPV6
+/**
+ * @ingroup ip
+ * Output IP packet, netif is selected by source address
+ */
+#define ip_output(p, src, dest, ttl, tos, proto, pcb) \
+        (IP_IS_V6(dest) ? \
+        ip6_output(p, ip_2_ip6(src), ip_2_ip6(dest), ttl, tos, proto, pcb) : \
+        ip4_output(p, ip_2_ip4(src), ip_2_ip4(dest), ttl, tos, proto, pcb))
+/**
+ * @ingroup ip
+ * Output IP packet to specified interface
+ */
+#define ip_output_if(p, src, dest, ttl, tos, proto, netif) \
+        (IP_IS_V6(dest) ? \
+        ip6_output_if(p, ip_2_ip6(src), ip_2_ip6(dest), ttl, tos, proto, netif) : \
+        ip4_output_if(p, ip_2_ip4(src), ip_2_ip4(dest), ttl, tos, proto, netif))
+/**
+ * @ingroup ip
+ * Output IP packet to interface specifying source address
+ */
+#define ip_output_if_src(p, src, dest, ttl, tos, proto, netif) \
+        (IP_IS_V6(dest) ? \
+        ip6_output_if_src(p, ip_2_ip6(src), ip_2_ip6(dest), ttl, tos, proto, netif) : \
+        ip4_output_if_src(p, ip_2_ip4(src), ip_2_ip4(dest), ttl, tos, proto, netif))
+/** Output IP packet with addr_hint */
+#define ip_output_hinted(p, src, dest, ttl, tos, proto, addr_hint) \
+        (IP_IS_V6(dest) ? \
+        ip6_output_hinted(p, ip_2_ip6(src), ip_2_ip6(dest), ttl, tos, proto, addr_hint) : \
+        ip4_output_hinted(p, ip_2_ip4(src), ip_2_ip4(dest), ttl, tos, proto, addr_hint))
+/**
+ * @ingroup ip
+ * Get netif for address combination. See \ref ip6_route and \ref ip4_route
+ */
+#define ip_route(src, dest) \
+        (IP_IS_V6(dest) ? \
+        ip6_route(ip_2_ip6(src), ip_2_ip6(dest)) : \
+        ip4_route_src(ip_2_ip4(dest), ip_2_ip4(src)))
+/**
+ * @ingroup ip
+ * Get netif for IP.
+ */
+#define ip_netif_get_local_ip(netif, dest) (IP_IS_V6(dest) ? \
+        ip6_netif_get_local_ip(netif, ip_2_ip6(dest)) : \
+        ip4_netif_get_local_ip(netif))
+#define ip_debug_print(is_ipv6, p) ((is_ipv6) ? ip6_debug_print(p) : ip4_debug_print(p))
+
+err_t ip_input(struct pbuf *p, struct netif *inp);
+
+#elif LWIP_IPV4 /* LWIP_IPV4 && LWIP_IPV6 */
+
+#define ip_output(p, src, dest, ttl, tos, proto, pcb) \
+        ip4_output(p, src, dest, ttl, tos, proto, pcb)
+#define ip_output_if(p, src, dest, ttl, tos, proto, netif) \
+        ip4_output_if(p, src, dest, ttl, tos, proto, netif)
+#define ip_output_if_src(p, src, dest, ttl, tos, proto, netif) \
+        ip4_output_if_src(p, src, dest, ttl, tos, proto, netif)
+#define ip_output_hinted(p, src, dest, ttl, tos, proto, addr_hint) \
+        ip4_output_hinted(p, src, dest, ttl, tos, proto, addr_hint)
+#define ip_route(src, dest) \
+        ip4_route_src(dest, src)
+#define ip_netif_get_local_ip(netif, dest) \
+        ip4_netif_get_local_ip(netif)
+#define ip_debug_print(is_ipv6, p) ip4_debug_print(p)
+
+#define ip_input ip4_input
+
+#elif LWIP_IPV6 /* LWIP_IPV4 && LWIP_IPV6 */
+
+#define ip_output(p, src, dest, ttl, tos, proto, pcb) \
+        ip6_output(p, src, dest, ttl, tos, proto, pcb)
+#define ip_output_if(p, src, dest, ttl, tos, proto, netif) \
+        ip6_output_if(p, src, dest, ttl, tos, proto, netif)
+#define ip_output_if_src(p, src, dest, ttl, tos, proto, netif) \
+        ip6_output_if_src(p, src, dest, ttl, tos, proto, netif)
+#define ip_output_hinted(p, src, dest, ttl, tos, proto, addr_hint) \
+        ip6_output_hinted(p, src, dest, ttl, tos, proto, addr_hint)
+#define ip_route(src, dest) \
+        ip6_route(src, dest)
+#define ip_netif_get_local_ip(netif, dest) \
+        ip6_netif_get_local_ip(netif, dest)
+#define ip_debug_print(is_ipv6, p) ip6_debug_print(p)
+
+#define ip_input ip6_input
+
+#endif /* LWIP_IPV6 */
+
+#define ip_route_get_local_ip(src, dest, netif, ipaddr) do { \
+  (netif) = ip_route(src, dest); \
+  (ipaddr) = ip_netif_get_local_ip(netif, dest); \
+}while(0)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_IP_H */
+
+
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip4.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip4.h
new file mode 100644
index 000000000..d7f84aafb
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip4.h
@@ -0,0 +1,111 @@
+/**
+ * @file
+ * IPv4 API
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_IP4_H
+#define LWIP_HDR_IP4_H
+
+#include "lwip/opt.h"
+
+#if LWIP_IPV4
+
+#include "lwip/def.h"
+#include "lwip/pbuf.h"
+#include "lwip/ip4_addr.h"
+#include "lwip/err.h"
+#include "lwip/netif.h"
+#include "lwip/prot/ip4.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef LWIP_HOOK_IP4_ROUTE_SRC
+#define LWIP_IPV4_SRC_ROUTING   1
+#else
+#define LWIP_IPV4_SRC_ROUTING   0
+#endif
+
+/** Currently, the function ip_output_if_opt() is only used with IGMP */
+#define IP_OPTIONS_SEND   (LWIP_IPV4 && LWIP_IGMP)
+
+#define ip_init() /* Compatibility define, no init needed. */
+struct netif *ip4_route(const ip4_addr_t *dest);
+#if LWIP_IPV4_SRC_ROUTING
+struct netif *ip4_route_src(const ip4_addr_t *dest, const ip4_addr_t *src);
+#else /* LWIP_IPV4_SRC_ROUTING */
+#define ip4_route_src(dest, src) ip4_route(dest)
+#endif /* LWIP_IPV4_SRC_ROUTING */
+err_t ip4_input(struct pbuf *p, struct netif *inp);
+err_t ip4_output(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
+       u8_t ttl, u8_t tos, u8_t proto, struct ip_pcb *pcb);
+err_t ip4_output_if(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
+       u8_t ttl, u8_t tos, u8_t proto, struct netif *netif);
+err_t ip4_output_if_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
+       u8_t ttl, u8_t tos, u8_t proto, struct netif *netif);
+#if LWIP_NETIF_HWADDRHINT
+err_t ip4_output_hinted(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
+       u8_t ttl, u8_t tos, u8_t proto, u8_t *addr_hint);
+#endif /* LWIP_NETIF_HWADDRHINT */
+#if IP_OPTIONS_SEND
+err_t ip4_output_if_opt(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
+       u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
+       u16_t optlen);
+err_t ip4_output_if_opt_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
+       u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
+       u16_t optlen);
+#endif /* IP_OPTIONS_SEND */
+
+#if LWIP_MULTICAST_TX_OPTIONS
+void  ip4_set_default_multicast_netif(struct netif* default_multicast_netif);
+#endif /* LWIP_MULTICAST_TX_OPTIONS */
+
+#define ip4_netif_get_local_ip(netif) (((netif) != NULL) ? netif_ip_addr4(netif) : NULL)
+
+#if IP_DEBUG
+void ip4_debug_print(struct pbuf *p);
+#else
+#define ip4_debug_print(p)
+#endif /* IP_DEBUG */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_IPV4 */
+
+#endif /* LWIP_HDR_IP_H */
+
+
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip4_addr.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip4_addr.h
new file mode 100644
index 000000000..51b46b8d4
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip4_addr.h
@@ -0,0 +1,227 @@
+/**
+ * @file
+ * IPv4 address API
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_IP4_ADDR_H
+#define LWIP_HDR_IP4_ADDR_H
+
+#include "lwip/opt.h"
+#include "lwip/def.h"
+
+#if LWIP_IPV4
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** This is the aligned version of ip4_addr_t,
+   used as local variable, on the stack, etc. */
+struct ip4_addr {
+  u32_t addr;
+};
+
+/** ip4_addr_t uses a struct for convenience only, so that the same defines can
+ * operate both on ip4_addr_t as well as on ip4_addr_p_t. */
+typedef struct ip4_addr ip4_addr_t;
+
+/**
+ * struct ipaddr2 is used in the definition of the ARP packet format in
+ * order to support compilers that don't have structure packing.
+ */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct ip4_addr2 {
+  PACK_STRUCT_FIELD(u16_t addrw[2]);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/* Forward declaration to not include netif.h */
+struct netif;
+
+/** 255.255.255.255 */
+#define IPADDR_NONE         ((u32_t)0xffffffffUL)
+/** 127.0.0.1 */
+#define IPADDR_LOOPBACK     ((u32_t)0x7f000001UL)
+/** 0.0.0.0 */
+#define IPADDR_ANY          ((u32_t)0x00000000UL)
+/** 255.255.255.255 */
+#define IPADDR_BROADCAST    ((u32_t)0xffffffffUL)
+
+/* Definitions of the bits in an Internet address integer.
+
+   On subnets, host and network parts are found according to
+   the subnet mask, not these masks.  */
+#define IP_CLASSA(a)        ((((u32_t)(a)) & 0x80000000UL) == 0)
+#define IP_CLASSA_NET       0xff000000
+#define IP_CLASSA_NSHIFT    24
+#define IP_CLASSA_HOST      (0xffffffff & ~IP_CLASSA_NET)
+#define IP_CLASSA_MAX       128
+
+#define IP_CLASSB(a)        ((((u32_t)(a)) & 0xc0000000UL) == 0x80000000UL)
+#define IP_CLASSB_NET       0xffff0000
+#define IP_CLASSB_NSHIFT    16
+#define IP_CLASSB_HOST      (0xffffffff & ~IP_CLASSB_NET)
+#define IP_CLASSB_MAX       65536
+
+#define IP_CLASSC(a)        ((((u32_t)(a)) & 0xe0000000UL) == 0xc0000000UL)
+#define IP_CLASSC_NET       0xffffff00
+#define IP_CLASSC_NSHIFT    8
+#define IP_CLASSC_HOST      (0xffffffff & ~IP_CLASSC_NET)
+
+#define IP_CLASSD(a)        (((u32_t)(a) & 0xf0000000UL) == 0xe0000000UL)
+#define IP_CLASSD_NET       0xf0000000          /* These ones aren't really */
+#define IP_CLASSD_NSHIFT    28                  /*   net and host fields, but */
+#define IP_CLASSD_HOST      0x0fffffff          /*   routing needn't know. */
+#define IP_MULTICAST(a)     IP_CLASSD(a)
+
+#define IP_EXPERIMENTAL(a)  (((u32_t)(a) & 0xf0000000UL) == 0xf0000000UL)
+#define IP_BADCLASS(a)      (((u32_t)(a) & 0xf0000000UL) == 0xf0000000UL)
+
+#define IP_LOOPBACKNET      127                 /* official! */
+
+/** Set an IP address given by the four byte-parts */
+#define IP4_ADDR(ipaddr, a,b,c,d)  (ipaddr)->addr = PP_HTONL(LWIP_MAKEU32(a,b,c,d))
+
+/** MEMCPY-like copying of IP addresses where addresses are known to be
+ * 16-bit-aligned if the port is correctly configured (so a port could define
+ * this to copying 2 u16_t's) - no NULL-pointer-checking needed. */
+#ifndef IPADDR2_COPY
+#define IPADDR2_COPY(dest, src) SMEMCPY(dest, src, sizeof(ip4_addr_t))
+#endif
+
+/** Copy IP address - faster than ip4_addr_set: no NULL check */
+#define ip4_addr_copy(dest, src) ((dest).addr = (src).addr)
+/** Safely copy one IP address to another (src may be NULL) */
+#define ip4_addr_set(dest, src) ((dest)->addr = \
+                                    ((src) == NULL ? 0 : \
+                                    (src)->addr))
+/** Set complete address to zero */
+#define ip4_addr_set_zero(ipaddr)     ((ipaddr)->addr = 0)
+/** Set address to IPADDR_ANY (no need for lwip_htonl()) */
+#define ip4_addr_set_any(ipaddr)      ((ipaddr)->addr = IPADDR_ANY)
+/** Set address to loopback address */
+#define ip4_addr_set_loopback(ipaddr) ((ipaddr)->addr = PP_HTONL(IPADDR_LOOPBACK))
+/** Check if an address is in the loopback region */
+#define ip4_addr_isloopback(ipaddr)    (((ipaddr)->addr & PP_HTONL(IP_CLASSA_NET)) == PP_HTONL(((u32_t)IP_LOOPBACKNET) << 24))
+/** Safely copy one IP address to another and change byte order
+ * from host- to network-order. */
+#define ip4_addr_set_hton(dest, src) ((dest)->addr = \
+                               ((src) == NULL ? 0:\
+                               lwip_htonl((src)->addr)))
+/** IPv4 only: set the IP address given as an u32_t */
+#define ip4_addr_set_u32(dest_ipaddr, src_u32) ((dest_ipaddr)->addr = (src_u32))
+/** IPv4 only: get the IP address as an u32_t */
+#define ip4_addr_get_u32(src_ipaddr) ((src_ipaddr)->addr)
+
+/** Get the network address by combining host address with netmask */
+#define ip4_addr_get_network(target, host, netmask) do { ((target)->addr = ((host)->addr) & ((netmask)->addr)); } while(0)
+
+/**
+ * Determine if two address are on the same network.
+ *
+ * @arg addr1 IP address 1
+ * @arg addr2 IP address 2
+ * @arg mask network identifier mask
+ * @return !0 if the network identifiers of both address match
+ */
+#define ip4_addr_netcmp(addr1, addr2, mask) (((addr1)->addr & \
+                                              (mask)->addr) == \
+                                             ((addr2)->addr & \
+                                              (mask)->addr))
+#define ip4_addr_cmp(addr1, addr2) ((addr1)->addr == (addr2)->addr)
+
+#define ip4_addr_isany_val(addr1)   ((addr1).addr == IPADDR_ANY)
+#define ip4_addr_isany(addr1) ((addr1) == NULL || ip4_addr_isany_val(*(addr1)))
+
+#define ip4_addr_isbroadcast(addr1, netif) ip4_addr_isbroadcast_u32((addr1)->addr, netif)
+u8_t ip4_addr_isbroadcast_u32(u32_t addr, const struct netif *netif);
+
+#define ip_addr_netmask_valid(netmask) ip4_addr_netmask_valid((netmask)->addr)
+u8_t ip4_addr_netmask_valid(u32_t netmask);
+
+#define ip4_addr_ismulticast(addr1) (((addr1)->addr & PP_HTONL(0xf0000000UL)) == PP_HTONL(0xe0000000UL))
+
+#define ip4_addr_islinklocal(addr1) (((addr1)->addr & PP_HTONL(0xffff0000UL)) == PP_HTONL(0xa9fe0000UL))
+
+#define ip4_addr_debug_print_parts(debug, a, b, c, d) \
+  LWIP_DEBUGF(debug, ("%" U16_F ".%" U16_F ".%" U16_F ".%" U16_F, a, b, c, d))
+#define ip4_addr_debug_print(debug, ipaddr) \
+  ip4_addr_debug_print_parts(debug, \
+                      (u16_t)((ipaddr) != NULL ? ip4_addr1_16(ipaddr) : 0),       \
+                      (u16_t)((ipaddr) != NULL ? ip4_addr2_16(ipaddr) : 0),       \
+                      (u16_t)((ipaddr) != NULL ? ip4_addr3_16(ipaddr) : 0),       \
+                      (u16_t)((ipaddr) != NULL ? ip4_addr4_16(ipaddr) : 0))
+#define ip4_addr_debug_print_val(debug, ipaddr) \
+  ip4_addr_debug_print_parts(debug, \
+                      ip4_addr1_16(&(ipaddr)),       \
+                      ip4_addr2_16(&(ipaddr)),       \
+                      ip4_addr3_16(&(ipaddr)),       \
+                      ip4_addr4_16(&(ipaddr)))
+
+/* Get one byte from the 4-byte address */
+#define ip4_addr1(ipaddr) (((const u8_t*)(&(ipaddr)->addr))[0])
+#define ip4_addr2(ipaddr) (((const u8_t*)(&(ipaddr)->addr))[1])
+#define ip4_addr3(ipaddr) (((const u8_t*)(&(ipaddr)->addr))[2])
+#define ip4_addr4(ipaddr) (((const u8_t*)(&(ipaddr)->addr))[3])
+/* These are cast to u16_t, with the intent that they are often arguments
+ * to printf using the U16_F format from cc.h. */
+#define ip4_addr1_16(ipaddr) ((u16_t)ip4_addr1(ipaddr))
+#define ip4_addr2_16(ipaddr) ((u16_t)ip4_addr2(ipaddr))
+#define ip4_addr3_16(ipaddr) ((u16_t)ip4_addr3(ipaddr))
+#define ip4_addr4_16(ipaddr) ((u16_t)ip4_addr4(ipaddr))
+
+#define IP4ADDR_STRLEN_MAX  16
+
+/** For backwards compatibility */
+#define ip_ntoa(ipaddr)  ipaddr_ntoa(ipaddr)
+
+u32_t ipaddr_addr(const char *cp);
+int ip4addr_aton(const char *cp, ip4_addr_t *addr);
+/** returns ptr to static buffer; not reentrant! */
+char *ip4addr_ntoa(const ip4_addr_t *addr);
+char *ip4addr_ntoa_r(const ip4_addr_t *addr, char *buf, int buflen);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_IPV4 */
+
+#endif /* LWIP_HDR_IP_ADDR_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip4_frag.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip4_frag.h
new file mode 100644
index 000000000..ed5bf14a3
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip4_frag.h
@@ -0,0 +1,100 @@
+/**
+ * @file
+ * IP fragmentation/reassembly
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Jani Monoses <jani@iv.ro>
+ *
+ */
+
+#ifndef LWIP_HDR_IP4_FRAG_H
+#define LWIP_HDR_IP4_FRAG_H
+
+#include "lwip/opt.h"
+#include "lwip/err.h"
+#include "lwip/pbuf.h"
+#include "lwip/netif.h"
+#include "lwip/ip_addr.h"
+#include "lwip/ip.h"
+
+#if LWIP_IPV4
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if IP_REASSEMBLY
+/* The IP reassembly timer interval in milliseconds. */
+#define IP_TMR_INTERVAL 1000
+
+/** IP reassembly helper struct.
+ * This is exported because memp needs to know the size.
+ */
+struct ip_reassdata {
+  struct ip_reassdata *next;
+  struct pbuf *p;
+  struct ip_hdr iphdr;
+  u16_t datagram_len;
+  u8_t flags;
+  u8_t timer;
+};
+
+void ip_reass_init(void);
+void ip_reass_tmr(void);
+struct pbuf * ip4_reass(struct pbuf *p);
+#endif /* IP_REASSEMBLY */
+
+#if IP_FRAG
+#if !LWIP_NETIF_TX_SINGLE_PBUF
+#ifndef LWIP_PBUF_CUSTOM_REF_DEFINED
+#define LWIP_PBUF_CUSTOM_REF_DEFINED
+/** A custom pbuf that holds a reference to another pbuf, which is freed
+ * when this custom pbuf is freed. This is used to create a custom PBUF_REF
+ * that points into the original pbuf. */
+struct pbuf_custom_ref {
+  /** 'base class' */
+  struct pbuf_custom pc;
+  /** pointer to the original pbuf that is referenced */
+  struct pbuf *original;
+};
+#endif /* LWIP_PBUF_CUSTOM_REF_DEFINED */
+#endif /* !LWIP_NETIF_TX_SINGLE_PBUF */
+
+err_t ip4_frag(struct pbuf *p, struct netif *netif, const ip4_addr_t *dest);
+#endif /* IP_FRAG */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_IPV4 */
+
+#endif /* LWIP_HDR_IP4_FRAG_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip6.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip6.h
new file mode 100644
index 000000000..9cadabe44
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip6.h
@@ -0,0 +1,93 @@
+/**
+ * @file
+ *
+ * IPv6 layer.
+ */
+
+/*
+ * Copyright (c) 2010 Inico Technologies Ltd.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Ivan Delamer <delamer@inicotech.com>
+ *
+ *
+ * Please coordinate changes and requests with Ivan Delamer
+ * <delamer@inicotech.com>
+ */
+#ifndef LWIP_HDR_IP6_H
+#define LWIP_HDR_IP6_H
+
+#include "lwip/opt.h"
+
+#if LWIP_IPV6  /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/ip6_addr.h"
+#include "lwip/prot/ip6.h"
+#include "lwip/def.h"
+#include "lwip/pbuf.h"
+#include "lwip/netif.h"
+
+#include "lwip/err.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct netif *ip6_route(const ip6_addr_t *src, const ip6_addr_t *dest);
+const ip_addr_t *ip6_select_source_address(struct netif *netif, const ip6_addr_t * dest);
+err_t         ip6_input(struct pbuf *p, struct netif *inp);
+err_t         ip6_output(struct pbuf *p, const ip6_addr_t *src, const ip6_addr_t *dest,
+                         u8_t hl, u8_t tc, u8_t nexth, struct ip_pcb *pcb);
+err_t         ip6_output_if(struct pbuf *p, const ip6_addr_t *src, const ip6_addr_t *dest,
+                            u8_t hl, u8_t tc, u8_t nexth, struct netif *netif);
+err_t         ip6_output_if_src(struct pbuf *p, const ip6_addr_t *src, const ip6_addr_t *dest,
+                            u8_t hl, u8_t tc, u8_t nexth, struct netif *netif);
+#if LWIP_NETIF_HWADDRHINT
+err_t         ip6_output_hinted(struct pbuf *p, const ip6_addr_t *src, const ip6_addr_t *dest,
+                                u8_t hl, u8_t tc, u8_t nexth, u8_t *addr_hint);
+#endif /* LWIP_NETIF_HWADDRHINT */
+#if LWIP_IPV6_MLD
+err_t         ip6_options_add_hbh_ra(struct pbuf * p, u8_t nexth, u8_t value);
+#endif /* LWIP_IPV6_MLD */
+
+#define ip6_netif_get_local_ip(netif, dest) (((netif) != NULL) ? \
+  ip6_select_source_address(netif, dest) : NULL)
+
+#if IP6_DEBUG
+void ip6_debug_print(struct pbuf *p);
+#else
+#define ip6_debug_print(p)
+#endif /* IP6_DEBUG */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_IPV6 */
+
+#endif /* LWIP_HDR_IP6_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip6_addr.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip6_addr.h
new file mode 100644
index 000000000..017502200
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip6_addr.h
@@ -0,0 +1,306 @@
+/**
+ * @file
+ *
+ * IPv6 addresses.
+ */
+
+/*
+ * Copyright (c) 2010 Inico Technologies Ltd.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Ivan Delamer <delamer@inicotech.com>
+ *
+ * Structs and macros for handling IPv6 addresses.
+ *
+ * Please coordinate changes and requests with Ivan Delamer
+ * <delamer@inicotech.com>
+ */
+#ifndef LWIP_HDR_IP6_ADDR_H
+#define LWIP_HDR_IP6_ADDR_H
+
+#include "lwip/opt.h"
+#include "def.h"
+
+#if LWIP_IPV6  /* don't build if not configured for use in lwipopts.h */
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/** This is the aligned version of ip6_addr_t,
+    used as local variable, on the stack, etc. */
+struct ip6_addr {
+  u32_t addr[4];
+};
+
+/** IPv6 address */
+typedef struct ip6_addr ip6_addr_t;
+
+/** Set an IPv6 partial address given by byte-parts */
+#define IP6_ADDR_PART(ip6addr, index, a,b,c,d) \
+  (ip6addr)->addr[index] = PP_HTONL(LWIP_MAKEU32(a,b,c,d))
+
+/** Set a full IPv6 address by passing the 4 u32_t indices in network byte order
+    (use PP_HTONL() for constants) */
+#define IP6_ADDR(ip6addr, idx0, idx1, idx2, idx3) do { \
+  (ip6addr)->addr[0] = idx0; \
+  (ip6addr)->addr[1] = idx1; \
+  (ip6addr)->addr[2] = idx2; \
+  (ip6addr)->addr[3] = idx3; } while(0)
+
+/** Access address in 16-bit block */
+#define IP6_ADDR_BLOCK1(ip6addr) ((u16_t)((lwip_htonl((ip6addr)->addr[0]) >> 16) & 0xffff))
+/** Access address in 16-bit block */
+#define IP6_ADDR_BLOCK2(ip6addr) ((u16_t)((lwip_htonl((ip6addr)->addr[0])) & 0xffff))
+/** Access address in 16-bit block */
+#define IP6_ADDR_BLOCK3(ip6addr) ((u16_t)((lwip_htonl((ip6addr)->addr[1]) >> 16) & 0xffff))
+/** Access address in 16-bit block */
+#define IP6_ADDR_BLOCK4(ip6addr) ((u16_t)((lwip_htonl((ip6addr)->addr[1])) & 0xffff))
+/** Access address in 16-bit block */
+#define IP6_ADDR_BLOCK5(ip6addr) ((u16_t)((lwip_htonl((ip6addr)->addr[2]) >> 16) & 0xffff))
+/** Access address in 16-bit block */
+#define IP6_ADDR_BLOCK6(ip6addr) ((u16_t)((lwip_htonl((ip6addr)->addr[2])) & 0xffff))
+/** Access address in 16-bit block */
+#define IP6_ADDR_BLOCK7(ip6addr) ((u16_t)((lwip_htonl((ip6addr)->addr[3]) >> 16) & 0xffff))
+/** Access address in 16-bit block */
+#define IP6_ADDR_BLOCK8(ip6addr) ((u16_t)((lwip_htonl((ip6addr)->addr[3])) & 0xffff))
+
+/** Copy IPv6 address - faster than ip6_addr_set: no NULL check */
+#define ip6_addr_copy(dest, src) do{(dest).addr[0] = (src).addr[0]; \
+                                    (dest).addr[1] = (src).addr[1]; \
+                                    (dest).addr[2] = (src).addr[2]; \
+                                    (dest).addr[3] = (src).addr[3];}while(0)
+/** Safely copy one IPv6 address to another (src may be NULL) */
+#define ip6_addr_set(dest, src) do{(dest)->addr[0] = (src) == NULL ? 0 : (src)->addr[0]; \
+                                   (dest)->addr[1] = (src) == NULL ? 0 : (src)->addr[1]; \
+                                   (dest)->addr[2] = (src) == NULL ? 0 : (src)->addr[2]; \
+                                   (dest)->addr[3] = (src) == NULL ? 0 : (src)->addr[3];}while(0)
+
+/** Set complete address to zero */
+#define ip6_addr_set_zero(ip6addr)    do{(ip6addr)->addr[0] = 0; \
+                                         (ip6addr)->addr[1] = 0; \
+                                         (ip6addr)->addr[2] = 0; \
+                                         (ip6addr)->addr[3] = 0;}while(0)
+
+/** Set address to ipv6 'any' (no need for lwip_htonl()) */
+#define ip6_addr_set_any(ip6addr)       ip6_addr_set_zero(ip6addr)
+/** Set address to ipv6 loopback address */
+#define ip6_addr_set_loopback(ip6addr) do{(ip6addr)->addr[0] = 0; \
+                                          (ip6addr)->addr[1] = 0; \
+                                          (ip6addr)->addr[2] = 0; \
+                                          (ip6addr)->addr[3] = PP_HTONL(0x00000001UL);}while(0)
+/** Safely copy one IPv6 address to another and change byte order
+ * from host- to network-order. */
+#define ip6_addr_set_hton(dest, src) do{(dest)->addr[0] = (src) == NULL ? 0 : lwip_htonl((src)->addr[0]); \
+                                        (dest)->addr[1] = (src) == NULL ? 0 : lwip_htonl((src)->addr[1]); \
+                                        (dest)->addr[2] = (src) == NULL ? 0 : lwip_htonl((src)->addr[2]); \
+                                        (dest)->addr[3] = (src) == NULL ? 0 : lwip_htonl((src)->addr[3]);}while(0)
+
+
+/**
+ * Determine if two IPv6 address are on the same network.
+ *
+ * @arg addr1 IPv6 address 1
+ * @arg addr2 IPv6 address 2
+ * @return !0 if the network identifiers of both address match
+ */
+#define ip6_addr_netcmp(addr1, addr2) (((addr1)->addr[0] == (addr2)->addr[0]) && \
+                                       ((addr1)->addr[1] == (addr2)->addr[1]))
+
+#define ip6_addr_net48cmp(addr1, addr2) (((addr1)->addr[0] == (addr2)->addr[0]) && \
+                                         (((addr1)->addr[1] & PP_HTONL(0xffff0000UL)) == \
+                                          ((addr2)->addr[1] & PP_HTONL(0xffff0000UL))))
+
+/* Exact-host comparison *after* ip6_addr_netcmp() succeeded, for efficiency. */
+#define ip6_addr_nethostcmp(addr1, addr2) (((addr1)->addr[2] == (addr2)->addr[2]) && \
+                                           ((addr1)->addr[3] == (addr2)->addr[3]))
+
+#define ip6_addr_cmp(addr1, addr2) (((addr1)->addr[0] == (addr2)->addr[0]) && \
+                                    ((addr1)->addr[1] == (addr2)->addr[1]) && \
+                                    ((addr1)->addr[2] == (addr2)->addr[2]) && \
+                                    ((addr1)->addr[3] == (addr2)->addr[3]))
+
+#define ip6_get_subnet_id(ip6addr)   (lwip_htonl((ip6addr)->addr[1]) & 0x0000ffffUL)
+
+#define ip6_addr_isany_val(ip6addr) (((ip6addr).addr[0] == 0) && \
+                                     ((ip6addr).addr[1] == 0) && \
+                                     ((ip6addr).addr[2] == 0) && \
+                                     ((ip6addr).addr[3] == 0))
+#define ip6_addr_isany(ip6addr) (((ip6addr) == NULL) || ip6_addr_isany_val(*(ip6addr)))
+
+#define ip6_addr_isloopback(ip6addr) (((ip6addr)->addr[0] == 0UL) && \
+                                      ((ip6addr)->addr[1] == 0UL) && \
+                                      ((ip6addr)->addr[2] == 0UL) && \
+                                      ((ip6addr)->addr[3] == PP_HTONL(0x00000001UL)))
+
+#define ip6_addr_isglobal(ip6addr) (((ip6addr)->addr[0] & PP_HTONL(0xe0000000UL)) == PP_HTONL(0x20000000UL))
+
+#define ip6_addr_islinklocal(ip6addr) (((ip6addr)->addr[0] & PP_HTONL(0xffc00000UL)) == PP_HTONL(0xfe800000UL))
+
+#define ip6_addr_issitelocal(ip6addr) (((ip6addr)->addr[0] & PP_HTONL(0xffc00000UL)) == PP_HTONL(0xfec00000UL))
+
+#define ip6_addr_isuniquelocal(ip6addr) (((ip6addr)->addr[0] & PP_HTONL(0xfe000000UL)) == PP_HTONL(0xfc000000UL))
+
+#define ip6_addr_isipv4mappedipv6(ip6addr) (((ip6addr)->addr[0] == 0) && ((ip6addr)->addr[1] == 0) && (((ip6addr)->addr[2]) == PP_HTONL(0x0000FFFFUL)))
+
+#define ip6_addr_ismulticast(ip6addr) (((ip6addr)->addr[0] & PP_HTONL(0xff000000UL)) == PP_HTONL(0xff000000UL))
+#define ip6_addr_multicast_transient_flag(ip6addr)  ((ip6addr)->addr[0] & PP_HTONL(0x00100000UL))
+#define ip6_addr_multicast_prefix_flag(ip6addr)     ((ip6addr)->addr[0] & PP_HTONL(0x00200000UL))
+#define ip6_addr_multicast_rendezvous_flag(ip6addr) ((ip6addr)->addr[0] & PP_HTONL(0x00400000UL))
+#define ip6_addr_multicast_scope(ip6addr) ((lwip_htonl((ip6addr)->addr[0]) >> 16) & 0xf)
+#define IP6_MULTICAST_SCOPE_RESERVED            0x0
+#define IP6_MULTICAST_SCOPE_RESERVED0           0x0
+#define IP6_MULTICAST_SCOPE_INTERFACE_LOCAL     0x1
+#define IP6_MULTICAST_SCOPE_LINK_LOCAL          0x2
+#define IP6_MULTICAST_SCOPE_RESERVED3           0x3
+#define IP6_MULTICAST_SCOPE_ADMIN_LOCAL         0x4
+#define IP6_MULTICAST_SCOPE_SITE_LOCAL          0x5
+#define IP6_MULTICAST_SCOPE_ORGANIZATION_LOCAL  0x8
+#define IP6_MULTICAST_SCOPE_GLOBAL              0xe
+#define IP6_MULTICAST_SCOPE_RESERVEDF           0xf
+#define ip6_addr_ismulticast_iflocal(ip6addr) (((ip6addr)->addr[0] & PP_HTONL(0xff8f0000UL)) == PP_HTONL(0xff010000UL))
+#define ip6_addr_ismulticast_linklocal(ip6addr) (((ip6addr)->addr[0] & PP_HTONL(0xff8f0000UL)) == PP_HTONL(0xff020000UL))
+#define ip6_addr_ismulticast_adminlocal(ip6addr) (((ip6addr)->addr[0] & PP_HTONL(0xff8f0000UL)) == PP_HTONL(0xff040000UL))
+#define ip6_addr_ismulticast_sitelocal(ip6addr) (((ip6addr)->addr[0] & PP_HTONL(0xff8f0000UL)) == PP_HTONL(0xff050000UL))
+#define ip6_addr_ismulticast_orglocal(ip6addr) (((ip6addr)->addr[0] & PP_HTONL(0xff8f0000UL)) == PP_HTONL(0xff080000UL))
+#define ip6_addr_ismulticast_global(ip6addr) (((ip6addr)->addr[0] & PP_HTONL(0xff8f0000UL)) == PP_HTONL(0xff0e0000UL))
+
+/* @todo define get/set for well-know multicast addresses, e.g. ff02::1 */
+#define ip6_addr_isallnodes_iflocal(ip6addr) (((ip6addr)->addr[0] == PP_HTONL(0xff010000UL)) && \
+    ((ip6addr)->addr[1] == 0UL) && \
+    ((ip6addr)->addr[2] == 0UL) && \
+    ((ip6addr)->addr[3] == PP_HTONL(0x00000001UL)))
+
+#define ip6_addr_isallnodes_linklocal(ip6addr) (((ip6addr)->addr[0] == PP_HTONL(0xff020000UL)) && \
+    ((ip6addr)->addr[1] == 0UL) && \
+    ((ip6addr)->addr[2] == 0UL) && \
+    ((ip6addr)->addr[3] == PP_HTONL(0x00000001UL)))
+#define ip6_addr_isallnodes_networklocal(ip6addr) (((ip6addr)->addr[0] == PP_HTONL(0xff030000UL)) && \
+    ((ip6addr)->addr[1] == 0UL) && \
+    ((ip6addr)->addr[2] == 0UL) && \
+    ((ip6addr)->addr[3] == PP_HTONL(0x00000001UL)))
+#define ip6_addr_set_allnodes_linklocal(ip6addr) do{(ip6addr)->addr[0] = PP_HTONL(0xff020000UL); \
+                (ip6addr)->addr[1] = 0; \
+                (ip6addr)->addr[2] = 0; \
+                (ip6addr)->addr[3] = PP_HTONL(0x00000001UL);}while(0)
+
+#define ip6_addr_isallrouters_linklocal(ip6addr) (((ip6addr)->addr[0] == PP_HTONL(0xff020000UL)) && \
+    ((ip6addr)->addr[1] == 0UL) && \
+    ((ip6addr)->addr[2] == 0UL) && \
+    ((ip6addr)->addr[3] == PP_HTONL(0x00000002UL)))
+#define ip6_addr_set_allrouters_linklocal(ip6addr) do{(ip6addr)->addr[0] = PP_HTONL(0xff020000UL); \
+                (ip6addr)->addr[1] = 0; \
+                (ip6addr)->addr[2] = 0; \
+                (ip6addr)->addr[3] = PP_HTONL(0x00000002UL);}while(0)
+
+#define ip6_addr_issolicitednode(ip6addr) ( ((ip6addr)->addr[0] == PP_HTONL(0xff020000UL)) && \
+        ((ip6addr)->addr[2] == PP_HTONL(0x00000001UL)) && \
+        (((ip6addr)->addr[3] & PP_HTONL(0xff000000UL)) == PP_HTONL(0xff000000UL)) )
+
+#define ip6_addr_set_solicitednode(ip6addr, if_id) do{(ip6addr)->addr[0] = PP_HTONL(0xff020000UL); \
+                (ip6addr)->addr[1] = 0; \
+                (ip6addr)->addr[2] = PP_HTONL(0x00000001UL); \
+                (ip6addr)->addr[3] = (PP_HTONL(0xff000000UL) | (if_id));}while(0)
+
+#define ip6_addr_cmp_solicitednode(ip6addr, sn_addr) (((ip6addr)->addr[0] == PP_HTONL(0xff020000UL)) && \
+                                    ((ip6addr)->addr[1] == 0) && \
+                                    ((ip6addr)->addr[2] == PP_HTONL(0x00000001UL)) && \
+                                    ((ip6addr)->addr[3] == (PP_HTONL(0xff000000UL) | (sn_addr)->addr[3])))
+
+/* IPv6 address states. */
+#define IP6_ADDR_INVALID      0x00
+#define IP6_ADDR_TENTATIVE    0x08
+#define IP6_ADDR_TENTATIVE_1  0x09 /* 1 probe sent */
+#define IP6_ADDR_TENTATIVE_2  0x0a /* 2 probes sent */
+#define IP6_ADDR_TENTATIVE_3  0x0b /* 3 probes sent */
+#define IP6_ADDR_TENTATIVE_4  0x0c /* 4 probes sent */
+#define IP6_ADDR_TENTATIVE_5  0x0d /* 5 probes sent */
+#define IP6_ADDR_TENTATIVE_6  0x0e /* 6 probes sent */
+#define IP6_ADDR_TENTATIVE_7  0x0f /* 7 probes sent */
+#define IP6_ADDR_VALID        0x10 /* This bit marks an address as valid (preferred or deprecated) */
+#define IP6_ADDR_PREFERRED    0x30
+#define IP6_ADDR_DEPRECATED   0x10 /* Same as VALID (valid but not preferred) */
+#define IP6_ADDR_DUPLICATED   0x40 /* Failed DAD test, not valid */
+
+#define IP6_ADDR_TENTATIVE_COUNT_MASK 0x07 /* 1-7 probes sent */
+
+#define ip6_addr_isinvalid(addr_state) (addr_state == IP6_ADDR_INVALID)
+#define ip6_addr_istentative(addr_state) (addr_state & IP6_ADDR_TENTATIVE)
+#define ip6_addr_isvalid(addr_state) (addr_state & IP6_ADDR_VALID) /* Include valid, preferred, and deprecated. */
+#define ip6_addr_ispreferred(addr_state) (addr_state == IP6_ADDR_PREFERRED)
+#define ip6_addr_isdeprecated(addr_state) (addr_state == IP6_ADDR_DEPRECATED)
+#define ip6_addr_isduplicated(addr_state) (addr_state == IP6_ADDR_DUPLICATED)
+
+#if LWIP_IPV6_ADDRESS_LIFETIMES
+#define IP6_ADDR_LIFE_STATIC   (0)
+#define IP6_ADDR_LIFE_INFINITE (0xffffffffUL)
+#define ip6_addr_life_isstatic(addr_life) ((addr_life) == IP6_ADDR_LIFE_STATIC)
+#define ip6_addr_life_isinfinite(addr_life) ((addr_life) == IP6_ADDR_LIFE_INFINITE)
+#endif /* LWIP_IPV6_ADDRESS_LIFETIMES */
+
+#define ip6_addr_debug_print_parts(debug, a, b, c, d, e, f, g, h) \
+  LWIP_DEBUGF(debug, ("%" X16_F ":%" X16_F ":%" X16_F ":%" X16_F ":%" X16_F ":%" X16_F ":%" X16_F ":%" X16_F, \
+                      a, b, c, d, e, f, g, h))
+#define ip6_addr_debug_print(debug, ipaddr) \
+  ip6_addr_debug_print_parts(debug, \
+                      (u16_t)((ipaddr) != NULL ? IP6_ADDR_BLOCK1(ipaddr) : 0),    \
+                      (u16_t)((ipaddr) != NULL ? IP6_ADDR_BLOCK2(ipaddr) : 0),    \
+                      (u16_t)((ipaddr) != NULL ? IP6_ADDR_BLOCK3(ipaddr) : 0),    \
+                      (u16_t)((ipaddr) != NULL ? IP6_ADDR_BLOCK4(ipaddr) : 0),    \
+                      (u16_t)((ipaddr) != NULL ? IP6_ADDR_BLOCK5(ipaddr) : 0),    \
+                      (u16_t)((ipaddr) != NULL ? IP6_ADDR_BLOCK6(ipaddr) : 0),    \
+                      (u16_t)((ipaddr) != NULL ? IP6_ADDR_BLOCK7(ipaddr) : 0),    \
+                      (u16_t)((ipaddr) != NULL ? IP6_ADDR_BLOCK8(ipaddr) : 0))
+#define ip6_addr_debug_print_val(debug, ipaddr) \
+  ip6_addr_debug_print_parts(debug, \
+                      IP6_ADDR_BLOCK1(&(ipaddr)),    \
+                      IP6_ADDR_BLOCK2(&(ipaddr)),    \
+                      IP6_ADDR_BLOCK3(&(ipaddr)),    \
+                      IP6_ADDR_BLOCK4(&(ipaddr)),    \
+                      IP6_ADDR_BLOCK5(&(ipaddr)),    \
+                      IP6_ADDR_BLOCK6(&(ipaddr)),    \
+                      IP6_ADDR_BLOCK7(&(ipaddr)),    \
+                      IP6_ADDR_BLOCK8(&(ipaddr)))
+
+#define IP6ADDR_STRLEN_MAX    46
+
+int ip6addr_aton(const char *cp, ip6_addr_t *addr);
+/** returns ptr to static buffer; not reentrant! */
+char *ip6addr_ntoa(const ip6_addr_t *addr);
+char *ip6addr_ntoa_r(const ip6_addr_t *addr, char *buf, int buflen);
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_IPV6 */
+
+#endif /* LWIP_HDR_IP6_ADDR_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip6_frag.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip6_frag.h
new file mode 100644
index 000000000..6be274734
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip6_frag.h
@@ -0,0 +1,120 @@
+/**
+ * @file
+ *
+ * IPv6 fragmentation and reassembly.
+ */
+
+/*
+ * Copyright (c) 2010 Inico Technologies Ltd.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Ivan Delamer <delamer@inicotech.com>
+ *
+ *
+ * Please coordinate changes and requests with Ivan Delamer
+ * <delamer@inicotech.com>
+ */
+#ifndef LWIP_HDR_IP6_FRAG_H
+#define LWIP_HDR_IP6_FRAG_H
+
+#include "lwip/opt.h"
+#include "lwip/pbuf.h"
+#include "lwip/ip6_addr.h"
+#include "lwip/ip6.h"
+#include "lwip/netif.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#if LWIP_IPV6 && LWIP_IPV6_REASS  /* don't build if not configured for use in lwipopts.h */
+
+/** IP6_FRAG_COPYHEADER==1: for platforms where sizeof(void*) > 4, this needs to
+ * be enabled (to not overwrite part of the data). When enabled, the IPv6 header
+ * is copied instead of referencing it, which gives more room for struct ip6_reass_helper */
+#ifndef IPV6_FRAG_COPYHEADER
+#define IPV6_FRAG_COPYHEADER   0
+#endif
+
+/** The IPv6 reassembly timer interval in milliseconds. */
+#define IP6_REASS_TMR_INTERVAL 1000
+
+/* Copy the complete header of the first fragment to struct ip6_reassdata
+   or just point to its original location in the first pbuf? */
+#if IPV6_FRAG_COPYHEADER
+#define IPV6_FRAG_HDRPTR
+#define IPV6_FRAG_HDRREF(hdr) (&(hdr))
+#else /* IPV6_FRAG_COPYHEADER */
+#define IPV6_FRAG_HDRPTR *
+#define IPV6_FRAG_HDRREF(hdr) (hdr)
+#endif /* IPV6_FRAG_COPYHEADER */
+
+/** IPv6 reassembly helper struct.
+ * This is exported because memp needs to know the size.
+ */
+struct ip6_reassdata {
+  struct ip6_reassdata *next;
+  struct pbuf *p;
+  struct ip6_hdr IPV6_FRAG_HDRPTR iphdr;
+  u32_t identification;
+  u16_t datagram_len;
+  u8_t nexth;
+  u8_t timer;
+};
+
+#define ip6_reass_init() /* Compatibility define */
+void ip6_reass_tmr(void);
+struct pbuf *ip6_reass(struct pbuf *p);
+
+#endif /* LWIP_IPV6 && LWIP_IPV6_REASS */
+
+#if LWIP_IPV6 && LWIP_IPV6_FRAG  /* don't build if not configured for use in lwipopts.h */
+
+#ifndef LWIP_PBUF_CUSTOM_REF_DEFINED
+#define LWIP_PBUF_CUSTOM_REF_DEFINED
+/** A custom pbuf that holds a reference to another pbuf, which is freed
+ * when this custom pbuf is freed. This is used to create a custom PBUF_REF
+ * that points into the original pbuf. */
+struct pbuf_custom_ref {
+  /** 'base class' */
+  struct pbuf_custom pc;
+  /** pointer to the original pbuf that is referenced */
+  struct pbuf *original;
+};
+#endif /* LWIP_PBUF_CUSTOM_REF_DEFINED */
+
+err_t ip6_frag(struct pbuf *p, struct netif *netif, const ip6_addr_t *dest);
+
+#endif /* LWIP_IPV6 && LWIP_IPV6_FRAG */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_IP6_FRAG_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip6_route_table.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip6_route_table.h
new file mode 100644
index 000000000..c11b54344
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip6_route_table.h
@@ -0,0 +1,90 @@
+/**
+ * @file
+ *
+ * IPv6 static route table.
+ */
+
+/*
+ * Copyright (c) 2015 Nest Labs, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * Author: Pradip De <pde@nestlabs.com>
+ *
+ *
+ * Please coordinate changes and requests with Pradip De
+ * <pde@nestlabs.com>
+ */
+
+#ifndef __LWIP_IP6_ROUTE_TABLE_H__
+#define __LWIP_IP6_ROUTE_TABLE_H__
+
+#include "lwip/opt.h"
+
+#if LWIP_IPV6  /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/ip.h"
+#include "lwip/ip6_addr.h"
+#include "lwip/def.h"
+#include "lwip/netif.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_IPV6_ROUTE_TABLE_SUPPORT
+
+#define IP6_MAX_PREFIX_LEN                  (128)
+#define IP6_PREFIX_ALLOWED_GRANULARITY      (8)
+/* Prefix length cannot be greater than 128 bits and needs to be at a byte boundary */
+#define ip6_prefix_valid(prefix_len)        (((prefix_len) <= IP6_MAX_PREFIX_LEN) &&                 \
+                                             (((prefix_len) % IP6_PREFIX_ALLOWED_GRANULARITY) == 0))
+
+struct ip6_prefix {
+  ip6_addr_t addr;
+  u8_t prefix_len; /* prefix length in bits at byte boundaries */
+};
+
+struct ip6_route_entry {
+  struct ip6_prefix prefix;
+  struct netif *netif;
+  ip6_addr_t *gateway;
+};
+
+err_t ip6_add_route_entry(struct ip6_prefix *ip6_prefix, struct netif *netif, 
+                         ip6_addr_t *gateway, s8_t *index);
+void ip6_remove_route_entry(struct ip6_prefix *ip6_prefix);
+s8_t ip6_find_route_entry(const ip6_addr_t *ip6_dest_addr);
+struct netif *ip6_static_route(const ip6_addr_t *src, const ip6_addr_t *dest);
+ip6_addr_t *ip6_get_gateway(struct netif *netif, const ip6_addr_t *dest);
+struct ip6_route_entry *ip6_get_route_table(void);
+#endif /* LWIP_IPV6_ROUTE_TABLE_SUPPORT */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_IPV6 */
+
+#endif /* __LWIP_IP6_ROUTE_TABLE_H__ */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip_addr.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip_addr.h
new file mode 100644
index 000000000..11f65d25b
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/ip_addr.h
@@ -0,0 +1,407 @@
+/**
+ * @file
+ * IP address API (common IPv4 and IPv6)
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_IP_ADDR_H
+#define LWIP_HDR_IP_ADDR_H
+
+#include "lwip/opt.h"
+#include "lwip/def.h"
+
+#include "lwip/ip4_addr.h"
+#include "lwip/ip6_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @ingroup ipaddr
+ * IP address types for use in ip_addr_t.type member.
+ * @see tcp_new_ip_type(), udp_new_ip_type(), raw_new_ip_type().
+ */
+enum lwip_ip_addr_type {
+  /** IPv4 */
+  IPADDR_TYPE_V4 =   0U,
+  /** IPv6 */
+  IPADDR_TYPE_V6 =   6U,
+  /** IPv4+IPv6 ("dual-stack") */
+  IPADDR_TYPE_ANY = 46U
+};
+
+#if LWIP_IPV4 && LWIP_IPV6
+/**
+ * @ingroup ipaddr
+ * A union struct for both IP version's addresses.
+ * ATTENTION: watch out for its size when adding IPv6 address scope!
+ */
+typedef struct ip_addr {
+  union {
+    ip6_addr_t ip6;
+    ip4_addr_t ip4;
+  } u_addr;
+  /** @ref lwip_ip_addr_type */
+  u8_t type;
+} ip_addr_t;
+
+extern const ip_addr_t ip_addr_any_type;
+
+/** @ingroup ip4addr */
+#define IPADDR4_INIT(u32val)          { { { { u32val, 0ul, 0ul, 0ul } } }, IPADDR_TYPE_V4 }
+/** @ingroup ip4addr */
+#define IPADDR4_INIT_BYTES(a,b,c,d)   IPADDR4_INIT(PP_HTONL(LWIP_MAKEU32(a,b,c,d)))
+/** @ingroup ip6addr */
+#define IPADDR6_INIT(a, b, c, d)      { { { { a, b, c, d } } }, IPADDR_TYPE_V6 }
+/** @ingroup ip6addr */
+#define IPADDR6_INIT_HOST(a, b, c, d) { { { { PP_HTONL(a), PP_HTONL(b), PP_HTONL(c), PP_HTONL(d) } } }, IPADDR_TYPE_V6 }
+
+/** @ingroup ipaddr */
+#define IP_IS_ANY_TYPE_VAL(ipaddr)    (IP_GET_TYPE(&ipaddr) == IPADDR_TYPE_ANY)
+/** @ingroup ipaddr */
+#define IPADDR_ANY_TYPE_INIT          { { { { 0ul, 0ul, 0ul, 0ul } } }, IPADDR_TYPE_ANY }
+
+/** @ingroup ip4addr */
+#define IP_IS_V4_VAL(ipaddr)          (IP_GET_TYPE(&ipaddr) == IPADDR_TYPE_V4)
+/** @ingroup ip6addr */
+#define IP_IS_V6_VAL(ipaddr)          (IP_GET_TYPE(&ipaddr) == IPADDR_TYPE_V6)
+/** @ingroup ip4addr */
+#define IP_IS_V4(ipaddr)              (((ipaddr) == NULL) || IP_IS_V4_VAL(*(ipaddr)))
+/** @ingroup ip6addr */
+#define IP_IS_V6(ipaddr)              (((ipaddr) != NULL) && IP_IS_V6_VAL(*(ipaddr)))
+
+#define IP_SET_TYPE_VAL(ipaddr, iptype) do { (ipaddr).type = (iptype); }while(0)
+#define IP_SET_TYPE(ipaddr, iptype)     do { if((ipaddr) != NULL) { IP_SET_TYPE_VAL(*(ipaddr), iptype); }}while(0)
+#define IP_GET_TYPE(ipaddr)           ((ipaddr)->type)
+
+#define IP_ADDR_PCB_VERSION_MATCH_EXACT(pcb, ipaddr) (IP_GET_TYPE(&pcb->local_ip) == IP_GET_TYPE(ipaddr))
+#define IP_ADDR_PCB_VERSION_MATCH(pcb, ipaddr) (IP_IS_ANY_TYPE_VAL(pcb->local_ip) || IP_ADDR_PCB_VERSION_MATCH_EXACT(pcb, ipaddr))
+
+/** @ingroup ip6addr
+ * Convert generic ip address to specific protocol version
+ */
+#define ip_2_ip6(ipaddr)   (&((ipaddr)->u_addr.ip6))
+/** @ingroup ip4addr
+ * Convert generic ip address to specific protocol version
+ */
+#define ip_2_ip4(ipaddr)   (&((ipaddr)->u_addr.ip4))
+
+/** @ingroup ip4addr */
+#define IP_ADDR4(ipaddr,a,b,c,d)      do { IP4_ADDR(ip_2_ip4(ipaddr),a,b,c,d); \
+                                           IP_SET_TYPE_VAL(*(ipaddr), IPADDR_TYPE_V4); } while(0)
+/** @ingroup ip6addr */
+#define IP_ADDR6(ipaddr,i0,i1,i2,i3)  do { IP6_ADDR(ip_2_ip6(ipaddr),i0,i1,i2,i3); \
+                                           IP_SET_TYPE_VAL(*(ipaddr), IPADDR_TYPE_V6); } while(0)
+/** @ingroup ip6addr */
+#define IP_ADDR6_HOST(ipaddr,i0,i1,i2,i3)  IP_ADDR6(ipaddr,PP_HTONL(i0),PP_HTONL(i1),PP_HTONL(i2),PP_HTONL(i3))
+
+/** @ingroup ipaddr */
+#define ip_addr_copy(dest, src)      do{ IP_SET_TYPE_VAL(dest, IP_GET_TYPE(&src)); if(IP_IS_V6_VAL(src)){ \
+  ip6_addr_copy(*ip_2_ip6(&(dest)), *ip_2_ip6(&(src))); }else{ \
+  ip4_addr_copy(*ip_2_ip4(&(dest)), *ip_2_ip4(&(src))); }}while(0)
+/** @ingroup ip6addr */
+#define ip_addr_copy_from_ip6(dest, src)      do{ \
+  ip6_addr_copy(*ip_2_ip6(&(dest)), src); IP_SET_TYPE_VAL(dest, IPADDR_TYPE_V6); }while(0)
+/** @ingroup ip4addr */
+#define ip_addr_copy_from_ip4(dest, src)      do{ \
+  ip4_addr_copy(*ip_2_ip4(&(dest)), src); IP_SET_TYPE_VAL(dest, IPADDR_TYPE_V4); }while(0)
+/** @ingroup ip4addr */
+#define ip_addr_set_ip4_u32(ipaddr, val)  do{if(ipaddr){ip4_addr_set_u32(ip_2_ip4(ipaddr), val); \
+  IP_SET_TYPE(ipaddr, IPADDR_TYPE_V4); }}while(0)
+/** @ingroup ip4addr */
+#define ip_addr_get_ip4_u32(ipaddr)  (((ipaddr) && IP_IS_V4(ipaddr)) ? \
+  ip4_addr_get_u32(ip_2_ip4(ipaddr)) : 0)
+/** @ingroup ipaddr */
+#define ip_addr_set(dest, src) do{ IP_SET_TYPE(dest, IP_GET_TYPE(src)); if(IP_IS_V6(src)){ \
+  ip6_addr_set(ip_2_ip6(dest), ip_2_ip6(src)); }else{ \
+  ip4_addr_set(ip_2_ip4(dest), ip_2_ip4(src)); }}while(0)
+/** @ingroup ipaddr */
+#define ip_addr_set_ipaddr(dest, src) ip_addr_set(dest, src)
+/** @ingroup ipaddr */
+#define ip_addr_set_zero(ipaddr)     do{ \
+  ip6_addr_set_zero(ip_2_ip6(ipaddr)); IP_SET_TYPE(ipaddr, 0); }while(0)
+/** @ingroup ip5addr */
+#define ip_addr_set_zero_ip4(ipaddr)     do{ \
+  ip6_addr_set_zero(ip_2_ip6(ipaddr)); IP_SET_TYPE(ipaddr, IPADDR_TYPE_V4); }while(0)
+/** @ingroup ip6addr */
+#define ip_addr_set_zero_ip6(ipaddr)     do{ \
+  ip6_addr_set_zero(ip_2_ip6(ipaddr)); IP_SET_TYPE(ipaddr, IPADDR_TYPE_V6); }while(0)
+/** @ingroup ipaddr */
+#define ip_addr_set_any(is_ipv6, ipaddr)      do{if(is_ipv6){ \
+  ip6_addr_set_any(ip_2_ip6(ipaddr)); IP_SET_TYPE(ipaddr, IPADDR_TYPE_V6); }else{ \
+  ip4_addr_set_any(ip_2_ip4(ipaddr)); IP_SET_TYPE(ipaddr, IPADDR_TYPE_V4); }}while(0)
+/** @ingroup ipaddr */
+#define ip_addr_set_loopback(is_ipv6, ipaddr) do{if(is_ipv6){ \
+  ip6_addr_set_loopback(ip_2_ip6(ipaddr)); IP_SET_TYPE(ipaddr, IPADDR_TYPE_V6); }else{ \
+  ip4_addr_set_loopback(ip_2_ip4(ipaddr)); IP_SET_TYPE(ipaddr, IPADDR_TYPE_V4); }}while(0)
+/** @ingroup ipaddr */
+#define ip_addr_set_hton(dest, src)  do{if(IP_IS_V6(src)){ \
+  ip6_addr_set_hton(ip_2_ip6(ipaddr), (src)); IP_SET_TYPE(dest, IPADDR_TYPE_V6); }else{ \
+  ip4_addr_set_hton(ip_2_ip4(ipaddr), (src)); IP_SET_TYPE(dest, IPADDR_TYPE_V4); }}while(0)
+/** @ingroup ipaddr */
+#define ip_addr_get_network(target, host, netmask) do{if(IP_IS_V6(host)){ \
+  ip4_addr_set_zero(ip_2_ip4(target)); IP_SET_TYPE(target, IPADDR_TYPE_V6); } else { \
+  ip4_addr_get_network(ip_2_ip4(target), ip_2_ip4(host), ip_2_ip4(netmask)); IP_SET_TYPE(target, IPADDR_TYPE_V4); }}while(0)
+/** @ingroup ipaddr */
+#define ip_addr_netcmp(addr1, addr2, mask) ((IP_IS_V6(addr1) && IP_IS_V6(addr2)) ? \
+  0 : \
+  ip4_addr_netcmp(ip_2_ip4(addr1), ip_2_ip4(addr2), mask))
+/** @ingroup ipaddr */
+#define ip_addr_cmp(addr1, addr2)    ((IP_GET_TYPE(addr1) != IP_GET_TYPE(addr2)) ? 0 : (IP_IS_V6_VAL(*(addr1)) ? \
+  ip6_addr_cmp(ip_2_ip6(addr1), ip_2_ip6(addr2)) : \
+  ip4_addr_cmp(ip_2_ip4(addr1), ip_2_ip4(addr2))))
+/** @ingroup ipaddr */
+#define ip_addr_isany(ipaddr)        ((IP_IS_V6(ipaddr)) ? \
+  ip6_addr_isany(ip_2_ip6(ipaddr)) : \
+  ip4_addr_isany(ip_2_ip4(ipaddr)))
+/** @ingroup ipaddr */
+#define ip_addr_isany_val(ipaddr)        ((IP_IS_V6_VAL(ipaddr)) ? \
+  ip6_addr_isany_val(*ip_2_ip6(&(ipaddr))) : \
+  ip4_addr_isany_val(*ip_2_ip4(&(ipaddr))))
+/** @ingroup ipaddr */
+#define ip_addr_isbroadcast(ipaddr, netif) ((IP_IS_V6(ipaddr)) ? \
+  0 : \
+  ip4_addr_isbroadcast(ip_2_ip4(ipaddr), netif))
+/** @ingroup ipaddr */
+#define ip_addr_ismulticast(ipaddr)  ((IP_IS_V6(ipaddr)) ? \
+  ip6_addr_ismulticast(ip_2_ip6(ipaddr)) : \
+  ip4_addr_ismulticast(ip_2_ip4(ipaddr)))
+/** @ingroup ipaddr */
+#define ip_addr_isloopback(ipaddr)  ((IP_IS_V6(ipaddr)) ? \
+  ip6_addr_isloopback(ip_2_ip6(ipaddr)) : \
+  ip4_addr_isloopback(ip_2_ip4(ipaddr)))
+/** @ingroup ipaddr */
+#define ip_addr_islinklocal(ipaddr)  ((IP_IS_V6(ipaddr)) ? \
+  ip6_addr_islinklocal(ip_2_ip6(ipaddr)) : \
+  ip4_addr_islinklocal(ip_2_ip4(ipaddr)))
+#define ip_addr_debug_print(debug, ipaddr) do { if(IP_IS_V6(ipaddr)) { \
+  ip6_addr_debug_print(debug, ip_2_ip6(ipaddr)); } else { \
+  ip4_addr_debug_print(debug, ip_2_ip4(ipaddr)); }}while(0)
+#define ip_addr_debug_print_val(debug, ipaddr) do { if(IP_IS_V6_VAL(ipaddr)) { \
+  ip6_addr_debug_print_val(debug, *ip_2_ip6(&(ipaddr))); } else { \
+  ip4_addr_debug_print_val(debug, *ip_2_ip4(&(ipaddr))); }}while(0)
+/** @ingroup ipaddr */
+#define ipaddr_ntoa(addr)   (((addr) == NULL) ? "NULL" : \
+  ((IP_IS_V6(addr)) ? ip6addr_ntoa(ip_2_ip6(addr)) : ip4addr_ntoa(ip_2_ip4(addr))))
+/** @ingroup ipaddr */
+#define ipaddr_ntoa_r(addr, buf, buflen)   (((addr) == NULL) ? "NULL" : \
+  ((IP_IS_V6(addr)) ? ip6addr_ntoa_r(ip_2_ip6(addr), buf, buflen) : ip4addr_ntoa_r(ip_2_ip4(addr), buf, buflen)))
+int ipaddr_aton(const char *cp, ip_addr_t *addr);
+
+/** @ingroup ipaddr */
+#define IPADDR_STRLEN_MAX   IP6ADDR_STRLEN_MAX
+
+/** @ingroup ipaddr */
+#define ip4_2_ipv4_mapped_ipv6(ip6addr, ip4addr) do { \
+  (ip6addr)->addr[3] = (ip4addr)->addr; \
+  (ip6addr)->addr[2] = PP_HTONL(0x0000FFFFUL); \
+  (ip6addr)->addr[1] = 0; \
+  (ip6addr)->addr[0] = 0; } while(0);
+
+/** @ingroup ipaddr */
+#define unmap_ipv4_mapped_ipv6(ip4addr, ip6addr) \
+  (ip4addr)->addr = (ip6addr)->addr[3];
+
+#define IP46_ADDR_ANY(type) (((type) == IPADDR_TYPE_V6)? IP6_ADDR_ANY : IP4_ADDR_ANY)
+
+#else /* LWIP_IPV4 && LWIP_IPV6 */
+
+#define IP_ADDR_PCB_VERSION_MATCH(addr, pcb)         1
+#define IP_ADDR_PCB_VERSION_MATCH_EXACT(pcb, ipaddr) 1
+
+#if LWIP_IPV4
+
+typedef ip4_addr_t ip_addr_t;
+#define IPADDR4_INIT(u32val)                    { u32val }
+#define IPADDR4_INIT_BYTES(a,b,c,d)             IPADDR4_INIT(PP_HTONL(LWIP_MAKEU32(a,b,c,d)))
+#define IP_IS_V4_VAL(ipaddr)                    1
+#define IP_IS_V6_VAL(ipaddr)                    0
+#define IP_IS_V4(ipaddr)                        1
+#define IP_IS_V6(ipaddr)                        0
+#define IP_IS_ANY_TYPE_VAL(ipaddr)              0
+#define IP_SET_TYPE_VAL(ipaddr, iptype)
+#define IP_SET_TYPE(ipaddr, iptype)
+#define IP_GET_TYPE(ipaddr)                     IPADDR_TYPE_V4
+#define ip_2_ip4(ipaddr)                        (ipaddr)
+#define IP_ADDR4(ipaddr,a,b,c,d)                IP4_ADDR(ipaddr,a,b,c,d)
+
+#define ip_addr_copy(dest, src)                 ip4_addr_copy(dest, src)
+#define ip_addr_copy_from_ip4(dest, src)        ip4_addr_copy(dest, src)
+#define ip_addr_set_ip4_u32(ipaddr, val)        ip4_addr_set_u32(ip_2_ip4(ipaddr), val)
+#define ip_addr_get_ip4_u32(ipaddr)             ip4_addr_get_u32(ip_2_ip4(ipaddr))
+#define ip_addr_set(dest, src)                  ip4_addr_set(dest, src)
+#define ip_addr_set_ipaddr(dest, src)           ip4_addr_set(dest, src)
+#define ip_addr_set_zero(ipaddr)                ip4_addr_set_zero(ipaddr)
+#define ip_addr_set_zero_ip4(ipaddr)            ip4_addr_set_zero(ipaddr)
+#define ip_addr_set_any(is_ipv6, ipaddr)        ip4_addr_set_any(ipaddr)
+#define ip_addr_set_loopback(is_ipv6, ipaddr)   ip4_addr_set_loopback(ipaddr)
+#define ip_addr_set_hton(dest, src)             ip4_addr_set_hton(dest, src)
+#define ip_addr_get_network(target, host, mask) ip4_addr_get_network(target, host, mask)
+#define ip_addr_netcmp(addr1, addr2, mask)      ip4_addr_netcmp(addr1, addr2, mask)
+#define ip_addr_cmp(addr1, addr2)               ip4_addr_cmp(addr1, addr2)
+#define ip_addr_isany(ipaddr)                   ip4_addr_isany(ipaddr)
+#define ip_addr_isany_val(ipaddr)               ip4_addr_isany_val(ipaddr)
+#define ip_addr_isloopback(ipaddr)              ip4_addr_isloopback(ipaddr)
+#define ip_addr_islinklocal(ipaddr)             ip4_addr_islinklocal(ipaddr)
+#define ip_addr_isbroadcast(addr, netif)        ip4_addr_isbroadcast(addr, netif)
+#define ip_addr_ismulticast(ipaddr)             ip4_addr_ismulticast(ipaddr)
+#define ip_addr_debug_print(debug, ipaddr)      ip4_addr_debug_print(debug, ipaddr)
+#define ip_addr_debug_print_val(debug, ipaddr)  ip4_addr_debug_print_val(debug, ipaddr)
+#define ipaddr_ntoa(ipaddr)                     ip4addr_ntoa(ipaddr)
+#define ipaddr_ntoa_r(ipaddr, buf, buflen)      ip4addr_ntoa_r(ipaddr, buf, buflen)
+#define ipaddr_aton(cp, addr)                   ip4addr_aton(cp, addr)
+
+#define IPADDR_STRLEN_MAX   IP4ADDR_STRLEN_MAX
+
+#define IP46_ADDR_ANY(type) (IP4_ADDR_ANY)
+
+#else /* LWIP_IPV4 */
+
+typedef ip6_addr_t ip_addr_t;
+#define IPADDR6_INIT(a, b, c, d)                { { a, b, c, d } }
+#define IPADDR6_INIT_HOST(a, b, c, d)           { { PP_HTONL(a), PP_HTONL(b), PP_HTONL(c), PP_HTONL(d) } }
+#define IP_IS_V4_VAL(ipaddr)                    0
+#define IP_IS_V6_VAL(ipaddr)                    1
+#define IP_IS_V4(ipaddr)                        0
+#define IP_IS_V6(ipaddr)                        1
+#define IP_IS_ANY_TYPE_VAL(ipaddr)              0
+#define IP_SET_TYPE_VAL(ipaddr, iptype)
+#define IP_SET_TYPE(ipaddr, iptype)
+#define IP_GET_TYPE(ipaddr)                     IPADDR_TYPE_V6
+#define ip_2_ip6(ipaddr)                        (ipaddr)
+#define IP_ADDR6(ipaddr,i0,i1,i2,i3)            IP6_ADDR(ipaddr,i0,i1,i2,i3)
+#define IP_ADDR6_HOST(ipaddr,i0,i1,i2,i3)       IP_ADDR6(ipaddr,PP_HTONL(i0),PP_HTONL(i1),PP_HTONL(i2),PP_HTONL(i3))
+
+#define ip_addr_copy(dest, src)                 ip6_addr_copy(dest, src)
+#define ip_addr_copy_from_ip6(dest, src)        ip6_addr_copy(dest, src)
+#define ip_addr_set(dest, src)                  ip6_addr_set(dest, src)
+#define ip_addr_set_ipaddr(dest, src)           ip6_addr_set(dest, src)
+#define ip_addr_set_zero(ipaddr)                ip6_addr_set_zero(ipaddr)
+#define ip_addr_set_zero_ip6(ipaddr)            ip6_addr_set_zero(ipaddr)
+#define ip_addr_set_any(is_ipv6, ipaddr)        ip6_addr_set_any(ipaddr)
+#define ip_addr_set_loopback(is_ipv6, ipaddr)   ip6_addr_set_loopback(ipaddr)
+#define ip_addr_set_hton(dest, src)             ip6_addr_set_hton(dest, src)
+#define ip_addr_get_network(target, host, mask) ip6_addr_set_zero(target)
+#define ip_addr_netcmp(addr1, addr2, mask)      0
+#define ip_addr_cmp(addr1, addr2)               ip6_addr_cmp(addr1, addr2)
+#define ip_addr_isany(ipaddr)                   ip6_addr_isany(ipaddr)
+#define ip_addr_isany_val(ipaddr)               ip6_addr_isany_val(ipaddr)
+#define ip_addr_isloopback(ipaddr)              ip6_addr_isloopback(ipaddr)
+#define ip_addr_islinklocal(ipaddr)             ip6_addr_islinklocal(ipaddr)
+#define ip_addr_isbroadcast(addr, netif)        0
+#define ip_addr_ismulticast(ipaddr)             ip6_addr_ismulticast(ipaddr)
+#define ip_addr_debug_print(debug, ipaddr)      ip6_addr_debug_print(debug, ipaddr)
+#define ip_addr_debug_print_val(debug, ipaddr)  ip6_addr_debug_print_val(debug, ipaddr)
+#define ipaddr_ntoa(ipaddr)                     ip6addr_ntoa(ipaddr)
+#define ipaddr_ntoa_r(ipaddr, buf, buflen)      ip6addr_ntoa_r(ipaddr, buf, buflen)
+#define ipaddr_aton(cp, addr)                   ip6addr_aton(cp, addr)
+
+#define IPADDR_STRLEN_MAX   IP6ADDR_STRLEN_MAX
+
+#define IP46_ADDR_ANY(type) (IP6_ADDR_ANY)
+
+#endif /* LWIP_IPV4 */
+#endif /* LWIP_IPV4 && LWIP_IPV6 */
+
+#if LWIP_IPV4
+
+extern const ip_addr_t ip_addr_any;
+extern const ip_addr_t ip_addr_broadcast;
+
+/**
+ * @ingroup ip4addr
+ * Can be used as a fixed/const ip_addr_t
+ * for the IP wildcard.
+ * Defined to @ref IP4_ADDR_ANY when IPv4 is enabled.
+ * Defined to @ref IP6_ADDR_ANY in IPv6 only systems.
+ * Use this if you can handle IPv4 _AND_ IPv6 addresses.
+ * Use @ref IP4_ADDR_ANY or @ref IP6_ADDR_ANY when the IP
+ * type matters.
+ */
+#define IP_ADDR_ANY         IP4_ADDR_ANY
+/**
+ * @ingroup ip4addr
+ * Can be used as a fixed/const ip_addr_t
+ * for the IPv4 wildcard and the broadcast address
+ */
+#define IP4_ADDR_ANY        (&ip_addr_any)
+/**
+ * @ingroup ip4addr
+ * Can be used as a fixed/const ip4_addr_t
+ * for the wildcard and the broadcast address
+ */
+#define IP4_ADDR_ANY4       (ip_2_ip4(&ip_addr_any))
+
+/** @ingroup ip4addr */
+#define IP_ADDR_BROADCAST   (&ip_addr_broadcast)
+/** @ingroup ip4addr */
+#define IP4_ADDR_BROADCAST  (ip_2_ip4(&ip_addr_broadcast))
+
+#endif /* LWIP_IPV4*/
+
+#if LWIP_IPV6
+
+extern const ip_addr_t ip6_addr_any;
+
+/** 
+ * @ingroup ip6addr
+ * IP6_ADDR_ANY can be used as a fixed ip_addr_t
+ * for the IPv6 wildcard address
+ */
+#define IP6_ADDR_ANY   (&ip6_addr_any)
+/**
+ * @ingroup ip6addr
+ * IP6_ADDR_ANY6 can be used as a fixed ip6_addr_t
+ * for the IPv6 wildcard address
+ */
+#define IP6_ADDR_ANY6  (ip_2_ip6(&ip6_addr_any))
+
+#if !LWIP_IPV4
+/** IPv6-only configurations */
+#define IP_ADDR_ANY IP6_ADDR_ANY
+#endif /* !LWIP_IPV4 */
+
+#endif
+
+#if LWIP_IPV4 && LWIP_IPV6
+/** @ingroup ipaddr */
+#define IP_ANY_TYPE    (&ip_addr_any_type)
+#else
+#define IP_ANY_TYPE    IP_ADDR_ANY
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_IP_ADDR_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/mem.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/mem.h
new file mode 100644
index 000000000..ff208d25c
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/mem.h
@@ -0,0 +1,82 @@
+/**
+ * @file
+ * Heap API
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_MEM_H
+#define LWIP_HDR_MEM_H
+
+#include "lwip/opt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if MEM_LIBC_MALLOC
+
+#include "lwip/arch.h"
+
+typedef size_t mem_size_t;
+#define MEM_SIZE_F SZT_F
+
+#elif MEM_USE_POOLS
+
+typedef u16_t mem_size_t;
+#define MEM_SIZE_F U16_F
+
+#else
+
+/* MEM_SIZE would have to be aligned, but using 64000 here instead of
+ * 65535 leaves some room for alignment...
+ */
+#if MEM_SIZE > 64000L
+typedef u32_t mem_size_t;
+#define MEM_SIZE_F U32_F
+#else
+typedef u16_t mem_size_t;
+#define MEM_SIZE_F U16_F
+#endif /* MEM_SIZE > 64000 */
+#endif
+
+void  mem_init(void);
+void *mem_trim(void *mem, mem_size_t size);
+void *mem_malloc(mem_size_t size);
+void *mem_calloc(mem_size_t count, mem_size_t size);
+void  mem_free(void *mem);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_MEM_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/memp.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/memp.h
new file mode 100644
index 000000000..cd30996de
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/memp.h
@@ -0,0 +1,164 @@
+/**
+ * @file
+ * Memory pool API
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+#ifndef LWIP_HDR_MEMP_H
+#define LWIP_HDR_MEMP_H
+
+#include "lwip/opt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* run once with empty definition to handle all custom includes in lwippools.h */
+#define LWIP_MEMPOOL(name,num,size,desc)
+#include "lwip/priv/memp_std.h"
+
+/** Create the list of all memory pools managed by memp. MEMP_MAX represents a NULL pool at the end */
+typedef enum {
+#define LWIP_MEMPOOL(name,num,size,desc)  MEMP_##name,
+#include "lwip/priv/memp_std.h"
+  MEMP_MAX
+} memp_t;
+
+#include "lwip/priv/memp_priv.h"
+#include "lwip/stats.h"
+
+extern const struct memp_desc* const memp_pools[MEMP_MAX];
+
+#if MEMP_MEM_MALLOC || MEM_USE_POOLS || LWIP_PBUF_FROM_CUSTOM_POOLS
+extern const u16_t memp_sizes[MEMP_MAX];
+#endif /* MEMP_MEM_MALLOC || MEM_USE_POOLS */
+
+/**
+ * @ingroup mempool
+ * Declare prototype for private memory pool if it is used in multiple files
+ */
+#define LWIP_MEMPOOL_PROTOTYPE(name) extern const struct memp_desc memp_ ## name
+
+#if MEMP_MEM_MALLOC
+
+#define LWIP_MEMPOOL_DECLARE(name,num,size,desc) \
+  LWIP_MEMPOOL_DECLARE_STATS_INSTANCE(memp_stats_ ## name) \
+  const struct memp_desc memp_ ## name = { \
+    DECLARE_LWIP_MEMPOOL_DESC(desc) \
+    LWIP_MEMPOOL_DECLARE_STATS_REFERENCE(memp_stats_ ## name) \
+    LWIP_MEM_ALIGN_SIZE(size) \
+  };
+
+#else /* MEMP_MEM_MALLOC */
+
+/**
+ * @ingroup mempool
+ * Declare a private memory pool
+ * Private mempools example:
+ * .h: only when pool is used in multiple .c files: LWIP_MEMPOOL_PROTOTYPE(my_private_pool);
+ * .c:
+ *   - in global variables section: LWIP_MEMPOOL_DECLARE(my_private_pool, 10, sizeof(foo), "Some description")
+ *   - call ONCE before using pool (e.g. in some init() function): LWIP_MEMPOOL_INIT(my_private_pool);
+ *   - allocate: void* my_new_mem = LWIP_MEMPOOL_ALLOC(my_private_pool);
+ *   - free: LWIP_MEMPOOL_FREE(my_private_pool, my_new_mem);
+ *
+ * To relocate a pool, declare it as extern in cc.h. Example for GCC:
+ *   extern u8_t __attribute__((section(".onchip_mem"))) memp_memory_my_private_pool[];
+ */
+#define LWIP_MEMPOOL_DECLARE(name,num,size,desc) \
+  LWIP_DECLARE_MEMORY_ALIGNED(memp_memory_ ## name ## _base, ((num) * (MEMP_SIZE + MEMP_ALIGN_SIZE(size)))); \
+    \
+  LWIP_MEMPOOL_DECLARE_STATS_INSTANCE(memp_stats_ ## name) \
+    \
+  static struct memp *memp_tab_ ## name; \
+    \
+  const struct memp_desc memp_ ## name = { \
+    DECLARE_LWIP_MEMPOOL_DESC(desc) \
+    LWIP_MEMPOOL_DECLARE_STATS_REFERENCE(memp_stats_ ## name) \
+    LWIP_MEM_ALIGN_SIZE(size), \
+    (num), \
+    memp_memory_ ## name ## _base, \
+    &memp_tab_ ## name \
+  };
+
+#endif /* MEMP_MEM_MALLOC */
+
+/**
+ * @ingroup mempool
+ * Initialize a private memory pool
+ */
+#define LWIP_MEMPOOL_INIT(name)    memp_init_pool(&memp_ ## name)
+/**
+ * @ingroup mempool
+ * Allocate from a private memory pool
+ */
+#define LWIP_MEMPOOL_ALLOC(name)   memp_malloc_pool(&memp_ ## name)
+/**
+ * @ingroup mempool
+ * Free element from a private memory pool
+ */
+#define LWIP_MEMPOOL_FREE(name, x) memp_free_pool(&memp_ ## name, (x))
+
+#if MEM_USE_POOLS
+/** This structure is used to save the pool one element came from.
+ * This has to be defined here as it is required for pool size calculation. */
+struct memp_malloc_helper
+{
+   memp_t poolnr;
+#if MEMP_OVERFLOW_CHECK || (LWIP_STATS && MEM_STATS)
+   u16_t size;
+#endif /* MEMP_OVERFLOW_CHECK || (LWIP_STATS && MEM_STATS) */
+};
+#endif /* MEM_USE_POOLS */
+
+void  memp_init(void);
+
+#if MEMP_OVERFLOW_CHECK
+void *memp_malloc_fn(memp_t type, const char* file, const int line);
+#define memp_malloc(t) memp_malloc_fn((t), __FILE__, __LINE__)
+#else
+void *memp_malloc(memp_t type);
+#endif
+void  memp_free(memp_t type, void *mem);
+#if MEMP_SEPARATE_POOLS
+u16_t memp_pbuf_index(memp_t type, const void *mem);
+u16_t memp_num_pbufs(memp_t type);
+#endif
+u8_t memp_is_not_empty (memp_t type);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_MEMP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/mld6.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/mld6.h
new file mode 100644
index 000000000..7219beb6f
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/mld6.h
@@ -0,0 +1,97 @@
+/**
+ * @file
+ *
+ * Multicast listener discovery for IPv6. Aims to be compliant with RFC 2710.
+ * No support for MLDv2.
+ */
+
+/*
+ * Copyright (c) 2010 Inico Technologies Ltd.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Ivan Delamer <delamer@inicotech.com>
+ *
+ *
+ * Please coordinate changes and requests with Ivan Delamer
+ * <delamer@inicotech.com>
+ */
+
+#ifndef LWIP_HDR_MLD6_H
+#define LWIP_HDR_MLD6_H
+
+#include "lwip/opt.h"
+
+ /* don't build if not configured for use in lwipopts.h */
+ #if LWIP_IPV6_MLD && LWIP_IPV6_ND && LWIP_IPV6 
+
+#include "lwip/pbuf.h"
+#include "lwip/netif.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** MLD group */
+struct mld_group {
+  /** next link */
+  struct mld_group *next;
+  /** multicast address */
+  ip6_addr_t         group_address;
+  /** signifies we were the last person to report */
+  u8_t               last_reporter_flag;
+  /** current state of the group */
+  u8_t               group_state;
+  /** timer for reporting */
+  u16_t              timer;
+  /** counter of simultaneous uses */
+  u8_t               use;
+};
+
+err_t  mld6_stop(struct netif *netif);
+void   mld6_report_groups(struct netif *netif);
+struct mld_group *mld6_lookfor_group(struct netif *ifp, const ip6_addr_t *addr);
+void   mld6_input(struct pbuf *p, struct netif *inp);
+err_t  mld6_joingroup(const ip6_addr_t *srcaddr, const ip6_addr_t *groupaddr);
+err_t  mld6_joingroup_netif(struct netif *netif, const ip6_addr_t *groupaddr);
+err_t  mld6_leavegroup(const ip6_addr_t *srcaddr, const ip6_addr_t *groupaddr);
+err_t  mld6_leavegroup_netif(struct netif *netif, const ip6_addr_t *groupaddr);
+
+/** @ingroup mld6
+ * Get list head of MLD6 groups for netif.
+ * Note: The allnodes group IP is NOT in the list, since it must always 
+ * be received for correct IPv6 operation.
+ * @see @ref netif_set_mld_mac_filter()
+ */
+#define netif_mld6_data(netif) ((struct mld_group *)netif_get_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_MLD6))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_IPV6_MLD && LWIP_IPV6_ND && LWIP_IPV6 */
+
+#endif /* LWIP_HDR_MLD6_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/nd6.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/nd6.h
new file mode 100644
index 000000000..e68eb3573
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/nd6.h
@@ -0,0 +1,85 @@
+/**
+ * @file
+ *
+ * Neighbor discovery and stateless address autoconfiguration for IPv6.
+ * Aims to be compliant with RFC 4861 (Neighbor discovery) and RFC 4862
+ * (Address autoconfiguration).
+ */
+
+/*
+ * Copyright (c) 2010 Inico Technologies Ltd.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Ivan Delamer <delamer@inicotech.com>
+ *
+ *
+ * Please coordinate changes and requests with Ivan Delamer
+ * <delamer@inicotech.com>
+ */
+
+#ifndef LWIP_HDR_ND6_H
+#define LWIP_HDR_ND6_H
+
+#include "lwip/opt.h"
+
+/* don't build if not configured for use in lwipopts.h */
+#if LWIP_IPV6 && LWIP_IPV6_ND
+
+#include "lwip/ip6_addr.h"
+#include "lwip/err.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** 1 second period */
+#define ND6_TMR_INTERVAL 1000
+
+struct pbuf;
+struct netif;
+
+void nd6_tmr(void);
+void nd6_input(struct pbuf *p, struct netif *inp);
+void nd6_clear_destination_cache(void);
+struct netif *nd6_find_route(const ip6_addr_t *ip6addr);
+err_t nd6_get_next_hop_addr_or_queue(struct netif *netif, struct pbuf *q, const ip6_addr_t *ip6addr, const u8_t **hwaddrp);
+u16_t nd6_get_destination_mtu(const ip6_addr_t *ip6addr, struct netif *netif);
+#if LWIP_ND6_TCP_REACHABILITY_HINTS
+void nd6_reachability_hint(const ip6_addr_t *ip6addr);
+#endif /* LWIP_ND6_TCP_REACHABILITY_HINTS */
+void nd6_cleanup_netif(struct netif *netif);
+#if LWIP_IPV6_MLD
+void nd6_adjust_mld_membership(struct netif *netif, s8_t addr_idx, u8_t new_state);
+#endif /* LWIP_IPV6_MLD */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_IPV6 && LWIP_IPV6_ND */
+
+#endif /* LWIP_HDR_ND6_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/netbuf.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/netbuf.h
new file mode 100644
index 000000000..e6865f80f
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/netbuf.h
@@ -0,0 +1,118 @@
+/**
+ * @file
+ * netbuf API (for netconn API)
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_NETBUF_H
+#define LWIP_HDR_NETBUF_H
+
+#include "lwip/opt.h"
+
+#if LWIP_NETCONN || LWIP_SOCKET /* don't build if not configured for use in lwipopts.h */
+/* Note: Netconn API is always available when sockets are enabled -
+ * sockets are implemented on top of them */
+
+#include "lwip/pbuf.h"
+#include "lwip/ip_addr.h"
+#include "lwip/ip6_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** This netbuf has dest-addr/port set */
+#define NETBUF_FLAG_DESTADDR    0x01
+/** This netbuf includes a checksum */
+#define NETBUF_FLAG_CHKSUM      0x02
+
+/** "Network buffer" - contains data and addressing info */
+struct netbuf {
+  struct pbuf *p, *ptr;
+  ip_addr_t addr;
+  u16_t port;
+#if LWIP_NETBUF_RECVINFO || LWIP_CHECKSUM_ON_COPY
+#if LWIP_CHECKSUM_ON_COPY
+  u8_t flags;
+#endif /* LWIP_CHECKSUM_ON_COPY */
+  u16_t toport_chksum;
+#if LWIP_NETBUF_RECVINFO
+  ip_addr_t toaddr;
+#endif /* LWIP_NETBUF_RECVINFO */
+#endif /* LWIP_NETBUF_RECVINFO || LWIP_CHECKSUM_ON_COPY */
+};
+
+/* Network buffer functions: */
+struct netbuf *   netbuf_new      (void);
+void              netbuf_delete   (struct netbuf *buf);
+void *            netbuf_alloc    (struct netbuf *buf, u16_t size);
+void              netbuf_free     (struct netbuf *buf);
+err_t             netbuf_ref      (struct netbuf *buf,
+                                   const void *dataptr, u16_t size);
+void              netbuf_chain    (struct netbuf *head, struct netbuf *tail);
+
+err_t             netbuf_data     (struct netbuf *buf,
+                                   void **dataptr, u16_t *len);
+s8_t              netbuf_next     (struct netbuf *buf);
+void              netbuf_first    (struct netbuf *buf);
+
+
+#define netbuf_copy_partial(buf, dataptr, len, offset) \
+  pbuf_copy_partial((buf)->p, (dataptr), (len), (offset))
+#define netbuf_copy(buf,dataptr,len) netbuf_copy_partial(buf, dataptr, len, 0)
+#define netbuf_take(buf, dataptr, len) pbuf_take((buf)->p, dataptr, len)
+#define netbuf_len(buf)              ((buf)->p->tot_len)
+#define netbuf_fromaddr(buf)         (&((buf)->addr))
+#define netbuf_set_fromaddr(buf, fromaddr) ip_addr_set(&((buf)->addr), fromaddr)
+#define netbuf_fromport(buf)         ((buf)->port)
+#if LWIP_NETBUF_RECVINFO
+#define netbuf_destaddr(buf)         (&((buf)->toaddr))
+#define netbuf_set_destaddr(buf, destaddr) ip_addr_set(&((buf)->toaddr), destaddr)
+#if LWIP_CHECKSUM_ON_COPY
+#define netbuf_destport(buf)         (((buf)->flags & NETBUF_FLAG_DESTADDR) ? (buf)->toport_chksum : 0)
+#else /* LWIP_CHECKSUM_ON_COPY */
+#define netbuf_destport(buf)         ((buf)->toport_chksum)
+#endif /* LWIP_CHECKSUM_ON_COPY */
+#endif /* LWIP_NETBUF_RECVINFO */
+#if LWIP_CHECKSUM_ON_COPY
+#define netbuf_set_chksum(buf, chksum) do { (buf)->flags = NETBUF_FLAG_CHKSUM; \
+                                            (buf)->toport_chksum = chksum; } while(0)
+#endif /* LWIP_CHECKSUM_ON_COPY */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_NETCONN || LWIP_SOCKET */
+
+#endif /* LWIP_HDR_NETBUF_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/netdb.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/netdb.h
new file mode 100644
index 000000000..d3d15dfac
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/netdb.h
@@ -0,0 +1,150 @@
+/**
+ * @file
+ * NETDB API (sockets)
+ */
+
+/*
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Simon Goldschmidt
+ *
+ */
+#ifndef LWIP_HDR_NETDB_H
+#define LWIP_HDR_NETDB_H
+
+#include "lwip/opt.h"
+
+#if LWIP_DNS && LWIP_SOCKET
+
+#include "lwip/arch.h"
+#include "lwip/inet.h"
+#include "lwip/sockets.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* some rarely used options */
+#ifndef LWIP_DNS_API_DECLARE_H_ERRNO
+#define LWIP_DNS_API_DECLARE_H_ERRNO  1
+#endif
+
+#ifndef LWIP_DNS_API_DEFINE_ERRORS
+#define LWIP_DNS_API_DEFINE_ERRORS    1
+#endif
+
+#ifndef LWIP_DNS_API_DEFINE_FLAGS
+#define LWIP_DNS_API_DEFINE_FLAGS     1
+#endif
+
+#ifndef LWIP_DNS_API_DECLARE_STRUCTS
+#define LWIP_DNS_API_DECLARE_STRUCTS  1
+#endif
+
+#if LWIP_DNS_API_DEFINE_ERRORS
+/** Errors used by the DNS API functions, h_errno can be one of them */
+#define EAI_NONAME      200
+#define EAI_SERVICE     201
+#define EAI_FAIL        202
+#define EAI_MEMORY      203
+#define EAI_FAMILY      204
+
+#define HOST_NOT_FOUND  210
+#define NO_DATA         211
+#define NO_RECOVERY     212
+#define TRY_AGAIN       213
+#endif /* LWIP_DNS_API_DEFINE_ERRORS */
+
+#if LWIP_DNS_API_DEFINE_FLAGS
+/* input flags for struct addrinfo */
+#define AI_PASSIVE      0x01
+#define AI_CANONNAME    0x02
+#define AI_NUMERICHOST  0x04
+#define AI_NUMERICSERV  0x08
+#define AI_V4MAPPED     0x10
+#define AI_ALL          0x20
+#define AI_ADDRCONFIG   0x40
+#endif /* LWIP_DNS_API_DEFINE_FLAGS */
+
+#if LWIP_DNS_API_DECLARE_STRUCTS
+struct hostent {
+    char  *h_name;      /* Official name of the host. */
+    char **h_aliases;   /* A pointer to an array of pointers to alternative host names,
+                           terminated by a null pointer. */
+    int    h_addrtype;  /* Address type. */
+    int    h_length;    /* The length, in bytes, of the address. */
+    char **h_addr_list; /* A pointer to an array of pointers to network addresses (in
+                           network byte order) for the host, terminated by a null pointer. */
+#define h_addr h_addr_list[0] /* for backward compatibility */
+};
+
+struct addrinfo {
+    int               ai_flags;      /* Input flags. */
+    int               ai_family;     /* Address family of socket. */
+    int               ai_socktype;   /* Socket type. */
+    int               ai_protocol;   /* Protocol of socket. */
+    socklen_t         ai_addrlen;    /* Length of socket address. */
+    struct sockaddr  *ai_addr;       /* Socket address of socket. */
+    char             *ai_canonname;  /* Canonical name of service location. */
+    struct addrinfo  *ai_next;       /* Pointer to next in list. */
+};
+#endif /* LWIP_DNS_API_DECLARE_STRUCTS */
+
+#define NETDB_ELEM_SIZE           (sizeof(struct addrinfo) + sizeof(struct sockaddr_storage) + DNS_MAX_NAME_LENGTH + 1)
+
+#if LWIP_DNS_API_DECLARE_H_ERRNO
+/* application accessible error code set by the DNS API functions */
+extern int h_errno;
+#endif /* LWIP_DNS_API_DECLARE_H_ERRNO*/
+
+struct hostent *lwip_gethostbyname(const char *name);
+int lwip_gethostbyname_r(const char *name, struct hostent *ret, char *buf,
+                size_t buflen, struct hostent **result, int *h_errnop);
+void lwip_freeaddrinfo(struct addrinfo *ai);
+int lwip_getaddrinfo(const char *nodename,
+       const char *servname,
+       const struct addrinfo *hints,
+       struct addrinfo **res);
+
+#if LWIP_COMPAT_SOCKETS
+/** @ingroup netdbapi */
+#define gethostbyname(name) lwip_gethostbyname(name)
+/** @ingroup netdbapi */
+#define gethostbyname_r(name, ret, buf, buflen, result, h_errnop) \
+       lwip_gethostbyname_r(name, ret, buf, buflen, result, h_errnop)
+/** @ingroup netdbapi */
+#define freeaddrinfo(addrinfo) lwip_freeaddrinfo(addrinfo)
+/** @ingroup netdbapi */
+#define getaddrinfo(nodname, servname, hints, res) \
+       lwip_getaddrinfo(nodname, servname, hints, res)
+#endif /* LWIP_COMPAT_SOCKETS */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_DNS && LWIP_SOCKET */
+
+#endif /* LWIP_HDR_NETDB_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/netif.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/netif.h
new file mode 100644
index 000000000..9f4ee1ff2
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/netif.h
@@ -0,0 +1,515 @@
+/**
+ * @file
+ * netif API (to be used from TCPIP thread)
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_NETIF_H
+#define LWIP_HDR_NETIF_H
+
+#include "lwip/opt.h"
+
+#define ENABLE_LOOPBACK (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF)
+
+#include "lwip/err.h"
+
+#include "lwip/ip_addr.h"
+
+#include "lwip/def.h"
+#include "lwip/pbuf.h"
+#include "lwip/stats.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Throughout this file, IP addresses are expected to be in
+ * the same byte order as in IP_PCB. */
+
+/** Must be the maximum of all used hardware address lengths
+    across all types of interfaces in use.
+    This does not have to be changed, normally. */
+#ifndef NETIF_MAX_HWADDR_LEN
+#define NETIF_MAX_HWADDR_LEN 6U
+#endif
+
+/**
+ * @defgroup netif_flags Flags
+ * @ingroup netif
+ * @{
+ */
+
+/** Whether the network interface is 'up'. This is
+ * a software flag used to control whether this network
+ * interface is enabled and processes traffic.
+ * It must be set by the startup code before this netif can be used
+ * (also for dhcp/autoip).
+ */
+#define NETIF_FLAG_UP           0x01U
+/** If set, the netif has broadcast capability.
+ * Set by the netif driver in its init function. */
+#define NETIF_FLAG_BROADCAST    0x02U
+/** If set, the interface has an active link
+ *  (set by the network interface driver).
+ * Either set by the netif driver in its init function (if the link
+ * is up at that time) or at a later point once the link comes up
+ * (if link detection is supported by the hardware). */
+#define NETIF_FLAG_LINK_UP      0x04U
+/** If set, the netif is an ethernet device using ARP.
+ * Set by the netif driver in its init function.
+ * Used to check input packet types and use of DHCP. */
+#define NETIF_FLAG_ETHARP       0x08U
+/** If set, the netif is an ethernet device. It might not use
+ * ARP or TCP/IP if it is used for PPPoE only.
+ */
+#define NETIF_FLAG_ETHERNET     0x10U
+/** If set, the netif has IGMP capability.
+ * Set by the netif driver in its init function. */
+#define NETIF_FLAG_IGMP         0x20U
+/** If set, the netif has MLD6 capability.
+ * Set by the netif driver in its init function. */
+#define NETIF_FLAG_MLD6         0x40U
+
+/**
+ * @}
+ */
+
+enum lwip_internal_netif_client_data_index
+{
+#if LWIP_DHCP
+   LWIP_NETIF_CLIENT_DATA_INDEX_DHCP,
+#endif
+#if LWIP_AUTOIP
+   LWIP_NETIF_CLIENT_DATA_INDEX_AUTOIP,
+#endif
+#if LWIP_IGMP
+   LWIP_NETIF_CLIENT_DATA_INDEX_IGMP,
+#endif
+#if LWIP_IPV6_MLD
+   LWIP_NETIF_CLIENT_DATA_INDEX_MLD6,
+#endif
+   LWIP_NETIF_CLIENT_DATA_INDEX_MAX
+};
+
+#if LWIP_CHECKSUM_CTRL_PER_NETIF
+#define NETIF_CHECKSUM_GEN_IP       0x0001
+#define NETIF_CHECKSUM_GEN_UDP      0x0002
+#define NETIF_CHECKSUM_GEN_TCP      0x0004
+#define NETIF_CHECKSUM_GEN_ICMP     0x0008
+#define NETIF_CHECKSUM_GEN_ICMP6    0x0010
+#define NETIF_CHECKSUM_CHECK_IP     0x0100
+#define NETIF_CHECKSUM_CHECK_UDP    0x0200
+#define NETIF_CHECKSUM_CHECK_TCP    0x0400
+#define NETIF_CHECKSUM_CHECK_ICMP   0x0800
+#define NETIF_CHECKSUM_CHECK_ICMP6  0x1000
+#define NETIF_CHECKSUM_ENABLE_ALL   0xFFFF
+#define NETIF_CHECKSUM_DISABLE_ALL  0x0000
+#endif /* LWIP_CHECKSUM_CTRL_PER_NETIF */
+
+struct netif;
+
+/** MAC Filter Actions, these are passed to a netif's igmp_mac_filter or
+ * mld_mac_filter callback function. */
+enum netif_mac_filter_action {
+  /** Delete a filter entry */
+  NETIF_DEL_MAC_FILTER = 0,
+  /** Add a filter entry */
+  NETIF_ADD_MAC_FILTER = 1
+};
+
+/** Function prototype for netif init functions. Set up flags and output/linkoutput
+ * callback functions in this function.
+ *
+ * @param netif The netif to initialize
+ */
+typedef err_t (*netif_init_fn)(struct netif *netif);
+/** Function prototype for netif->input functions. This function is saved as 'input'
+ * callback function in the netif struct. Call it when a packet has been received.
+ *
+ * @param p The received packet, copied into a pbuf
+ * @param inp The netif which received the packet
+ */
+typedef err_t (*netif_input_fn)(struct pbuf *p, struct netif *inp);
+
+#if LWIP_IPV4
+/** Function prototype for netif->output functions. Called by lwIP when a packet
+ * shall be sent. For ethernet netif, set this to 'etharp_output' and set
+ * 'linkoutput'.
+ *
+ * @param netif The netif which shall send a packet
+ * @param p The packet to send (p->payload points to IP header)
+ * @param ipaddr The IP address to which the packet shall be sent
+ */
+typedef err_t (*netif_output_fn)(struct netif *netif, struct pbuf *p,
+       const ip4_addr_t *ipaddr);
+#endif /* LWIP_IPV4*/
+
+#if LWIP_IPV6
+/** Function prototype for netif->output_ip6 functions. Called by lwIP when a packet
+ * shall be sent. For ethernet netif, set this to 'ethip6_output' and set
+ * 'linkoutput'.
+ *
+ * @param netif The netif which shall send a packet
+ * @param p The packet to send (p->payload points to IP header)
+ * @param ipaddr The IPv6 address to which the packet shall be sent
+ */
+typedef err_t (*netif_output_ip6_fn)(struct netif *netif, struct pbuf *p,
+       const ip6_addr_t *ipaddr);
+#endif /* LWIP_IPV6 */
+
+/** Function prototype for netif->linkoutput functions. Only used for ethernet
+ * netifs. This function is called by ARP when a packet shall be sent.
+ *
+ * @param netif The netif which shall send a packet
+ * @param p The packet to send (raw ethernet packet)
+ */
+typedef err_t (*netif_linkoutput_fn)(struct netif *netif, struct pbuf *p);
+/** Function prototype for netif status- or link-callback functions. */
+typedef void (*netif_status_callback_fn)(struct netif *netif);
+#if LWIP_IPV4 && LWIP_IGMP
+/** Function prototype for netif igmp_mac_filter functions */
+typedef err_t (*netif_igmp_mac_filter_fn)(struct netif *netif,
+       const ip4_addr_t *group, enum netif_mac_filter_action action);
+#endif /* LWIP_IPV4 && LWIP_IGMP */
+#if LWIP_IPV6 && LWIP_IPV6_MLD
+/** Function prototype for netif mld_mac_filter functions */
+typedef err_t (*netif_mld_mac_filter_fn)(struct netif *netif,
+       const ip6_addr_t *group, enum netif_mac_filter_action action);
+#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
+
+#if LWIP_DHCP || LWIP_AUTOIP || LWIP_IGMP || LWIP_IPV6_MLD || (LWIP_NUM_NETIF_CLIENT_DATA > 0)
+u8_t netif_alloc_client_data_id(void);
+/** @ingroup netif_cd
+ * Set client data. Obtain ID from netif_alloc_client_data_id().
+ */
+#define netif_set_client_data(netif, id, data) netif_get_client_data(netif, id) = (data)
+/** @ingroup netif_cd
+ * Get client data. Obtain ID from netif_alloc_client_data_id().
+ */
+#define netif_get_client_data(netif, id)       (netif)->client_data[(id)]
+#endif /* LWIP_DHCP || LWIP_AUTOIP || (LWIP_NUM_NETIF_CLIENT_DATA > 0) */
+
+/** Generic data structure used for all lwIP network interfaces.
+ *  The following fields should be filled in by the initialization
+ *  function for the device driver: hwaddr_len, hwaddr[], mtu, flags */
+struct netif {
+  /** pointer to next in linked list */
+  struct netif *next;
+
+#if LWIP_IPV4
+  /** IP address configuration in network byte order */
+  ip_addr_t ip_addr;
+  ip_addr_t netmask;
+  ip_addr_t gw;
+#endif /* LWIP_IPV4 */
+#if LWIP_IPV6
+  /** Array of IPv6 addresses for this netif. */
+  ip_addr_t ip6_addr[LWIP_IPV6_NUM_ADDRESSES];
+  /** The state of each IPv6 address (Tentative, Preferred, etc).
+   * @see ip6_addr.h */
+  u8_t ip6_addr_state[LWIP_IPV6_NUM_ADDRESSES];
+#if LWIP_IPV6_ADDRESS_LIFETIMES
+  /** Remaining valid and preferred lifetime of each IPv6 address, in seconds.
+   * For valid lifetimes, the special value of IP6_ADDR_LIFE_STATIC (0)
+   * indicates the address is static and has no lifetimes. */
+  u32_t ip6_addr_valid_life[LWIP_IPV6_NUM_ADDRESSES];
+  u32_t ip6_addr_pref_life[LWIP_IPV6_NUM_ADDRESSES];
+#endif /* LWIP_IPV6_ADDRESS_LIFETIMES */
+#endif /* LWIP_IPV6 */
+  /** This function is called by the network device driver
+   *  to pass a packet up the TCP/IP stack. */
+  netif_input_fn input;
+#if LWIP_IPV4
+  /** This function is called by the IP module when it wants
+   *  to send a packet on the interface. This function typically
+   *  first resolves the hardware address, then sends the packet.
+   *  For ethernet physical layer, this is usually etharp_output() */
+  netif_output_fn output;
+#endif /* LWIP_IPV4 */
+  /** This function is called by ethernet_output() when it wants
+   *  to send a packet on the interface. This function outputs
+   *  the pbuf as-is on the link medium. */
+  netif_linkoutput_fn linkoutput;
+#if LWIP_IPV6
+  /** This function is called by the IPv6 module when it wants
+   *  to send a packet on the interface. This function typically
+   *  first resolves the hardware address, then sends the packet.
+   *  For ethernet physical layer, this is usually ethip6_output() */
+  netif_output_ip6_fn output_ip6;
+#endif /* LWIP_IPV6 */
+#if LWIP_NETIF_STATUS_CALLBACK
+  /** This function is called when the netif state is set to up or down
+   */
+  netif_status_callback_fn status_callback;
+#endif /* LWIP_NETIF_STATUS_CALLBACK */
+#if LWIP_NETIF_LINK_CALLBACK
+  /** This function is called when the netif link is set to up or down
+   */
+  netif_status_callback_fn link_callback;
+#endif /* LWIP_NETIF_LINK_CALLBACK */
+#if LWIP_NETIF_REMOVE_CALLBACK
+  /** This function is called when the netif has been removed */
+  netif_status_callback_fn remove_callback;
+#endif /* LWIP_NETIF_REMOVE_CALLBACK */
+  /** This field can be set by the device driver and could point
+   *  to state information for the device. */
+  void *state;
+#ifdef netif_get_client_data
+  void* client_data[LWIP_NETIF_CLIENT_DATA_INDEX_MAX + LWIP_NUM_NETIF_CLIENT_DATA];
+#endif
+#if LWIP_IPV6_AUTOCONFIG
+  /** is this netif enabled for IPv6 autoconfiguration */
+  u8_t ip6_autoconfig_enabled;
+#endif /* LWIP_IPV6_AUTOCONFIG */
+#if LWIP_IPV6_SEND_ROUTER_SOLICIT
+  /** Number of Router Solicitation messages that remain to be sent. */
+  u8_t rs_count;
+#endif /* LWIP_IPV6_SEND_ROUTER_SOLICIT */
+#if LWIP_NETIF_HOSTNAME
+  /* the hostname for this netif, NULL is a valid value */
+  const char*  hostname;
+#endif /* LWIP_NETIF_HOSTNAME */
+#if LWIP_CHECKSUM_CTRL_PER_NETIF
+  u16_t chksum_flags;
+#endif /* LWIP_CHECKSUM_CTRL_PER_NETIF*/
+  /** maximum transfer unit (in bytes) */
+  u16_t mtu;
+  /** number of bytes used in hwaddr */
+  u8_t hwaddr_len;
+  /** link level hardware address of this interface */
+  u8_t hwaddr[NETIF_MAX_HWADDR_LEN];
+  /** flags (@see @ref netif_flags) */
+  u8_t flags;
+#if LWIP_MANAGEMENT_CHANNEL
+  u8_t using_management_channel:1;
+#endif
+  /** descriptive abbreviation */
+  char name[2];
+  /** number of this interface */
+  u8_t num;
+#if MIB2_STATS
+  /** link type (from "snmp_ifType" enum from snmp_mib2.h) */
+  u8_t link_type;
+  /** (estimate) link speed */
+  u32_t link_speed;
+  /** timestamp at last change made (up/down) */
+  u32_t ts;
+  /** counters */
+  struct stats_mib2_netif_ctrs mib2_counters;
+#endif /* MIB2_STATS */
+#if LWIP_IPV4 && LWIP_IGMP
+  /** This function could be called to add or delete an entry in the multicast
+      filter table of the ethernet MAC.*/
+  netif_igmp_mac_filter_fn igmp_mac_filter;
+#endif /* LWIP_IPV4 && LWIP_IGMP */
+#if LWIP_IPV6 && LWIP_IPV6_MLD
+  /** This function could be called to add or delete an entry in the IPv6 multicast
+      filter table of the ethernet MAC. */
+  netif_mld_mac_filter_fn mld_mac_filter;
+#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
+#if LWIP_NETIF_HWADDRHINT
+  u8_t *addr_hint;
+#endif /* LWIP_NETIF_HWADDRHINT */
+#if ENABLE_LOOPBACK
+  /* List of packets to be queued for ourselves. */
+  struct pbuf *loop_first;
+  struct pbuf *loop_last;
+#if LWIP_LOOPBACK_MAX_PBUFS
+  u16_t loop_cnt_current;
+#endif /* LWIP_LOOPBACK_MAX_PBUFS */
+#endif /* ENABLE_LOOPBACK */
+};
+
+#if LWIP_CHECKSUM_CTRL_PER_NETIF
+#define NETIF_SET_CHECKSUM_CTRL(netif, chksumflags) do { \
+  (netif)->chksum_flags = chksumflags; } while(0)
+#define IF__NETIF_CHECKSUM_ENABLED(netif, chksumflag) if (((netif) == NULL) || (((netif)->chksum_flags & (chksumflag)) != 0))
+#else /* LWIP_CHECKSUM_CTRL_PER_NETIF */
+#define NETIF_SET_CHECKSUM_CTRL(netif, chksumflags)
+#define IF__NETIF_CHECKSUM_ENABLED(netif, chksumflag)
+#endif /* LWIP_CHECKSUM_CTRL_PER_NETIF */
+
+/** The list of network interfaces. */
+extern struct netif *netif_list;
+/** The default network interface. */
+extern struct netif *netif_default;
+
+void netif_init(void);
+
+struct ip_pcb;
+
+void netif_apply_pcb(struct netif *netif, struct ip_pcb *pcb);
+
+struct netif *netif_add(struct netif *netif,
+#if LWIP_IPV4
+                        const ip4_addr_t *ipaddr, const ip4_addr_t *netmask, const ip4_addr_t *gw,
+#endif /* LWIP_IPV4 */
+                        void *state, netif_init_fn init, netif_input_fn input);
+#if LWIP_IPV4
+void netif_set_addr(struct netif *netif, const ip4_addr_t *ipaddr, const ip4_addr_t *netmask,
+                    const ip4_addr_t *gw);
+#endif /* LWIP_IPV4 */
+void netif_remove(struct netif * netif);
+
+/* Returns a network interface given its name. The name is of the form
+   "et0", where the first two letters are the "name" field in the
+   netif structure, and the digit is in the num field in the same
+   structure. */
+struct netif *netif_find(const char *name);
+
+void netif_set_default(struct netif *netif);
+
+#if LWIP_IPV4
+void netif_set_ipaddr(struct netif *netif, const ip4_addr_t *ipaddr);
+void netif_set_netmask(struct netif *netif, const ip4_addr_t *netmask);
+void netif_set_gw(struct netif *netif, const ip4_addr_t *gw);
+/** @ingroup netif_ip4 */
+#define netif_ip4_addr(netif)    ((const ip4_addr_t*)ip_2_ip4(&((netif)->ip_addr)))
+/** @ingroup netif_ip4 */
+#define netif_ip4_netmask(netif) ((const ip4_addr_t*)ip_2_ip4(&((netif)->netmask)))
+/** @ingroup netif_ip4 */
+#define netif_ip4_gw(netif)      ((const ip4_addr_t*)ip_2_ip4(&((netif)->gw)))
+/** @ingroup netif_ip4 */
+#define netif_ip_addr4(netif)    ((const ip_addr_t*)&((netif)->ip_addr))
+/** @ingroup netif_ip4 */
+#define netif_ip_netmask4(netif) ((const ip_addr_t*)&((netif)->netmask))
+/** @ingroup netif_ip4 */
+#define netif_ip_gw4(netif)      ((const ip_addr_t*)&((netif)->gw))
+#endif /* LWIP_IPV4 */
+
+void netif_set_up(struct netif *netif);
+void netif_set_down(struct netif *netif);
+/** @ingroup netif
+ * Ask if an interface is up
+ */
+#define netif_is_up(netif) (((netif)->flags & NETIF_FLAG_UP) ? (u8_t)1 : (u8_t)0)
+
+#if LWIP_NETIF_STATUS_CALLBACK
+void netif_set_status_callback(struct netif *netif, netif_status_callback_fn status_callback);
+#endif /* LWIP_NETIF_STATUS_CALLBACK */
+#if LWIP_NETIF_REMOVE_CALLBACK
+void netif_set_remove_callback(struct netif *netif, netif_status_callback_fn remove_callback);
+#endif /* LWIP_NETIF_REMOVE_CALLBACK */
+
+void netif_set_link_up(struct netif *netif);
+void netif_set_link_down(struct netif *netif);
+/** Ask if a link is up */
+#define netif_is_link_up(netif) (((netif)->flags & NETIF_FLAG_LINK_UP) ? (u8_t)1 : (u8_t)0)
+
+#if LWIP_NETIF_LINK_CALLBACK
+void netif_set_link_callback(struct netif *netif, netif_status_callback_fn link_callback);
+#endif /* LWIP_NETIF_LINK_CALLBACK */
+
+#if LWIP_NETIF_HOSTNAME
+/** @ingroup netif */
+#define netif_set_hostname(netif, name) do { if((netif) != NULL) { (netif)->hostname = name; }}while(0)
+/** @ingroup netif */
+#define netif_get_hostname(netif) (((netif) != NULL) ? ((netif)->hostname) : NULL)
+#endif /* LWIP_NETIF_HOSTNAME */
+
+#if LWIP_IGMP
+/** @ingroup netif */
+#define netif_set_igmp_mac_filter(netif, function) do { if((netif) != NULL) { (netif)->igmp_mac_filter = function; }}while(0)
+#define netif_get_igmp_mac_filter(netif) (((netif) != NULL) ? ((netif)->igmp_mac_filter) : NULL)
+#endif /* LWIP_IGMP */
+
+#if LWIP_IPV6 && LWIP_IPV6_MLD
+/** @ingroup netif */
+#define netif_set_mld_mac_filter(netif, function) do { if((netif) != NULL) { (netif)->mld_mac_filter = function; }}while(0)
+#define netif_get_mld_mac_filter(netif) (((netif) != NULL) ? ((netif)->mld_mac_filter) : NULL)
+#define netif_mld_mac_filter(netif, addr, action) do { if((netif) && (netif)->mld_mac_filter) { (netif)->mld_mac_filter((netif), (addr), (action)); }}while(0)
+#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
+
+#if ENABLE_LOOPBACK
+err_t netif_loop_output(struct netif *netif, struct pbuf *p);
+void netif_poll(struct netif *netif);
+#if !LWIP_NETIF_LOOPBACK_MULTITHREADING
+void netif_poll_all(void);
+#endif /* !LWIP_NETIF_LOOPBACK_MULTITHREADING */
+#endif /* ENABLE_LOOPBACK */
+
+err_t netif_input(struct pbuf *p, struct netif *inp);
+
+#if LWIP_IPV6
+/** @ingroup netif_ip6 */
+#define netif_ip_addr6(netif, i)  ((const ip_addr_t*)(&((netif)->ip6_addr[i])))
+/** @ingroup netif_ip6 */
+#define netif_ip6_addr(netif, i)  ((const ip6_addr_t*)ip_2_ip6(&((netif)->ip6_addr[i])))
+void netif_ip6_addr_set(struct netif *netif, s8_t addr_idx, const ip6_addr_t *addr6);
+void netif_ip6_addr_set_parts(struct netif *netif, s8_t addr_idx, u32_t i0, u32_t i1, u32_t i2, u32_t i3);
+#define netif_ip6_addr_state(netif, i)  ((netif)->ip6_addr_state[i])
+void netif_ip6_addr_set_state(struct netif* netif, s8_t addr_idx, u8_t state);
+s8_t netif_get_ip6_addr_match(struct netif *netif, const ip6_addr_t *ip6addr);
+void netif_create_ip6_linklocal_address(struct netif *netif, u8_t from_mac_48bit);
+err_t netif_add_ip6_address(struct netif *netif, const ip6_addr_t *ip6addr, s8_t *chosen_idx);
+err_t netif_add_ip6_address_with_route(struct netif *netif, ip6_addr_t *ip6addr, 
+                                       u8_t prefix_len, s8_t *chosen_idx);
+err_t netif_remove_ip6_address(struct netif *netif, ip6_addr_t *ip6addr);
+err_t netif_remove_ip6_address_with_route(struct netif *netif, ip6_addr_t *ip6addr, 
+                                          u8_t prefix_len);
+#define netif_set_ip6_autoconfig_enabled(netif, action) do { if(netif) { (netif)->ip6_autoconfig_enabled = (action); }}while(0)
+#if LWIP_IPV6_ADDRESS_LIFETIMES
+#define netif_ip6_addr_valid_life(netif, i)  \
+    (((netif) != NULL) ? ((netif)->ip6_addr_valid_life[i]) : IP6_ADDR_LIFE_STATIC)
+#define netif_ip6_addr_set_valid_life(netif, i, secs) \
+    do { if (netif != NULL) { (netif)->ip6_addr_valid_life[i] = (secs); }} while (0)
+#define netif_ip6_addr_pref_life(netif, i)  \
+    (((netif) != NULL) ? ((netif)->ip6_addr_pref_life[i]) : IP6_ADDR_LIFE_STATIC)
+#define netif_ip6_addr_set_pref_life(netif, i, secs) \
+    do { if (netif != NULL) { (netif)->ip6_addr_pref_life[i] = (secs); }} while (0)
+#define netif_ip6_addr_isstatic(netif, i)  \
+    (netif_ip6_addr_valid_life((netif), (i)) == IP6_ADDR_LIFE_STATIC)
+#else /* !LWIP_IPV6_ADDRESS_LIFETIMES */
+#define netif_ip6_addr_isstatic(netif, i)  (1) /* all addresses are static */
+#endif /* !LWIP_IPV6_ADDRESS_LIFETIMES */
+#endif /* LWIP_IPV6 */
+
+#if LWIP_NETIF_HWADDRHINT
+#define NETIF_SET_HWADDRHINT(netif, hint) ((netif)->addr_hint = (hint))
+#else /* LWIP_NETIF_HWADDRHINT */
+#define NETIF_SET_HWADDRHINT(netif, hint)
+#endif /* LWIP_NETIF_HWADDRHINT */
+
+u8_t netif_name_to_index(const char *name);
+char * netif_index_to_name(u8_t idx, char *name);
+struct netif* netif_get_by_index(u8_t index);
+
+/* Interface indexes always start at 1 per RFC 3493, section 4, num starts at 0 */
+#define netif_get_index(netif)      ((netif)->num + 1)
+#define NETIF_NO_INDEX              (0)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_NETIF_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/netifapi.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/netifapi.h
new file mode 100644
index 000000000..79369c281
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/netifapi.h
@@ -0,0 +1,154 @@
+/**
+ * @file
+ * netif API (to be used from non-TCPIP threads)
+ */
+
+/*
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ */
+#ifndef LWIP_HDR_NETIFAPI_H
+#define LWIP_HDR_NETIFAPI_H
+
+#include "lwip/opt.h"
+
+#if LWIP_NETIF_API /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/sys.h"
+#include "lwip/netif.h"
+#include "lwip/dhcp.h"
+#include "lwip/autoip.h"
+#include "lwip/if.h"
+#include "lwip/priv/tcpip_priv.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_MPU_COMPATIBLE
+#define NETIFAPI_IPADDR_DEF(type, m)  type m
+#else /* LWIP_MPU_COMPATIBLE */
+#define NETIFAPI_IPADDR_DEF(type, m)  const type * m
+#endif /* LWIP_MPU_COMPATIBLE */
+
+typedef void (*netifapi_void_fn)(struct netif *netif);
+typedef err_t (*netifapi_errt_fn)(struct netif *netif);
+
+struct netifapi_msg {
+  struct tcpip_api_call_data call;
+  struct netif *netif;
+  union {
+    struct {
+#if LWIP_IPV4
+      NETIFAPI_IPADDR_DEF(ip4_addr_t, ipaddr);
+      NETIFAPI_IPADDR_DEF(ip4_addr_t, netmask);
+      NETIFAPI_IPADDR_DEF(ip4_addr_t, gw);
+#endif /* LWIP_IPV4 */
+      void *state;
+      netif_init_fn init;
+      netif_input_fn input;
+    } add;
+    struct {
+      netifapi_void_fn voidfunc;
+      netifapi_errt_fn errtfunc;
+    } common;
+    struct {
+#if LWIP_MPU_COMPATIBLE
+      char name[IF_NAMESIZE];
+#else /* LWIP_MPU_COMPATIBLE */
+      char *name;
+#endif /* LWIP_MPU_COMPATIBLE */
+      u8_t index;
+    } ifs;
+  } msg;
+};
+
+
+/* API for application */
+err_t netifapi_netif_add(struct netif *netif,
+#if LWIP_IPV4
+                         const ip4_addr_t *ipaddr, const ip4_addr_t *netmask, const ip4_addr_t *gw,
+#endif /* LWIP_IPV4 */
+                         void *state, netif_init_fn init, netif_input_fn input);
+
+#if LWIP_IPV4
+err_t netifapi_netif_set_addr(struct netif *netif, const ip4_addr_t *ipaddr,
+                              const ip4_addr_t *netmask, const ip4_addr_t *gw);
+#endif /* LWIP_IPV4*/
+
+err_t netifapi_netif_common(struct netif *netif, netifapi_void_fn voidfunc,
+                            netifapi_errt_fn errtfunc);
+
+/** @ingroup netifapi_netif */
+err_t netifapi_netif_name_to_index(const char *name, u8_t *index);
+/** @ingroup netifapi_netif */
+err_t netifapi_netif_index_to_name(u8_t index, char *name);
+
+/** @ingroup netifapi_netif */
+#define netifapi_netif_remove(n)        netifapi_netif_common(n, netif_remove, NULL)
+/** @ingroup netifapi_netif */
+#define netifapi_netif_set_up(n)        netifapi_netif_common(n, netif_set_up, NULL)
+/** @ingroup netifapi_netif */
+#define netifapi_netif_set_down(n)      netifapi_netif_common(n, netif_set_down, NULL)
+/** @ingroup netifapi_netif */
+#define netifapi_netif_set_default(n)   netifapi_netif_common(n, netif_set_default, NULL)
+/** @ingroup netifapi_netif */
+#define netifapi_netif_set_link_up(n)   netifapi_netif_common(n, netif_set_link_up, NULL)
+/** @ingroup netifapi_netif */
+#define netifapi_netif_set_link_down(n) netifapi_netif_common(n, netif_set_link_down, NULL)
+
+/**
+ * @defgroup netifapi_dhcp4 DHCPv4
+ * @ingroup netifapi
+ * To be called from non-TCPIP threads
+ */
+/** @ingroup netifapi_dhcp4 */
+#define netifapi_dhcp_start(n)        netifapi_netif_common(n, NULL, dhcp_start)
+/** @ingroup netifapi_dhcp4 */
+#define netifapi_dhcp_stop(n)         netifapi_netif_common(n, dhcp_stop, NULL)
+/** @ingroup netifapi_dhcp4 */
+#define netifapi_dhcp_inform(n)       netifapi_netif_common(n, dhcp_inform, NULL)
+/** @ingroup netifapi_dhcp4 */
+#define netifapi_dhcp_renew(n)        netifapi_netif_common(n, NULL, dhcp_renew)
+/** @ingroup netifapi_dhcp4 */
+#define netifapi_dhcp_release(n)      netifapi_netif_common(n, NULL, dhcp_release)
+
+/**
+ * @defgroup netifapi_autoip AUTOIP
+ * @ingroup netifapi
+ * To be called from non-TCPIP threads
+ */
+/** @ingroup netifapi_autoip */
+#define netifapi_autoip_start(n)      netifapi_netif_common(n, NULL, autoip_start)
+/** @ingroup netifapi_autoip */
+#define netifapi_autoip_stop(n)       netifapi_netif_common(n, NULL, autoip_stop)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_NETIF_API */
+
+#endif /* LWIP_HDR_NETIFAPI_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/opt.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/opt.h
new file mode 100644
index 000000000..0c97ebd0c
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/opt.h
@@ -0,0 +1,3014 @@
+/**
+ * @file
+ *
+ * lwIP Options Configuration
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+/*
+ * NOTE: || defined __DOXYGEN__ is a workaround for doxygen bug -
+ * without this, doxygen does not see the actual #define
+ */
+
+#if !defined LWIP_HDR_OPT_H
+#define LWIP_HDR_OPT_H
+
+/*
+ * Include user defined options first. Anything not defined in these files
+ * will be set to standard values. Override anything you don't like!
+ */
+#include "lwipopts.h"
+#include "lwip/debug.h"
+
+/**
+ * @defgroup lwip_opts Options (lwipopts.h)
+ * @ingroup lwip
+ *
+ * @defgroup lwip_opts_debug Debugging
+ * @ingroup lwip_opts
+ *
+ * @defgroup lwip_opts_infrastructure Infrastructure
+ * @ingroup lwip_opts
+ *
+ * @defgroup lwip_opts_callback Callback-style APIs
+ * @ingroup lwip_opts
+ *
+ * @defgroup lwip_opts_threadsafe_apis Thread-safe APIs
+ * @ingroup lwip_opts
+ */
+
+ /*
+   ------------------------------------
+   -------------- NO SYS --------------
+   ------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_nosys NO_SYS
+ * @ingroup lwip_opts_infrastructure
+ * @{
+ */
+/**
+ * NO_SYS==1: Use lwIP without OS-awareness (no thread, semaphores, mutexes or
+ * mboxes). This means threaded APIs cannot be used (socket, netconn,
+ * i.e. everything in the 'api' folder), only the callback-style raw API is
+ * available (and you have to watch out for yourself that you don't access
+ * lwIP functions/structures from more than one context at a time!)
+ */
+#if !defined NO_SYS || defined __DOXYGEN__
+#define NO_SYS                          0
+#endif
+/**
+ * @}
+ */
+
+/**
+ * @defgroup lwip_opts_timers Timers
+ * @ingroup lwip_opts_infrastructure
+ * @{
+ */
+/**
+ * LWIP_TIMERS==0: Drop support for sys_timeout and lwip-internal cyclic timers.
+ * (the array of lwip-internal cyclic timers is still provided)
+ * (check NO_SYS_NO_TIMERS for compatibility to old versions)
+ */
+#if !defined LWIP_TIMERS || defined __DOXYGEN__
+#ifdef NO_SYS_NO_TIMERS
+#define LWIP_TIMERS                     (!NO_SYS || (NO_SYS && !NO_SYS_NO_TIMERS))
+#else
+#define LWIP_TIMERS                     1
+#endif
+#endif
+
+/**
+ * LWIP_TIMERS_CUSTOM==1: Provide your own timer implementation.
+ * Function prototypes in timeouts.h and the array of lwip-internal cyclic timers
+ * are still included, but the implementation is not. The following functions
+ * will be required: sys_timeouts_init(), sys_timeout(), sys_untimeout(),
+ *                   sys_timeouts_mbox_fetch()
+ */
+#if !defined LWIP_TIMERS_CUSTOM || defined __DOXYGEN__
+#define LWIP_TIMERS_CUSTOM              0
+#endif
+/**
+ * @}
+ */
+
+/**
+ * @defgroup lwip_opts_memcpy memcpy
+ * @ingroup lwip_opts_infrastructure
+ * @{
+ */
+/**
+ * MEMCPY: override this if you have a faster implementation at hand than the
+ * one included in your C library
+ */
+#if !defined MEMCPY || defined __DOXYGEN__
+#define MEMCPY(dst,src,len)             memcpy(dst,src,len)
+#endif
+
+/**
+ * SMEMCPY: override this with care! Some compilers (e.g. gcc) can inline a
+ * call to memcpy() if the length is known at compile time and is small.
+ */
+#if !defined SMEMCPY || defined __DOXYGEN__
+#define SMEMCPY(dst,src,len)            memcpy(dst,src,len)
+#endif
+/**
+ * @}
+ */
+
+/*
+   ------------------------------------
+   ----------- Core locking -----------
+   ------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_lock Core locking and MPU
+ * @ingroup lwip_opts_infrastructure
+ * @{
+ */
+/**
+ * LWIP_MPU_COMPATIBLE: enables special memory management mechanism
+ * which makes lwip able to work on MPU (Memory Protection Unit) system
+ * by not passing stack-pointers to other threads
+ * (this decreases performance as memory is allocated from pools instead
+ * of keeping it on the stack)
+ */
+#if !defined LWIP_MPU_COMPATIBLE || defined __DOXYGEN__
+#define LWIP_MPU_COMPATIBLE             0
+#endif
+
+/**
+ * LWIP_TCPIP_CORE_LOCKING
+ * Creates a global mutex that is held during TCPIP thread operations.
+ * Can be locked by client code to perform lwIP operations without changing
+ * into TCPIP thread using callbacks. See LOCK_TCPIP_CORE() and
+ * UNLOCK_TCPIP_CORE().
+ * Your system should provide mutexes supporting priority inversion to use this.
+ */
+#if !defined LWIP_TCPIP_CORE_LOCKING || defined __DOXYGEN__
+#define LWIP_TCPIP_CORE_LOCKING         1
+#endif
+
+/**
+ * LWIP_TCPIP_CORE_LOCKING_INPUT: when LWIP_TCPIP_CORE_LOCKING is enabled,
+ * this lets tcpip_input() grab the mutex for input packets as well,
+ * instead of allocating a message and passing it to tcpip_thread.
+ *
+ * ATTENTION: this does not work when tcpip_input() is called from
+ * interrupt context!
+ */
+#if !defined LWIP_TCPIP_CORE_LOCKING_INPUT || defined __DOXYGEN__
+#define LWIP_TCPIP_CORE_LOCKING_INPUT   0
+#endif
+
+/**
+ * SYS_LIGHTWEIGHT_PROT==1: enable inter-task protection (and task-vs-interrupt
+ * protection) for certain critical regions during buffer allocation, deallocation
+ * and memory allocation and deallocation.
+ * ATTENTION: This is required when using lwIP from more than one context! If
+ * you disable this, you must be sure what you are doing!
+ */
+#if !defined SYS_LIGHTWEIGHT_PROT || defined __DOXYGEN__
+#define SYS_LIGHTWEIGHT_PROT            1
+#endif
+
+/**
+ * LWIP_ASSERT_CORE_LOCKED: Macro to check whether lwIP's threading/locking
+ * requirements are satisfied during current function call.
+ * This macro usually calls a function that is implemented in the OS-dependent
+ * sys layer and performs the following checks:
+ * - Not in ISR
+ * - If LWIP_TCPIP_CORE_LOCKING=1: TCPIP core lock is held
+ * - If LWIP_TCPIP_CORE_LOCKING=0: function is called from TCPIP thread
+ */
+#if !defined LWIP_ASSERT_CORE_LOCKED || defined __DOXYGEN__
+#define LWIP_ASSERT_CORE_LOCKED()
+#endif
+
+/**
+ * Called as first thing in the lwIP TCPIP thread. Can be used in conjunction
+ * with LWIP_ASSERT_CORE_LOCKED to check core locking.
+ */
+#if !defined LWIP_MARK_TCPIP_THREAD || defined __DOXYGEN__
+#define LWIP_MARK_TCPIP_THREAD()
+#endif
+/**
+ * @}
+ */
+
+/*
+   ------------------------------------
+   ---------- Memory options ----------
+   ------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_mem Heap and memory pools
+ * @ingroup lwip_opts_infrastructure
+ * @{
+ */
+/**
+ * MEM_LIBC_MALLOC==1: Use malloc/free/realloc provided by your C-library
+ * instead of the lwip internal allocator. Can save code size if you
+ * already use it.
+ */
+#if !defined MEM_LIBC_MALLOC || defined __DOXYGEN__
+#define MEM_LIBC_MALLOC                 0
+#endif
+
+/**
+ * MEMP_MEM_MALLOC==1: Use mem_malloc/mem_free instead of the lwip pool allocator.
+ * Especially useful with MEM_LIBC_MALLOC but handle with care regarding execution
+ * speed (heap alloc can be much slower than pool alloc) and usage from interrupts
+ * (especially if your netif driver allocates PBUF_POOL pbufs for received frames
+ * from interrupt)!
+ * ATTENTION: Currently, this uses the heap for ALL pools (also for private pools,
+ * not only for internal pools defined in memp_std.h)!
+ */
+#if !defined MEMP_MEM_MALLOC || defined __DOXYGEN__
+#define MEMP_MEM_MALLOC                 0
+#endif
+
+/**
+ * MEM_ALIGNMENT: should be set to the alignment of the CPU
+ *    4 byte alignment -> \#define MEM_ALIGNMENT 4
+ *    2 byte alignment -> \#define MEM_ALIGNMENT 2
+ */
+#if !defined MEM_ALIGNMENT || defined __DOXYGEN__
+#define MEM_ALIGNMENT                   1
+#endif
+
+/**
+ * MEM_SIZE: the size of the heap memory. If the application will send
+ * a lot of data that needs to be copied, this should be set high.
+ */
+#if !defined MEM_SIZE || defined __DOXYGEN__
+#define MEM_SIZE                        1600
+#endif
+
+/**
+ * MEMP_OVERFLOW_CHECK: memp overflow protection reserves a configurable
+ * amount of bytes before and after each memp element in every pool and fills
+ * it with a prominent default value.
+ *    MEMP_OVERFLOW_CHECK == 0 no checking
+ *    MEMP_OVERFLOW_CHECK == 1 checks each element when it is freed
+ *    MEMP_OVERFLOW_CHECK >= 2 checks each element in every pool every time
+ *      memp_malloc() or memp_free() is called (useful but slow!)
+ */
+#if !defined MEMP_OVERFLOW_CHECK || defined __DOXYGEN__
+#define MEMP_OVERFLOW_CHECK             0
+#endif
+
+/**
+ * MEMP_SANITY_CHECK==1: run a sanity check after each memp_free() to make
+ * sure that there are no cycles in the linked lists.
+ */
+#if !defined MEMP_SANITY_CHECK || defined __DOXYGEN__
+#define MEMP_SANITY_CHECK               0
+#endif
+
+/**
+ * MEM_USE_POOLS==1: Use an alternative to malloc() by allocating from a set
+ * of memory pools of various sizes. When mem_malloc is called, an element of
+ * the smallest pool that can provide the length needed is returned.
+ * To use this, MEMP_USE_CUSTOM_POOLS also has to be enabled.
+ */
+#if !defined MEM_USE_POOLS || defined __DOXYGEN__
+#define MEM_USE_POOLS                   0
+#endif
+
+/**
+ * MEM_USE_POOLS_TRY_BIGGER_POOL==1: if one malloc-pool is empty, try the next
+ * bigger pool - WARNING: THIS MIGHT WASTE MEMORY but it can make a system more
+ * reliable. */
+#if !defined MEM_USE_POOLS_TRY_BIGGER_POOL || defined __DOXYGEN__
+#define MEM_USE_POOLS_TRY_BIGGER_POOL   0
+#endif
+
+/**
+ * MEMP_USE_CUSTOM_POOLS==1: whether to include a user file lwippools.h
+ * that defines additional pools beyond the "standard" ones required
+ * by lwIP. If you set this to 1, you must have lwippools.h in your
+ * include path somewhere.
+ */
+#if !defined MEMP_USE_CUSTOM_POOLS || defined __DOXYGEN__
+#define MEMP_USE_CUSTOM_POOLS           0
+#endif
+
+/**
+ * Set this to 1 if you want to free PBUF_RAM pbufs (or call mem_free()) from
+ * interrupt context (or another context that doesn't allow waiting for a
+ * semaphore).
+ * If set to 1, mem_malloc will be protected by a semaphore and SYS_ARCH_PROTECT,
+ * while mem_free will only use SYS_ARCH_PROTECT. mem_malloc SYS_ARCH_UNPROTECTs
+ * with each loop so that mem_free can run.
+ *
+ * ATTENTION: As you can see from the above description, this leads to dis-/
+ * enabling interrupts often, which can be slow! Also, on low memory, mem_malloc
+ * can need longer.
+ *
+ * If you don't want that, at least for NO_SYS=0, you can still use the following
+ * functions to enqueue a deallocation call which then runs in the tcpip_thread
+ * context:
+ * - pbuf_free_callback(p);
+ * - mem_free_callback(m);
+ */
+#if !defined LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT || defined __DOXYGEN__
+#define LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT 0
+#endif
+/**
+ * @}
+ */
+
+/*
+   ------------------------------------------------
+   ---------- Internal Memory Pool Sizes ----------
+   ------------------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_memp Internal memory pools
+ * @ingroup lwip_opts_infrastructure
+ * @{
+ */
+/**
+ * MEMP_NUM_PBUF: the number of memp struct pbufs (used for PBUF_ROM and PBUF_REF).
+ * If the application sends a lot of data out of ROM (or other static memory),
+ * this should be set high.
+ */
+#if !defined MEMP_NUM_PBUF || defined __DOXYGEN__
+#define MEMP_NUM_PBUF                   16
+#endif
+
+/**
+ * MEMP_NUM_RAW_PCB: Number of raw connection PCBs
+ * (requires the LWIP_RAW option)
+ */
+#if !defined MEMP_NUM_RAW_PCB || defined __DOXYGEN__
+#define MEMP_NUM_RAW_PCB                4
+#endif
+
+/**
+ * MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
+ * per active UDP "connection".
+ * (requires the LWIP_UDP option)
+ */
+#if !defined MEMP_NUM_UDP_PCB || defined __DOXYGEN__
+#define MEMP_NUM_UDP_PCB                4
+#endif
+
+/**
+ * MEMP_NUM_TCP_PCB: the number of simultaneously active TCP connections.
+ * (requires the LWIP_TCP option)
+ */
+#if !defined MEMP_NUM_TCP_PCB || defined __DOXYGEN__
+#define MEMP_NUM_TCP_PCB                5
+#endif
+
+/**
+ * MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP connections.
+ * (requires the LWIP_TCP option)
+ */
+#if !defined MEMP_NUM_TCP_PCB_LISTEN || defined __DOXYGEN__
+#define MEMP_NUM_TCP_PCB_LISTEN         8
+#endif
+
+/**
+ * MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP segments.
+ * (requires the LWIP_TCP option)
+ */
+#if !defined MEMP_NUM_TCP_SEG || defined __DOXYGEN__
+#define MEMP_NUM_TCP_SEG                16
+#endif
+
+/**
+ * MEMP_NUM_REASSDATA: the number of IP packets simultaneously queued for
+ * reassembly (whole packets, not fragments!)
+ */
+#if !defined MEMP_NUM_REASSDATA || defined __DOXYGEN__
+#define MEMP_NUM_REASSDATA              5
+#endif
+
+/**
+ * MEMP_NUM_FRAG_PBUF: the number of IP fragments simultaneously sent
+ * (fragments, not whole packets!).
+ * This is only used with LWIP_NETIF_TX_SINGLE_PBUF==0 and only has to be > 1
+ * with DMA-enabled MACs where the packet is not yet sent when netif->output
+ * returns.
+ */
+#if !defined MEMP_NUM_FRAG_PBUF || defined __DOXYGEN__
+#define MEMP_NUM_FRAG_PBUF              15
+#endif
+
+/**
+ * MEMP_NUM_ARP_QUEUE: the number of simultaneously queued outgoing
+ * packets (pbufs) that are waiting for an ARP request (to resolve
+ * their destination address) to finish.
+ * (requires the ARP_QUEUEING option)
+ */
+#if !defined MEMP_NUM_ARP_QUEUE || defined __DOXYGEN__
+#define MEMP_NUM_ARP_QUEUE              30
+#endif
+
+/**
+ * MEMP_NUM_IGMP_GROUP: The number of multicast groups whose network interfaces
+ * can be members at the same time (one per netif - allsystems group -, plus one
+ * per netif membership).
+ * (requires the LWIP_IGMP option)
+ */
+#if !defined MEMP_NUM_IGMP_GROUP || defined __DOXYGEN__
+#define MEMP_NUM_IGMP_GROUP             8
+#endif
+
+/**
+ * MEMP_NUM_SYS_TIMEOUT: the number of simultaneously active timeouts.
+ * The default number of timeouts is calculated here for all enabled modules.
+ * The formula expects settings to be either '0' or '1'.
+ */
+#if !defined MEMP_NUM_SYS_TIMEOUT || defined __DOXYGEN__
+#define MEMP_NUM_SYS_TIMEOUT            (LWIP_TCP + IP_REASSEMBLY + LWIP_ARP + (2*LWIP_DHCP) + LWIP_AUTOIP + LWIP_IGMP + LWIP_DNS + (PPP_SUPPORT*6*MEMP_NUM_PPP_PCB) + (LWIP_IPV6 ? (1 + LWIP_IPV6_REASS + LWIP_IPV6_MLD) : 0))
+#endif
+
+/**
+ * MEMP_NUM_NETBUF: the number of struct netbufs.
+ * (only needed if you use the sequential API, like api_lib.c)
+ */
+#if !defined MEMP_NUM_NETBUF || defined __DOXYGEN__
+#define MEMP_NUM_NETBUF                 2
+#endif
+
+/**
+ * MEMP_NUM_NETCONN: the number of struct netconns.
+ * (only needed if you use the sequential API, like api_lib.c)
+ */
+#if !defined MEMP_NUM_NETCONN || defined __DOXYGEN__
+#define MEMP_NUM_NETCONN                4
+#endif
+
+/**
+ * MEMP_NUM_TCPIP_MSG_API: the number of struct tcpip_msg, which are used
+ * for callback/timeout API communication.
+ * (only needed if you use tcpip.c)
+ */
+#if !defined MEMP_NUM_TCPIP_MSG_API || defined __DOXYGEN__
+#define MEMP_NUM_TCPIP_MSG_API          8
+#endif
+
+/**
+ * MEMP_NUM_TCPIP_MSG_INPKT: the number of struct tcpip_msg, which are used
+ * for incoming packets.
+ * (only needed if you use tcpip.c)
+ */
+#if !defined MEMP_NUM_TCPIP_MSG_INPKT || defined __DOXYGEN__
+#define MEMP_NUM_TCPIP_MSG_INPKT        8
+#endif
+
+/**
+ * MEMP_NUM_NETDB: the number of concurrently running lwip_addrinfo() calls
+ * (before freeing the corresponding memory using lwip_freeaddrinfo()).
+ */
+#if !defined MEMP_NUM_NETDB || defined __DOXYGEN__
+#define MEMP_NUM_NETDB                  1
+#endif
+
+/**
+ * MEMP_NUM_LOCALHOSTLIST: the number of host entries in the local host list
+ * if DNS_LOCAL_HOSTLIST_IS_DYNAMIC==1.
+ */
+#if !defined MEMP_NUM_LOCALHOSTLIST || defined __DOXYGEN__
+#define MEMP_NUM_LOCALHOSTLIST          1
+#endif
+
+/**
+ * PBUF_POOL_SIZE: the number of buffers in the pbuf pool.
+ */
+#if !defined PBUF_POOL_SIZE || defined __DOXYGEN__
+#define PBUF_POOL_SIZE                  16
+#endif
+
+/** MEMP_NUM_API_MSG: the number of concurrently active calls to various
+ * socket, netconn, and tcpip functions
+ */
+#if !defined MEMP_NUM_API_MSG || defined __DOXYGEN__
+#define MEMP_NUM_API_MSG                MEMP_NUM_TCPIP_MSG_API
+#endif
+
+/** MEMP_NUM_DNS_API_MSG: the number of concurrently active calls to netconn_gethostbyname
+ */
+#if !defined MEMP_NUM_DNS_API_MSG || defined __DOXYGEN__
+#define MEMP_NUM_DNS_API_MSG            MEMP_NUM_TCPIP_MSG_API
+#endif
+
+/** MEMP_NUM_SOCKET_SETGETSOCKOPT_DATA: the number of concurrently active calls
+ * to getsockopt/setsockopt
+ */
+#if !defined MEMP_NUM_SOCKET_SETGETSOCKOPT_DATA || defined __DOXYGEN__
+#define MEMP_NUM_SOCKET_SETGETSOCKOPT_DATA MEMP_NUM_TCPIP_MSG_API
+#endif
+
+/** MEMP_NUM_NETIFAPI_MSG: the number of concurrently active calls to the
+ * netifapi functions
+ */
+#if !defined MEMP_NUM_NETIFAPI_MSG || defined __DOXYGEN__
+#define MEMP_NUM_NETIFAPI_MSG           MEMP_NUM_TCPIP_MSG_API
+#endif
+/**
+ * @}
+ */
+
+/*
+   ---------------------------------
+   ---------- ARP options ----------
+   ---------------------------------
+*/
+/**
+ * @defgroup lwip_opts_arp ARP
+ * @ingroup lwip_opts_ipv4
+ * @{
+ */
+/**
+ * LWIP_ARP==1: Enable ARP functionality.
+ */
+#if !defined LWIP_ARP || defined __DOXYGEN__
+#define LWIP_ARP                        1
+#endif
+
+/**
+ * ARP_TABLE_SIZE: Number of active MAC-IP address pairs cached.
+ */
+#if !defined ARP_TABLE_SIZE || defined __DOXYGEN__
+#define ARP_TABLE_SIZE                  10
+#endif
+
+/** the time an ARP entry stays valid after its last update,
+ *  for ARP_TMR_INTERVAL = 1000, this is
+ *  (60 * 5) seconds = 5 minutes.
+ */
+#if !defined ARP_MAXAGE || defined __DOXYGEN__
+#define ARP_MAXAGE                      300
+#endif
+
+/**
+ * ARP_QUEUEING==1: Multiple outgoing packets are queued during hardware address
+ * resolution. By default, only the most recent packet is queued per IP address.
+ * This is sufficient for most protocols and mainly reduces TCP connection
+ * startup time. Set this to 1 if you know your application sends more than one
+ * packet in a row to an IP address that is not in the ARP cache.
+ */
+#if !defined ARP_QUEUEING || defined __DOXYGEN__
+#define ARP_QUEUEING                    0
+#endif
+
+/** The maximum number of packets which may be queued for each
+ *  unresolved address by other network layers. Defaults to 3, 0 means disabled.
+ *  Old packets are dropped, new packets are queued.
+ */
+#if !defined ARP_QUEUE_LEN || defined __DOXYGEN__
+#define ARP_QUEUE_LEN                   3
+#endif
+
+/**
+ * ETHARP_SUPPORT_VLAN==1: support receiving and sending ethernet packets with
+ * VLAN header. See the description of LWIP_HOOK_VLAN_CHECK and
+ * LWIP_HOOK_VLAN_SET hooks to check/set VLAN headers.
+ * Additionally, you can define ETHARP_VLAN_CHECK to an u16_t VLAN ID to check.
+ * If ETHARP_VLAN_CHECK is defined, only VLAN-traffic for this VLAN is accepted.
+ * If ETHARP_VLAN_CHECK is not defined, all traffic is accepted.
+ * Alternatively, define a function/define ETHARP_VLAN_CHECK_FN(eth_hdr, vlan)
+ * that returns 1 to accept a packet or 0 to drop a packet.
+ */
+#if !defined ETHARP_SUPPORT_VLAN || defined __DOXYGEN__
+#define ETHARP_SUPPORT_VLAN             0
+#endif
+
+/** LWIP_ETHERNET==1: enable ethernet support even though ARP might be disabled
+ */
+#if !defined LWIP_ETHERNET || defined __DOXYGEN__
+#define LWIP_ETHERNET                   LWIP_ARP
+#endif
+
+/** ETH_PAD_SIZE: number of bytes added before the ethernet header to ensure
+ * alignment of payload after that header. Since the header is 14 bytes long,
+ * without this padding e.g. addresses in the IP header will not be aligned
+ * on a 32-bit boundary, so setting this to 2 can speed up 32-bit-platforms.
+ */
+#if !defined ETH_PAD_SIZE || defined __DOXYGEN__
+#define ETH_PAD_SIZE                    0
+#endif
+
+/** ETHARP_SUPPORT_STATIC_ENTRIES==1: enable code to support static ARP table
+ * entries (using etharp_add_static_entry/etharp_remove_static_entry).
+ */
+#if !defined ETHARP_SUPPORT_STATIC_ENTRIES || defined __DOXYGEN__
+#define ETHARP_SUPPORT_STATIC_ENTRIES   0
+#endif
+
+/** ETHARP_TABLE_MATCH_NETIF==1: Match netif for ARP table entries.
+ * If disabled, duplicate IP address on multiple netifs are not supported
+ * (but this should only occur for AutoIP).
+ */
+#if !defined ETHARP_TABLE_MATCH_NETIF || defined __DOXYGEN__
+#define ETHARP_TABLE_MATCH_NETIF        0
+#endif
+/**
+ * @}
+ */
+
+/*
+   --------------------------------
+   ---------- IP options ----------
+   --------------------------------
+*/
+/**
+ * @defgroup lwip_opts_ipv4 IPv4
+ * @ingroup lwip_opts
+ * @{
+ */
+/**
+ * LWIP_IPV4==1: Enable IPv4
+ */
+#if !defined LWIP_IPV4 || defined __DOXYGEN__
+#define LWIP_IPV4                       1
+#endif
+
+/**
+ * IP_FORWARD==1: Enables the ability to forward IP packets across network
+ * interfaces. If you are going to run lwIP on a device with only one network
+ * interface, define this to 0.
+ */
+#if !defined IP_FORWARD || defined __DOXYGEN__
+#define IP_FORWARD                      0
+#endif
+
+/**
+ * IP_REASSEMBLY==1: Reassemble incoming fragmented IP packets. Note that
+ * this option does not affect outgoing packet sizes, which can be controlled
+ * via IP_FRAG.
+ */
+#if !defined IP_REASSEMBLY || defined __DOXYGEN__
+#define IP_REASSEMBLY                   1
+#endif
+
+/**
+ * IP_FRAG==1: Fragment outgoing IP packets if their size exceeds MTU. Note
+ * that this option does not affect incoming packet sizes, which can be
+ * controlled via IP_REASSEMBLY.
+ */
+#if !defined IP_FRAG || defined __DOXYGEN__
+#define IP_FRAG                         1
+#endif
+
+#if !LWIP_IPV4
+/* disable IPv4 extensions when IPv4 is disabled */
+#undef IP_FORWARD
+#define IP_FORWARD                      0
+#undef IP_REASSEMBLY
+#define IP_REASSEMBLY                   0
+#undef IP_FRAG
+#define IP_FRAG                         0
+#endif /* !LWIP_IPV4 */
+
+/**
+ * IP_OPTIONS_ALLOWED: Defines the behavior for IP options.
+ *      IP_OPTIONS_ALLOWED==0: All packets with IP options are dropped.
+ *      IP_OPTIONS_ALLOWED==1: IP options are allowed (but not parsed).
+ */
+#if !defined IP_OPTIONS_ALLOWED || defined __DOXYGEN__
+#define IP_OPTIONS_ALLOWED              1
+#endif
+
+/**
+ * IP_REASS_MAXAGE: Maximum time (in multiples of IP_TMR_INTERVAL - so seconds, normally)
+ * a fragmented IP packet waits for all fragments to arrive. If not all fragments arrived
+ * in this time, the whole packet is discarded.
+ */
+#if !defined IP_REASS_MAXAGE || defined __DOXYGEN__
+#define IP_REASS_MAXAGE                 3
+#endif
+
+/**
+ * IP_REASS_MAX_PBUFS: Total maximum amount of pbufs waiting to be reassembled.
+ * Since the received pbufs are enqueued, be sure to configure
+ * PBUF_POOL_SIZE > IP_REASS_MAX_PBUFS so that the stack is still able to receive
+ * packets even if the maximum amount of fragments is enqueued for reassembly!
+ */
+#if !defined IP_REASS_MAX_PBUFS || defined __DOXYGEN__
+#define IP_REASS_MAX_PBUFS              10
+#endif
+
+/**
+ * IP_DEFAULT_TTL: Default value for Time-To-Live used by transport layers.
+ */
+#if !defined IP_DEFAULT_TTL || defined __DOXYGEN__
+#define IP_DEFAULT_TTL                  255
+#endif
+
+/**
+ * IP_SOF_BROADCAST=1: Use the SOF_BROADCAST field to enable broadcast
+ * filter per pcb on udp and raw send operations. To enable broadcast filter
+ * on recv operations, you also have to set IP_SOF_BROADCAST_RECV=1.
+ */
+#if !defined IP_SOF_BROADCAST || defined __DOXYGEN__
+#define IP_SOF_BROADCAST                0
+#endif
+
+/**
+ * IP_SOF_BROADCAST_RECV (requires IP_SOF_BROADCAST=1) enable the broadcast
+ * filter on recv operations.
+ */
+#if !defined IP_SOF_BROADCAST_RECV || defined __DOXYGEN__
+#define IP_SOF_BROADCAST_RECV           0
+#endif
+
+/**
+ * IP_FORWARD_ALLOW_TX_ON_RX_NETIF==1: allow ip_forward() to send packets back
+ * out on the netif where it was received. This should only be used for
+ * wireless networks.
+ * ATTENTION: When this is 1, make sure your netif driver correctly marks incoming
+ * link-layer-broadcast/multicast packets as such using the corresponding pbuf flags!
+ */
+#if !defined IP_FORWARD_ALLOW_TX_ON_RX_NETIF || defined __DOXYGEN__
+#define IP_FORWARD_ALLOW_TX_ON_RX_NETIF 0
+#endif
+
+/**
+ * LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS==1: randomize the local port for the first
+ * local TCP/UDP pcb (default==0). This can prevent creating predictable port
+ * numbers after booting a device.
+ */
+#if !defined LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS || defined __DOXYGEN__
+#define LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS 0
+#endif
+/**
+ * @}
+ */
+
+/*
+   ----------------------------------
+   ---------- ICMP options ----------
+   ----------------------------------
+*/
+/**
+ * @defgroup lwip_opts_icmp ICMP
+ * @ingroup lwip_opts_ipv4
+ * @{
+ */
+/**
+ * LWIP_ICMP==1: Enable ICMP module inside the IP stack.
+ * Be careful, disable that make your product non-compliant to RFC1122
+ */
+#if !defined LWIP_ICMP || defined __DOXYGEN__
+#define LWIP_ICMP                       1
+#endif
+
+/**
+ * ICMP_TTL: Default value for Time-To-Live used by ICMP packets.
+ */
+#if !defined ICMP_TTL || defined __DOXYGEN__
+#define ICMP_TTL                       (IP_DEFAULT_TTL)
+#endif
+
+/**
+ * LWIP_BROADCAST_PING==1: respond to broadcast pings (default is unicast only)
+ */
+#if !defined LWIP_BROADCAST_PING || defined __DOXYGEN__
+#define LWIP_BROADCAST_PING             0
+#endif
+
+/**
+ * LWIP_MULTICAST_PING==1: respond to multicast pings (default is unicast only)
+ */
+#if !defined LWIP_MULTICAST_PING || defined __DOXYGEN__
+#define LWIP_MULTICAST_PING             0
+#endif
+/**
+ * @}
+ */
+
+/*
+   ---------------------------------
+   ---------- RAW options ----------
+   ---------------------------------
+*/
+/**
+ * @defgroup lwip_opts_raw RAW
+ * @ingroup lwip_opts_callback
+ * @{
+ */
+/**
+ * LWIP_RAW==1: Enable application layer to hook into the IP layer itself.
+ */
+#if !defined LWIP_RAW || defined __DOXYGEN__
+#define LWIP_RAW                        0
+#endif
+
+/**
+ * LWIP_RAW==1: Enable application layer to hook into the IP layer itself.
+ */
+#if !defined RAW_TTL || defined __DOXYGEN__
+#define RAW_TTL                        (IP_DEFAULT_TTL)
+#endif
+/**
+ * @}
+ */
+
+/*
+   ----------------------------------
+   ---------- DHCP options ----------
+   ----------------------------------
+*/
+/**
+ * @defgroup lwip_opts_dhcp DHCP
+ * @ingroup lwip_opts_ipv4
+ * @{
+ */
+/**
+ * LWIP_DHCP==1: Enable DHCP module.
+ */
+#if !defined LWIP_DHCP || defined __DOXYGEN__
+#define LWIP_DHCP                       0
+#endif
+#if !LWIP_IPV4
+/* disable DHCP when IPv4 is disabled */
+#undef LWIP_DHCP
+#define LWIP_DHCP                       0
+#endif /* !LWIP_IPV4 */
+
+/**
+ * DHCP_DOES_ARP_CHECK==1: Do an ARP check on the offered address.
+ */
+#if !defined DHCP_DOES_ARP_CHECK || defined __DOXYGEN__
+#define DHCP_DOES_ARP_CHECK             ((LWIP_DHCP) && (LWIP_ARP))
+#endif
+
+/**
+ * LWIP_DHCP_CHECK_LINK_UP==1: dhcp_start() only really starts if the netif has
+ * NETIF_FLAG_LINK_UP set in its flags. As this is only an optimization and
+ * netif drivers might not set this flag, the default is off. If enabled,
+ * netif_set_link_up() must be called to continue dhcp starting.
+ */
+#if !defined LWIP_DHCP_CHECK_LINK_UP
+#define LWIP_DHCP_CHECK_LINK_UP         0
+#endif
+
+/**
+ * LWIP_DHCP_BOOTP_FILE==1: Store offered_si_addr and boot_file_name.
+ */
+#if !defined LWIP_DHCP_BOOTP_FILE || defined __DOXYGEN__
+#define LWIP_DHCP_BOOTP_FILE            0
+#endif
+
+/**
+ * LWIP_DHCP_GETS_NTP==1: Request NTP servers with discover/select. For each
+ * response packet, an callback is called, which has to be provided by the port:
+ * void dhcp_set_ntp_servers(u8_t num_ntp_servers, ip_addr_t* ntp_server_addrs);
+*/
+#if !defined LWIP_DHCP_GET_NTP_SRV || defined __DOXYGEN__
+#define LWIP_DHCP_GET_NTP_SRV           0
+#endif
+
+/**
+ * The maximum of NTP servers requested
+ */
+#if !defined LWIP_DHCP_MAX_NTP_SERVERS || defined __DOXYGEN__
+#define LWIP_DHCP_MAX_NTP_SERVERS       1
+#endif
+
+/**
+ * LWIP_DHCP_MAX_DNS_SERVERS > 0: Request DNS servers with discover/select.
+ * DHCP servers received in the response are passed to DNS via @ref dns_setserver()
+ * (up to the maximum limit defined here).
+ */
+#if !defined LWIP_DHCP_MAX_DNS_SERVERS || defined __DOXYGEN__
+#define LWIP_DHCP_MAX_DNS_SERVERS       DNS_MAX_SERVERS
+#endif
+/**
+ * @}
+ */
+
+/*
+   ------------------------------------
+   ---------- AUTOIP options ----------
+   ------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_autoip AUTOIP
+ * @ingroup lwip_opts_ipv4
+ * @{
+ */
+/**
+ * LWIP_AUTOIP==1: Enable AUTOIP module.
+ */
+#if !defined LWIP_AUTOIP || defined __DOXYGEN__
+#define LWIP_AUTOIP                     0
+#endif
+#if !LWIP_IPV4
+/* disable AUTOIP when IPv4 is disabled */
+#undef LWIP_AUTOIP
+#define LWIP_AUTOIP                     0
+#endif /* !LWIP_IPV4 */
+
+/**
+ * LWIP_DHCP_AUTOIP_COOP==1: Allow DHCP and AUTOIP to be both enabled on
+ * the same interface at the same time.
+ */
+#if !defined LWIP_DHCP_AUTOIP_COOP || defined __DOXYGEN__
+#define LWIP_DHCP_AUTOIP_COOP           0
+#endif
+
+/**
+ * LWIP_DHCP_AUTOIP_COOP_TRIES: Set to the number of DHCP DISCOVER probes
+ * that should be sent before falling back on AUTOIP (the DHCP client keeps
+ * running in this case). This can be set as low as 1 to get an AutoIP address
+ * very  quickly, but you should be prepared to handle a changing IP address
+ * when DHCP overrides AutoIP.
+ */
+#if !defined LWIP_DHCP_AUTOIP_COOP_TRIES || defined __DOXYGEN__
+#define LWIP_DHCP_AUTOIP_COOP_TRIES     9
+#endif
+/**
+ * @}
+ */
+
+/*
+   ----------------------------------
+   ----- SNMP MIB2 support      -----
+   ----------------------------------
+*/
+/**
+ * @defgroup lwip_opts_mib2 SNMP MIB2 callbacks
+ * @ingroup lwip_opts_infrastructure
+ * @{
+ */
+/**
+ * LWIP_MIB2_CALLBACKS==1: Turn on SNMP MIB2 callbacks.
+ * Turn this on to get callbacks needed to implement MIB2.
+ * Usually MIB2_STATS should be enabled, too.
+ */
+#if !defined LWIP_MIB2_CALLBACKS || defined __DOXYGEN__
+#define LWIP_MIB2_CALLBACKS             0
+#endif
+/**
+ * @}
+ */
+
+/*
+   ----------------------------------
+   -------- Multicast options -------
+   ----------------------------------
+*/
+/**
+ * @defgroup lwip_opts_multicast Multicast
+ * @ingroup lwip_opts_infrastructure
+ * @{
+ */
+/**
+ * LWIP_MULTICAST_TX_OPTIONS==1: Enable multicast TX support like the socket options
+ * IP_MULTICAST_TTL/IP_MULTICAST_IF/IP_MULTICAST_LOOP, as well as (currently only)
+ * core support for the corresponding IPv6 options.
+ */
+#if !defined LWIP_MULTICAST_TX_OPTIONS || defined __DOXYGEN__
+#define LWIP_MULTICAST_TX_OPTIONS       ((LWIP_IGMP || LWIP_IPV6_MLD) && (LWIP_UDP || LWIP_RAW))
+#endif
+/**
+ * @}
+ */
+
+/*
+   ----------------------------------
+   ---------- IGMP options ----------
+   ----------------------------------
+*/
+/**
+ * @defgroup lwip_opts_igmp IGMP
+ * @ingroup lwip_opts_ipv4
+ * @{
+ */
+/**
+ * LWIP_IGMP==1: Turn on IGMP module.
+ */
+#if !defined LWIP_IGMP || defined __DOXYGEN__
+#define LWIP_IGMP                       0
+#endif
+#if !LWIP_IPV4
+#undef LWIP_IGMP
+#define LWIP_IGMP                       0
+#endif
+/**
+ * @}
+ */
+
+/*
+   ----------------------------------
+   ---------- DNS options -----------
+   ----------------------------------
+*/
+/**
+ * @defgroup lwip_opts_dns DNS
+ * @ingroup lwip_opts_callback
+ * @{
+ */
+/**
+ * LWIP_DNS==1: Turn on DNS module. UDP must be available for DNS
+ * transport.
+ */
+#if !defined LWIP_DNS || defined __DOXYGEN__
+#define LWIP_DNS                        0
+#endif
+
+/**
+ * LWIP_DNS_RAND_ID==1: Runs on the fix for CVE-2014-4883
+ * Randomizes the id of dns requests.
+ * This should be on for security purposes
+ */
+#ifndef LWIP_DNS_RAND_ID
+#define LWIP_DNS_RAND_ID                1
+#endif
+
+/** DNS maximum number of entries to maintain locally. */
+#if !defined DNS_TABLE_SIZE || defined __DOXYGEN__
+#define DNS_TABLE_SIZE                  4
+#endif
+
+/** DNS maximum host name length supported in the name table. */
+#if !defined DNS_MAX_NAME_LENGTH || defined __DOXYGEN__
+#define DNS_MAX_NAME_LENGTH             256
+#endif
+
+/** The maximum of DNS servers
+ * The first server can be initialized automatically by defining
+ * DNS_SERVER_ADDRESS(ipaddr), where 'ipaddr' is an 'ip_addr_t*'
+ */
+#if !defined DNS_MAX_SERVERS || defined __DOXYGEN__
+#define DNS_MAX_SERVERS                 2
+#endif
+
+/** DNS do a name checking between the query and the response. */
+#if !defined DNS_DOES_NAME_CHECK || defined __DOXYGEN__
+#define DNS_DOES_NAME_CHECK             1
+#endif
+
+/** LWIP_DNS_SECURE: controls the security level of the DNS implementation
+ * Use all DNS security features by default.
+ * This is overridable but should only be needed by very small targets
+ * or when using against non standard DNS servers. */
+#if !defined LWIP_DNS_SECURE || defined __DOXYGEN__
+#define LWIP_DNS_SECURE (LWIP_DNS_SECURE_RAND_XID | LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING | LWIP_DNS_SECURE_RAND_SRC_PORT)
+#endif
+
+/* A list of DNS security features follows */
+#define LWIP_DNS_SECURE_RAND_XID                1
+#define LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING 2
+#define LWIP_DNS_SECURE_RAND_SRC_PORT           4
+
+/** DNS_LOCAL_HOSTLIST: Implements a local host-to-address list. If enabled, you have to define an initializer:
+ *  \#define DNS_LOCAL_HOSTLIST_INIT {DNS_LOCAL_HOSTLIST_ELEM("host_ip4", IPADDR4_INIT_BYTES(1,2,3,4)), \
+ *                                    DNS_LOCAL_HOSTLIST_ELEM("host_ip6", IPADDR6_INIT_HOST(123, 234, 345, 456)}
+ *
+ *  Instead, you can also use an external function:
+ *  \#define DNS_LOOKUP_LOCAL_EXTERN(x) extern err_t my_lookup_function(const char *name, ip_addr_t *addr, u8_t dns_addrtype)
+ *  that looks up the IP address and returns ERR_OK if found (LWIP_DNS_ADDRTYPE_xxx is passed in dns_addrtype).
+ */
+#if !defined DNS_LOCAL_HOSTLIST || defined __DOXYGEN__
+#define DNS_LOCAL_HOSTLIST              0
+#endif /* DNS_LOCAL_HOSTLIST */
+
+/** If this is turned on, the local host-list can be dynamically changed
+ *  at runtime. */
+#if !defined DNS_LOCAL_HOSTLIST_IS_DYNAMIC || defined __DOXYGEN__
+#define DNS_LOCAL_HOSTLIST_IS_DYNAMIC   0
+#endif /* DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
+
+/** Set this to 1 to enable querying ".local" names via mDNS
+ *  using a One-Shot Multicast DNS Query */
+#if !defined LWIP_DNS_SUPPORT_MDNS_QUERIES || defined __DOXYGEN__
+#define LWIP_DNS_SUPPORT_MDNS_QUERIES  0
+#endif
+
+/** DNS message max. size. Default value is RFC compliant. */
+#ifndef DNS_MSG_SIZE
+#define DNS_MSG_SIZE                    512
+#endif
+
+/** DNS maximum addresses per host name supported in the name table. */
+#if !defined DNS_MAX_ADDRS_PER_NAME || defined __DOXYGEN__
+#define DNS_MAX_ADDRS_PER_NAME          4
+#endif
+/**
+ * @}
+ */
+
+/*
+   ---------------------------------
+   ---------- UDP options ----------
+   ---------------------------------
+*/
+/**
+ * @defgroup lwip_opts_udp UDP
+ * @ingroup lwip_opts_callback
+ * @{
+ */
+/**
+ * LWIP_UDP==1: Turn on UDP.
+ */
+#if !defined LWIP_UDP || defined __DOXYGEN__
+#define LWIP_UDP                        1
+#endif
+
+/**
+ * LWIP_UDPLITE==1: Turn on UDP-Lite. (Requires LWIP_UDP)
+ */
+#if !defined LWIP_UDPLITE || defined __DOXYGEN__
+#define LWIP_UDPLITE                    0
+#endif
+
+/**
+ * UDP_TTL: Default Time-To-Live value.
+ */
+#if !defined UDP_TTL || defined __DOXYGEN__
+#define UDP_TTL                         (IP_DEFAULT_TTL)
+#endif
+
+/**
+ * LWIP_NETBUF_RECVINFO==1: append destination addr and port to every netbuf.
+ */
+#if !defined LWIP_NETBUF_RECVINFO || defined __DOXYGEN__
+#define LWIP_NETBUF_RECVINFO            0
+#endif
+/**
+ * @}
+ */
+
+/*
+   ---------------------------------
+   ---------- TCP options ----------
+   ---------------------------------
+*/
+/**
+ * @defgroup lwip_opts_tcp TCP
+ * @ingroup lwip_opts_callback
+ * @{
+ */
+/**
+ * LWIP_TCP==1: Turn on TCP.
+ */
+#if !defined LWIP_TCP || defined __DOXYGEN__
+#define LWIP_TCP                        1
+#endif
+
+/**
+ * TCP_TTL: Default Time-To-Live value.
+ */
+#if !defined TCP_TTL || defined __DOXYGEN__
+#define TCP_TTL                         (IP_DEFAULT_TTL)
+#endif
+
+/**
+ * TCP_WND: The size of a TCP window.  This must be at least
+ * (2 * TCP_MSS) for things to work well.
+ * ATTENTION: when using TCP_RCV_SCALE, TCP_WND is the total size
+ * with scaling applied. Maximum window value in the TCP header
+ * will be TCP_WND >> TCP_RCV_SCALE
+ */
+#if !defined TCP_WND || defined __DOXYGEN__
+#define TCP_WND                         (4 * TCP_MSS)
+#endif
+
+/**
+ * TCP_MAXRTX: Maximum number of retransmissions of data segments.
+ */
+#if !defined TCP_MAXRTX || defined __DOXYGEN__
+#define TCP_MAXRTX                      12
+#endif
+
+/**
+ * TCP_SYNMAXRTX: Maximum number of retransmissions of SYN segments.
+ */
+#if !defined TCP_SYNMAXRTX || defined __DOXYGEN__
+#define TCP_SYNMAXRTX                   6
+#endif
+
+/**
+ * TCP_QUEUE_OOSEQ==1: TCP will queue segments that arrive out of order.
+ * Define to 0 if your device is low on memory.
+ */
+#if !defined TCP_QUEUE_OOSEQ || defined __DOXYGEN__
+#define TCP_QUEUE_OOSEQ                 (LWIP_TCP)
+#endif
+
+/**
+ * TCP_MSS: TCP Maximum segment size. (default is 536, a conservative default,
+ * you might want to increase this.)
+ * For the receive side, this MSS is advertised to the remote side
+ * when opening a connection. For the transmit size, this MSS sets
+ * an upper limit on the MSS advertised by the remote host.
+ */
+#if !defined TCP_MSS || defined __DOXYGEN__
+#define TCP_MSS                         536
+#endif
+
+/**
+ * TCP_CALCULATE_EFF_SEND_MSS: "The maximum size of a segment that TCP really
+ * sends, the 'effective send MSS,' MUST be the smaller of the send MSS (which
+ * reflects the available reassembly buffer size at the remote host) and the
+ * largest size permitted by the IP layer" (RFC 1122)
+ * Setting this to 1 enables code that checks TCP_MSS against the MTU of the
+ * netif used for a connection and limits the MSS if it would be too big otherwise.
+ */
+#if !defined TCP_CALCULATE_EFF_SEND_MSS || defined __DOXYGEN__
+#define TCP_CALCULATE_EFF_SEND_MSS      1
+#endif
+
+
+/**
+ * TCP_SND_BUF: TCP sender buffer space (bytes).
+ * To achieve good performance, this should be at least 2 * TCP_MSS.
+ */
+#if !defined TCP_SND_BUF || defined __DOXYGEN__
+#define TCP_SND_BUF                     (2 * TCP_MSS)
+#endif
+
+/**
+ * TCP_SND_QUEUELEN: TCP sender buffer space (pbufs). This must be at least
+ * as much as (2 * TCP_SND_BUF/TCP_MSS) for things to work.
+ */
+#if !defined TCP_SND_QUEUELEN || defined __DOXYGEN__
+#define TCP_SND_QUEUELEN                ((4 * (TCP_SND_BUF) + (TCP_MSS - 1))/(TCP_MSS))
+#endif
+
+/**
+ * TCP_SNDLOWAT: TCP writable space (bytes). This must be less than
+ * TCP_SND_BUF. It is the amount of space which must be available in the
+ * TCP snd_buf for select to return writable (combined with TCP_SNDQUEUELOWAT).
+ */
+#if !defined TCP_SNDLOWAT || defined __DOXYGEN__
+#define TCP_SNDLOWAT                    LWIP_MIN(LWIP_MAX(((TCP_SND_BUF)/2), (2 * TCP_MSS) + 1), (TCP_SND_BUF) - 1)
+#endif
+
+/**
+ * TCP_SNDQUEUELOWAT: TCP writable bufs (pbuf count). This must be less
+ * than TCP_SND_QUEUELEN. If the number of pbufs queued on a pcb drops below
+ * this number, select returns writable (combined with TCP_SNDLOWAT).
+ */
+#if !defined TCP_SNDQUEUELOWAT || defined __DOXYGEN__
+#define TCP_SNDQUEUELOWAT               LWIP_MAX(((TCP_SND_QUEUELEN)/2), 5)
+#endif
+
+/**
+ * TCP_OOSEQ_MAX_BYTES: The maximum number of bytes queued on ooseq per pcb.
+ * Default is 0 (no limit). Only valid for TCP_QUEUE_OOSEQ==1.
+ */
+#if !defined TCP_OOSEQ_MAX_BYTES || defined __DOXYGEN__
+#define TCP_OOSEQ_MAX_BYTES             0
+#endif
+
+/**
+ * TCP_OOSEQ_MAX_PBUFS: The maximum number of pbufs queued on ooseq per pcb.
+ * Default is 0 (no limit). Only valid for TCP_QUEUE_OOSEQ==1.
+ */
+#if !defined TCP_OOSEQ_MAX_PBUFS || defined __DOXYGEN__
+#define TCP_OOSEQ_MAX_PBUFS             0
+#endif
+
+/**
+ * TCP_LISTEN_BACKLOG: Enable the backlog option for tcp listen pcb.
+ */
+#if !defined TCP_LISTEN_BACKLOG || defined __DOXYGEN__
+#define TCP_LISTEN_BACKLOG              0
+#endif
+
+/**
+ * The maximum allowed backlog for TCP listen netconns.
+ * This backlog is used unless another is explicitly specified.
+ * 0xff is the maximum (u8_t).
+ */
+#if !defined TCP_DEFAULT_LISTEN_BACKLOG || defined __DOXYGEN__
+#define TCP_DEFAULT_LISTEN_BACKLOG      0xff
+#endif
+
+/**
+ * TCP_OVERSIZE: The maximum number of bytes that tcp_write may
+ * allocate ahead of time in an attempt to create shorter pbuf chains
+ * for transmission. The meaningful range is 0 to TCP_MSS. Some
+ * suggested values are:
+ *
+ * 0:         Disable oversized allocation. Each tcp_write() allocates a new
+              pbuf (old behaviour).
+ * 1:         Allocate size-aligned pbufs with minimal excess. Use this if your
+ *            scatter-gather DMA requires aligned fragments.
+ * 128:       Limit the pbuf/memory overhead to 20%.
+ * TCP_MSS:   Try to create unfragmented TCP packets.
+ * TCP_MSS/4: Try to create 4 fragments or less per TCP packet.
+ */
+#if !defined TCP_OVERSIZE || defined __DOXYGEN__
+#define TCP_OVERSIZE                    TCP_MSS
+#endif
+
+/**
+ * LWIP_TCP_TIMESTAMPS==1: support the TCP timestamp option.
+ * The timestamp option is currently only used to help remote hosts, it is not
+ * really used locally. Therefore, it is only enabled when a TS option is
+ * received in the initial SYN packet from a remote host.
+ */
+#if !defined LWIP_TCP_TIMESTAMPS || defined __DOXYGEN__
+#define LWIP_TCP_TIMESTAMPS             0
+#endif
+
+/**
+ * TCP_WND_UPDATE_THRESHOLD: difference in window to trigger an
+ * explicit window update
+ */
+#if !defined TCP_WND_UPDATE_THRESHOLD || defined __DOXYGEN__
+#define TCP_WND_UPDATE_THRESHOLD   LWIP_MIN((TCP_WND / 4), (TCP_MSS * 4))
+#endif
+
+/**
+ * LWIP_EVENT_API and LWIP_CALLBACK_API: Only one of these should be set to 1.
+ *     LWIP_EVENT_API==1: The user defines lwip_tcp_event() to receive all
+ *         events (accept, sent, etc) that happen in the system.
+ *     LWIP_CALLBACK_API==1: The PCB callback function is called directly
+ *         for the event. This is the default.
+ */
+#if !defined(LWIP_EVENT_API) && !defined(LWIP_CALLBACK_API) || defined __DOXYGEN__
+#define LWIP_EVENT_API                  0
+#define LWIP_CALLBACK_API               1
+#else
+#ifndef LWIP_EVENT_API
+#define LWIP_EVENT_API                  0
+#endif
+#ifndef LWIP_CALLBACK_API
+#define LWIP_CALLBACK_API               0
+#endif
+#endif
+
+/**
+ * LWIP_WND_SCALE and TCP_RCV_SCALE:
+ * Set LWIP_WND_SCALE to 1 to enable window scaling.
+ * Set TCP_RCV_SCALE to the desired scaling factor (shift count in the
+ * range of [0..14]).
+ * When LWIP_WND_SCALE is enabled but TCP_RCV_SCALE is 0, we can use a large
+ * send window while having a small receive window only.
+ */
+#if !defined LWIP_WND_SCALE || defined __DOXYGEN__
+#define LWIP_WND_SCALE                  0
+#define TCP_RCV_SCALE                   0
+#endif
+/**
+ * @}
+ */
+
+/*
+   ----------------------------------
+   ---------- Pbuf options ----------
+   ----------------------------------
+*/
+/**
+ * @defgroup lwip_opts_pbuf PBUF
+ * @ingroup lwip_opts
+ * @{
+ */
+/**
+ * PBUF_LINK_HLEN: the number of bytes that should be allocated for a
+ * link level header. The default is 14, the standard value for
+ * Ethernet.
+ */
+#if !defined PBUF_LINK_HLEN || defined __DOXYGEN__
+#if defined LWIP_HOOK_VLAN_SET && !defined __DOXYGEN__
+#define PBUF_LINK_HLEN                  (18 + ETH_PAD_SIZE)
+#else /* LWIP_HOOK_VLAN_SET */
+#define PBUF_LINK_HLEN                  (14 + ETH_PAD_SIZE)
+#endif /* LWIP_HOOK_VLAN_SET */
+#endif
+
+/**
+ * PBUF_LINK_ENCAPSULATION_HLEN: the number of bytes that should be allocated
+ * for an additional encapsulation header before ethernet headers (e.g. 802.11)
+ */
+#if !defined PBUF_LINK_ENCAPSULATION_HLEN || defined __DOXYGEN__
+#define PBUF_LINK_ENCAPSULATION_HLEN    0u
+#endif
+
+/**
+ * PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. The default is
+ * designed to accommodate single full size TCP frame in one pbuf, including
+ * TCP_MSS, IP header, and link header.
+ */
+#if !defined PBUF_POOL_BUFSIZE || defined __DOXYGEN__
+#define PBUF_POOL_BUFSIZE               LWIP_MEM_ALIGN_SIZE(TCP_MSS+40+PBUF_LINK_ENCAPSULATION_HLEN+PBUF_LINK_HLEN)
+#endif
+/**
+ * @}
+ */
+
+/*
+   ------------------------------------------------
+   ---------- Network Interfaces options ----------
+   ------------------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_netif NETIF
+ * @ingroup lwip_opts
+ * @{
+ */
+/**
+ * LWIP_NETIF_HOSTNAME==1: use DHCP_OPTION_HOSTNAME with netif's hostname
+ * field.
+ */
+#if !defined LWIP_NETIF_HOSTNAME || defined __DOXYGEN__
+#define LWIP_NETIF_HOSTNAME             0
+#endif
+
+/**
+ * LWIP_NETIF_API==1: Support netif api (in netifapi.c)
+ */
+#if !defined LWIP_NETIF_API || defined __DOXYGEN__
+#define LWIP_NETIF_API                  0
+#endif
+
+/**
+ * LWIP_NETIF_STATUS_CALLBACK==1: Support a callback function whenever an interface
+ * changes its up/down status (i.e., due to DHCP IP acquisition)
+ */
+#if !defined LWIP_NETIF_STATUS_CALLBACK || defined __DOXYGEN__
+#define LWIP_NETIF_STATUS_CALLBACK      0
+#endif
+
+/**
+ * LWIP_NETIF_LINK_CALLBACK==1: Support a callback function from an interface
+ * whenever the link changes (i.e., link down)
+ */
+#if !defined LWIP_NETIF_LINK_CALLBACK || defined __DOXYGEN__
+#define LWIP_NETIF_LINK_CALLBACK        0
+#endif
+
+/**
+ * LWIP_NETIF_REMOVE_CALLBACK==1: Support a callback function that is called
+ * when a netif has been removed
+ */
+#if !defined LWIP_NETIF_REMOVE_CALLBACK || defined __DOXYGEN__
+#define LWIP_NETIF_REMOVE_CALLBACK      0
+#endif
+
+/**
+ * LWIP_NETIF_HWADDRHINT==1: Cache link-layer-address hints (e.g. table
+ * indices) in struct netif. TCP and UDP can make use of this to prevent
+ * scanning the ARP table for every sent packet. While this is faster for big
+ * ARP tables or many concurrent connections, it might be counterproductive
+ * if you have a tiny ARP table or if there never are concurrent connections.
+ */
+#if !defined LWIP_NETIF_HWADDRHINT || defined __DOXYGEN__
+#define LWIP_NETIF_HWADDRHINT           0
+#endif
+
+/**
+ * LWIP_NETIF_TX_SINGLE_PBUF: if this is set to 1, lwIP tries to put all data
+ * to be sent into one single pbuf. This is for compatibility with DMA-enabled
+ * MACs that do not support scatter-gather.
+ * Beware that this might involve CPU-memcpy before transmitting that would not
+ * be needed without this flag! Use this only if you need to!
+ *
+ * @todo: TCP and IP-frag do not work with this, yet:
+ */
+#if !defined LWIP_NETIF_TX_SINGLE_PBUF || defined __DOXYGEN__
+#define LWIP_NETIF_TX_SINGLE_PBUF             0
+#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
+
+/**
+ * LWIP_NUM_NETIF_CLIENT_DATA: Number of clients that may store
+ * data in client_data member array of struct netif.
+ */
+#if !defined LWIP_NUM_NETIF_CLIENT_DATA || defined __DOXYGEN__
+#define LWIP_NUM_NETIF_CLIENT_DATA            0
+#endif
+/**
+ * @}
+ */
+
+#ifndef LWIP_MANAGEMENT_CHANNEL
+#define LWIP_MANAGEMENT_CHANNEL    0
+#endif
+
+/*
+   ------------------------------------
+   ---------- LOOPIF options ----------
+   ------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_loop Loopback interface
+ * @ingroup lwip_opts_netif
+ * @{
+ */
+/**
+ * LWIP_HAVE_LOOPIF==1: Support loop interface (127.0.0.1).
+ * This is only needed when no real netifs are available. If at least one other
+ * netif is available, loopback traffic uses this netif.
+ */
+#if !defined LWIP_HAVE_LOOPIF || defined __DOXYGEN__
+#define LWIP_HAVE_LOOPIF                LWIP_NETIF_LOOPBACK
+#endif
+
+/**
+ * LWIP_LOOPIF_MULTICAST==1: Support multicast/IGMP on loop interface (127.0.0.1).
+ */
+#if !defined LWIP_LOOPIF_MULTICAST || defined __DOXYGEN__
+#define LWIP_LOOPIF_MULTICAST               0
+#endif
+
+/**
+ * LWIP_NETIF_LOOPBACK==1: Support sending packets with a destination IP
+ * address equal to the netif IP address, looping them back up the stack.
+ */
+#if !defined LWIP_NETIF_LOOPBACK || defined __DOXYGEN__
+#define LWIP_NETIF_LOOPBACK             0
+#endif
+
+/**
+ * LWIP_LOOPBACK_MAX_PBUFS: Maximum number of pbufs on queue for loopback
+ * sending for each netif (0 = disabled)
+ */
+#if !defined LWIP_LOOPBACK_MAX_PBUFS || defined __DOXYGEN__
+#define LWIP_LOOPBACK_MAX_PBUFS         0
+#endif
+
+/**
+ * LWIP_NETIF_LOOPBACK_MULTITHREADING: Indicates whether threading is enabled in
+ * the system, as netifs must change how they behave depending on this setting
+ * for the LWIP_NETIF_LOOPBACK option to work.
+ * Setting this is needed to avoid reentering non-reentrant functions like
+ * tcp_input().
+ *    LWIP_NETIF_LOOPBACK_MULTITHREADING==1: Indicates that the user is using a
+ *       multithreaded environment like tcpip.c. In this case, netif->input()
+ *       is called directly.
+ *    LWIP_NETIF_LOOPBACK_MULTITHREADING==0: Indicates a polling (or NO_SYS) setup.
+ *       The packets are put on a list and netif_poll() must be called in
+ *       the main application loop.
+ */
+#if !defined LWIP_NETIF_LOOPBACK_MULTITHREADING || defined __DOXYGEN__
+#define LWIP_NETIF_LOOPBACK_MULTITHREADING    (!NO_SYS)
+#endif
+/**
+ * @}
+ */
+
+/*
+   ------------------------------------
+   ---------- Thread options ----------
+   ------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_thread Threading
+ * @ingroup lwip_opts_infrastructure
+ * @{
+ */
+/**
+ * TCPIP_THREAD_NAME: The name assigned to the main tcpip thread.
+ */
+#if !defined TCPIP_THREAD_NAME || defined __DOXYGEN__
+#define TCPIP_THREAD_NAME              "tcpip_thread"
+#endif
+
+/**
+ * TCPIP_THREAD_STACKSIZE: The stack size used by the main tcpip thread.
+ * The stack size value itself is platform-dependent, but is passed to
+ * sys_thread_new() when the thread is created.
+ */
+#if !defined TCPIP_THREAD_STACKSIZE || defined __DOXYGEN__
+#define TCPIP_THREAD_STACKSIZE          0
+#endif
+
+/**
+ * TCPIP_THREAD_PRIO: The priority assigned to the main tcpip thread.
+ * The priority value itself is platform-dependent, but is passed to
+ * sys_thread_new() when the thread is created.
+ */
+#if !defined TCPIP_THREAD_PRIO || defined __DOXYGEN__
+#define TCPIP_THREAD_PRIO               1
+#endif
+
+/**
+ * TCPIP_MBOX_SIZE: The mailbox size for the tcpip thread messages
+ * The queue size value itself is platform-dependent, but is passed to
+ * sys_mbox_new() when tcpip_init is called.
+ */
+#if !defined TCPIP_MBOX_SIZE || defined __DOXYGEN__
+#define TCPIP_MBOX_SIZE                 0
+#endif
+
+/**
+ * Define this to something that triggers a watchdog. This is called from
+ * tcpip_thread after processing a message.
+ */
+#if !defined LWIP_TCPIP_THREAD_ALIVE || defined __DOXYGEN__
+#define LWIP_TCPIP_THREAD_ALIVE()
+#endif
+
+/**
+ * SLIPIF_THREAD_NAME: The name assigned to the slipif_loop thread.
+ */
+#if !defined SLIPIF_THREAD_NAME || defined __DOXYGEN__
+#define SLIPIF_THREAD_NAME             "slipif_loop"
+#endif
+
+/**
+ * SLIP_THREAD_STACKSIZE: The stack size used by the slipif_loop thread.
+ * The stack size value itself is platform-dependent, but is passed to
+ * sys_thread_new() when the thread is created.
+ */
+#if !defined SLIPIF_THREAD_STACKSIZE || defined __DOXYGEN__
+#define SLIPIF_THREAD_STACKSIZE         0
+#endif
+
+/**
+ * SLIPIF_THREAD_PRIO: The priority assigned to the slipif_loop thread.
+ * The priority value itself is platform-dependent, but is passed to
+ * sys_thread_new() when the thread is created.
+ */
+#if !defined SLIPIF_THREAD_PRIO || defined __DOXYGEN__
+#define SLIPIF_THREAD_PRIO              1
+#endif
+
+/**
+ * DEFAULT_THREAD_NAME: The name assigned to any other lwIP thread.
+ */
+#if !defined DEFAULT_THREAD_NAME || defined __DOXYGEN__
+#define DEFAULT_THREAD_NAME            "lwIP"
+#endif
+
+/**
+ * DEFAULT_THREAD_STACKSIZE: The stack size used by any other lwIP thread.
+ * The stack size value itself is platform-dependent, but is passed to
+ * sys_thread_new() when the thread is created.
+ */
+#if !defined DEFAULT_THREAD_STACKSIZE || defined __DOXYGEN__
+#define DEFAULT_THREAD_STACKSIZE        0
+#endif
+
+/**
+ * DEFAULT_THREAD_PRIO: The priority assigned to any other lwIP thread.
+ * The priority value itself is platform-dependent, but is passed to
+ * sys_thread_new() when the thread is created.
+ */
+#if !defined DEFAULT_THREAD_PRIO || defined __DOXYGEN__
+#define DEFAULT_THREAD_PRIO             1
+#endif
+
+/**
+ * DEFAULT_RAW_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
+ * NETCONN_RAW. The queue size value itself is platform-dependent, but is passed
+ * to sys_mbox_new() when the recvmbox is created.
+ */
+#if !defined DEFAULT_RAW_RECVMBOX_SIZE || defined __DOXYGEN__
+#define DEFAULT_RAW_RECVMBOX_SIZE       0
+#endif
+
+/**
+ * DEFAULT_UDP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
+ * NETCONN_UDP. The queue size value itself is platform-dependent, but is passed
+ * to sys_mbox_new() when the recvmbox is created.
+ */
+#if !defined DEFAULT_UDP_RECVMBOX_SIZE || defined __DOXYGEN__
+#define DEFAULT_UDP_RECVMBOX_SIZE       0
+#endif
+
+/**
+ * DEFAULT_TCP_RECVMBOX_SIZE: The mailbox size for the incoming packets on a
+ * NETCONN_TCP. The queue size value itself is platform-dependent, but is passed
+ * to sys_mbox_new() when the recvmbox is created.
+ */
+#if !defined DEFAULT_TCP_RECVMBOX_SIZE || defined __DOXYGEN__
+#define DEFAULT_TCP_RECVMBOX_SIZE       0
+#endif
+
+/**
+ * DEFAULT_ACCEPTMBOX_SIZE: The mailbox size for the incoming connections.
+ * The queue size value itself is platform-dependent, but is passed to
+ * sys_mbox_new() when the acceptmbox is created.
+ */
+#if !defined DEFAULT_ACCEPTMBOX_SIZE || defined __DOXYGEN__
+#define DEFAULT_ACCEPTMBOX_SIZE         0
+#endif
+/**
+ * @}
+ */
+
+/*
+   ----------------------------------------------
+   ---------- Sequential layer options ----------
+   ----------------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_netconn Netconn
+ * @ingroup lwip_opts_threadsafe_apis
+ * @{
+ */
+/**
+ * LWIP_NETCONN==1: Enable Netconn API (require to use api_lib.c)
+ */
+#if !defined LWIP_NETCONN || defined __DOXYGEN__
+#define LWIP_NETCONN                    1
+#endif
+
+/** LWIP_TCPIP_TIMEOUT==1: Enable tcpip_timeout/tcpip_untimeout to create
+ * timers running in tcpip_thread from another thread.
+ */
+#if !defined LWIP_TCPIP_TIMEOUT || defined __DOXYGEN__
+#define LWIP_TCPIP_TIMEOUT              0
+#endif
+
+/** LWIP_NETCONN_SEM_PER_THREAD==1: Use one (thread-local) semaphore per
+ * thread calling socket/netconn functions instead of allocating one
+ * semaphore per netconn (and per select etc.)
+ * ATTENTION: a thread-local semaphore for API calls is needed:
+ * - LWIP_NETCONN_THREAD_SEM_GET() returning a sys_sem_t*
+ * - LWIP_NETCONN_THREAD_SEM_ALLOC() creating the semaphore
+ * - LWIP_NETCONN_THREAD_SEM_FREE() freeing the semaphore
+ * The latter 2 can be invoked up by calling netconn_thread_init()/netconn_thread_cleanup().
+ * Ports may call these for threads created with sys_thread_new().
+ */
+#if !defined LWIP_NETCONN_SEM_PER_THREAD || defined __DOXYGEN__
+#define LWIP_NETCONN_SEM_PER_THREAD     0
+#endif
+
+/** LWIP_NETCONN_FULLDUPLEX==1: Enable code that allows reading from one thread,
+ * writing from a 2nd thread and closing from a 3rd thread at the same time.
+ * ATTENTION: This is currently really alpha! Some requirements:
+ * - LWIP_NETCONN_SEM_PER_THREAD==1 is required to use one socket/netconn from
+ *   multiple threads at once
+ * - sys_mbox_free() has to unblock receive tasks waiting on recvmbox/acceptmbox
+ *   and prevent a task pending on this during/after deletion
+ */
+#if !defined LWIP_NETCONN_FULLDUPLEX || defined __DOXYGEN__
+#define LWIP_NETCONN_FULLDUPLEX         0
+#endif
+/**
+ * @}
+ */
+
+/*
+   ------------------------------------
+   ---------- Socket options ----------
+   ------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_socket Sockets
+ * @ingroup lwip_opts_threadsafe_apis
+ * @{
+ */
+/**
+ * LWIP_SOCKET==1: Enable Socket API (require to use sockets.c)
+ */
+#if !defined LWIP_SOCKET || defined __DOXYGEN__
+#define LWIP_SOCKET                     1
+#endif
+
+/* LWIP_SOCKET_SET_ERRNO==1: Set errno when socket functions cannot complete
+ * successfully, as required by POSIX. Default is POSIX-compliant.
+ */
+#if !defined LWIP_SOCKET_SET_ERRNO || defined __DOXYGEN__
+#define LWIP_SOCKET_SET_ERRNO           1
+#endif
+
+/**
+ * LWIP_COMPAT_SOCKETS==1: Enable BSD-style sockets functions names through defines.
+ * LWIP_COMPAT_SOCKETS==2: Same as ==1 but correctly named functions are created.
+ * While this helps code completion, it might conflict with existing libraries.
+ * (only used if you use sockets.c)
+ */
+#if !defined LWIP_COMPAT_SOCKETS || defined __DOXYGEN__
+#define LWIP_COMPAT_SOCKETS             1
+#endif
+
+/**
+ * LWIP_POSIX_SOCKETS_IO_NAMES==1: Enable POSIX-style sockets functions names.
+ * Disable this option if you use a POSIX operating system that uses the same
+ * names (read, write & close). (only used if you use sockets.c)
+ */
+#if !defined LWIP_POSIX_SOCKETS_IO_NAMES || defined __DOXYGEN__
+#define LWIP_POSIX_SOCKETS_IO_NAMES     1
+#endif
+
+/**
+ * LWIP_SOCKET_OFFSET==n: Increases the file descriptor number created by LwIP with n.
+ * This can be useful when there are multiple APIs which create file descriptors.
+ * When they all start with a different offset and you won't make them overlap you can
+ * re implement read/write/close/ioctl/fnctl to send the requested action to the right
+ * library (sharing select will need more work though).
+ */
+#if !defined LWIP_SOCKET_OFFSET || defined __DOXYGEN__
+#define LWIP_SOCKET_OFFSET              0
+#endif
+
+/**
+ * LWIP_TCP_KEEPALIVE==1: Enable TCP_KEEPIDLE, TCP_KEEPINTVL and TCP_KEEPCNT
+ * options processing. Note that TCP_KEEPIDLE and TCP_KEEPINTVL have to be set
+ * in seconds. (does not require sockets.c, and will affect tcp.c)
+ */
+#if !defined LWIP_TCP_KEEPALIVE || defined __DOXYGEN__
+#define LWIP_TCP_KEEPALIVE              0
+#endif
+
+/**
+ * LWIP_SO_SNDTIMEO==1: Enable send timeout for sockets/netconns and
+ * SO_SNDTIMEO processing.
+ */
+#if !defined LWIP_SO_SNDTIMEO || defined __DOXYGEN__
+#define LWIP_SO_SNDTIMEO                0
+#endif
+
+/**
+ * LWIP_SO_RCVTIMEO==1: Enable receive timeout for sockets/netconns and
+ * SO_RCVTIMEO processing.
+ */
+#if !defined LWIP_SO_RCVTIMEO || defined __DOXYGEN__
+#define LWIP_SO_RCVTIMEO                0
+#endif
+
+/**
+ * LWIP_SO_SNDRCVTIMEO_NONSTANDARD==1: SO_RCVTIMEO/SO_SNDTIMEO take an int
+ * (milliseconds, much like winsock does) instead of a struct timeval (default).
+ */
+#if !defined LWIP_SO_SNDRCVTIMEO_NONSTANDARD || defined __DOXYGEN__
+#define LWIP_SO_SNDRCVTIMEO_NONSTANDARD 0
+#endif
+
+/**
+ * LWIP_SO_RCVBUF==1: Enable SO_RCVBUF processing.
+ */
+#if !defined LWIP_SO_RCVBUF || defined __DOXYGEN__
+#define LWIP_SO_RCVBUF                  0
+#endif
+
+/**
+ * LWIP_SO_LINGER==1: Enable SO_LINGER processing.
+ */
+#if !defined LWIP_SO_LINGER || defined __DOXYGEN__
+#define LWIP_SO_LINGER                  0
+#endif
+
+/**
+ * If LWIP_SO_RCVBUF is used, this is the default value for recv_bufsize.
+ */
+#if !defined RECV_BUFSIZE_DEFAULT || defined __DOXYGEN__
+#define RECV_BUFSIZE_DEFAULT            INT_MAX
+#endif
+
+/**
+ * By default, TCP socket/netconn close waits 20 seconds max to send the FIN
+ */
+#if !defined LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT || defined __DOXYGEN__
+#define LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT 20000
+#endif
+
+/**
+ * SO_REUSE==1: Enable SO_REUSEADDR option.
+ */
+#if !defined SO_REUSE || defined __DOXYGEN__
+#define SO_REUSE                        0
+#endif
+
+/**
+ * SO_REUSE_RXTOALL==1: Pass a copy of incoming broadcast/multicast packets
+ * to all local matches if SO_REUSEADDR is turned on.
+ * WARNING: Adds a memcpy for every packet if passing to more than one pcb!
+ */
+#if !defined SO_REUSE_RXTOALL || defined __DOXYGEN__
+#define SO_REUSE_RXTOALL                0
+#endif
+
+/**
+ * LWIP_FIONREAD_LINUXMODE==0 (default): ioctl/FIONREAD returns the amount of
+ * pending data in the network buffer. This is the way windows does it. It's
+ * the default for lwIP since it is smaller.
+ * LWIP_FIONREAD_LINUXMODE==1: ioctl/FIONREAD returns the size of the next
+ * pending datagram in bytes. This is the way linux does it. This code is only
+ * here for compatibility.
+ */
+#if !defined LWIP_FIONREAD_LINUXMODE || defined __DOXYGEN__
+#define LWIP_FIONREAD_LINUXMODE         0
+#endif
+/**
+ * @}
+ */
+
+/*
+   ----------------------------------------
+   ---------- Statistics options ----------
+   ----------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_stats Statistics
+ * @ingroup lwip_opts_debug
+ * @{
+ */
+/**
+ * LWIP_STATS==1: Enable statistics collection in lwip_stats.
+ */
+#if !defined LWIP_STATS || defined __DOXYGEN__
+#define LWIP_STATS                      1
+#endif
+
+#if LWIP_STATS
+
+/**
+ * LWIP_STATS_DISPLAY==1: Compile in the statistics output functions.
+ */
+#if !defined LWIP_STATS_DISPLAY || defined __DOXYGEN__
+#define LWIP_STATS_DISPLAY              0
+#endif
+
+/**
+ * LINK_STATS==1: Enable link stats.
+ */
+#if !defined LINK_STATS || defined __DOXYGEN__
+#define LINK_STATS                      1
+#endif
+
+/**
+ * ETHARP_STATS==1: Enable etharp stats.
+ */
+#if !defined ETHARP_STATS || defined __DOXYGEN__
+#define ETHARP_STATS                    (LWIP_ARP)
+#endif
+
+/**
+ * IP_STATS==1: Enable IP stats.
+ */
+#if !defined IP_STATS || defined __DOXYGEN__
+#define IP_STATS                        1
+#endif
+
+/**
+ * IPFRAG_STATS==1: Enable IP fragmentation stats. Default is
+ * on if using either frag or reass.
+ */
+#if !defined IPFRAG_STATS || defined __DOXYGEN__
+#define IPFRAG_STATS                    (IP_REASSEMBLY || IP_FRAG)
+#endif
+
+/**
+ * ICMP_STATS==1: Enable ICMP stats.
+ */
+#if !defined ICMP_STATS || defined __DOXYGEN__
+#define ICMP_STATS                      1
+#endif
+
+/**
+ * IGMP_STATS==1: Enable IGMP stats.
+ */
+#if !defined IGMP_STATS || defined __DOXYGEN__
+#define IGMP_STATS                      (LWIP_IGMP)
+#endif
+
+/**
+ * UDP_STATS==1: Enable UDP stats. Default is on if
+ * UDP enabled, otherwise off.
+ */
+#if !defined UDP_STATS || defined __DOXYGEN__
+#define UDP_STATS                       (LWIP_UDP)
+#endif
+
+/**
+ * TCP_STATS==1: Enable TCP stats. Default is on if TCP
+ * enabled, otherwise off.
+ */
+#if !defined TCP_STATS || defined __DOXYGEN__
+#define TCP_STATS                       (LWIP_TCP)
+#endif
+
+/**
+ * MEM_STATS==1: Enable mem.c stats.
+ */
+#if !defined MEM_STATS || defined __DOXYGEN__
+#define MEM_STATS                       ((MEM_LIBC_MALLOC == 0) && (MEM_USE_POOLS == 0))
+#endif
+
+/**
+ * MEMP_STATS==1: Enable memp.c pool stats.
+ */
+#if !defined MEMP_STATS || defined __DOXYGEN__
+#define MEMP_STATS                      (MEMP_MEM_MALLOC == 0)
+#endif
+
+/**
+ * SYS_STATS==1: Enable system stats (sem and mbox counts, etc).
+ */
+#if !defined SYS_STATS || defined __DOXYGEN__
+#define SYS_STATS                       (NO_SYS == 0)
+#endif
+
+/**
+ * IP6_STATS==1: Enable IPv6 stats.
+ */
+#if !defined IP6_STATS || defined __DOXYGEN__
+#define IP6_STATS                       (LWIP_IPV6)
+#endif
+
+/**
+ * ICMP6_STATS==1: Enable ICMP for IPv6 stats.
+ */
+#if !defined ICMP6_STATS || defined __DOXYGEN__
+#define ICMP6_STATS                     (LWIP_IPV6 && LWIP_ICMP6)
+#endif
+
+/**
+ * IP6_FRAG_STATS==1: Enable IPv6 fragmentation stats.
+ */
+#if !defined IP6_FRAG_STATS || defined __DOXYGEN__
+#define IP6_FRAG_STATS                  (LWIP_IPV6 && (LWIP_IPV6_FRAG || LWIP_IPV6_REASS))
+#endif
+
+/**
+ * MLD6_STATS==1: Enable MLD for IPv6 stats.
+ */
+#if !defined MLD6_STATS || defined __DOXYGEN__
+#define MLD6_STATS                      (LWIP_IPV6 && LWIP_IPV6_MLD)
+#endif
+
+/**
+ * ND6_STATS==1: Enable Neighbor discovery for IPv6 stats.
+ */
+#if !defined ND6_STATS || defined __DOXYGEN__
+#define ND6_STATS                       (LWIP_IPV6_ND)
+#endif
+
+/**
+ * MIB2_STATS==1: Stats for SNMP MIB2.
+ */
+#if !defined MIB2_STATS || defined __DOXYGEN__
+#define MIB2_STATS                      0
+#endif
+
+#else
+
+#define LINK_STATS                      0
+#define ETHARP_STATS                    0
+#define IP_STATS                        0
+#define IPFRAG_STATS                    0
+#define ICMP_STATS                      0
+#define IGMP_STATS                      0
+#define UDP_STATS                       0
+#define TCP_STATS                       0
+#define MEM_STATS                       0
+#define MEMP_STATS                      0
+#define SYS_STATS                       0
+#define LWIP_STATS_DISPLAY              0
+#define IP6_STATS                       0
+#define ICMP6_STATS                     0
+#define IP6_FRAG_STATS                  0
+#define MLD6_STATS                      0
+#define ND6_STATS                       0
+#define MIB2_STATS                      0
+
+#endif /* LWIP_STATS */
+/**
+ * @}
+ */
+
+/*
+   --------------------------------------
+   ---------- Checksum options ----------
+   --------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_checksum Checksum
+ * @ingroup lwip_opts_infrastructure
+ * @{
+ */
+/**
+ * LWIP_CHECKSUM_CTRL_PER_NETIF==1: Checksum generation/check can be enabled/disabled
+ * per netif.
+ * ATTENTION: if enabled, the CHECKSUM_GEN_* and CHECKSUM_CHECK_* defines must be enabled!
+ */
+#if !defined LWIP_CHECKSUM_CTRL_PER_NETIF || defined __DOXYGEN__
+#define LWIP_CHECKSUM_CTRL_PER_NETIF    0
+#endif
+
+/**
+ * CHECKSUM_GEN_IP==1: Generate checksums in software for outgoing IP packets.
+ */
+#if !defined CHECKSUM_GEN_IP || defined __DOXYGEN__
+#define CHECKSUM_GEN_IP                 1
+#endif
+
+/**
+ * CHECKSUM_GEN_UDP==1: Generate checksums in software for outgoing UDP packets.
+ */
+#if !defined CHECKSUM_GEN_UDP || defined __DOXYGEN__
+#define CHECKSUM_GEN_UDP                1
+#endif
+
+/**
+ * CHECKSUM_GEN_TCP==1: Generate checksums in software for outgoing TCP packets.
+ */
+#if !defined CHECKSUM_GEN_TCP || defined __DOXYGEN__
+#define CHECKSUM_GEN_TCP                1
+#endif
+
+/**
+ * CHECKSUM_GEN_ICMP==1: Generate checksums in software for outgoing ICMP packets.
+ */
+#if !defined CHECKSUM_GEN_ICMP || defined __DOXYGEN__
+#define CHECKSUM_GEN_ICMP               1
+#endif
+
+/**
+ * CHECKSUM_GEN_ICMP6==1: Generate checksums in software for outgoing ICMP6 packets.
+ */
+#if !defined CHECKSUM_GEN_ICMP6 || defined __DOXYGEN__
+#define CHECKSUM_GEN_ICMP6              1
+#endif
+
+/**
+ * CHECKSUM_CHECK_IP==1: Check checksums in software for incoming IP packets.
+ */
+#if !defined CHECKSUM_CHECK_IP || defined __DOXYGEN__
+#define CHECKSUM_CHECK_IP               1
+#endif
+
+/**
+ * CHECKSUM_CHECK_UDP==1: Check checksums in software for incoming UDP packets.
+ */
+#if !defined CHECKSUM_CHECK_UDP || defined __DOXYGEN__
+#define CHECKSUM_CHECK_UDP              1
+#endif
+
+/**
+ * CHECKSUM_CHECK_TCP==1: Check checksums in software for incoming TCP packets.
+ */
+#if !defined CHECKSUM_CHECK_TCP || defined __DOXYGEN__
+#define CHECKSUM_CHECK_TCP              1
+#endif
+
+/**
+ * CHECKSUM_CHECK_ICMP==1: Check checksums in software for incoming ICMP packets.
+ */
+#if !defined CHECKSUM_CHECK_ICMP || defined __DOXYGEN__
+#define CHECKSUM_CHECK_ICMP             1
+#endif
+
+/**
+ * CHECKSUM_CHECK_ICMP6==1: Check checksums in software for incoming ICMPv6 packets
+ */
+#if !defined CHECKSUM_CHECK_ICMP6 || defined __DOXYGEN__
+#define CHECKSUM_CHECK_ICMP6            1
+#endif
+
+/**
+ * LWIP_CHECKSUM_ON_COPY==1: Calculate checksum when copying data from
+ * application buffers to pbufs.
+ */
+#if !defined LWIP_CHECKSUM_ON_COPY || defined __DOXYGEN__
+#define LWIP_CHECKSUM_ON_COPY           0
+#endif
+/**
+ * @}
+ */
+
+/*
+   ---------------------------------------
+   ---------- IPv6 options ---------------
+   ---------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_ipv6 IPv6
+ * @ingroup lwip_opts
+ * @{
+ */
+/**
+ * LWIP_IPV6==1: Enable IPv6
+ */
+#if !defined LWIP_IPV6 || defined __DOXYGEN__
+#define LWIP_IPV6                       0
+#endif
+
+/**
+ * LWIP_IPV6_NUM_ADDRESSES: Number of IPv6 addresses per netif.
+ */
+#if !defined LWIP_IPV6_NUM_ADDRESSES || defined __DOXYGEN__
+#define LWIP_IPV6_NUM_ADDRESSES         3
+#endif
+
+/**
+ * LWIP_IPV6_FORWARD==1: Forward IPv6 packets across netifs
+ */
+#if !defined LWIP_IPV6_FORWARD || defined __DOXYGEN__
+#define LWIP_IPV6_FORWARD               0
+#endif
+
+/**
+ * LWIP_IPV6_FRAG==1: Fragment outgoing IPv6 packets that are too big.
+ */
+#if !defined LWIP_IPV6_FRAG || defined __DOXYGEN__
+#define LWIP_IPV6_FRAG                  0
+#endif
+
+/**
+ * LWIP_IPV6_REASS==1: reassemble incoming IPv6 packets that fragmented
+ */
+#if !defined LWIP_IPV6_REASS || defined __DOXYGEN__
+#define LWIP_IPV6_REASS                 (LWIP_IPV6)
+#endif
+
+/**
+ * LWIP_IPV6_SEND_ROUTER_SOLICIT==1: Send router solicitation messages during
+ * network startup.
+ */
+#if !defined LWIP_IPV6_SEND_ROUTER_SOLICIT || defined __DOXYGEN__
+#define LWIP_IPV6_SEND_ROUTER_SOLICIT   1
+#endif
+
+/**
+ * LWIP_IPV6_ADDRESS_LIFETIMES==1: Keep valid and preferred lifetimes for each
+ * IPv6 address. Required for LWIP_IPV6_AUTOCONFIG. May still be enabled
+ * otherwise, in which case the application may assign address lifetimes with
+ * the appropriate macros. Addresses with no lifetime are assumed to be static.
+ * If this option is disabled, all addresses are assumed to be static.
+ */
+#if !defined LWIP_IPV6_ADDRESS_LIFETIMES || defined __DOXYGEN__
+#define LWIP_IPV6_ADDRESS_LIFETIMES     (LWIP_IPV6_AUTOCONFIG)
+#endif
+
+/**
+ * LWIP_IPV6_DUP_DETECT_ATTEMPTS=[0..7]: Number of duplicate address detection attempts.
+ */
+#if !defined LWIP_IPV6_DUP_DETECT_ATTEMPTS || defined __DOXYGEN__
+#define LWIP_IPV6_DUP_DETECT_ATTEMPTS   1
+#endif
+/**
+ * @}
+ */
+
+/**
+ * @defgroup lwip_opts_icmp6 ICMP6
+ * @ingroup lwip_opts_ipv6
+ * @{
+ */
+/**
+ * LWIP_ICMP6==1: Enable ICMPv6 (mandatory per RFC)
+ */
+#if !defined LWIP_ICMP6 || defined __DOXYGEN__
+#define LWIP_ICMP6                      (LWIP_IPV6)
+#endif
+
+/**
+ * LWIP_ICMP6_DATASIZE: bytes from original packet to send back in
+ * ICMPv6 error messages.
+ */
+#if !defined LWIP_ICMP6_DATASIZE || defined __DOXYGEN__
+#define LWIP_ICMP6_DATASIZE             8
+#endif
+
+/**
+ * LWIP_ICMP6_HL: default hop limit for ICMPv6 messages
+ */
+#if !defined LWIP_ICMP6_HL || defined __DOXYGEN__
+#define LWIP_ICMP6_HL                   255
+#endif
+/**
+ * @}
+ */
+
+/**
+ * @defgroup lwip_opts_nd6 Neighbor discovery
+ * @ingroup lwip_opts_ipv6
+ * @{
+ */
+
+/**
+ * LWIP_IPV6_ND==1: Enable neighbor discovery protocol.
+ * If LWIP_IPV6 is enabled but this setting is disabled, then neighbor and
+ * destination caches, duplicate address detection, neighbor unreachability
+ * detection, multicast listener discovery and router discovery are delegated
+ * entirely to the sub-IP layer.
+ */
+#if !defined LWIP_IPV6_ND || defined __DOXYGEN__
+#define LWIP_IPV6_ND                   (LWIP_IPV6)
+#endif
+
+/**
+ * LWIP_IPV6_AUTOCONFIG==1: Enable stateless address autoconfiguration as per RFC 4862.
+ */
+#if !defined LWIP_IPV6_AUTOCONFIG || defined __DOXYGEN__
+#define LWIP_IPV6_AUTOCONFIG            (LWIP_IPV6_ND)
+#endif
+
+/**
+ * @defgroup lwip_opts_mld6 Multicast listener discovery
+ * @ingroup lwip_opts_ipv6
+ * @{
+ */
+/**
+ * LWIP_IPV6_MLD==1: Enable multicast listener discovery protocol.
+ * If LWIP_IPV6_ND is enabled but this setting is disabled, the MAC layer must
+ * indiscriminately pass all inbound IPv6 multicast traffic to lwIP.
+ */
+#if !defined LWIP_IPV6_MLD || defined __DOXYGEN__
+#define LWIP_IPV6_MLD                   (LWIP_IPV6_ND)
+#endif
+
+/**
+ * MEMP_NUM_MLD6_GROUP: Max number of IPv6 multicast groups that can be joined.
+ * There must be enough groups so that each netif can join the solicited-node
+ * multicast group for each of its local addresses, plus one for MDNS if
+ * applicable, plus any number of groups to be joined on UDP sockets.
+ */
+#if !defined MEMP_NUM_MLD6_GROUP || defined __DOXYGEN__
+#define MEMP_NUM_MLD6_GROUP             4
+#endif
+/**
+ * @}
+ */
+
+/**
+ * @defgroup lwip_opts_nd6 Neighbor discovery
+ * @ingroup lwip_opts_ipv6
+ * @{
+ */
+/**
+ * LWIP_ND6_QUEUEING==1: queue outgoing IPv6 packets while MAC address
+ * is being resolved.
+ */
+#if !defined LWIP_ND6_QUEUEING || defined __DOXYGEN__
+#define LWIP_ND6_QUEUEING               (LWIP_IPV6_ND)
+#endif
+
+/**
+ * MEMP_NUM_ND6_QUEUE: Max number of IPv6 packets to queue during MAC resolution.
+ */
+#if !defined MEMP_NUM_ND6_QUEUE || defined __DOXYGEN__
+#define MEMP_NUM_ND6_QUEUE              20
+#endif
+
+/**
+ * LWIP_ND6_NUM_NEIGHBORS: Number of entries in IPv6 neighbor cache
+ */
+#if !defined LWIP_ND6_NUM_NEIGHBORS || defined __DOXYGEN__
+#define LWIP_ND6_NUM_NEIGHBORS          10
+#endif
+
+/**
+ * LWIP_ND6_NUM_DESTINATIONS: number of entries in IPv6 destination cache
+ */
+#if !defined LWIP_ND6_NUM_DESTINATIONS || defined __DOXYGEN__
+#define LWIP_ND6_NUM_DESTINATIONS       10
+#endif
+
+/**
+ * LWIP_ND6_NUM_PREFIXES: number of entries in IPv6 on-link prefixes cache
+ */
+#if !defined LWIP_ND6_NUM_PREFIXES || defined __DOXYGEN__
+#define LWIP_ND6_NUM_PREFIXES           5
+#endif
+
+/**
+ * LWIP_ND6_NUM_ROUTERS: number of entries in IPv6 default router cache
+ */
+#if !defined LWIP_ND6_NUM_ROUTERS || defined __DOXYGEN__
+#define LWIP_ND6_NUM_ROUTERS            3
+#endif
+
+/**
+ * LWIP_ND6_MAX_MULTICAST_SOLICIT: max number of multicast solicit messages to send
+ * (neighbor solicit and router solicit)
+ */
+#if !defined LWIP_ND6_MAX_MULTICAST_SOLICIT || defined __DOXYGEN__
+#define LWIP_ND6_MAX_MULTICAST_SOLICIT  3
+#endif
+
+/**
+ * LWIP_ND6_MAX_UNICAST_SOLICIT: max number of unicast neighbor solicitation messages
+ * to send during neighbor reachability detection.
+ */
+#if !defined LWIP_ND6_MAX_UNICAST_SOLICIT || defined __DOXYGEN__
+#define LWIP_ND6_MAX_UNICAST_SOLICIT    3
+#endif
+
+/**
+ * Unused: See ND RFC (time in milliseconds).
+ */
+#if !defined LWIP_ND6_MAX_ANYCAST_DELAY_TIME || defined __DOXYGEN__
+#define LWIP_ND6_MAX_ANYCAST_DELAY_TIME 1000
+#endif
+
+/**
+ * Unused: See ND RFC
+ */
+#if !defined LWIP_ND6_MAX_NEIGHBOR_ADVERTISEMENT || defined __DOXYGEN__
+#define LWIP_ND6_MAX_NEIGHBOR_ADVERTISEMENT  3
+#endif
+
+/**
+ * LWIP_ND6_REACHABLE_TIME: default neighbor reachable time (in milliseconds).
+ * May be updated by router advertisement messages.
+ */
+#if !defined LWIP_ND6_REACHABLE_TIME || defined __DOXYGEN__
+#define LWIP_ND6_REACHABLE_TIME         30000
+#endif
+
+/**
+ * LWIP_ND6_RETRANS_TIMER: default retransmission timer for solicitation messages
+ */
+#if !defined LWIP_ND6_RETRANS_TIMER || defined __DOXYGEN__
+#define LWIP_ND6_RETRANS_TIMER          1000
+#endif
+
+/**
+ * LWIP_ND6_DELAY_FIRST_PROBE_TIME: Delay before first unicast neighbor solicitation
+ * message is sent, during neighbor reachability detection.
+ */
+#if !defined LWIP_ND6_DELAY_FIRST_PROBE_TIME || defined __DOXYGEN__
+#define LWIP_ND6_DELAY_FIRST_PROBE_TIME 5000
+#endif
+
+/**
+ * LWIP_ND6_ALLOW_RA_UPDATES==1: Allow Router Advertisement messages to update
+ * Reachable time and retransmission timers, and netif MTU.
+ */
+#if !defined LWIP_ND6_ALLOW_RA_UPDATES || defined __DOXYGEN__
+#define LWIP_ND6_ALLOW_RA_UPDATES       1
+#endif
+
+/**
+ * LWIP_ND6_TCP_REACHABILITY_HINTS==1: Allow TCP to provide Neighbor Discovery
+ * with reachability hints for connected destinations. This helps avoid sending
+ * unicast neighbor solicitation messages.
+ */
+#if !defined LWIP_ND6_TCP_REACHABILITY_HINTS || defined __DOXYGEN__
+#define LWIP_ND6_TCP_REACHABILITY_HINTS 1
+#endif
+
+/**
+ * LWIP_ND6_RDNSS_MAX_DNS_SERVERS > 0: Use IPv6 Router Advertisement Recursive
+ * DNS Server Option (as per RFC 6106) to copy a defined maximum number of DNS
+ * servers to the DNS module.
+ */
+#if !defined LWIP_ND6_RDNSS_MAX_DNS_SERVERS || defined __DOXYGEN__
+#define LWIP_ND6_RDNSS_MAX_DNS_SERVERS  0
+#endif
+/**
+ * @}
+ */
+
+/**
+ * LWIP_IPV6_DHCP6==1: enable DHCPv6 stateful address autoconfiguration.
+ */
+#if !defined LWIP_IPV6_DHCP6 || defined __DOXYGEN__
+#define LWIP_IPV6_DHCP6                 0
+#endif
+
+/**
+ * LWIP_ND6_LISTEN_RA==1: Enable listening and processing incoming Router Advertisements.
+ */
+#ifndef LWIP_ND6_LISTEN_RA
+#define LWIP_ND6_LISTEN_RA              1
+#endif
+
+/**
+ * LWIP_IPV6_ROUTER_SUPPORT==1: Maintain a list of IPV6 routers dynamically discovered via Router Advertisements.
+ */
+#ifndef LWIP_IPV6_ROUTER_SUPPORT
+#define LWIP_IPV6_ROUTER_SUPPORT        1
+#endif
+
+/**
+ * LWIP_IPV6_ROUTE_TABLE_SUPPORT==1: Enable support for adding static routes and referring to these during forwarding.
+ */
+#ifndef LWIP_IPV6_ROUTE_TABLE_SUPPORT
+#define LWIP_IPV6_ROUTE_TABLE_SUPPORT   0
+#endif
+
+/**
+ * LWIP_IPV6_NUM_ROUTES: Number of IPV6 routes that can be kept in the static route table.
+ */
+#ifndef LWIP_IPV6_NUM_ROUTE_ENTRIES
+#define LWIP_IPV6_NUM_ROUTE_ENTRIES     8
+#endif
+
+
+/*
+   ---------------------------------------
+   ---------- Hook options ---------------
+   ---------------------------------------
+*/
+
+/**
+ * @defgroup lwip_opts_hooks Hooks
+ * @ingroup lwip_opts_infrastructure
+ * Hooks are undefined by default, define them to a function if you need them.
+ * @{
+ */
+
+/**
+ * LWIP_HOOK_FILENAME: Custom filename to #include in files that provide hooks.
+ * Declare your hook function prototypes in there, you may also #include all headers
+ * providing data types that are need in this file.
+ */
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_FILENAME "path/to/my/lwip_hooks.h"
+#endif
+
+/**
+ * LWIP_HOOK_TCP_ISN:
+ * Hook for generation of the Initial Sequence Number (ISN) for a new TCP
+ * connection. The default lwIP ISN generation algorithm is very basic and may
+ * allow for TCP spoofing attacks. This hook provides the means to implement
+ * the standardized ISN generation algorithm from RFC 6528 (see contrib/adons/tcp_isn),
+ * or any other desired algorithm as a replacement.
+ * Called from tcp_connect() and tcp_listen_input() when an ISN is needed for
+ * a new TCP connection, if TCP support (@ref LWIP_TCP) is enabled.\n
+ * Signature: u32_t my_hook_tcp_isn(const ip_addr_t* local_ip, u16_t local_port, const ip_addr_t* remote_ip, u16_t remote_port);
+ * - it may be necessary to use "struct ip_addr" (ip4_addr, ip6_addr) instead of "ip_addr_t" in function declarations\n
+ * Arguments:
+ * - local_ip: pointer to the local IP address of the connection
+ * - local_port: local port number of the connection (host-byte order)
+ * - remote_ip: pointer to the remote IP address of the connection
+ * - remote_port: remote port number of the connection (host-byte order)\n
+ * Return value:
+ * - the 32-bit Initial Sequence Number to use for the new TCP connection.
+ */
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_TCP_ISN(local_ip, local_port, remote_ip, remote_port)
+#endif
+
+/**
+ * LWIP_HOOK_IP4_INPUT(pbuf, input_netif):
+ * - called from ip_input() (IPv4)
+ * - pbuf: received struct pbuf passed to ip_input()
+ * - input_netif: struct netif on which the packet has been received
+ * Return values:
+ * - 0: Hook has not consumed the packet, packet is processed as normal
+ * - != 0: Hook has consumed the packet.
+ * If the hook consumed the packet, 'pbuf' is in the responsibility of the hook
+ * (i.e. free it when done).
+ */
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_IP4_INPUT(pbuf, input_netif)
+#endif
+
+/**
+ * LWIP_HOOK_IP4_ROUTE(dest):
+ * - called from ip_route() (IPv4)
+ * - dest: destination IPv4 address
+ * Returns the destination netif or NULL if no destination netif is found. In
+ * that case, ip_route() continues as normal.
+ */
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_IP4_ROUTE()
+#endif
+
+/**
+ * LWIP_HOOK_IP4_ROUTE_SRC(dest, src):
+ * - source-based routing for IPv4 (see LWIP_HOOK_IP4_ROUTE(), src may be NULL)
+ */
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_IP4_ROUTE_SRC(dest, src)
+#endif
+
+/**
+ * LWIP_HOOK_ETHARP_GET_GW(netif, dest):
+ * - called from etharp_output() (IPv4)
+ * - netif: the netif used for sending
+ * - dest: the destination IPv4 address
+ * Returns the IPv4 address of the gateway to handle the specified destination
+ * IPv4 address. If NULL is returned, the netif's default gateway is used.
+ * The returned address MUST be directly reachable on the specified netif!
+ * This function is meant to implement advanced IPv4 routing together with
+ * LWIP_HOOK_IP4_ROUTE(). The actual routing/gateway table implementation is
+ * not part of lwIP but can e.g. be hidden in the netif's state argument.
+*/
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_ETHARP_GET_GW(netif, dest)
+#endif
+
+/**
+ * LWIP_HOOK_IP6_INPUT(pbuf, input_netif):
+ * - called from ip6_input() (IPv6)
+ * - pbuf: received struct pbuf passed to ip6_input()
+ * - input_netif: struct netif on which the packet has been received
+ * Return values:
+ * - 0: Hook has not consumed the packet, packet is processed as normal
+ * - != 0: Hook has consumed the packet.
+ * If the hook consumed the packet, 'pbuf' is in the responsibility of the hook
+ * (i.e. free it when done).
+ */
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_IP6_INPUT(pbuf, input_netif)
+#endif
+
+/**
+ * LWIP_HOOK_IP6_ROUTE(src, dest):
+ * - called from ip6_route() (IPv6)
+ * - src: sourc IPv6 address
+ * - dest: destination IPv6 address
+ * Returns the destination netif or NULL if no destination netif is found. In
+ * that case, ip6_route() continues as normal.
+ */
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_IP6_ROUTE(src, dest)
+#endif
+
+/**
+ * LWIP_HOOK_ND6_GET_GW(netif, dest):
+ * - called from nd6_get_next_hop_entry() (IPv6)
+ * - netif: the netif used for sending
+ * - dest: the destination IPv6 address
+ * Returns the IPv6 address of the next hop to handle the specified destination
+ * IPv6 address. If NULL is returned, a NDP-discovered router is used instead.
+ * The returned address MUST be directly reachable on the specified netif!
+ * This function is meant to implement advanced IPv6 routing together with
+ * LWIP_HOOK_IP6_ROUTE(). The actual routing/gateway table implementation is
+ * not part of lwIP but can e.g. be hidden in the netif's state argument.
+*/
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_ND6_GET_GW(netif, dest)
+#endif
+
+/**
+ * LWIP_HOOK_VLAN_CHECK(netif, eth_hdr, vlan_hdr):
+ * - called from ethernet_input() if VLAN support is enabled
+ * - netif: struct netif on which the packet has been received
+ * - eth_hdr: struct eth_hdr of the packet
+ * - vlan_hdr: struct eth_vlan_hdr of the packet
+ * Return values:
+ * - 0: Packet must be dropped.
+ * - != 0: Packet must be accepted.
+ */
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_VLAN_CHECK(netif, eth_hdr, vlan_hdr)
+#endif
+
+/**
+ * LWIP_HOOK_VLAN_SET:
+ * Hook can be used to set prio_vid field of vlan_hdr. If you need to store data
+ * on per-netif basis to implement this callback, see @ref netif_cd.
+ * Called from ethernet_output() if VLAN support (@ref ETHARP_SUPPORT_VLAN) is enabled.\n
+ * Signature: s32_t my_hook_vlan_set(struct netif* netif, struct pbuf* pbuf, const struct eth_addr* src, const struct eth_addr* dst, u16_t eth_type);\n
+ * Arguments:
+ * - netif: struct netif that the packet will be sent through
+ * - p: struct pbuf packet to be sent
+ * - src: source eth address
+ * - dst: destination eth address
+ * - eth_type: ethernet type to packet to be sent\n
+ * 
+ * 
+ * Return values:
+ * - &lt;0: Packet shall not contain VLAN header.
+ * - 0 &lt;= return value &lt;= 0xFFFF: Packet shall contain VLAN header. Return value is prio_vid in host byte order.
+ */
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_VLAN_SET(netif, p, src, dst, eth_type)
+#endif
+
+/**
+ * LWIP_HOOK_MEMP_AVAILABLE(memp_t_type):
+ * - called from memp_free() when a memp pool was empty and an item is now available
+ */
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_MEMP_AVAILABLE(memp_t_type)
+#endif
+
+/**
+ * LWIP_HOOK_UNKNOWN_ETH_PROTOCOL(pbuf, netif):
+ * Called from ethernet_input() when an unknown eth type is encountered.
+ * Return ERR_OK if packet is accepted, any error code otherwise.
+ * Payload points to ethernet header!
+ */
+#ifdef __DOXYGEN__
+#define LWIP_HOOK_UNKNOWN_ETH_PROTOCOL(pbuf, netif)
+#endif
+/**
+ * @}
+ */
+
+/**
+* LWIP_HOOK_ETHIP6_GET_GW(netif, dest):
+* - called from ethip6_output() (IPv6)
+* - netif: the netif used for sending
+* - dest: the destination IPv6 address
+* Returns the IPv6 address of the gateway to handle the specified destination
+* IPv6 address. If NULL is returned, the netif's default gateway is used.
+* The returned address MUST be reachable on the specified netif!
+*/
+#if LWIP_IPV6_ROUTE_TABLE_SUPPORT
+#define LWIP_HOOK_ETHIP6_GET_GW(netif, dest)         ip6_get_gateway(netif, dest)
+#endif
+
+
+/*
+   ---------------------------------------
+   ---------- Debugging options ----------
+   ---------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_debugmsg Debug messages
+ * @ingroup lwip_opts_debug
+ * @{
+ */
+/**
+ * LWIP_DBG_MIN_LEVEL: After masking, the value of the debug is
+ * compared against this value. If it is smaller, then debugging
+ * messages are written.
+ * @see debugging_levels
+ */
+#if !defined LWIP_DBG_MIN_LEVEL || defined __DOXYGEN__
+#define LWIP_DBG_MIN_LEVEL              LWIP_DBG_LEVEL_ALL
+#endif
+
+/**
+ * LWIP_DBG_TYPES_ON: A mask that can be used to globally enable/disable
+ * debug messages of certain types.
+ * @see debugging_levels
+ */
+#if !defined LWIP_DBG_TYPES_ON || defined __DOXYGEN__
+#define LWIP_DBG_TYPES_ON               LWIP_DBG_ON
+#endif
+
+/**
+ * ETHARP_DEBUG: Enable debugging in etharp.c.
+ */
+#if !defined ETHARP_DEBUG || defined __DOXYGEN__
+#define ETHARP_DEBUG                    LWIP_DBG_OFF
+#endif
+
+/**
+ * NETIF_DEBUG: Enable debugging in netif.c.
+ */
+#if !defined NETIF_DEBUG || defined __DOXYGEN__
+#define NETIF_DEBUG                     LWIP_DBG_OFF
+#endif
+
+/**
+ * PBUF_DEBUG: Enable debugging in pbuf.c.
+ */
+#if !defined PBUF_DEBUG || defined __DOXYGEN__
+#define PBUF_DEBUG                      LWIP_DBG_OFF
+#endif
+
+/**
+ * API_LIB_DEBUG: Enable debugging in api_lib.c.
+ */
+#if !defined API_LIB_DEBUG || defined __DOXYGEN__
+#define API_LIB_DEBUG                   LWIP_DBG_OFF
+#endif
+
+/**
+ * API_MSG_DEBUG: Enable debugging in api_msg.c.
+ */
+#if !defined API_MSG_DEBUG || defined __DOXYGEN__
+#define API_MSG_DEBUG                   LWIP_DBG_OFF
+#endif
+
+/**
+ * SOCKETS_DEBUG: Enable debugging in sockets.c.
+ */
+#if !defined SOCKETS_DEBUG || defined __DOXYGEN__
+#define SOCKETS_DEBUG                   LWIP_DBG_OFF
+#endif
+
+/**
+ * ICMP_DEBUG: Enable debugging in icmp.c.
+ */
+#if !defined ICMP_DEBUG || defined __DOXYGEN__
+#define ICMP_DEBUG                      LWIP_DBG_OFF
+#endif
+
+/**
+ * IGMP_DEBUG: Enable debugging in igmp.c.
+ */
+#if !defined IGMP_DEBUG || defined __DOXYGEN__
+#define IGMP_DEBUG                      LWIP_DBG_OFF
+#endif
+
+/**
+ * INET_DEBUG: Enable debugging in inet.c.
+ */
+#if !defined INET_DEBUG || defined __DOXYGEN__
+#define INET_DEBUG                      LWIP_DBG_OFF
+#endif
+
+/**
+ * IP_DEBUG: Enable debugging for IP.
+ */
+#if !defined IP_DEBUG || defined __DOXYGEN__
+#define IP_DEBUG                        LWIP_DBG_OFF
+#endif
+
+/**
+ * IP_REASS_DEBUG: Enable debugging in ip_frag.c for both frag & reass.
+ */
+#if !defined IP_REASS_DEBUG || defined __DOXYGEN__
+#define IP_REASS_DEBUG                  LWIP_DBG_OFF
+#endif
+
+/**
+ * RAW_DEBUG: Enable debugging in raw.c.
+ */
+#if !defined RAW_DEBUG || defined __DOXYGEN__
+#define RAW_DEBUG                       LWIP_DBG_OFF
+#endif
+
+/**
+ * MEM_DEBUG: Enable debugging in mem.c.
+ */
+#if !defined MEM_DEBUG || defined __DOXYGEN__
+#define MEM_DEBUG                       LWIP_DBG_OFF
+#endif
+
+/**
+ * MEMP_DEBUG: Enable debugging in memp.c.
+ */
+#if !defined MEMP_DEBUG || defined __DOXYGEN__
+#define MEMP_DEBUG                      LWIP_DBG_OFF
+#endif
+
+/**
+ * SYS_DEBUG: Enable debugging in sys.c.
+ */
+#if !defined SYS_DEBUG || defined __DOXYGEN__
+#define SYS_DEBUG                       LWIP_DBG_OFF
+#endif
+
+/**
+ * TIMERS_DEBUG: Enable debugging in timers.c.
+ */
+#if !defined TIMERS_DEBUG || defined __DOXYGEN__
+#define TIMERS_DEBUG                    LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_DEBUG: Enable debugging for TCP.
+ */
+#if !defined TCP_DEBUG || defined __DOXYGEN__
+#define TCP_DEBUG                       LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_INPUT_DEBUG: Enable debugging in tcp_in.c for incoming debug.
+ */
+#if !defined TCP_INPUT_DEBUG || defined __DOXYGEN__
+#define TCP_INPUT_DEBUG                 LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_FR_DEBUG: Enable debugging in tcp_in.c for fast retransmit.
+ */
+#if !defined TCP_FR_DEBUG || defined __DOXYGEN__
+#define TCP_FR_DEBUG                    LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_RTO_DEBUG: Enable debugging in TCP for retransmit
+ * timeout.
+ */
+#if !defined TCP_RTO_DEBUG || defined __DOXYGEN__
+#define TCP_RTO_DEBUG                   LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_CWND_DEBUG: Enable debugging for TCP congestion window.
+ */
+#if !defined TCP_CWND_DEBUG || defined __DOXYGEN__
+#define TCP_CWND_DEBUG                  LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_WND_DEBUG: Enable debugging in tcp_in.c for window updating.
+ */
+#if !defined TCP_WND_DEBUG || defined __DOXYGEN__
+#define TCP_WND_DEBUG                   LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_OUTPUT_DEBUG: Enable debugging in tcp_out.c output functions.
+ */
+#if !defined TCP_OUTPUT_DEBUG || defined __DOXYGEN__
+#define TCP_OUTPUT_DEBUG                LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_RST_DEBUG: Enable debugging for TCP with the RST message.
+ */
+#if !defined TCP_RST_DEBUG || defined __DOXYGEN__
+#define TCP_RST_DEBUG                   LWIP_DBG_OFF
+#endif
+
+/**
+ * TCP_QLEN_DEBUG: Enable debugging for TCP queue lengths.
+ */
+#if !defined TCP_QLEN_DEBUG || defined __DOXYGEN__
+#define TCP_QLEN_DEBUG                  LWIP_DBG_OFF
+#endif
+
+/**
+ * UDP_DEBUG: Enable debugging in UDP.
+ */
+#if !defined UDP_DEBUG || defined __DOXYGEN__
+#define UDP_DEBUG                       LWIP_DBG_OFF
+#endif
+
+/**
+ * TCPIP_DEBUG: Enable debugging in tcpip.c.
+ */
+#if !defined TCPIP_DEBUG || defined __DOXYGEN__
+#define TCPIP_DEBUG                     LWIP_DBG_OFF
+#endif
+
+/**
+ * SLIP_DEBUG: Enable debugging in slipif.c.
+ */
+#if !defined SLIP_DEBUG || defined __DOXYGEN__
+#define SLIP_DEBUG                      LWIP_DBG_OFF
+#endif
+
+/**
+ * DHCP_DEBUG: Enable debugging in dhcp.c.
+ */
+#if !defined DHCP_DEBUG || defined __DOXYGEN__
+#define DHCP_DEBUG                      LWIP_DBG_OFF
+#endif
+
+/**
+ * AUTOIP_DEBUG: Enable debugging in autoip.c.
+ */
+#if !defined AUTOIP_DEBUG || defined __DOXYGEN__
+#define AUTOIP_DEBUG                    LWIP_DBG_OFF
+#endif
+
+/**
+ * DNS_DEBUG: Enable debugging for DNS.
+ */
+#if !defined DNS_DEBUG || defined __DOXYGEN__
+#define DNS_DEBUG                       LWIP_DBG_OFF
+#endif
+
+/**
+ * IP6_DEBUG: Enable debugging for IPv6.
+ */
+#if !defined IP6_DEBUG || defined __DOXYGEN__
+#define IP6_DEBUG                       LWIP_DBG_OFF
+#endif
+
+/**
+ * LWIP_IP_DEBUG_TARGET: Enable selective output of IP-level debug for
+ * a particular IP address.
+ */
+#ifndef LWIP_IP_DEBUG_TARGET
+#define LWIP_IP_DEBUG_TARGET            0
+#endif
+
+/**
+ * @}
+ */
+
+/*
+   --------------------------------------------------
+   ---------- Performance tracking options ----------
+   --------------------------------------------------
+*/
+/**
+ * @defgroup lwip_opts_perf Performance
+ * @ingroup lwip_opts_debug
+ * @{
+ */
+/**
+ * LWIP_PERF: Enable performance testing for lwIP
+ * (if enabled, arch/perf.h is included)
+ */
+#if !defined LWIP_PERF || defined __DOXYGEN__
+#define LWIP_PERF                       0
+#endif
+/**
+ * @}
+ */
+
+#endif /* LWIP_HDR_OPT_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/pbuf.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/pbuf.h
new file mode 100644
index 000000000..9996770df
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/pbuf.h
@@ -0,0 +1,269 @@
+/**
+ * @file
+ * pbuf API
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+#ifndef LWIP_HDR_PBUF_H
+#define LWIP_HDR_PBUF_H
+
+#include "lwip/opt.h"
+#include "lwip/err.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** LWIP_SUPPORT_CUSTOM_PBUF==1: Custom pbufs behave much like their pbuf type
+ * but they are allocated by external code (initialised by calling
+ * pbuf_alloced_custom()) and when pbuf_free gives up their last reference, they
+ * are freed by calling pbuf_custom->custom_free_function().
+ * Currently, the pbuf_custom code is only needed for one specific configuration
+ * of IP_FRAG, unless required by external driver/application code. */
+#ifndef LWIP_SUPPORT_CUSTOM_PBUF
+#define LWIP_SUPPORT_CUSTOM_PBUF ((IP_FRAG && !LWIP_NETIF_TX_SINGLE_PBUF) || (LWIP_IPV6 && LWIP_IPV6_FRAG))
+#endif
+
+/* @todo: We need a mechanism to prevent wasting memory in every pbuf
+   (TCP vs. UDP, IPv4 vs. IPv6: UDP/IPv4 packets may waste up to 28 bytes) */
+
+#define PBUF_TRANSPORT_HLEN 20
+#if LWIP_IPV6
+#define PBUF_IP_HLEN        40
+#else
+#define PBUF_IP_HLEN        20
+#endif
+
+/**
+ * @ingroup pbuf
+ * Enumeration of pbuf layers
+ */
+typedef enum {
+  /** Includes spare room for transport layer header, e.g. UDP header.
+   * Use this if you intend to pass the pbuf to functions like udp_send().
+   */
+  PBUF_TRANSPORT,
+  /** Includes spare room for IP header.
+   * Use this if you intend to pass the pbuf to functions like raw_send().
+   */
+  PBUF_IP,
+  /** Includes spare room for link layer header (ethernet header).
+   * Use this if you intend to pass the pbuf to functions like ethernet_output().
+   * @see PBUF_LINK_HLEN
+   */
+  PBUF_LINK,
+  /** Includes spare room for additional encapsulation header before ethernet
+   * headers (e.g. 802.11).
+   * Use this if you intend to pass the pbuf to functions like netif->linkoutput().
+   * @see PBUF_LINK_ENCAPSULATION_HLEN
+   */
+  PBUF_RAW_TX,
+  /** Use this for input packets in a netif driver when calling netif->input()
+   * in the most common case - ethernet-layer netif driver. */
+  PBUF_RAW
+} pbuf_layer;
+
+/**
+ * @ingroup pbuf
+ * Enumeration of pbuf types
+ */
+typedef enum {
+  /** pbuf data is stored in RAM, used for TX mostly, struct pbuf and its payload
+      are allocated in one piece of contiguous memory (so the first payload byte
+      can be calculated from struct pbuf).
+      pbuf_alloc() allocates PBUF_RAM pbufs as unchained pbufs (although that might
+      change in future versions).
+      This should be used for all OUTGOING packets (TX).*/
+  PBUF_RAM,
+  /** pbuf data is stored in ROM, i.e. struct pbuf and its payload are located in
+      totally different memory areas. Since it points to ROM, payload does not
+      have to be copied when queued for transmission. */
+  PBUF_ROM,
+  /** pbuf comes from the pbuf pool. Much like PBUF_ROM but payload might change
+      so it has to be duplicated when queued before transmitting, depending on
+      who has a 'ref' to it. */
+  PBUF_REF,
+  /** pbuf payload refers to RAM. This one comes from a pool and should be used
+      for RX. Payload can be chained (scatter-gather RX) but like PBUF_RAM, struct
+      pbuf and its payload are allocated in one piece of contiguous memory (so
+      the first payload byte can be calculated from struct pbuf).
+      Don't use this for TX, if the pool becomes empty e.g. because of TCP queuing,
+      you are unable to receive TCP acks! */
+  PBUF_POOL
+} pbuf_type;
+
+
+/** indicates this packet's data should be immediately passed to the application */
+#define PBUF_FLAG_PUSH      0x01U
+/** indicates this is a custom pbuf: pbuf_free calls pbuf_custom->custom_free_function()
+    when the last reference is released (plus custom PBUF_RAM cannot be trimmed) */
+#define PBUF_FLAG_IS_CUSTOM 0x02U
+/** indicates this pbuf is UDP multicast to be looped back */
+#define PBUF_FLAG_MCASTLOOP 0x04U
+/** indicates this pbuf was received as link-level broadcast */
+#define PBUF_FLAG_LLBCAST   0x08U
+/** indicates this pbuf was received as link-level multicast */
+#define PBUF_FLAG_LLMCAST   0x10U
+/** indicates this pbuf includes a TCP FIN flag */
+#define PBUF_FLAG_TCP_FIN   0x20U
+
+/** Main packet buffer struct */
+struct pbuf {
+  /** next pbuf in singly linked pbuf chain */
+  struct pbuf *next;
+
+  /** pointer to the actual data in the buffer */
+  void *payload;
+
+  /**
+   * total length of this buffer and all next buffers in chain
+   * belonging to the same packet.
+   *
+   * For non-queue packet chains this is the invariant:
+   * p->tot_len == p->len + (p->next? p->next->tot_len: 0)
+   */
+  u16_t tot_len;
+
+  /** length of this buffer */
+  u16_t len;
+
+  /** pbuf_type as u8_t instead of enum to save space */
+  u8_t /*pbuf_type*/ type;
+
+  /** misc flags */
+  u8_t flags;
+
+  /**
+   * the reference count always equals the number of pointers
+   * that refer to this pbuf. This can be pointers from an application,
+   * the stack itself, or pbuf->next pointers from a chain.
+   */
+  u16_t ref;
+
+#if LWIP_PBUF_FROM_CUSTOM_POOLS
+  /** Pool from which pbuf was allocated */
+  u16_t pool;
+#endif
+};
+
+
+/** Helper struct for const-correctness only.
+ * The only meaning of this one is to provide a const payload pointer
+ * for PBUF_ROM type.
+ */
+struct pbuf_rom {
+  /** next pbuf in singly linked pbuf chain */
+  struct pbuf *next;
+
+  /** pointer to the actual data in the buffer */
+  const void *payload;
+};
+
+#if LWIP_SUPPORT_CUSTOM_PBUF
+/** Prototype for a function to free a custom pbuf */
+typedef void (*pbuf_free_custom_fn)(struct pbuf *p);
+
+/** A custom pbuf: like a pbuf, but following a function pointer to free it. */
+struct pbuf_custom {
+  /** The actual pbuf */
+  struct pbuf pbuf;
+  /** This function is called when pbuf_free deallocates this pbuf(_custom) */
+  pbuf_free_custom_fn custom_free_function;
+};
+#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
+
+/** Define this to 0 to prevent freeing ooseq pbufs when the PBUF_POOL is empty */
+#ifndef PBUF_POOL_FREE_OOSEQ
+#define PBUF_POOL_FREE_OOSEQ 1
+#endif /* PBUF_POOL_FREE_OOSEQ */
+#if LWIP_TCP && TCP_QUEUE_OOSEQ && NO_SYS && PBUF_POOL_FREE_OOSEQ
+extern volatile u8_t pbuf_free_ooseq_pending;
+void pbuf_free_ooseq(void);
+/** When not using sys_check_timeouts(), call PBUF_CHECK_FREE_OOSEQ()
+    at regular intervals from main level to check if ooseq pbufs need to be
+    freed! */
+#define PBUF_CHECK_FREE_OOSEQ() do { if(pbuf_free_ooseq_pending) { \
+  /* pbuf_alloc() reported PBUF_POOL to be empty -> try to free some \
+     ooseq queued pbufs now */ \
+  pbuf_free_ooseq(); }}while(0)
+#else /* LWIP_TCP && TCP_QUEUE_OOSEQ && NO_SYS && PBUF_POOL_FREE_OOSEQ */
+  /* Otherwise declare an empty PBUF_CHECK_FREE_OOSEQ */
+  #define PBUF_CHECK_FREE_OOSEQ()
+#endif /* LWIP_TCP && TCP_QUEUE_OOSEQ && NO_SYS && PBUF_POOL_FREE_OOSEQ*/
+
+/* Initializes the pbuf module. This call is empty for now, but may not be in future. */
+#define pbuf_init()
+
+struct pbuf *pbuf_alloc(pbuf_layer l, u16_t length, pbuf_type type);
+#if LWIP_SUPPORT_CUSTOM_PBUF
+struct pbuf *pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type,
+                                 struct pbuf_custom *p, void *payload_mem,
+                                 u16_t payload_mem_len);
+#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
+struct pbuf *pbuf_rightsize(struct pbuf *p, s16_t offset);
+void pbuf_realloc(struct pbuf *p, u16_t size);
+u8_t pbuf_header(struct pbuf *p, s16_t header_size);
+u8_t pbuf_header_force(struct pbuf *p, s16_t header_size);
+void pbuf_ref(struct pbuf *p);
+u8_t pbuf_free(struct pbuf *p);
+u16_t pbuf_clen(const struct pbuf *p);
+void pbuf_cat(struct pbuf *head, struct pbuf *tail);
+void pbuf_chain(struct pbuf *head, struct pbuf *tail);
+struct pbuf *pbuf_dechain(struct pbuf *p);
+err_t pbuf_copy(struct pbuf *p_to, const struct pbuf *p_from);
+u16_t pbuf_copy_partial(const struct pbuf *p, void *dataptr, u16_t len, u16_t offset);
+err_t pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len);
+err_t pbuf_take_at(struct pbuf *buf, const void *dataptr, u16_t len, u16_t offset);
+struct pbuf *pbuf_skip(struct pbuf* in, u16_t in_offset, u16_t* out_offset);
+struct pbuf *pbuf_coalesce(struct pbuf *p, pbuf_layer layer);
+#if LWIP_CHECKSUM_ON_COPY
+err_t pbuf_fill_chksum(struct pbuf *p, u16_t start_offset, const void *dataptr,
+                       u16_t len, u16_t *chksum);
+#endif /* LWIP_CHECKSUM_ON_COPY */
+#if LWIP_TCP && TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
+void pbuf_split_64k(struct pbuf *p, struct pbuf **rest);
+#endif /* LWIP_TCP && TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
+
+u8_t pbuf_get_at(const struct pbuf* p, u16_t offset);
+int pbuf_try_get_at(const struct pbuf* p, u16_t offset);
+void pbuf_put_at(struct pbuf* p, u16_t offset, u8_t data);
+u16_t pbuf_memcmp(const struct pbuf* p, u16_t offset, const void* s2, u16_t n);
+u16_t pbuf_memfind(const struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset);
+u16_t pbuf_strstr(const struct pbuf* p, const char* substr);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PBUF_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/priv/api_msg.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/priv/api_msg.h
new file mode 100644
index 000000000..f12b8b7d4
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/priv/api_msg.h
@@ -0,0 +1,216 @@
+/**
+ * @file
+ * netconn API lwIP internal implementations (do not use in application code)
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_API_MSG_H
+#define LWIP_HDR_API_MSG_H
+
+#include "lwip/opt.h"
+
+#if LWIP_NETCONN || LWIP_SOCKET /* don't build if not configured for use in lwipopts.h */
+/* Note: Netconn API is always available when sockets are enabled -
+ * sockets are implemented on top of them */
+
+#include "lwip/arch.h"
+#include "lwip/ip_addr.h"
+#include "lwip/err.h"
+#include "lwip/sys.h"
+#include "lwip/igmp.h"
+#include "lwip/api.h"
+#include "lwip/priv/tcpip_priv.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_MPU_COMPATIBLE
+#if LWIP_NETCONN_SEM_PER_THREAD
+#define API_MSG_M_DEF_SEM(m)  *m
+#else
+#define API_MSG_M_DEF_SEM(m)  API_MSG_M_DEF(m)
+#endif
+#else /* LWIP_MPU_COMPATIBLE */
+#define API_MSG_M_DEF_SEM(m)  API_MSG_M_DEF(m)
+#endif /* LWIP_MPU_COMPATIBLE */
+
+/* For the netconn API, these values are use as a bitmask! */
+#define NETCONN_SHUT_RD   1
+#define NETCONN_SHUT_WR   2
+#define NETCONN_SHUT_RDWR (NETCONN_SHUT_RD | NETCONN_SHUT_WR)
+
+/* IP addresses and port numbers are expected to be in
+ * the same byte order as in the corresponding pcb.
+ */
+/** This struct includes everything that is necessary to execute a function
+    for a netconn in another thread context (mainly used to process netconns
+    in the tcpip_thread context to be thread safe). */
+struct api_msg {
+  /** The netconn which to process - always needed: it includes the semaphore
+      which is used to block the application thread until the function finished. */
+  struct netconn *conn;
+  /** The return value of the function executed in tcpip_thread. */
+  err_t err;
+  /** Depending on the executed function, one of these union members is used */
+  union {
+    /** used for lwip_netconn_do_send */
+    struct netbuf *b;
+    /** used for lwip_netconn_do_newconn */
+    struct {
+      u8_t proto;
+    } n;
+    /** used for lwip_netconn_do_bind and lwip_netconn_do_connect */
+    struct {
+      API_MSG_M_DEF_C(ip_addr_t, ipaddr);
+      u16_t port;
+    } bc;
+    /** used for lwip_netconn_do_getaddr */
+    struct {
+      ip_addr_t API_MSG_M_DEF(ipaddr);
+      u16_t API_MSG_M_DEF(port);
+      u8_t local;
+    } ad;
+    /** used for lwip_netconn_do_write */
+    struct {
+      const void *dataptr;
+      size_t len;
+      u8_t apiflags;
+#if LWIP_SO_SNDTIMEO
+      u32_t time_started;
+#endif /* LWIP_SO_SNDTIMEO */
+    } w;
+    /** used for lwip_netconn_do_recv */
+    struct {
+      u32_t len;
+    } r;
+#if LWIP_TCP
+    /** used for lwip_netconn_do_close (/shutdown) */
+    struct {
+      u8_t shut;
+#if LWIP_SO_SNDTIMEO || LWIP_SO_LINGER
+      u32_t time_started;
+#else /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
+      u8_t polls_left;
+#endif /* LWIP_SO_SNDTIMEO || LWIP_SO_LINGER */
+    } sd;
+#endif /* LWIP_TCP */
+#if LWIP_IGMP || (LWIP_IPV6 && LWIP_IPV6_MLD)
+    /** used for lwip_netconn_do_join_leave_group */
+    struct {
+      API_MSG_M_DEF_C(ip_addr_t, multiaddr);
+      API_MSG_M_DEF_C(ip_addr_t, netif_addr);
+      enum netconn_igmp join_or_leave;
+    } jl;
+#endif /* LWIP_IGMP || (LWIP_IPV6 && LWIP_IPV6_MLD) */
+#if TCP_LISTEN_BACKLOG
+    struct {
+      u8_t backlog;
+    } lb;
+#endif /* TCP_LISTEN_BACKLOG */
+  } msg;
+#if LWIP_NETCONN_SEM_PER_THREAD
+  sys_sem_t* op_completed_sem;
+#endif /* LWIP_NETCONN_SEM_PER_THREAD */
+};
+
+#if LWIP_NETCONN_SEM_PER_THREAD
+#define LWIP_API_MSG_SEM(msg)          ((msg)->op_completed_sem)
+#else /* LWIP_NETCONN_SEM_PER_THREAD */
+#define LWIP_API_MSG_SEM(msg)          (&(msg)->conn->op_completed)
+#endif /* LWIP_NETCONN_SEM_PER_THREAD */
+
+
+#if LWIP_DNS
+/** As lwip_netconn_do_gethostbyname requires more arguments but doesn't require a netconn,
+    it has its own struct (to avoid struct api_msg getting bigger than necessary).
+    lwip_netconn_do_gethostbyname must be called using tcpip_callback instead of tcpip_apimsg
+    (see netconn_gethostbyname). */
+struct dns_api_msg {
+  /** Hostname to query or dotted IP address string */
+#if LWIP_MPU_COMPATIBLE
+  char name[DNS_MAX_NAME_LENGTH];
+#else /* LWIP_MPU_COMPATIBLE */
+  const char *name;
+#endif /* LWIP_MPU_COMPATIBLE */
+  /** The resolved address is stored here */
+  ip_addr_t API_MSG_M_DEF(addr);
+#if LWIP_IPV4 && LWIP_IPV6
+  /** Type of resolve call */
+  u8_t dns_addrtype;
+#endif /* LWIP_IPV4 && LWIP_IPV6 */
+  /** This semaphore is posted when the name is resolved, the application thread
+      should wait on it. */
+  sys_sem_t API_MSG_M_DEF_SEM(sem);
+  /** Errors are given back here */
+  err_t API_MSG_M_DEF(err);
+};
+#endif /* LWIP_DNS */
+
+#if LWIP_TCP
+extern u8_t netconn_aborted;
+#endif /* LWIP_TCP */
+
+void lwip_netconn_do_newconn         (void *m);
+void lwip_netconn_do_delconn         (void *m);
+void lwip_netconn_do_bind            (void *m);
+void lwip_netconn_do_connect         (void *m);
+void lwip_netconn_do_disconnect      (void *m);
+void lwip_netconn_do_listen          (void *m);
+void lwip_netconn_do_send            (void *m);
+void lwip_netconn_do_recv            (void *m);
+#if TCP_LISTEN_BACKLOG
+void lwip_netconn_do_accepted        (void *m);
+#endif /* TCP_LISTEN_BACKLOG */
+void lwip_netconn_do_write           (void *m);
+void lwip_netconn_do_getaddr         (void *m);
+void lwip_netconn_do_close           (void *m);
+void lwip_netconn_do_shutdown        (void *m);
+#if LWIP_IGMP || (LWIP_IPV6 && LWIP_IPV6_MLD)
+void lwip_netconn_do_join_leave_group(void *m);
+#endif /* LWIP_IGMP || (LWIP_IPV6 && LWIP_IPV6_MLD) */
+
+#if LWIP_DNS
+void lwip_netconn_do_gethostbyname(void *arg);
+#endif /* LWIP_DNS */
+
+struct netconn* netconn_alloc(enum netconn_type t, netconn_callback callback);
+void netconn_free(struct netconn *conn);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_NETCONN || LWIP_SOCKET */
+
+#endif /* LWIP_HDR_API_MSG_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/priv/memp_priv.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/priv/memp_priv.h
new file mode 100644
index 000000000..f246061da
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/priv/memp_priv.h
@@ -0,0 +1,183 @@
+/**
+ * @file
+ * memory pools lwIP internal implementations (do not use in application code)
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+#ifndef LWIP_HDR_MEMP_PRIV_H
+#define LWIP_HDR_MEMP_PRIV_H
+
+#include "lwip/opt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "lwip/mem.h"
+
+#if MEMP_OVERFLOW_CHECK
+/* if MEMP_OVERFLOW_CHECK is turned on, we reserve some bytes at the beginning
+ * and at the end of each element, initialize them as 0xcd and check
+ * them later. */
+/* If MEMP_OVERFLOW_CHECK is >= 2, on every call to memp_malloc or memp_free,
+ * every single element in each pool is checked!
+ * This is VERY SLOW but also very helpful. */
+/* MEMP_SANITY_REGION_BEFORE and MEMP_SANITY_REGION_AFTER can be overridden in
+ * lwipopts.h to change the amount reserved for checking. */
+#ifndef MEMP_SANITY_REGION_BEFORE
+#define MEMP_SANITY_REGION_BEFORE  16
+#endif /* MEMP_SANITY_REGION_BEFORE*/
+#if MEMP_SANITY_REGION_BEFORE > 0
+#define MEMP_SANITY_REGION_BEFORE_ALIGNED    LWIP_MEM_ALIGN_SIZE(MEMP_SANITY_REGION_BEFORE)
+#else
+#define MEMP_SANITY_REGION_BEFORE_ALIGNED    0
+#endif /* MEMP_SANITY_REGION_BEFORE*/
+#ifndef MEMP_SANITY_REGION_AFTER
+#define MEMP_SANITY_REGION_AFTER   16
+#endif /* MEMP_SANITY_REGION_AFTER*/
+#if MEMP_SANITY_REGION_AFTER > 0
+#define MEMP_SANITY_REGION_AFTER_ALIGNED     LWIP_MEM_ALIGN_SIZE(MEMP_SANITY_REGION_AFTER)
+#else
+#define MEMP_SANITY_REGION_AFTER_ALIGNED     0
+#endif /* MEMP_SANITY_REGION_AFTER*/
+
+/* MEMP_SIZE: save space for struct memp and for sanity check */
+#define MEMP_SIZE          (LWIP_MEM_ALIGN_SIZE(sizeof(struct memp)) + MEMP_SANITY_REGION_BEFORE_ALIGNED)
+#define MEMP_ALIGN_SIZE(x) (LWIP_MEM_ALIGN_SIZE(x) + MEMP_SANITY_REGION_AFTER_ALIGNED)
+
+#else /* MEMP_OVERFLOW_CHECK */
+
+/* No sanity checks
+ * We don't need to preserve the struct memp while not allocated, so we
+ * can save a little space and set MEMP_SIZE to 0.
+ */
+#define MEMP_SIZE           0
+#define MEMP_ALIGN_SIZE(x) (LWIP_MEM_ALIGN_SIZE(x))
+
+#endif /* MEMP_OVERFLOW_CHECK */
+
+#if !MEMP_MEM_MALLOC || MEMP_OVERFLOW_CHECK
+struct memp {
+  struct memp *next;
+#if MEMP_OVERFLOW_CHECK
+  const char *file;
+  int line;
+#endif /* MEMP_OVERFLOW_CHECK */
+};
+#endif /* !MEMP_MEM_MALLOC || MEMP_OVERFLOW_CHECK */
+
+#if MEM_USE_POOLS && MEMP_USE_CUSTOM_POOLS
+/* Use a helper type to get the start and end of the user "memory pools" for mem_malloc */
+typedef enum {
+    /* Get the first (via:
+       MEMP_POOL_HELPER_START = ((u8_t) 1*MEMP_POOL_A + 0*MEMP_POOL_B + 0*MEMP_POOL_C + 0)*/
+    MEMP_POOL_HELPER_FIRST = ((u8_t)
+#define LWIP_MEMPOOL(name,num,size,desc)
+#define LWIP_MALLOC_MEMPOOL_START 1
+#define LWIP_MALLOC_MEMPOOL(num, size) * MEMP_POOL_##size + 0
+#define LWIP_MALLOC_MEMPOOL_END
+#include "lwip/priv/memp_std.h"
+    ) ,
+    /* Get the last (via:
+       MEMP_POOL_HELPER_END = ((u8_t) 0 + MEMP_POOL_A*0 + MEMP_POOL_B*0 + MEMP_POOL_C*1) */
+    MEMP_POOL_HELPER_LAST = ((u8_t)
+#define LWIP_MEMPOOL(name,num,size,desc)
+#define LWIP_MALLOC_MEMPOOL_START
+#define LWIP_MALLOC_MEMPOOL(num, size) 0 + MEMP_POOL_##size *
+#define LWIP_MALLOC_MEMPOOL_END 1
+#include "lwip/priv/memp_std.h"
+    )
+} memp_pool_helper_t;
+
+/* The actual start and stop values are here (cast them over)
+   We use this helper type and these defines so we can avoid using const memp_t values */
+#define MEMP_POOL_FIRST ((memp_t) MEMP_POOL_HELPER_FIRST)
+#define MEMP_POOL_LAST   ((memp_t) MEMP_POOL_HELPER_LAST)
+#endif /* MEM_USE_POOLS && MEMP_USE_CUSTOM_POOLS */
+
+/** Memory pool descriptor */
+struct memp_desc {
+#if defined(LWIP_DEBUG) || MEMP_OVERFLOW_CHECK || LWIP_STATS_DISPLAY
+  /** Textual description */
+  const char *desc;
+#endif /* LWIP_DEBUG || MEMP_OVERFLOW_CHECK || LWIP_STATS_DISPLAY */
+#if MEMP_STATS
+  /** Statistics */
+  struct stats_mem *stats;
+#endif
+
+  /** Element size */
+  u16_t size;
+
+#if !MEMP_MEM_MALLOC
+  /** Number of elements */
+  u16_t num;
+
+  /** Base address */
+  u8_t *base;
+
+  /** First free element of each pool. Elements form a linked list. */
+  struct memp **tab;
+#endif /* MEMP_MEM_MALLOC */
+};
+
+#if defined(LWIP_DEBUG) || MEMP_OVERFLOW_CHECK || LWIP_STATS_DISPLAY
+#define DECLARE_LWIP_MEMPOOL_DESC(desc) (desc),
+#else
+#define DECLARE_LWIP_MEMPOOL_DESC(desc)
+#endif
+
+#if MEMP_STATS
+#define LWIP_MEMPOOL_DECLARE_STATS_INSTANCE(name) static struct stats_mem name;
+#define LWIP_MEMPOOL_DECLARE_STATS_REFERENCE(name) &name,
+#else
+#define LWIP_MEMPOOL_DECLARE_STATS_INSTANCE(name)
+#define LWIP_MEMPOOL_DECLARE_STATS_REFERENCE(name)
+#endif
+
+void memp_init_pool(const struct memp_desc *desc);
+
+#if MEMP_OVERFLOW_CHECK
+void *memp_malloc_pool_fn(const struct memp_desc* desc, const char* file, const int line);
+#define memp_malloc_pool(d) memp_malloc_pool_fn((d), __FILE__, __LINE__)
+#else
+void *memp_malloc_pool(const struct memp_desc *desc);
+#endif
+void  memp_free_pool(const struct memp_desc* desc, void *mem);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_MEMP_PRIV_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/priv/memp_std.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/priv/memp_std.h
new file mode 100644
index 000000000..d39106744
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/priv/memp_std.h
@@ -0,0 +1,146 @@
+/**
+ * @file
+ * lwIP internal memory pools (do not use in application code)
+ * This file is deliberately included multiple times: once with empty
+ * definition of LWIP_MEMPOOL() to handle all includes and multiple times
+ * to build up various lists of mem pools.
+ */
+
+/*
+ * SETUP: Make sure we define everything we will need.
+ *
+ * We have create three types of pools:
+ *   1) MEMPOOL - standard pools
+ *   2) MALLOC_MEMPOOL - to be used by mem_malloc in mem.c
+ *   3) PBUF_MEMPOOL - a mempool of pbuf's, so include space for the pbuf struct
+ *
+ * If the include'r doesn't require any special treatment of each of the types
+ * above, then will declare #2 & #3 to be just standard mempools.
+ */
+#ifndef LWIP_MALLOC_MEMPOOL
+/* This treats "malloc pools" just like any other pool.
+   The pools are a little bigger to provide 'size' as the amount of user data. */
+#define LWIP_MALLOC_MEMPOOL(num, size) LWIP_MEMPOOL(POOL_##size, num, (size + LWIP_MEM_ALIGN_SIZE(sizeof(struct memp_malloc_helper))), "MALLOC_"#size)
+#define LWIP_MALLOC_MEMPOOL_START
+#define LWIP_MALLOC_MEMPOOL_END
+#endif /* LWIP_MALLOC_MEMPOOL */
+
+#ifndef LWIP_PBUF_MEMPOOL
+/* This treats "pbuf pools" just like any other pool.
+ * Allocates buffers for a pbuf struct AND a payload size */
+#define LWIP_PBUF_MEMPOOL(name, num, payload, desc) LWIP_MEMPOOL(name, num, (MEMP_ALIGN_SIZE(sizeof(struct pbuf)) + MEMP_ALIGN_SIZE(payload)), desc)
+#endif /* LWIP_PBUF_MEMPOOL */
+
+
+/*
+ * A list of internal pools used by LWIP.
+ *
+ * LWIP_MEMPOOL(pool_name, number_elements, element_size, pool_description)
+ *     creates a pool name MEMP_pool_name. description is used in stats.c
+ */
+#if LWIP_RAW
+LWIP_MEMPOOL(RAW_PCB,        MEMP_NUM_RAW_PCB,         sizeof(struct raw_pcb),        "RAW_PCB")
+#endif /* LWIP_RAW */
+
+#if LWIP_UDP
+LWIP_MEMPOOL(UDP_PCB,        MEMP_NUM_UDP_PCB,         sizeof(struct udp_pcb),        "UDP_PCB")
+#endif /* LWIP_UDP */
+
+#if LWIP_TCP
+LWIP_MEMPOOL(TCP_PCB,        MEMP_NUM_TCP_PCB,         sizeof(struct tcp_pcb),        "TCP_PCB")
+LWIP_MEMPOOL(TCP_PCB_LISTEN, MEMP_NUM_TCP_PCB_LISTEN,  sizeof(struct tcp_pcb_listen), "TCP_PCB_LISTEN")
+LWIP_MEMPOOL(TCP_SEG,        MEMP_NUM_TCP_SEG,         sizeof(struct tcp_seg),        "TCP_SEG")
+#endif /* LWIP_TCP */
+
+#if LWIP_IPV4 && IP_REASSEMBLY
+LWIP_MEMPOOL(REASSDATA,      MEMP_NUM_REASSDATA,       sizeof(struct ip_reassdata),   "REASSDATA")
+#endif /* LWIP_IPV4 && IP_REASSEMBLY */
+#if (IP_FRAG && !LWIP_NETIF_TX_SINGLE_PBUF) || (LWIP_IPV6 && LWIP_IPV6_FRAG)
+LWIP_MEMPOOL(FRAG_PBUF,      MEMP_NUM_FRAG_PBUF,       sizeof(struct pbuf_custom_ref),"FRAG_PBUF")
+#endif /* IP_FRAG && !LWIP_NETIF_TX_SINGLE_PBUF || (LWIP_IPV6 && LWIP_IPV6_FRAG) */
+
+#if LWIP_NETCONN || LWIP_SOCKET
+LWIP_MEMPOOL(NETBUF,         MEMP_NUM_NETBUF,          sizeof(struct netbuf),         "NETBUF")
+LWIP_MEMPOOL(NETCONN,        MEMP_NUM_NETCONN,         sizeof(struct netconn),        "NETCONN")
+#endif /* LWIP_NETCONN || LWIP_SOCKET */
+
+#if NO_SYS==0
+LWIP_MEMPOOL(TCPIP_MSG_API,  MEMP_NUM_TCPIP_MSG_API,   sizeof(struct tcpip_msg),      "TCPIP_MSG_API")
+#if LWIP_MPU_COMPATIBLE
+LWIP_MEMPOOL(API_MSG,        MEMP_NUM_API_MSG,         sizeof(struct api_msg),        "API_MSG")
+#if LWIP_DNS
+LWIP_MEMPOOL(DNS_API_MSG,    MEMP_NUM_DNS_API_MSG,     sizeof(struct dns_api_msg),    "DNS_API_MSG")
+#endif
+#if LWIP_SOCKET && !LWIP_TCPIP_CORE_LOCKING
+LWIP_MEMPOOL(SOCKET_SETGETSOCKOPT_DATA, MEMP_NUM_SOCKET_SETGETSOCKOPT_DATA, sizeof(struct lwip_setgetsockopt_data), "SOCKET_SETGETSOCKOPT_DATA")
+#endif
+#if LWIP_NETIF_API
+LWIP_MEMPOOL(NETIFAPI_MSG,   MEMP_NUM_NETIFAPI_MSG,    sizeof(struct netifapi_msg),   "NETIFAPI_MSG")
+#endif
+#endif /* LWIP_MPU_COMPATIBLE */
+#if !LWIP_TCPIP_CORE_LOCKING_INPUT
+LWIP_MEMPOOL(TCPIP_MSG_INPKT,MEMP_NUM_TCPIP_MSG_INPKT, sizeof(struct tcpip_msg),      "TCPIP_MSG_INPKT")
+#endif /* !LWIP_TCPIP_CORE_LOCKING_INPUT */
+#endif /* NO_SYS==0 */
+
+#if LWIP_IPV4 && LWIP_ARP && ARP_QUEUEING
+LWIP_MEMPOOL(ARP_QUEUE,      MEMP_NUM_ARP_QUEUE,       sizeof(struct etharp_q_entry), "ARP_QUEUE")
+#endif /* LWIP_IPV4 && LWIP_ARP && ARP_QUEUEING */
+
+#if LWIP_IGMP
+LWIP_MEMPOOL(IGMP_GROUP,     MEMP_NUM_IGMP_GROUP,      sizeof(struct igmp_group),     "IGMP_GROUP")
+#endif /* LWIP_IGMP */
+
+#if LWIP_TIMERS && !LWIP_TIMERS_CUSTOM
+LWIP_MEMPOOL(SYS_TIMEOUT,    MEMP_NUM_SYS_TIMEOUT,     sizeof(struct sys_timeo),      "SYS_TIMEOUT")
+#endif /* LWIP_TIMERS && !LWIP_TIMERS_CUSTOM */
+
+#if LWIP_DNS && LWIP_SOCKET
+LWIP_MEMPOOL(NETDB,          MEMP_NUM_NETDB,           NETDB_ELEM_SIZE,               "NETDB")
+#endif /* LWIP_DNS && LWIP_SOCKET */
+#if LWIP_DNS && DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC
+LWIP_MEMPOOL(LOCALHOSTLIST,  MEMP_NUM_LOCALHOSTLIST,   LOCALHOSTLIST_ELEM_SIZE,       "LOCALHOSTLIST")
+#endif /* LWIP_DNS && DNS_LOCAL_HOSTLIST && DNS_LOCAL_HOSTLIST_IS_DYNAMIC */
+
+#if LWIP_IPV6 && LWIP_ND6_QUEUEING
+LWIP_MEMPOOL(ND6_QUEUE,      MEMP_NUM_ND6_QUEUE,       sizeof(struct nd6_q_entry), "ND6_QUEUE")
+#endif /* LWIP_IPV6 && LWIP_ND6_QUEUEING */
+
+#if LWIP_IPV6 && LWIP_IPV6_REASS
+LWIP_MEMPOOL(IP6_REASSDATA,      MEMP_NUM_REASSDATA,       sizeof(struct ip6_reassdata),   "IP6_REASSDATA")
+#endif /* LWIP_IPV6 && LWIP_IPV6_REASS */
+
+#if LWIP_IPV6 && LWIP_IPV6_ND && LWIP_IPV6_MLD
+LWIP_MEMPOOL(MLD6_GROUP,     MEMP_NUM_MLD6_GROUP,      sizeof(struct mld_group),     "MLD6_GROUP")
+#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
+
+
+/*
+ * A list of pools of pbuf's used by LWIP.
+ *
+ * LWIP_PBUF_MEMPOOL(pool_name, number_elements, pbuf_payload_size, pool_description)
+ *     creates a pool name MEMP_pool_name. description is used in stats.c
+ *     This allocates enough space for the pbuf struct and a payload.
+ *     (Example: pbuf_payload_size=0 allocates only size for the struct)
+ */
+LWIP_PBUF_MEMPOOL(PBUF,      MEMP_NUM_PBUF,            0,                             "PBUF_REF/ROM")
+LWIP_PBUF_MEMPOOL(PBUF_POOL, PBUF_POOL_SIZE,           PBUF_POOL_BUFSIZE,             "PBUF_POOL")
+
+
+/*
+ * Allow for user-defined pools; this must be explicitly set in lwipopts.h
+ * since the default is to NOT look for lwippools.h
+ */
+#if MEMP_USE_CUSTOM_POOLS
+#include "lwippools.h"
+#endif /* MEMP_USE_CUSTOM_POOLS */
+
+/*
+ * REQUIRED CLEANUP: Clear up so we don't get "multiply defined" error later
+ * (#undef is ignored for something that is not defined)
+ */
+#undef LWIP_MEMPOOL
+#undef LWIP_MALLOC_MEMPOOL
+#undef LWIP_MALLOC_MEMPOOL_START
+#undef LWIP_MALLOC_MEMPOOL_END
+#undef LWIP_PBUF_MEMPOOL
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/priv/nd6_priv.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/priv/nd6_priv.h
new file mode 100644
index 000000000..5d7731ca9
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/priv/nd6_priv.h
@@ -0,0 +1,140 @@
+/**
+ * @file
+ *
+ * Neighbor discovery and stateless address autoconfiguration for IPv6.
+ * Aims to be compliant with RFC 4861 (Neighbor discovery) and RFC 4862
+ * (Address autoconfiguration).
+ */
+
+/*
+ * Copyright (c) 2010 Inico Technologies Ltd.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Ivan Delamer <delamer@inicotech.com>
+ *
+ *
+ * Please coordinate changes and requests with Ivan Delamer
+ * <delamer@inicotech.com>
+ */
+
+#ifndef LWIP_HDR_ND6_PRIV_H
+#define LWIP_HDR_ND6_PRIV_H
+
+#include "lwip/opt.h"
+
+#if LWIP_IPV6  /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/pbuf.h"
+#include "lwip/ip6_addr.h"
+#include "lwip/netif.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_ND6_QUEUEING
+/** struct for queueing outgoing packets for unknown address
+  * defined here to be accessed by memp.h
+  */
+struct nd6_q_entry {
+  struct nd6_q_entry *next;
+  struct pbuf *p;
+};
+#endif /* LWIP_ND6_QUEUEING */
+
+/** Struct for tables. */
+struct nd6_neighbor_cache_entry {
+  ip6_addr_t next_hop_address;
+  struct netif *netif;
+  u8_t lladdr[NETIF_MAX_HWADDR_LEN];
+  /*u32_t pmtu;*/
+#if LWIP_ND6_QUEUEING
+  /** Pointer to queue of pending outgoing packets on this entry. */
+  struct nd6_q_entry *q;
+#else /* LWIP_ND6_QUEUEING */
+  /** Pointer to a single pending outgoing packet on this entry. */
+  struct pbuf *q;
+#endif /* LWIP_ND6_QUEUEING */
+  u8_t state;
+  u8_t isrouter;
+  union {
+    u32_t reachable_time; /* in seconds */
+    u32_t delay_time;     /* ticks (ND6_TMR_INTERVAL) */
+    u32_t probes_sent;
+    u32_t stale_time;     /* ticks (ND6_TMR_INTERVAL) */
+  } counter;
+};
+
+struct nd6_destination_cache_entry {
+  ip6_addr_t destination_addr;
+  ip6_addr_t next_hop_addr;
+  u16_t pmtu;
+  u32_t age;
+};
+
+struct nd6_prefix_list_entry {
+  ip6_addr_t prefix;
+  struct netif *netif;
+  u32_t invalidation_timer; /* in seconds */
+};
+
+struct nd6_router_list_entry {
+  struct nd6_neighbor_cache_entry *neighbor_entry;
+  u32_t invalidation_timer; /* in seconds */
+  u8_t flags;
+};
+
+enum nd6_neighbor_cache_entry_state {
+  ND6_NO_ENTRY = 0,
+  ND6_INCOMPLETE,
+  ND6_REACHABLE,
+  ND6_STALE,
+  ND6_DELAY,
+  ND6_PROBE
+};
+
+#define ND6_2HRS 7200 /* two hours, expressed in number of seconds */
+
+/* Router tables. */
+/* @todo make these static? and entries accessible through API? */
+extern struct nd6_neighbor_cache_entry neighbor_cache[];
+extern struct nd6_destination_cache_entry destination_cache[];
+extern struct nd6_prefix_list_entry prefix_list[];
+extern struct nd6_router_list_entry default_router_list[];
+
+/* Default values, can be updated by a RA message. */
+extern u32_t reachable_time;
+extern u32_t retrans_timer;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_IPV6 */
+
+#endif /* LWIP_HDR_ND6_PRIV_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/priv/tcp_priv.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/priv/tcp_priv.h
new file mode 100644
index 000000000..73e8967e4
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/priv/tcp_priv.h
@@ -0,0 +1,507 @@
+/**
+ * @file
+ * TCP internal implementations (do not use in application code)
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_TCP_PRIV_H
+#define LWIP_HDR_TCP_PRIV_H
+
+#include "lwip/opt.h"
+
+#if LWIP_TCP /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/tcp.h"
+#include "lwip/mem.h"
+#include "lwip/pbuf.h"
+#include "lwip/ip.h"
+#include "lwip/icmp.h"
+#include "lwip/err.h"
+#include "lwip/ip6.h"
+#include "lwip/ip6_addr.h"
+#include "lwip/prot/tcp.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Functions for interfacing with TCP: */
+
+/* Lower layer interface to TCP: */
+void             tcp_init    (void);  /* Initialize this module. */
+void             tcp_tmr     (void);  /* Must be called every
+                                         TCP_TMR_INTERVAL
+                                         ms. (Typically 250 ms). */
+/* It is also possible to call these two functions at the right
+   intervals (instead of calling tcp_tmr()). */
+void             tcp_slowtmr (void);
+void             tcp_fasttmr (void);
+
+/* Call this from a netif driver (watch out for threading issues!) that has
+   returned a memory error on transmit and now has free buffers to send more.
+   This iterates all active pcbs that had an error and tries to call
+   tcp_output, so use this with care as it might slow down the system. */
+void             tcp_txnow   (void);
+
+/* Only used by IP to pass a TCP segment to TCP: */
+void             tcp_input   (struct pbuf *p, struct netif *inp);
+/* Used within the TCP code only: */
+struct tcp_pcb * tcp_alloc   (u8_t prio);
+void             tcp_abandon (struct tcp_pcb *pcb, int reset);
+err_t            tcp_send_empty_ack(struct tcp_pcb *pcb);
+void             tcp_rexmit  (struct tcp_pcb *pcb);
+void             tcp_rexmit_rto  (struct tcp_pcb *pcb);
+void             tcp_rexmit_fast (struct tcp_pcb *pcb);
+u32_t            tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb);
+err_t            tcp_process_refused_data(struct tcp_pcb *pcb);
+
+/**
+ * This is the Nagle algorithm: try to combine user data to send as few TCP
+ * segments as possible. Only send if
+ * - no previously transmitted data on the connection remains unacknowledged or
+ * - the TF_NODELAY flag is set (nagle algorithm turned off for this pcb) or
+ * - the only unsent segment is at least pcb->mss bytes long (or there is more
+ *   than one unsent segment - with lwIP, this can happen although unsent->len < mss)
+ * - or if we are in fast-retransmit (TF_INFR)
+ */
+#define tcp_do_output_nagle(tpcb) ((((tpcb)->unacked == NULL) || \
+                            ((tpcb)->flags & (TF_NODELAY | TF_INFR)) || \
+                            (((tpcb)->unsent != NULL) && (((tpcb)->unsent->next != NULL) || \
+                              ((tpcb)->unsent->len >= (tpcb)->mss))) || \
+                            ((tcp_sndbuf(tpcb) == 0) || (tcp_sndqueuelen(tpcb) >= TCP_SND_QUEUELEN)) \
+                            ) ? 1 : 0)
+#define tcp_output_nagle(tpcb) (tcp_do_output_nagle(tpcb) ? tcp_output(tpcb) : ERR_OK)
+
+
+#define TCP_SEQ_LT(a,b)     ((s32_t)((u32_t)(a) - (u32_t)(b)) < 0)
+#define TCP_SEQ_LEQ(a,b)    ((s32_t)((u32_t)(a) - (u32_t)(b)) <= 0)
+#define TCP_SEQ_GT(a,b)     ((s32_t)((u32_t)(a) - (u32_t)(b)) > 0)
+#define TCP_SEQ_GEQ(a,b)    ((s32_t)((u32_t)(a) - (u32_t)(b)) >= 0)
+/* is b<=a<=c? */
+#if 0 /* see bug #10548 */
+#define TCP_SEQ_BETWEEN(a,b,c) ((c)-(b) >= (a)-(b))
+#endif
+#define TCP_SEQ_BETWEEN(a,b,c) (TCP_SEQ_GEQ(a,b) && TCP_SEQ_LEQ(a,c))
+
+#ifndef TCP_TMR_INTERVAL
+#define TCP_TMR_INTERVAL       250  /* The TCP timer interval in milliseconds. */
+#endif /* TCP_TMR_INTERVAL */
+
+#ifndef TCP_FAST_INTERVAL
+#define TCP_FAST_INTERVAL      TCP_TMR_INTERVAL /* the fine grained timeout in milliseconds */
+#endif /* TCP_FAST_INTERVAL */
+
+#ifndef TCP_SLOW_INTERVAL
+#define TCP_SLOW_INTERVAL      (2*TCP_TMR_INTERVAL)  /* the coarse grained timeout in milliseconds */
+#endif /* TCP_SLOW_INTERVAL */
+
+#define TCP_FIN_WAIT_TIMEOUT 20000 /* milliseconds */
+#define TCP_SYN_RCVD_TIMEOUT 20000 /* milliseconds */
+
+#define TCP_OOSEQ_TIMEOUT        6U /* x RTO */
+
+#ifndef TCP_MSL
+#define TCP_MSL 60000UL /* The maximum segment lifetime in milliseconds */
+#endif
+
+/* Keepalive values, compliant with RFC 1122. Don't change this unless you know what you're doing */
+#ifndef  TCP_KEEPIDLE_DEFAULT
+#define  TCP_KEEPIDLE_DEFAULT     7200000UL /* Default KEEPALIVE timer in milliseconds */
+#endif
+
+#ifndef  TCP_KEEPINTVL_DEFAULT
+#define  TCP_KEEPINTVL_DEFAULT    75000UL   /* Default Time between KEEPALIVE probes in milliseconds */
+#endif
+
+#ifndef  TCP_KEEPCNT_DEFAULT
+#define  TCP_KEEPCNT_DEFAULT      9U        /* Default Counter for KEEPALIVE probes */
+#endif
+
+#define  TCP_MAXIDLE              TCP_KEEPCNT_DEFAULT * TCP_KEEPINTVL_DEFAULT  /* Maximum KEEPALIVE probe time */
+
+#define TCP_TCPLEN(seg) ((seg)->len + (((TCPH_FLAGS((seg)->tcphdr) & (TCP_FIN | TCP_SYN)) != 0) ? 1U : 0U))
+
+/** Flags used on input processing, not on pcb->flags
+*/
+#define TF_RESET     (u8_t)0x08U   /* Connection was reset. */
+#define TF_CLOSED    (u8_t)0x10U   /* Connection was successfully closed. */
+#define TF_GOT_FIN   (u8_t)0x20U   /* Connection was closed by the remote end. */
+
+
+#if LWIP_EVENT_API
+
+#define TCP_EVENT_ACCEPT(lpcb,pcb,arg,err,ret) ret = lwip_tcp_event(arg, (pcb),\
+                LWIP_EVENT_ACCEPT, NULL, 0, err)
+#define TCP_EVENT_SENT(pcb,space,ret) ret = lwip_tcp_event((pcb)->callback_arg, (pcb),\
+                   LWIP_EVENT_SENT, NULL, space, ERR_OK)
+#define TCP_EVENT_RECV(pcb,p,err,ret) ret = lwip_tcp_event((pcb)->callback_arg, (pcb),\
+                LWIP_EVENT_RECV, (p), 0, (err))
+#define TCP_EVENT_CLOSED(pcb,ret) ret = lwip_tcp_event((pcb)->callback_arg, (pcb),\
+                LWIP_EVENT_RECV, NULL, 0, ERR_OK)
+#define TCP_EVENT_CONNECTED(pcb,err,ret) ret = lwip_tcp_event((pcb)->callback_arg, (pcb),\
+                LWIP_EVENT_CONNECTED, NULL, 0, (err))
+#define TCP_EVENT_POLL(pcb,ret)       do { if ((pcb)->state != SYN_RCVD) {                          \
+                ret = lwip_tcp_event((pcb)->callback_arg, (pcb), LWIP_EVENT_POLL, NULL, 0, ERR_OK); \
+                } else {                                                                            \
+                ret = ERR_ARG; } } while(0)
+#define TCP_EVENT_ERR(last_state,errf,arg,err)  do { if (last_state != SYN_RCVD) {                \
+                lwip_tcp_event((arg), NULL, LWIP_EVENT_ERR, NULL, 0, (err)); } } while(0)
+
+#else /* LWIP_EVENT_API */
+
+#define TCP_EVENT_ACCEPT(lpcb,pcb,arg,err,ret)                 \
+  do {                                                         \
+    if((lpcb)->accept != NULL)                                 \
+      (ret) = (lpcb)->accept((arg),(pcb),(err));               \
+    else (ret) = ERR_ARG;                                      \
+  } while (0)
+
+#define TCP_EVENT_SENT(pcb,space,ret)                          \
+  do {                                                         \
+    if((pcb)->sent != NULL)                                    \
+      (ret) = (pcb)->sent((pcb)->callback_arg,(pcb),(space));  \
+    else (ret) = ERR_OK;                                       \
+  } while (0)
+
+#define TCP_EVENT_RECV(pcb,p,err,ret)                          \
+  do {                                                         \
+    if((pcb)->recv != NULL) {                                  \
+      (ret) = (pcb)->recv((pcb)->callback_arg,(pcb),(p),(err));\
+    } else {                                                   \
+      (ret) = tcp_recv_null(NULL, (pcb), (p), (err));          \
+    }                                                          \
+  } while (0)
+
+#define TCP_EVENT_CLOSED(pcb,ret)                                \
+  do {                                                           \
+    if(((pcb)->recv != NULL)) {                                  \
+      (ret) = (pcb)->recv((pcb)->callback_arg,(pcb),NULL,ERR_OK);\
+    } else {                                                     \
+      (ret) = ERR_OK;                                            \
+    }                                                            \
+  } while (0)
+
+#define TCP_EVENT_CONNECTED(pcb,err,ret)                         \
+  do {                                                           \
+    if((pcb)->connected != NULL)                                 \
+      (ret) = (pcb)->connected((pcb)->callback_arg,(pcb),(err)); \
+    else (ret) = ERR_OK;                                         \
+  } while (0)
+
+#define TCP_EVENT_POLL(pcb,ret)                                \
+  do {                                                         \
+    if((pcb)->poll != NULL)                                    \
+      (ret) = (pcb)->poll((pcb)->callback_arg,(pcb));          \
+    else (ret) = ERR_OK;                                       \
+  } while (0)
+
+#define TCP_EVENT_ERR(last_state,errf,arg,err)                 \
+  do {                                                         \
+    LWIP_UNUSED_ARG(last_state);                               \
+    if((errf) != NULL)                                         \
+      (errf)((arg),(err));                                     \
+  } while (0)
+
+#endif /* LWIP_EVENT_API */
+
+/** Enabled extra-check for TCP_OVERSIZE if LWIP_DEBUG is enabled */
+#if TCP_OVERSIZE && defined(LWIP_DEBUG)
+#define TCP_OVERSIZE_DBGCHECK 1
+#else
+#define TCP_OVERSIZE_DBGCHECK 0
+#endif
+
+/** Don't generate checksum on copy if CHECKSUM_GEN_TCP is disabled */
+#define TCP_CHECKSUM_ON_COPY  (LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_TCP)
+
+/* This structure represents a TCP segment on the unsent, unacked and ooseq queues */
+struct tcp_seg {
+  struct tcp_seg *next;    /* used when putting segments on a queue */
+  struct pbuf *p;          /* buffer containing data + TCP header */
+  u16_t len;               /* the TCP length of this segment */
+#if TCP_OVERSIZE_DBGCHECK
+  u16_t oversize_left;     /* Extra bytes available at the end of the last
+                              pbuf in unsent (used for asserting vs.
+                              tcp_pcb.unsent_oversize only) */
+#endif /* TCP_OVERSIZE_DBGCHECK */
+#if TCP_CHECKSUM_ON_COPY
+  u16_t chksum;
+  u8_t  chksum_swapped;
+#endif /* TCP_CHECKSUM_ON_COPY */
+  u8_t  flags;
+#define TF_SEG_OPTS_MSS         (u8_t)0x01U /* Include MSS option. */
+#define TF_SEG_OPTS_TS          (u8_t)0x02U /* Include timestamp option. */
+#define TF_SEG_DATA_CHECKSUMMED (u8_t)0x04U /* ALL data (not the header) is
+                                               checksummed into 'chksum' */
+#define TF_SEG_OPTS_WND_SCALE   (u8_t)0x08U /* Include WND SCALE option */
+  struct tcp_hdr *tcphdr;  /* the TCP header */
+};
+
+#define LWIP_TCP_OPT_EOL        0
+#define LWIP_TCP_OPT_NOP        1
+#define LWIP_TCP_OPT_MSS        2
+#define LWIP_TCP_OPT_WS         3
+#define LWIP_TCP_OPT_TS         8
+
+#define LWIP_TCP_OPT_LEN_MSS    4
+#if LWIP_TCP_TIMESTAMPS
+#define LWIP_TCP_OPT_LEN_TS     10
+#define LWIP_TCP_OPT_LEN_TS_OUT 12 /* aligned for output (includes NOP padding) */
+#else
+#define LWIP_TCP_OPT_LEN_TS_OUT 0
+#endif
+#if LWIP_WND_SCALE
+#define LWIP_TCP_OPT_LEN_WS     3
+#define LWIP_TCP_OPT_LEN_WS_OUT 4 /* aligned for output (includes NOP padding) */
+#else
+#define LWIP_TCP_OPT_LEN_WS_OUT 0
+#endif
+
+#define LWIP_TCP_OPT_LENGTH(flags) \
+  (flags & TF_SEG_OPTS_MSS       ? LWIP_TCP_OPT_LEN_MSS    : 0) + \
+  (flags & TF_SEG_OPTS_TS        ? LWIP_TCP_OPT_LEN_TS_OUT : 0) + \
+  (flags & TF_SEG_OPTS_WND_SCALE ? LWIP_TCP_OPT_LEN_WS_OUT : 0)
+
+/** This returns a TCP header option for MSS in an u32_t */
+#define TCP_BUILD_MSS_OPTION(mss) lwip_htonl(0x02040000 | ((mss) & 0xFFFF))
+
+#if LWIP_WND_SCALE
+#define TCPWNDSIZE_F       U32_F
+#define TCPWND_MAX         0xFFFFFFFFU
+#define TCPWND_CHECK16(x)  LWIP_ASSERT("window size > 0xFFFF", (x) <= 0xFFFF)
+#define TCPWND_MIN16(x)    ((u16_t)LWIP_MIN((x), 0xFFFF))
+#else /* LWIP_WND_SCALE */
+#define TCPWNDSIZE_F       U16_F
+#define TCPWND_MAX         0xFFFFU
+#define TCPWND_CHECK16(x)
+#define TCPWND_MIN16(x)    x
+#endif /* LWIP_WND_SCALE */
+
+/* Global variables: */
+extern struct tcp_pcb *tcp_input_pcb;
+extern u32_t tcp_ticks;
+extern u8_t tcp_active_pcbs_changed;
+
+/* The TCP PCB lists. */
+union tcp_listen_pcbs_t { /* List of all TCP PCBs in LISTEN state. */
+  struct tcp_pcb_listen *listen_pcbs;
+  struct tcp_pcb *pcbs;
+};
+extern struct tcp_pcb *tcp_bound_pcbs;
+extern union tcp_listen_pcbs_t tcp_listen_pcbs;
+extern struct tcp_pcb *tcp_active_pcbs;  /* List of all TCP PCBs that are in a
+              state in which they accept or send
+              data. */
+extern struct tcp_pcb *tcp_tw_pcbs;      /* List of all TCP PCBs in TIME-WAIT. */
+
+#define NUM_TCP_PCB_LISTS_NO_TIME_WAIT  3
+#define NUM_TCP_PCB_LISTS               4
+extern struct tcp_pcb ** const tcp_pcb_lists[NUM_TCP_PCB_LISTS];
+
+/* Axioms about the above lists:
+   1) Every TCP PCB that is not CLOSED is in one of the lists.
+   2) A PCB is only in one of the lists.
+   3) All PCBs in the tcp_listen_pcbs list is in LISTEN state.
+   4) All PCBs in the tcp_tw_pcbs list is in TIME-WAIT state.
+*/
+/* Define two macros, TCP_REG and TCP_RMV that registers a TCP PCB
+   with a PCB list or removes a PCB from a list, respectively. */
+#ifndef TCP_DEBUG_PCB_LISTS
+#define TCP_DEBUG_PCB_LISTS 0
+#endif
+#if TCP_DEBUG_PCB_LISTS
+#define TCP_REG(pcbs, npcb) do {\
+                            struct tcp_pcb *tcp_tmp_pcb; \
+                            LWIP_DEBUGF(TCP_DEBUG, ("TCP_REG %p local port %d\n", (npcb), (npcb)->local_port)); \
+                            for (tcp_tmp_pcb = *(pcbs); \
+          tcp_tmp_pcb != NULL; \
+        tcp_tmp_pcb = tcp_tmp_pcb->next) { \
+                                LWIP_ASSERT("TCP_REG: already registered\n", tcp_tmp_pcb != (npcb)); \
+                            } \
+                            LWIP_ASSERT("TCP_REG: pcb->state != CLOSED", ((pcbs) == &tcp_bound_pcbs) || ((npcb)->state != CLOSED)); \
+                            (npcb)->next = *(pcbs); \
+                            LWIP_ASSERT("TCP_REG: npcb->next != npcb", (npcb)->next != (npcb)); \
+                            *(pcbs) = (npcb); \
+                            LWIP_ASSERT("TCP_RMV: tcp_pcbs sane", tcp_pcbs_sane()); \
+              tcp_timer_needed(); \
+                            } while(0)
+#define TCP_RMV(pcbs, npcb) do { \
+                            struct tcp_pcb *tcp_tmp_pcb; \
+                            LWIP_ASSERT("TCP_RMV: pcbs != NULL", *(pcbs) != NULL); \
+                            LWIP_DEBUGF(TCP_DEBUG, ("TCP_RMV: removing %p from %p\n", (npcb), *(pcbs))); \
+                            if(*(pcbs) == (npcb)) { \
+                               *(pcbs) = (*pcbs)->next; \
+                            } else for (tcp_tmp_pcb = *(pcbs); tcp_tmp_pcb != NULL; tcp_tmp_pcb = tcp_tmp_pcb->next) { \
+                               if(tcp_tmp_pcb->next == (npcb)) { \
+                                  tcp_tmp_pcb->next = (npcb)->next; \
+                                  break; \
+                               } \
+                            } \
+                            (npcb)->next = NULL; \
+                            LWIP_ASSERT("TCP_RMV: tcp_pcbs sane", tcp_pcbs_sane()); \
+                            LWIP_DEBUGF(TCP_DEBUG, ("TCP_RMV: removed %p from %p\n", (npcb), *(pcbs))); \
+                            } while(0)
+
+#else /* LWIP_DEBUG */
+
+#define TCP_REG(pcbs, npcb)                        \
+  do {                                             \
+    (npcb)->next = *pcbs;                          \
+    *(pcbs) = (npcb);                              \
+    tcp_timer_needed();                            \
+  } while (0)
+
+#define TCP_RMV(pcbs, npcb)                        \
+  do {                                             \
+    if(*(pcbs) == (npcb)) {                        \
+      (*(pcbs)) = (*pcbs)->next;                   \
+    }                                              \
+    else {                                         \
+      struct tcp_pcb *tcp_tmp_pcb;                 \
+      for (tcp_tmp_pcb = *pcbs;                    \
+          tcp_tmp_pcb != NULL;                     \
+          tcp_tmp_pcb = tcp_tmp_pcb->next) {       \
+        if(tcp_tmp_pcb->next == (npcb)) {          \
+          tcp_tmp_pcb->next = (npcb)->next;        \
+          break;                                   \
+        }                                          \
+      }                                            \
+    }                                              \
+    (npcb)->next = NULL;                           \
+  } while(0)
+
+#endif /* LWIP_DEBUG */
+
+#define TCP_REG_ACTIVE(npcb)                       \
+  do {                                             \
+    TCP_REG(&tcp_active_pcbs, npcb);               \
+    tcp_active_pcbs_changed = 1;                   \
+  } while (0)
+
+#define TCP_RMV_ACTIVE(npcb)                       \
+  do {                                             \
+    TCP_RMV(&tcp_active_pcbs, npcb);               \
+    tcp_active_pcbs_changed = 1;                   \
+  } while (0)
+
+#define TCP_PCB_REMOVE_ACTIVE(pcb)                 \
+  do {                                             \
+    tcp_pcb_remove(&tcp_active_pcbs, pcb);         \
+    tcp_active_pcbs_changed = 1;                   \
+  } while (0)
+
+
+/* Internal functions: */
+struct tcp_pcb *tcp_pcb_copy(struct tcp_pcb *pcb);
+void tcp_pcb_purge(struct tcp_pcb *pcb);
+void tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb);
+
+void tcp_segs_free(struct tcp_seg *seg);
+void tcp_seg_free(struct tcp_seg *seg);
+struct tcp_seg *tcp_seg_copy(struct tcp_seg *seg);
+
+#define tcp_ack(pcb)                               \
+  do {                                             \
+    if((pcb)->flags & TF_ACK_DELAY) {              \
+      (pcb)->flags &= ~TF_ACK_DELAY;               \
+      (pcb)->flags |= TF_ACK_NOW;                  \
+    }                                              \
+    else {                                         \
+      (pcb)->flags |= TF_ACK_DELAY;                \
+    }                                              \
+  } while (0)
+
+#define tcp_ack_now(pcb)                           \
+  do {                                             \
+    (pcb)->flags |= TF_ACK_NOW;                    \
+  } while (0)
+
+err_t tcp_send_fin(struct tcp_pcb *pcb);
+err_t tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags);
+
+void tcp_rexmit_seg(struct tcp_pcb *pcb, struct tcp_seg *seg);
+
+void tcp_rst(u32_t seqno, u32_t ackno,
+       const ip_addr_t *local_ip, const ip_addr_t *remote_ip,
+       u16_t local_port, u16_t remote_port);
+
+u32_t tcp_next_iss(struct tcp_pcb *pcb);
+
+err_t tcp_keepalive(struct tcp_pcb *pcb);
+err_t tcp_zero_window_probe(struct tcp_pcb *pcb);
+void  tcp_trigger_input_pcb_close(void);
+
+#if TCP_CALCULATE_EFF_SEND_MSS
+u16_t tcp_eff_send_mss_impl(u16_t sendmss, const ip_addr_t *dest
+#if LWIP_IPV6 || LWIP_IPV4_SRC_ROUTING
+                           , const ip_addr_t *src
+#endif /* LWIP_IPV6 || LWIP_IPV4_SRC_ROUTING */
+                           );
+#if LWIP_IPV6 || LWIP_IPV4_SRC_ROUTING
+#define tcp_eff_send_mss(sendmss, src, dest) tcp_eff_send_mss_impl(sendmss, dest, src)
+#else /* LWIP_IPV6 || LWIP_IPV4_SRC_ROUTING */
+#define tcp_eff_send_mss(sendmss, src, dest) tcp_eff_send_mss_impl(sendmss, dest)
+#endif /* LWIP_IPV6 || LWIP_IPV4_SRC_ROUTING */
+#endif /* TCP_CALCULATE_EFF_SEND_MSS */
+
+#if LWIP_CALLBACK_API
+err_t tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err);
+#endif /* LWIP_CALLBACK_API */
+
+#if TCP_DEBUG || TCP_INPUT_DEBUG || TCP_OUTPUT_DEBUG
+void tcp_debug_print(struct tcp_hdr *tcphdr);
+void tcp_debug_print_flags(u8_t flags);
+void tcp_debug_print_state(enum tcp_state s);
+void tcp_debug_print_pcbs(void);
+s16_t tcp_pcbs_sane(void);
+#else
+#  define tcp_debug_print(tcphdr)
+#  define tcp_debug_print_flags(flags)
+#  define tcp_debug_print_state(s)
+#  define tcp_debug_print_pcbs()
+#  define tcp_pcbs_sane() 1
+#endif /* TCP_DEBUG */
+
+/** External function (implemented in timers.c), called when TCP detects
+ * that a timer is needed (i.e. active- or time-wait-pcb found). */
+void tcp_timer_needed(void);
+
+void tcp_netif_ip_addr_changed(const ip_addr_t* old_addr, const ip_addr_t* new_addr);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_TCP */
+
+#endif /* LWIP_HDR_TCP_PRIV_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/priv/tcpip_priv.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/priv/tcpip_priv.h
new file mode 100644
index 000000000..127eae542
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/priv/tcpip_priv.h
@@ -0,0 +1,161 @@
+/**
+ * @file
+ * TCPIP API internal implementations (do not use in application code)
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_TCPIP_PRIV_H
+#define LWIP_HDR_TCPIP_PRIV_H
+
+#include "lwip/opt.h"
+
+#if !NO_SYS /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/tcpip.h"
+#include "lwip/sys.h"
+#include "lwip/timeouts.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct pbuf;
+struct netif;
+
+#if LWIP_MPU_COMPATIBLE
+#define API_VAR_REF(name)               (*(name))
+#define API_VAR_DECLARE(type, name)     type * name
+#define API_VAR_ALLOC(type, pool, name, errorval) do { \
+                                          name = (type *)memp_malloc(pool); \
+                                          if (name == NULL) { \
+                                            return errorval; \
+                                          } \
+                                        } while(0)
+#define API_VAR_ALLOC_POOL(type, pool, name, errorval) do { \
+                                          name = (type *)LWIP_MEMPOOL_ALLOC(pool); \
+                                          if (name == NULL) { \
+                                            return errorval; \
+                                          } \
+                                        } while(0)
+#define API_VAR_FREE(pool, name)        memp_free(pool, name)
+#define API_VAR_FREE_POOL(pool, name)   LWIP_MEMPOOL_FREE(pool, name)
+#define API_EXPR_REF(expr)              (&(expr))
+#if LWIP_NETCONN_SEM_PER_THREAD
+#define API_EXPR_REF_SEM(expr)          (expr)
+#else
+#define API_EXPR_REF_SEM(expr)          API_EXPR_REF(expr)
+#endif
+#define API_EXPR_DEREF(expr)            expr
+#define API_MSG_M_DEF(m)                m
+#define API_MSG_M_DEF_C(t, m)           t m
+#else /* LWIP_MPU_COMPATIBLE */
+#define API_VAR_REF(name)               name
+#define API_VAR_DECLARE(type, name)     type name
+#define API_VAR_ALLOC(type, pool, name, errorval)
+#define API_VAR_ALLOC_POOL(type, pool, name, errorval)
+#define API_VAR_FREE(pool, name)
+#define API_VAR_FREE_POOL(pool, name)
+#define API_EXPR_REF(expr)              expr
+#define API_EXPR_REF_SEM(expr)          API_EXPR_REF(expr)
+#define API_EXPR_DEREF(expr)            (*(expr))
+#define API_MSG_M_DEF(m)                *m
+#define API_MSG_M_DEF_C(t, m)           const t * m
+#endif /* LWIP_MPU_COMPATIBLE */
+
+err_t tcpip_send_msg_wait_sem(tcpip_callback_fn fn, void *apimsg, sys_sem_t* sem);
+
+struct tcpip_api_call_data
+{
+#if !LWIP_TCPIP_CORE_LOCKING
+  err_t err;
+#if !LWIP_NETCONN_SEM_PER_THREAD
+  sys_sem_t sem;
+#endif /* LWIP_NETCONN_SEM_PER_THREAD */
+#else /* !LWIP_TCPIP_CORE_LOCKING */
+  u8_t dummy; /* avoid empty struct :-( */
+#endif /* !LWIP_TCPIP_CORE_LOCKING */
+};
+typedef err_t (*tcpip_api_call_fn)(struct tcpip_api_call_data* call);
+err_t tcpip_api_call(tcpip_api_call_fn fn, struct tcpip_api_call_data *call);
+
+enum tcpip_msg_type {
+  TCPIP_MSG_API,
+  TCPIP_MSG_API_CALL,
+  TCPIP_MSG_INPKT,
+#if LWIP_TCPIP_TIMEOUT && LWIP_TIMERS
+  TCPIP_MSG_TIMEOUT,
+  TCPIP_MSG_UNTIMEOUT,
+#endif /* LWIP_TCPIP_TIMEOUT && LWIP_TIMERS */
+  TCPIP_MSG_CALLBACK,
+  TCPIP_MSG_CALLBACK_STATIC,
+  TCPIP_MSG_FINISH
+};
+
+struct tcpip_msg {
+  enum tcpip_msg_type type;
+  union {
+    struct {
+      tcpip_callback_fn function;
+      void* msg;
+    } api_msg;
+    struct {
+      tcpip_api_call_fn function;
+      struct tcpip_api_call_data *arg;
+      sys_sem_t *sem;
+    } api_call;
+    struct {
+      struct pbuf *p;
+      struct netif *netif;
+      netif_input_fn input_fn;
+    } inp;
+    struct {
+      tcpip_callback_fn function;
+      void *ctx;
+    } cb;
+#if LWIP_TCPIP_TIMEOUT && LWIP_TIMERS
+    struct {
+      u32_t msecs;
+      sys_timeout_handler h;
+      void *arg;
+    } tmo;
+#endif /* LWIP_TCPIP_TIMEOUT && LWIP_TIMERS */
+  } msg;
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !NO_SYS */
+
+#endif /* LWIP_HDR_TCPIP_PRIV_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/autoip.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/autoip.h
new file mode 100644
index 000000000..fd3af8a9f
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/autoip.h
@@ -0,0 +1,78 @@
+/**
+ * @file
+ * AutoIP protocol definitions
+ */
+
+/*
+ *
+ * Copyright (c) 2007 Dominik Spies <kontakt@dspies.de>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * Author: Dominik Spies <kontakt@dspies.de>
+ *
+ * This is a AutoIP implementation for the lwIP TCP/IP stack. It aims to conform
+ * with RFC 3927.
+ *
+ */
+
+#ifndef LWIP_HDR_PROT_AUTOIP_H
+#define LWIP_HDR_PROT_AUTOIP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* 169.254.0.0 */
+#define AUTOIP_NET              0xA9FE0000
+/* 169.254.1.0 */
+#define AUTOIP_RANGE_START      (AUTOIP_NET | 0x0100)
+/* 169.254.254.255 */
+#define AUTOIP_RANGE_END        (AUTOIP_NET | 0xFEFF)
+
+/* RFC 3927 Constants */
+#define PROBE_WAIT              1   /* second   (initial random delay)                 */
+#define PROBE_MIN               1   /* second   (minimum delay till repeated probe)    */
+#define PROBE_MAX               2   /* seconds  (maximum delay till repeated probe)    */
+#define PROBE_NUM               3   /*          (number of probe packets)              */
+#define ANNOUNCE_NUM            2   /*          (number of announcement packets)       */
+#define ANNOUNCE_INTERVAL       2   /* seconds  (time between announcement packets)    */
+#define ANNOUNCE_WAIT           2   /* seconds  (delay before announcing)              */
+#define MAX_CONFLICTS           10  /*          (max conflicts before rate limiting)   */
+#define RATE_LIMIT_INTERVAL     60  /* seconds  (delay between successive attempts)    */
+#define DEFEND_INTERVAL         10  /* seconds  (min. wait between defensive ARPs)     */
+
+/* AutoIP client states */
+typedef enum {
+  AUTOIP_STATE_OFF        = 0,
+  AUTOIP_STATE_PROBING    = 1,
+  AUTOIP_STATE_ANNOUNCING = 2,
+  AUTOIP_STATE_BOUND      = 3
+} autoip_state_enum_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_AUTOIP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/dhcp.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/dhcp.h
new file mode 100644
index 000000000..112953cb8
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/dhcp.h
@@ -0,0 +1,183 @@
+/**
+ * @file
+ * DHCP protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Leon Woestenberg <leon.woestenberg@gmx.net>
+ * Copyright (c) 2001-2004 Axon Digital Design B.V., The Netherlands.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Leon Woestenberg <leon.woestenberg@gmx.net>
+ *
+ */
+#ifndef LWIP_HDR_PROT_DHCP_H
+#define LWIP_HDR_PROT_DHCP_H
+
+#include "lwip/opt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define DHCP_CLIENT_PORT  68
+#define DHCP_SERVER_PORT  67
+
+
+ /* DHCP message item offsets and length */
+#define DHCP_CHADDR_LEN   16U
+#define DHCP_SNAME_OFS    44U
+#define DHCP_SNAME_LEN    64U
+#define DHCP_FILE_OFS     108U
+#define DHCP_FILE_LEN     128U
+#define DHCP_MSG_LEN      236U
+#define DHCP_OPTIONS_OFS  (DHCP_MSG_LEN + 4U) /* 4 byte: cookie */
+
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+/** minimum set of fields of any DHCP message */
+struct dhcp_msg
+{
+  PACK_STRUCT_FLD_8(u8_t op);
+  PACK_STRUCT_FLD_8(u8_t htype);
+  PACK_STRUCT_FLD_8(u8_t hlen);
+  PACK_STRUCT_FLD_8(u8_t hops);
+  PACK_STRUCT_FIELD(u32_t xid);
+  PACK_STRUCT_FIELD(u16_t secs);
+  PACK_STRUCT_FIELD(u16_t flags);
+  PACK_STRUCT_FLD_S(ip4_addr_p_t ciaddr);
+  PACK_STRUCT_FLD_S(ip4_addr_p_t yiaddr);
+  PACK_STRUCT_FLD_S(ip4_addr_p_t siaddr);
+  PACK_STRUCT_FLD_S(ip4_addr_p_t giaddr);
+  PACK_STRUCT_FLD_8(u8_t chaddr[DHCP_CHADDR_LEN]);
+  PACK_STRUCT_FLD_8(u8_t sname[DHCP_SNAME_LEN]);
+  PACK_STRUCT_FLD_8(u8_t file[DHCP_FILE_LEN]);
+  PACK_STRUCT_FIELD(u32_t cookie);
+#define DHCP_MIN_OPTIONS_LEN 68U
+/** make sure user does not configure this too small */
+#if ((defined(DHCP_OPTIONS_LEN)) && (DHCP_OPTIONS_LEN < DHCP_MIN_OPTIONS_LEN))
+#  undef DHCP_OPTIONS_LEN
+#endif
+/** allow this to be configured in lwipopts.h, but not too small */
+#if (!defined(DHCP_OPTIONS_LEN))
+/** set this to be sufficient for your options in outgoing DHCP msgs */
+#  define DHCP_OPTIONS_LEN DHCP_MIN_OPTIONS_LEN
+#endif
+  PACK_STRUCT_FLD_8(u8_t options[DHCP_OPTIONS_LEN]);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+
+/* DHCP client states */
+typedef enum {
+  DHCP_STATE_OFF             = 0,
+  DHCP_STATE_REQUESTING      = 1,
+  DHCP_STATE_INIT            = 2,
+  DHCP_STATE_REBOOTING       = 3,
+  DHCP_STATE_REBINDING       = 4,
+  DHCP_STATE_RENEWING        = 5,
+  DHCP_STATE_SELECTING       = 6,
+  DHCP_STATE_INFORMING       = 7,
+  DHCP_STATE_CHECKING        = 8,
+  DHCP_STATE_PERMANENT       = 9,  /* not yet implemented */
+  DHCP_STATE_BOUND           = 10,
+  DHCP_STATE_RELEASING       = 11, /* not yet implemented */
+  DHCP_STATE_BACKING_OFF     = 12
+} dhcp_state_enum_t;
+
+/* DHCP op codes */
+#define DHCP_BOOTREQUEST            1
+#define DHCP_BOOTREPLY              2
+
+/* DHCP message types */
+#define DHCP_DISCOVER               1
+#define DHCP_OFFER                  2
+#define DHCP_REQUEST                3
+#define DHCP_DECLINE                4
+#define DHCP_ACK                    5
+#define DHCP_NAK                    6
+#define DHCP_RELEASE                7
+#define DHCP_INFORM                 8
+
+/** DHCP hardware type, currently only ethernet is supported */
+#define DHCP_HTYPE_ETH              1
+
+#define DHCP_MAGIC_COOKIE           0x63825363UL
+
+/* This is a list of options for BOOTP and DHCP, see RFC 2132 for descriptions */
+
+/* BootP options */
+#define DHCP_OPTION_PAD             0
+#define DHCP_OPTION_SUBNET_MASK     1 /* RFC 2132 3.3 */
+#define DHCP_OPTION_ROUTER          3
+#define DHCP_OPTION_DNS_SERVER      6
+#define DHCP_OPTION_HOSTNAME        12
+#define DHCP_OPTION_IP_TTL          23
+#define DHCP_OPTION_MTU             26
+#define DHCP_OPTION_BROADCAST       28
+#define DHCP_OPTION_TCP_TTL         37
+#define DHCP_OPTION_NTP             42
+#define DHCP_OPTION_END             255
+
+/* DHCP options */
+#define DHCP_OPTION_REQUESTED_IP    50 /* RFC 2132 9.1, requested IP address */
+#define DHCP_OPTION_LEASE_TIME      51 /* RFC 2132 9.2, time in seconds, in 4 bytes */
+#define DHCP_OPTION_OVERLOAD        52 /* RFC2132 9.3, use file and/or sname field for options */
+
+#define DHCP_OPTION_MESSAGE_TYPE    53 /* RFC 2132 9.6, important for DHCP */
+#define DHCP_OPTION_MESSAGE_TYPE_LEN 1
+
+#define DHCP_OPTION_SERVER_ID       54 /* RFC 2132 9.7, server IP address */
+#define DHCP_OPTION_PARAMETER_REQUEST_LIST  55 /* RFC 2132 9.8, requested option types */
+
+#define DHCP_OPTION_MAX_MSG_SIZE    57 /* RFC 2132 9.10, message size accepted >= 576 */
+#define DHCP_OPTION_MAX_MSG_SIZE_LEN 2
+
+#define DHCP_OPTION_T1              58 /* T1 renewal time */
+#define DHCP_OPTION_T2              59 /* T2 rebinding time */
+#define DHCP_OPTION_US              60
+#define DHCP_OPTION_CLIENT_ID       61
+#define DHCP_OPTION_TFTP_SERVERNAME 66
+#define DHCP_OPTION_BOOTFILE        67
+
+/* possible combinations of overloading the file and sname fields with options */
+#define DHCP_OVERLOAD_NONE          0
+#define DHCP_OVERLOAD_FILE          1
+#define DHCP_OVERLOAD_SNAME         2
+#define DHCP_OVERLOAD_SNAME_FILE    3
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*LWIP_HDR_PROT_DHCP_H*/
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/dns.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/dns.h
new file mode 100644
index 000000000..94782d6e9
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/dns.h
@@ -0,0 +1,140 @@
+/**
+ * @file
+ * DNS - host name to IP address resolver.
+ */
+
+/*
+ * Port to lwIP from uIP
+ * by Jim Pettinato April 2007
+ *
+ * security fixes and more by Simon Goldschmidt
+ *
+ * uIP version Copyright (c) 2002-2003, Adam Dunkels.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote
+ *    products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+ * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef LWIP_HDR_PROT_DNS_H
+#define LWIP_HDR_PROT_DNS_H
+
+#include "lwip/arch.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** DNS server port address */
+#ifndef DNS_SERVER_PORT
+#define DNS_SERVER_PORT           53
+#endif
+
+/* DNS field TYPE used for "Resource Records" */
+#define DNS_RRTYPE_A              1     /* a host address */
+#define DNS_RRTYPE_NS             2     /* an authoritative name server */
+#define DNS_RRTYPE_MD             3     /* a mail destination (Obsolete - use MX) */
+#define DNS_RRTYPE_MF             4     /* a mail forwarder (Obsolete - use MX) */
+#define DNS_RRTYPE_CNAME          5     /* the canonical name for an alias */
+#define DNS_RRTYPE_SOA            6     /* marks the start of a zone of authority */
+#define DNS_RRTYPE_MB             7     /* a mailbox domain name (EXPERIMENTAL) */
+#define DNS_RRTYPE_MG             8     /* a mail group member (EXPERIMENTAL) */
+#define DNS_RRTYPE_MR             9     /* a mail rename domain name (EXPERIMENTAL) */
+#define DNS_RRTYPE_NULL           10    /* a null RR (EXPERIMENTAL) */
+#define DNS_RRTYPE_WKS            11    /* a well known service description */
+#define DNS_RRTYPE_PTR            12    /* a domain name pointer */
+#define DNS_RRTYPE_HINFO          13    /* host information */
+#define DNS_RRTYPE_MINFO          14    /* mailbox or mail list information */
+#define DNS_RRTYPE_MX             15    /* mail exchange */
+#define DNS_RRTYPE_TXT            16    /* text strings */
+#define DNS_RRTYPE_AAAA           28    /* IPv6 address */
+#define DNS_RRTYPE_SRV            33    /* service location */
+#define DNS_RRTYPE_ANY            255   /* any type */
+
+/* DNS field CLASS used for "Resource Records" */
+#define DNS_RRCLASS_IN            1     /* the Internet */
+#define DNS_RRCLASS_CS            2     /* the CSNET class (Obsolete - used only for examples in some obsolete RFCs) */
+#define DNS_RRCLASS_CH            3     /* the CHAOS class */
+#define DNS_RRCLASS_HS            4     /* Hesiod [Dyer 87] */
+#define DNS_RRCLASS_ANY           255   /* any class */
+#define DNS_RRCLASS_FLUSH         0x800 /* Flush bit */
+
+/* DNS protocol flags */
+#define DNS_FLAG1_RESPONSE        0x80
+#define DNS_FLAG1_OPCODE_STATUS   0x10
+#define DNS_FLAG1_OPCODE_INVERSE  0x08
+#define DNS_FLAG1_OPCODE_STANDARD 0x00
+#define DNS_FLAG1_AUTHORATIVE     0x04
+#define DNS_FLAG1_TRUNC           0x02
+#define DNS_FLAG1_RD              0x01
+#define DNS_FLAG2_RA              0x80
+#define DNS_FLAG2_ERR_MASK        0x0f
+#define DNS_FLAG2_ERR_NONE        0x00
+#define DNS_FLAG2_ERR_NAME        0x03
+
+#define DNS_HDR_GET_OPCODE(hdr) ((((hdr)->flags1) >> 3) & 0xF)
+
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+/** DNS message header */
+struct dns_hdr {
+  PACK_STRUCT_FIELD(u16_t id);
+  PACK_STRUCT_FLD_8(u8_t flags1);
+  PACK_STRUCT_FLD_8(u8_t flags2);
+  PACK_STRUCT_FIELD(u16_t numquestions);
+  PACK_STRUCT_FIELD(u16_t numanswers);
+  PACK_STRUCT_FIELD(u16_t numauthrr);
+  PACK_STRUCT_FIELD(u16_t numextrarr);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+#define SIZEOF_DNS_HDR 12
+
+
+/* Multicast DNS definitions */
+
+/** UDP port for multicast DNS queries */
+#ifndef DNS_MQUERY_PORT
+#define DNS_MQUERY_PORT             5353
+#endif
+
+/* IPv4 group for multicast DNS queries: 224.0.0.251 */
+#ifndef DNS_MQUERY_IPV4_GROUP_INIT
+#define DNS_MQUERY_IPV4_GROUP_INIT  IPADDR4_INIT_BYTES(224,0,0,251)
+#endif
+
+/* IPv6 group for multicast DNS queries: FF02::FB */
+#ifndef DNS_MQUERY_IPV6_GROUP_INIT
+#define DNS_MQUERY_IPV6_GROUP_INIT  IPADDR6_INIT_HOST(0xFF020000,0,0,0xFB)
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_DNS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/etharp.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/etharp.h
new file mode 100644
index 000000000..ec78305b8
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/etharp.h
@@ -0,0 +1,91 @@
+/**
+ * @file
+ * ARP protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_PROT_ETHARP_H
+#define LWIP_HDR_PROT_ETHARP_H
+
+#include "lwip/arch.h"
+#include "lwip/prot/ethernet.h"
+#include "lwip/ip4_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef ETHARP_HWADDR_LEN
+#define ETHARP_HWADDR_LEN     ETH_HWADDR_LEN
+#endif
+
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+/** the ARP message, see RFC 826 ("Packet format") */
+struct etharp_hdr {
+  PACK_STRUCT_FIELD(u16_t hwtype);
+  PACK_STRUCT_FIELD(u16_t proto);
+  PACK_STRUCT_FLD_8(u8_t  hwlen);
+  PACK_STRUCT_FLD_8(u8_t  protolen);
+  PACK_STRUCT_FIELD(u16_t opcode);
+  PACK_STRUCT_FLD_S(struct eth_addr shwaddr);
+  PACK_STRUCT_FLD_S(struct ip4_addr2 sipaddr);
+  PACK_STRUCT_FLD_S(struct eth_addr dhwaddr);
+  PACK_STRUCT_FLD_S(struct ip4_addr2 dipaddr);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+#define SIZEOF_ETHARP_HDR 28
+
+/* ARP hwtype values */
+enum etharp_hwtype {
+  HWTYPE_ETHERNET = 1
+  /* others not used */
+};
+
+/* ARP message types (opcodes) */
+enum etharp_opcode {
+  ARP_REQUEST = 1,
+  ARP_REPLY   = 2
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_ETHARP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/ethernet.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/ethernet.h
new file mode 100644
index 000000000..e4baa29dc
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/ethernet.h
@@ -0,0 +1,170 @@
+/**
+ * @file
+ * Ethernet protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_PROT_ETHERNET_H
+#define LWIP_HDR_PROT_ETHERNET_H
+
+#include "lwip/arch.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef ETH_HWADDR_LEN
+#ifdef ETHARP_HWADDR_LEN
+#define ETH_HWADDR_LEN    ETHARP_HWADDR_LEN /* compatibility mode */
+#else
+#define ETH_HWADDR_LEN    6
+#endif
+#endif
+
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct eth_addr {
+  PACK_STRUCT_FLD_8(u8_t addr[ETH_HWADDR_LEN]);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+/** Ethernet header */
+struct eth_hdr {
+#if ETH_PAD_SIZE
+  PACK_STRUCT_FLD_8(u8_t padding[ETH_PAD_SIZE]);
+#endif
+  PACK_STRUCT_FLD_S(struct eth_addr dest);
+  PACK_STRUCT_FLD_S(struct eth_addr src);
+  PACK_STRUCT_FIELD(u16_t type);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+#define SIZEOF_ETH_HDR (14 + ETH_PAD_SIZE)
+
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+/** VLAN header inserted between ethernet header and payload
+ * if 'type' in ethernet header is ETHTYPE_VLAN.
+ * See IEEE802.Q */
+struct eth_vlan_hdr {
+  PACK_STRUCT_FIELD(u16_t prio_vid);
+  PACK_STRUCT_FIELD(u16_t tpid);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+#define SIZEOF_VLAN_HDR 4
+#define VLAN_ID(vlan_hdr) (lwip_htons((vlan_hdr)->prio_vid) & 0xFFF)
+
+/**
+ * @ingroup ethernet
+ * A list of often ethtypes (although lwIP does not use all of them): */
+enum eth_type {
+  /** Internet protocol v4 */
+  ETHTYPE_IP        = 0x0800U,
+  /** Address resolution protocol */
+  ETHTYPE_ARP       = 0x0806U, 
+  /** Wake on lan */
+  ETHTYPE_WOL       = 0x0842U,
+  /** RARP */
+  ETHTYPE_RARP      = 0x8035U,
+  /** Virtual local area network */
+  ETHTYPE_VLAN      = 0x8100U,
+  /** Internet protocol v6 */
+  ETHTYPE_IPV6      = 0x86DDU,
+  /** PPP Over Ethernet Discovery Stage */
+  ETHTYPE_PPPOEDISC = 0x8863U,
+  /** PPP Over Ethernet Session Stage */
+  ETHTYPE_PPPOE     = 0x8864U,
+  /** Jumbo Frames */
+  ETHTYPE_JUMBO     = 0x8870U,
+  /** Process field network */
+  ETHTYPE_PROFINET  = 0x8892U,
+  /** Ethernet for control automation technology */
+  ETHTYPE_ETHERCAT  = 0x88A4U,
+  /** Link layer discovery protocol */
+  ETHTYPE_LLDP      = 0x88CCU,
+  /** Serial real-time communication system */
+  ETHTYPE_SERCOS    = 0x88CDU,
+  /** Media redundancy protocol */
+  ETHTYPE_MRP       = 0x88E3U,
+  /** Precision time protocol */
+  ETHTYPE_PTP       = 0x88F7U,
+  /** Q-in-Q, 802.1ad */
+  ETHTYPE_QINQ      = 0x9100U
+};
+
+/** The 24-bit IANA IPv4-multicast OUI is 01-00-5e: */
+#define LL_IP4_MULTICAST_ADDR_0 0x01
+#define LL_IP4_MULTICAST_ADDR_1 0x00
+#define LL_IP4_MULTICAST_ADDR_2 0x5e
+
+/** IPv6 multicast uses this prefix */
+#define LL_IP6_MULTICAST_ADDR_0 0x33
+#define LL_IP6_MULTICAST_ADDR_1 0x33
+
+/** MEMCPY-like macro to copy to/from struct eth_addr's that are local variables
+ * or known to be 32-bit aligned within the protocol header. */
+#ifndef ETHADDR32_COPY
+#define ETHADDR32_COPY(dst, src)  SMEMCPY(dst, src, ETH_HWADDR_LEN)
+#endif
+
+/** MEMCPY-like macro to copy to/from struct eth_addr's that are no local
+ * variables and known to be 16-bit aligned within the protocol header. */
+#ifndef ETHADDR16_COPY
+#define ETHADDR16_COPY(dst, src)  SMEMCPY(dst, src, ETH_HWADDR_LEN)
+#endif
+
+#define eth_addr_cmp(addr1, addr2) (memcmp((addr1)->addr, (addr2)->addr, ETH_HWADDR_LEN) == 0)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_ETHERNET_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/icmp.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/icmp.h
new file mode 100644
index 000000000..7d19385c7
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/icmp.h
@@ -0,0 +1,91 @@
+/**
+ * @file
+ * ICMP protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_PROT_ICMP_H
+#define LWIP_HDR_PROT_ICMP_H
+
+#include "lwip/arch.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ICMP_ER   0    /* echo reply */
+#define ICMP_DUR  3    /* destination unreachable */
+#define ICMP_SQ   4    /* source quench */
+#define ICMP_RD   5    /* redirect */
+#define ICMP_ECHO 8    /* echo */
+#define ICMP_TE  11    /* time exceeded */
+#define ICMP_PP  12    /* parameter problem */
+#define ICMP_TS  13    /* timestamp */
+#define ICMP_TSR 14    /* timestamp reply */
+#define ICMP_IRQ 15    /* information request */
+#define ICMP_IR  16    /* information reply */
+#define ICMP_AM  17    /* address mask request */
+#define ICMP_AMR 18    /* address mask reply */
+
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+/** This is the standard ICMP header only that the u32_t data
+ *  is split to two u16_t like ICMP echo needs it.
+ *  This header is also used for other ICMP types that do not
+ *  use the data part.
+ */
+PACK_STRUCT_BEGIN
+struct icmp_echo_hdr {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t code);
+  PACK_STRUCT_FIELD(u16_t chksum);
+  PACK_STRUCT_FIELD(u16_t id);
+  PACK_STRUCT_FIELD(u16_t seqno);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/* Compatibility defines, old versions used to combine type and code to an u16_t */
+#define ICMPH_TYPE(hdr) ((hdr)->type)
+#define ICMPH_CODE(hdr) ((hdr)->code)
+#define ICMPH_TYPE_SET(hdr, t) ((hdr)->type = (t))
+#define ICMPH_CODE_SET(hdr, c) ((hdr)->code = (c))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_ICMP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/icmp6.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/icmp6.h
new file mode 100644
index 000000000..346112042
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/icmp6.h
@@ -0,0 +1,170 @@
+/**
+ * @file
+ * ICMP6 protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_PROT_ICMP6_H
+#define LWIP_HDR_PROT_ICMP6_H
+
+#include "lwip/arch.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** ICMP type */
+enum icmp6_type {
+  /** Destination unreachable */
+  ICMP6_TYPE_DUR = 1,
+  /** Packet too big */
+  ICMP6_TYPE_PTB = 2,
+  /** Time exceeded */
+  ICMP6_TYPE_TE = 3,
+  /** Parameter problem */
+  ICMP6_TYPE_PP = 4,
+  /** Private experimentation */
+  ICMP6_TYPE_PE1 = 100,
+  /** Private experimentation */
+  ICMP6_TYPE_PE2 = 101,
+  /** Reserved for expansion of error messages */
+  ICMP6_TYPE_RSV_ERR = 127,
+
+  /** Echo request */
+  ICMP6_TYPE_EREQ = 128,
+  /** Echo reply */
+  ICMP6_TYPE_EREP = 129,
+  /** Multicast listener query */
+  ICMP6_TYPE_MLQ = 130,
+  /** Multicast listener report */
+  ICMP6_TYPE_MLR = 131,
+  /** Multicast listener done */
+  ICMP6_TYPE_MLD = 132,
+  /** Router solicitation */
+  ICMP6_TYPE_RS = 133,
+  /** Router advertisement */
+  ICMP6_TYPE_RA = 134,
+  /** Neighbor solicitation */
+  ICMP6_TYPE_NS = 135,
+  /** Neighbor advertisement */
+  ICMP6_TYPE_NA = 136,
+  /** Redirect */
+  ICMP6_TYPE_RD = 137,
+  /** Multicast router advertisement */
+  ICMP6_TYPE_MRA = 151,
+  /** Multicast router solicitation */
+  ICMP6_TYPE_MRS = 152,
+  /** Multicast router termination */
+  ICMP6_TYPE_MRT = 153,
+  /** Private experimentation */
+  ICMP6_TYPE_PE3 = 200,
+  /** Private experimentation */
+  ICMP6_TYPE_PE4 = 201,
+  /** Reserved for expansion of informational messages */
+  ICMP6_TYPE_RSV_INF = 255
+};
+
+/** ICMP destination unreachable codes */
+enum icmp6_dur_code {
+  /** No route to destination */
+  ICMP6_DUR_NO_ROUTE = 0,
+  /** Communication with destination administratively prohibited */
+  ICMP6_DUR_PROHIBITED = 1,
+  /** Beyond scope of source address */
+  ICMP6_DUR_SCOPE = 2,
+  /** Address unreachable */
+  ICMP6_DUR_ADDRESS = 3,
+  /** Port unreachable */
+  ICMP6_DUR_PORT = 4,
+  /** Source address failed ingress/egress policy */
+  ICMP6_DUR_POLICY = 5,
+  /** Reject route to destination */
+  ICMP6_DUR_REJECT_ROUTE = 6
+};
+
+/** ICMP time exceeded codes */
+enum icmp6_te_code {
+  /** Hop limit exceeded in transit */
+  ICMP6_TE_HL = 0,
+  /** Fragment reassembly time exceeded */
+  ICMP6_TE_FRAG = 1
+};
+
+/** ICMP parameter code */
+enum icmp6_pp_code {
+  /** Erroneous header field encountered */
+  ICMP6_PP_FIELD = 0,
+  /** Unrecognized next header type encountered */
+  ICMP6_PP_HEADER = 1,
+  /** Unrecognized IPv6 option encountered */
+  ICMP6_PP_OPTION = 2
+};
+
+/** This is the standard ICMP6 header. */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct icmp6_hdr {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t code);
+  PACK_STRUCT_FIELD(u16_t chksum);
+  PACK_STRUCT_FIELD(u32_t data);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/** This is the ICMP6 header adapted for echo req/resp. */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct icmp6_echo_hdr {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t code);
+  PACK_STRUCT_FIELD(u16_t chksum);
+  PACK_STRUCT_FIELD(u16_t id);
+  PACK_STRUCT_FIELD(u16_t seqno);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_ICMP6_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/igmp.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/igmp.h
new file mode 100644
index 000000000..d60cb31ee
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/igmp.h
@@ -0,0 +1,90 @@
+/**
+ * @file
+ * IGMP protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_PROT_IGMP_H
+#define LWIP_HDR_PROT_IGMP_H
+
+#include "lwip/arch.h"
+#include "lwip/ip4_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * IGMP constants
+ */
+#define IGMP_TTL                       1
+#define IGMP_MINLEN                    8
+#define ROUTER_ALERT                   0x9404U
+#define ROUTER_ALERTLEN                4
+
+/*
+ * IGMP message types, including version number.
+ */
+#define IGMP_MEMB_QUERY                0x11 /* Membership query         */
+#define IGMP_V1_MEMB_REPORT            0x12 /* Ver. 1 membership report */
+#define IGMP_V2_MEMB_REPORT            0x16 /* Ver. 2 membership report */
+#define IGMP_LEAVE_GROUP               0x17 /* Leave-group message      */
+
+/* Group  membership states */
+#define IGMP_GROUP_NON_MEMBER          0
+#define IGMP_GROUP_DELAYING_MEMBER     1
+#define IGMP_GROUP_IDLE_MEMBER         2
+
+/**
+ * IGMP packet format.
+ */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct igmp_msg {
+  PACK_STRUCT_FLD_8(u8_t         igmp_msgtype);
+  PACK_STRUCT_FLD_8(u8_t         igmp_maxresp);
+  PACK_STRUCT_FIELD(u16_t        igmp_checksum);
+  PACK_STRUCT_FLD_S(ip4_addr_p_t igmp_group_address);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_IGMP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/ip.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/ip.h
new file mode 100644
index 000000000..bbfae3675
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/ip.h
@@ -0,0 +1,51 @@
+/**
+ * @file
+ * IP protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_PROT_IP_H
+#define LWIP_HDR_PROT_IP_H
+
+#include "lwip/arch.h"
+
+#define IP_PROTO_ICMP    1
+#define IP_PROTO_IGMP    2
+#define IP_PROTO_UDP     17
+#define IP_PROTO_UDPLITE 136
+#define IP_PROTO_TCP     6
+
+/** This operates on a void* by loading the first byte */
+#define IP_HDR_GET_VERSION(ptr)   ((*(u8_t*)(ptr)) >> 4)
+
+#endif /* LWIP_HDR_PROT_IP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/ip4.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/ip4.h
new file mode 100644
index 000000000..bd442c689
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/ip4.h
@@ -0,0 +1,127 @@
+/**
+ * @file
+ * IPv4 protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_PROT_IP4_H
+#define LWIP_HDR_PROT_IP4_H
+
+#include "lwip/arch.h"
+#include "lwip/ip4_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** This is the packed version of ip4_addr_t,
+    used in network headers that are itself packed */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct ip4_addr_packed {
+  PACK_STRUCT_FIELD(u32_t addr);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+typedef struct ip4_addr_packed ip4_addr_p_t;
+
+/* Size of the IPv4 header. Same as 'sizeof(struct ip_hdr)'. */
+#define IP_HLEN 20
+
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+/* The IPv4 header */
+struct ip_hdr {
+  /* version / header length */
+  PACK_STRUCT_FLD_8(u8_t _v_hl);
+  /* type of service */
+  PACK_STRUCT_FLD_8(u8_t _tos);
+  /* total length */
+  PACK_STRUCT_FIELD(u16_t _len);
+  /* identification */
+  PACK_STRUCT_FIELD(u16_t _id);
+  /* fragment offset field */
+  PACK_STRUCT_FIELD(u16_t _offset);
+#define IP_RF 0x8000U        /* reserved fragment flag */
+#define IP_DF 0x4000U        /* don't fragment flag */
+#define IP_MF 0x2000U        /* more fragments flag */
+#define IP_OFFMASK 0x1fffU   /* mask for fragmenting bits */
+  /* time to live */
+  PACK_STRUCT_FLD_8(u8_t _ttl);
+  /* protocol*/
+  PACK_STRUCT_FLD_8(u8_t _proto);
+  /* checksum */
+  PACK_STRUCT_FIELD(u16_t _chksum);
+  /* source and destination IP addresses */
+  PACK_STRUCT_FLD_S(ip4_addr_p_t src);
+  PACK_STRUCT_FLD_S(ip4_addr_p_t dest);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/* Macros to get struct ip_hdr fields: */
+#define IPH_V(hdr)  ((hdr)->_v_hl >> 4)
+#define IPH_HL(hdr) ((hdr)->_v_hl & 0x0f)
+#define IPH_TOS(hdr) ((hdr)->_tos)
+#define IPH_LEN(hdr) ((hdr)->_len)
+#define IPH_ID(hdr) ((hdr)->_id)
+#define IPH_OFFSET(hdr) ((hdr)->_offset)
+#define IPH_TTL(hdr) ((hdr)->_ttl)
+#define IPH_PROTO(hdr) ((hdr)->_proto)
+#define IPH_CHKSUM(hdr) ((hdr)->_chksum)
+
+/* Macros to set struct ip_hdr fields: */
+#define IPH_VHL_SET(hdr, v, hl) (hdr)->_v_hl = (u8_t)((((v) << 4) | (hl)))
+#define IPH_TOS_SET(hdr, tos) (hdr)->_tos = (tos)
+#define IPH_LEN_SET(hdr, len) (hdr)->_len = (len)
+#define IPH_ID_SET(hdr, id) (hdr)->_id = (id)
+#define IPH_OFFSET_SET(hdr, off) (hdr)->_offset = (off)
+#define IPH_TTL_SET(hdr, ttl) (hdr)->_ttl = (u8_t)(ttl)
+#define IPH_PROTO_SET(hdr, proto) (hdr)->_proto = (u8_t)(proto)
+#define IPH_CHKSUM_SET(hdr, chksum) (hdr)->_chksum = (chksum)
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_IP4_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/ip6.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/ip6.h
new file mode 100644
index 000000000..61a553d10
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/ip6.h
@@ -0,0 +1,171 @@
+/**
+ * @file
+ * IPv6 protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_PROT_IP6_H
+#define LWIP_HDR_PROT_IP6_H
+
+#include "lwip/arch.h"
+#include "lwip/ip6_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define IP6_MIN_MTU 1280
+
+/** This is the packed version of ip6_addr_t,
+    used in network headers that are itself packed */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct ip6_addr_packed {
+  PACK_STRUCT_FIELD(u32_t addr[4]);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+typedef struct ip6_addr_packed ip6_addr_p_t;
+
+#define IP6_HLEN 40
+
+#define IP6_NEXTH_HOPBYHOP  0
+#define IP6_NEXTH_TCP       6
+#define IP6_NEXTH_UDP       17
+#define IP6_NEXTH_ENCAPS    41
+#define IP6_NEXTH_ROUTING   43
+#define IP6_NEXTH_FRAGMENT  44
+#define IP6_NEXTH_ICMP6     58
+#define IP6_NEXTH_NONE      59
+#define IP6_NEXTH_DESTOPTS  60
+#define IP6_NEXTH_UDPLITE   136
+
+/** The IPv6 header. */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct ip6_hdr {
+  /** version / traffic class / flow label */
+  PACK_STRUCT_FIELD(u32_t _v_tc_fl);
+  /** payload length */
+  PACK_STRUCT_FIELD(u16_t _plen);
+  /** next header */
+  PACK_STRUCT_FLD_8(u8_t _nexth);
+  /** hop limit */
+  PACK_STRUCT_FLD_8(u8_t _hoplim);
+  /** source and destination IP addresses */
+  PACK_STRUCT_FLD_S(ip6_addr_p_t src);
+  PACK_STRUCT_FLD_S(ip6_addr_p_t dest);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/* Hop-by-hop router alert option. */
+#define IP6_HBH_HLEN    8
+#define IP6_PAD1_OPTION         0
+#define IP6_PADN_ALERT_OPTION   1
+#define IP6_ROUTER_ALERT_OPTION 5
+#define IP6_ROUTER_ALERT_VALUE_MLD 0
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct ip6_hbh_hdr {
+  /* next header */
+  PACK_STRUCT_FLD_8(u8_t _nexth);
+  /* header length */
+  PACK_STRUCT_FLD_8(u8_t _hlen);
+  /* router alert option type */
+  PACK_STRUCT_FLD_8(u8_t _ra_opt_type);
+  /* router alert option data len */
+  PACK_STRUCT_FLD_8(u8_t _ra_opt_dlen);
+  /* router alert option data */
+  PACK_STRUCT_FIELD(u16_t _ra_opt_data);
+  /* PadN option type */
+  PACK_STRUCT_FLD_8(u8_t _padn_opt_type);
+  /* PadN option data len */
+  PACK_STRUCT_FLD_8(u8_t _padn_opt_dlen);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/* Fragment header. */
+#define IP6_FRAG_HLEN    8
+#define IP6_FRAG_OFFSET_MASK    0xfff8
+#define IP6_FRAG_MORE_FLAG      0x0001
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct ip6_frag_hdr {
+  /* next header */
+  PACK_STRUCT_FLD_8(u8_t _nexth);
+  /* reserved */
+  PACK_STRUCT_FLD_8(u8_t reserved);
+  /* fragment offset */
+  PACK_STRUCT_FIELD(u16_t _fragment_offset);
+  /* fragmented packet identification */
+  PACK_STRUCT_FIELD(u32_t _identification);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+#define IP6H_V(hdr)  ((lwip_ntohl((hdr)->_v_tc_fl) >> 28) & 0x0f)
+#define IP6H_TC(hdr) ((lwip_ntohl((hdr)->_v_tc_fl) >> 20) & 0xff)
+#define IP6H_FL(hdr) (lwip_ntohl((hdr)->_v_tc_fl) & 0x000fffff)
+#define IP6H_PLEN(hdr) (lwip_ntohs((hdr)->_plen))
+#define IP6H_NEXTH(hdr) ((hdr)->_nexth)
+#define IP6H_NEXTH_P(hdr) ((u8_t *)(hdr) + 6)
+#define IP6H_HOPLIM(hdr) ((hdr)->_hoplim)
+
+#define IP6H_VTCFL_SET(hdr, v, tc, fl) (hdr)->_v_tc_fl = (lwip_htonl((((u32_t)(v)) << 28) | (((u32_t)(tc)) << 20) | (fl)))
+#define IP6H_PLEN_SET(hdr, plen) (hdr)->_plen = lwip_htons(plen)
+#define IP6H_NEXTH_SET(hdr, nexth) (hdr)->_nexth = (nexth)
+#define IP6H_HOPLIM_SET(hdr, hl) (hdr)->_hoplim = (u8_t)(hl)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_IP6_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/mld6.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/mld6.h
new file mode 100644
index 000000000..be3a006af
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/mld6.h
@@ -0,0 +1,70 @@
+/**
+ * @file
+ * MLD6 protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_PROT_MLD6_H
+#define LWIP_HDR_PROT_MLD6_H
+
+#include "lwip/arch.h"
+#include "lwip/prot/ip6.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** Multicast listener report/query/done message header. */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct mld_header {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t code);
+  PACK_STRUCT_FIELD(u16_t chksum);
+  PACK_STRUCT_FIELD(u16_t max_resp_delay);
+  PACK_STRUCT_FIELD(u16_t reserved);
+  PACK_STRUCT_FLD_S(ip6_addr_p_t multicast_address);
+  /* Options follow. */
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_MLD6_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/nd6.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/nd6.h
new file mode 100644
index 000000000..4455066d5
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/nd6.h
@@ -0,0 +1,290 @@
+/**
+ * @file
+ * ND6 protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_PROT_ND6_H
+#define LWIP_HDR_PROT_ND6_H
+
+#include "lwip/arch.h"
+#include "lwip/ip6_addr.h"
+#include "lwip/prot/ip6.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** Neighbor solicitation message header. */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct ns_header {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t code);
+  PACK_STRUCT_FIELD(u16_t chksum);
+  PACK_STRUCT_FIELD(u32_t reserved);
+  PACK_STRUCT_FLD_S(ip6_addr_p_t target_address);
+  /* Options follow. */
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/** Neighbor advertisement message header. */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct na_header {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t code);
+  PACK_STRUCT_FIELD(u16_t chksum);
+  PACK_STRUCT_FLD_8(u8_t flags);
+  PACK_STRUCT_FLD_8(u8_t reserved[3]);
+  PACK_STRUCT_FLD_S(ip6_addr_p_t target_address);
+  /* Options follow. */
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+#define ND6_FLAG_ROUTER      (0x80)
+#define ND6_FLAG_SOLICITED   (0x40)
+#define ND6_FLAG_OVERRIDE    (0x20)
+
+/** Router solicitation message header. */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct rs_header {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t code);
+  PACK_STRUCT_FIELD(u16_t chksum);
+  PACK_STRUCT_FIELD(u32_t reserved);
+  /* Options follow. */
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/** Router advertisement message header. */
+#define ND6_RA_FLAG_MANAGED_ADDR_CONFIG (0x80)
+#define ND6_RA_FLAG_OTHER_CONFIG (0x40)
+#define ND6_RA_FLAG_HOME_AGENT (0x20)
+#define ND6_RA_PREFERENCE_MASK (0x18)
+#define ND6_RA_PREFERENCE_HIGH (0x08)
+#define ND6_RA_PREFERENCE_MEDIUM (0x00)
+#define ND6_RA_PREFERENCE_LOW (0x18)
+#define ND6_RA_PREFERENCE_DISABLED (0x10)
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct ra_header {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t code);
+  PACK_STRUCT_FIELD(u16_t chksum);
+  PACK_STRUCT_FLD_8(u8_t current_hop_limit);
+  PACK_STRUCT_FLD_8(u8_t flags);
+  PACK_STRUCT_FIELD(u16_t router_lifetime);
+  PACK_STRUCT_FIELD(u32_t reachable_time);
+  PACK_STRUCT_FIELD(u32_t retrans_timer);
+  /* Options follow. */
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/** Redirect message header. */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct redirect_header {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t code);
+  PACK_STRUCT_FIELD(u16_t chksum);
+  PACK_STRUCT_FIELD(u32_t reserved);
+  PACK_STRUCT_FLD_S(ip6_addr_p_t target_address);
+  PACK_STRUCT_FLD_S(ip6_addr_p_t destination_address);
+  /* Options follow. */
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/** Link-layer address option. */
+#define ND6_OPTION_TYPE_SOURCE_LLADDR (0x01)
+#define ND6_OPTION_TYPE_TARGET_LLADDR (0x02)
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct lladdr_option {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t length);
+  PACK_STRUCT_FLD_8(u8_t addr[NETIF_MAX_HWADDR_LEN]);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/** The address field is variable and not fixed in length, use the
+  * appropriate macros when accessing the length field or calculating
+  * the option size.
+  */
+#define __OFFSETOF(t, m)                       ((size_t)(&(((t *)0)->m)))
+#define __ROUND_UP(n, m)                       ((((n) + ((m) - 1)) / (m)) * (m))
+#define ND6_LLADDR_OPTION_LENGTH_SHIFT         3
+#define ND6_LLADDR_OPTION_LENGTH_SIZE          (1 << ND6_LLADDR_OPTION_LENGTH_SHIFT)
+#define ND6_LLADDR_OPTION_LENGTH_MASK          (ND6_LLADDR_OPTION_LENGTH_SIZE - 1)
+#define ND6_LLADDR_OPTION_LENGTH_ENCODE(hwlen) (__ROUND_UP(hwlen, ND6_LLADDR_OPTION_LENGTH_SIZE) >> ND6_LLADDR_OPTION_LENGTH_SHIFT)
+#define ND6_LLADDR_OPTION_LENGTH_DECODE(value) ((value) << ND6_LLADDR_OPTION_LENGTH_SHIFT)
+#define ND6_LLADDR_OPTION_SIZE(hwlen)          (__OFFSETOF(struct lladdr_option, addr) + (hwlen))
+
+/** Prefix information option. */
+#define ND6_OPTION_TYPE_PREFIX_INFO (0x03)
+#define ND6_PREFIX_FLAG_ON_LINK (0x80)
+#define ND6_PREFIX_FLAG_AUTONOMOUS (0x40)
+#define ND6_PREFIX_FLAG_ROUTER_ADDRESS (0x20)
+#define ND6_PREFIX_FLAG_SITE_PREFIX (0x10)
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct prefix_option {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t length);
+  PACK_STRUCT_FLD_8(u8_t prefix_length);
+  PACK_STRUCT_FLD_8(u8_t flags);
+  PACK_STRUCT_FIELD(u32_t valid_lifetime);
+  PACK_STRUCT_FIELD(u32_t preferred_lifetime);
+  PACK_STRUCT_FLD_8(u8_t reserved2[3]);
+  PACK_STRUCT_FLD_8(u8_t site_prefix_length);
+  PACK_STRUCT_FLD_S(ip6_addr_p_t prefix);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/** Redirected header option. */
+#define ND6_OPTION_TYPE_REDIR_HDR (0x04)
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct redirected_header_option {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t length);
+  PACK_STRUCT_FLD_8(u8_t reserved[6]);
+  /* Portion of redirected packet follows. */
+  /* PACK_STRUCT_FLD_8(u8_t redirected[8]); */
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/** MTU option. */
+#define ND6_OPTION_TYPE_MTU (0x05)
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct mtu_option {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t length);
+  PACK_STRUCT_FIELD(u16_t reserved);
+  PACK_STRUCT_FIELD(u32_t mtu);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/** Route information option. */
+#define ND6_OPTION_TYPE_ROUTE_INFO (24)
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct route_option {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t length);
+  PACK_STRUCT_FLD_8(u8_t prefix_length);
+  PACK_STRUCT_FLD_8(u8_t preference);
+  PACK_STRUCT_FIELD(u32_t route_lifetime);
+  PACK_STRUCT_FLD_S(ip6_addr_p_t prefix);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/** Recursive DNS Server Option. */
+#if LWIP_ND6_RDNSS_MAX_DNS_SERVERS
+#define LWIP_RDNSS_OPTION_MAX_SERVERS LWIP_ND6_RDNSS_MAX_DNS_SERVERS
+#else
+#define LWIP_RDNSS_OPTION_MAX_SERVERS 1
+#endif
+#define ND6_OPTION_TYPE_RDNSS (25)
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct rdnss_option {
+  PACK_STRUCT_FLD_8(u8_t type);
+  PACK_STRUCT_FLD_8(u8_t length);
+  PACK_STRUCT_FIELD(u16_t reserved);
+  PACK_STRUCT_FIELD(u32_t lifetime);
+  PACK_STRUCT_FLD_S(ip6_addr_p_t rdnss_address[LWIP_RDNSS_OPTION_MAX_SERVERS]);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_ND6_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/tcp.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/tcp.h
new file mode 100644
index 000000000..b251b80a8
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/tcp.h
@@ -0,0 +1,98 @@
+/**
+ * @file
+ * TCP protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_PROT_TCP_H
+#define LWIP_HDR_PROT_TCP_H
+
+#include "lwip/arch.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Length of the TCP header, excluding options. */
+#define TCP_HLEN 20
+
+/* Fields are (of course) in network byte order.
+ * Some fields are converted to host byte order in tcp_input().
+ */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct tcp_hdr {
+  PACK_STRUCT_FIELD(u16_t src);
+  PACK_STRUCT_FIELD(u16_t dest);
+  PACK_STRUCT_FIELD(u32_t seqno);
+  PACK_STRUCT_FIELD(u32_t ackno);
+  PACK_STRUCT_FIELD(u16_t _hdrlen_rsvd_flags);
+  PACK_STRUCT_FIELD(u16_t wnd);
+  PACK_STRUCT_FIELD(u16_t chksum);
+  PACK_STRUCT_FIELD(u16_t urgp);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+/* TCP header flags bits */
+#define TCP_FIN 0x01U
+#define TCP_SYN 0x02U
+#define TCP_RST 0x04U
+#define TCP_PSH 0x08U
+#define TCP_ACK 0x10U
+#define TCP_URG 0x20U
+#define TCP_ECE 0x40U
+#define TCP_CWR 0x80U
+/* Valid TCP header flags */
+#define TCP_FLAGS 0x3fU
+
+#define TCPH_HDRLEN(phdr) ((u16_t)(lwip_ntohs((phdr)->_hdrlen_rsvd_flags) >> 12))
+#define TCPH_HDRLEN_BYTES(phdr) ((u8_t)(TCPH_HDRLEN(phdr) << 2))
+#define TCPH_FLAGS(phdr)  ((u16_t)(lwip_ntohs((phdr)->_hdrlen_rsvd_flags) & TCP_FLAGS))
+
+#define TCPH_HDRLEN_SET(phdr, len) (phdr)->_hdrlen_rsvd_flags = lwip_htons(((len) << 12) | TCPH_FLAGS(phdr))
+#define TCPH_FLAGS_SET(phdr, flags) (phdr)->_hdrlen_rsvd_flags = (((phdr)->_hdrlen_rsvd_flags & PP_HTONS(~TCP_FLAGS)) | lwip_htons(flags))
+#define TCPH_HDRLEN_FLAGS_SET(phdr, len, flags) (phdr)->_hdrlen_rsvd_flags = (u16_t)(lwip_htons((u16_t)((len) << 12) | (flags)))
+
+#define TCPH_SET_FLAG(phdr, flags ) (phdr)->_hdrlen_rsvd_flags = ((phdr)->_hdrlen_rsvd_flags | lwip_htons(flags))
+#define TCPH_UNSET_FLAG(phdr, flags) (phdr)->_hdrlen_rsvd_flags = ((phdr)->_hdrlen_rsvd_flags & ~lwip_htons(flags))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_TCP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/udp.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/udp.h
new file mode 100644
index 000000000..664f19a3e
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/prot/udp.h
@@ -0,0 +1,68 @@
+/**
+ * @file
+ * UDP protocol definitions
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_PROT_UDP_H
+#define LWIP_HDR_PROT_UDP_H
+
+#include "lwip/arch.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define UDP_HLEN 8
+
+/* Fields are (of course) in network byte order. */
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/bpstruct.h"
+#endif
+PACK_STRUCT_BEGIN
+struct udp_hdr {
+  PACK_STRUCT_FIELD(u16_t src);
+  PACK_STRUCT_FIELD(u16_t dest);  /* src/dest UDP ports */
+  PACK_STRUCT_FIELD(u16_t len);
+  PACK_STRUCT_FIELD(u16_t chksum);
+} PACK_STRUCT_STRUCT;
+PACK_STRUCT_END
+#ifdef PACK_STRUCT_USE_INCLUDES
+#  include "arch/epstruct.h"
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_PROT_UDP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/raw.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/raw.h
new file mode 100644
index 000000000..787d91802
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/raw.h
@@ -0,0 +1,147 @@
+/**
+ * @file
+ * raw API (to be used from TCPIP thread)\n
+ * See also @ref raw_raw
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_RAW_H
+#define LWIP_HDR_RAW_H
+
+#include "lwip/opt.h"
+
+#if LWIP_RAW /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/pbuf.h"
+#include "lwip/def.h"
+#include "lwip/ip.h"
+#include "lwip/ip_addr.h"
+#include "lwip/ip6_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define RAW_FLAGS_CONNECTED      0x01U
+#define RAW_FLAGS_MULTICAST_LOOP 0x04U
+
+struct raw_pcb;
+
+/** Function prototype for raw pcb receive callback functions.
+ * @param arg user supplied argument (raw_pcb.recv_arg)
+ * @param pcb the raw_pcb which received data
+ * @param p the packet buffer that was received
+ * @param addr the remote IP address from which the packet was received
+ * @return 1 if the packet was 'eaten' (aka. deleted),
+ *         0 if the packet lives on
+ * If returning 1, the callback is responsible for freeing the pbuf
+ * if it's not used any more.
+ */
+typedef u8_t (*raw_recv_fn)(void *arg, struct raw_pcb *pcb, struct pbuf *p,
+    const ip_addr_t *addr);
+
+/** the RAW protocol control block */
+struct raw_pcb {
+  /* Common members of all PCB types */
+  IP_PCB;
+
+  struct raw_pcb *next;
+  struct netif *intf_filter;
+
+  u8_t protocol;
+  u8_t flags;
+
+#if LWIP_MULTICAST_TX_OPTIONS
+  /** outgoing network interface for multicast packets, by interface index (if nonzero) */
+  u8_t mcast_ifindex;
+  /** TTL for outgoing multicast packets */
+  u8_t mcast_ttl;
+#endif /* LWIP_MULTICAST_TX_OPTIONS */
+
+  /** receive callback function */
+  raw_recv_fn recv;
+  /* user-supplied argument for the recv callback */
+  void *recv_arg;
+#if LWIP_IPV6
+  /* fields for handling checksum computations as per RFC3542. */
+  u16_t chksum_offset;
+  u8_t  chksum_reqd;
+#endif
+};
+
+/* The following functions is the application layer interface to the
+   RAW code. */
+struct raw_pcb * raw_new        (u8_t proto);
+struct raw_pcb * raw_new_ip_type(u8_t type, u8_t proto);
+void             raw_remove     (struct raw_pcb *pcb);
+err_t            raw_bind       (struct raw_pcb *pcb, const ip_addr_t *ipaddr);
+void             raw_bind_netif (struct raw_pcb *pcb, const struct netif *netif);
+err_t            raw_connect    (struct raw_pcb *pcb, const ip_addr_t *ipaddr);
+void             raw_disconnect (struct raw_pcb *pcb);
+
+err_t            raw_sendto     (struct raw_pcb *pcb, struct pbuf *p, const ip_addr_t *ipaddr);
+err_t            raw_sendto_if_src(struct raw_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip, struct netif *netif, const ip_addr_t *src_ip);
+err_t            raw_send       (struct raw_pcb *pcb, struct pbuf *p);
+
+void             raw_recv       (struct raw_pcb *pcb, raw_recv_fn recv, void *recv_arg);
+
+#define          raw_flags(pcb) ((pcb)->flags)
+#define          raw_setflags(pcb,f)  ((pcb)->flags = (f))
+
+#define          raw_set_flags(pcb, set_flags)     do { (pcb)->flags = (u8_t)((pcb)->flags |  (set_flags)); } while(0)
+#define          raw_clear_flags(pcb, clr_flags)   do { (pcb)->flags = (u8_t)((pcb)->flags & ~(clr_flags)); } while(0)
+#define          raw_is_flag_set(pcb, flag)        (((pcb)->flags & (flag)) != 0)
+
+/* The following functions are the lower layer interface to RAW. */
+u8_t             raw_input      (struct pbuf *p, struct netif *inp);
+#define raw_init() /* Compatibility define, no init needed. */
+
+void raw_netif_ip_addr_changed(const ip_addr_t* old_addr, const ip_addr_t* new_addr);
+
+/* for compatibility with older implementation */
+#define raw_new_ip6(proto) raw_new_ip_type(IPADDR_TYPE_V6, proto)
+
+#if LWIP_MULTICAST_TX_OPTIONS
+#define raw_set_multicast_netif_index(pcb, idx) ((pcb)->mcast_ifindex = (idx))
+#define raw_get_multicast_netif_index(pcb)      ((pcb)->mcast_ifindex)
+#define raw_set_multicast_ttl(pcb, value)       ((pcb)->mcast_ttl = (value))
+#define raw_get_multicast_ttl(pcb)              ((pcb)->mcast_ttl)
+#endif /* LWIP_MULTICAST_TX_OPTIONS */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_RAW */
+
+#endif /* LWIP_HDR_RAW_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/sio.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/sio.h
new file mode 100644
index 000000000..7643e1956
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/sio.h
@@ -0,0 +1,142 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ */
+
+/*
+ * This is the interface to the platform specific serial IO module
+ * It needs to be implemented by those platforms which need SLIP or PPP
+ */
+
+#ifndef SIO_H
+#define SIO_H
+
+#include "lwip/arch.h"
+#include "lwip/opt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* If you want to define sio_fd_t elsewhere or differently,
+   define this in your cc.h file. */
+#ifndef __sio_fd_t_defined
+typedef void * sio_fd_t;
+#endif
+
+/* The following functions can be defined to something else in your cc.h file
+   or be implemented in your custom sio.c file. */
+
+#ifndef sio_open
+/**
+ * Opens a serial device for communication.
+ *
+ * @param devnum device number
+ * @return handle to serial device if successful, NULL otherwise
+ */
+sio_fd_t sio_open(u8_t devnum);
+#endif
+
+#ifndef sio_send
+/**
+ * Sends a single character to the serial device.
+ *
+ * @param c character to send
+ * @param fd serial device handle
+ *
+ * @note This function will block until the character can be sent.
+ */
+void sio_send(u8_t c, sio_fd_t fd);
+#endif
+
+#ifndef sio_recv
+/**
+ * Receives a single character from the serial device.
+ *
+ * @param fd serial device handle
+ *
+ * @note This function will block until a character is received.
+ */
+u8_t sio_recv(sio_fd_t fd);
+#endif
+
+#ifndef sio_read
+/**
+ * Reads from the serial device.
+ *
+ * @param fd serial device handle
+ * @param data pointer to data buffer for receiving
+ * @param len maximum length (in bytes) of data to receive
+ * @return number of bytes actually received - may be 0 if aborted by sio_read_abort
+ *
+ * @note This function will block until data can be received. The blocking
+ * can be cancelled by calling sio_read_abort().
+ */
+u32_t sio_read(sio_fd_t fd, u8_t *data, u32_t len);
+#endif
+
+#ifndef sio_tryread
+/**
+ * Tries to read from the serial device. Same as sio_read but returns
+ * immediately if no data is available and never blocks.
+ *
+ * @param fd serial device handle
+ * @param data pointer to data buffer for receiving
+ * @param len maximum length (in bytes) of data to receive
+ * @return number of bytes actually received
+ */
+u32_t sio_tryread(sio_fd_t fd, u8_t *data, u32_t len);
+#endif
+
+#ifndef sio_write
+/**
+ * Writes to the serial device.
+ *
+ * @param fd serial device handle
+ * @param data pointer to data to send
+ * @param len length (in bytes) of data to send
+ * @return number of bytes actually sent
+ *
+ * @note This function will block until all data can be sent.
+ */
+u32_t sio_write(sio_fd_t fd, u8_t *data, u32_t len);
+#endif
+
+#ifndef sio_read_abort
+/**
+ * Aborts a blocking sio_read() call.
+ *
+ * @param fd serial device handle
+ */
+void sio_read_abort(sio_fd_t fd);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* SIO_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/snmp.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/snmp.h
new file mode 100644
index 000000000..8704d0b4d
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/snmp.h
@@ -0,0 +1,213 @@
+/**
+ * @file
+ * SNMP support API for implementing netifs and statitics for MIB2
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Dirk Ziegelmeier <dziegel@gmx.de>
+ *
+ */
+#ifndef LWIP_HDR_SNMP_H
+#define LWIP_HDR_SNMP_H
+
+#include "lwip/opt.h"
+#include "lwip/ip_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct udp_pcb;
+struct netif;
+
+/**
+ * @defgroup netif_mib2 MIB2 statistics
+ * @ingroup netif
+ */
+
+/* MIB2 statistics functions */
+#if MIB2_STATS  /* don't build if not configured for use in lwipopts.h */
+/**
+ * @ingroup netif_mib2
+ * @see RFC1213, "MIB-II, 6. Definitions"
+ */
+enum snmp_ifType {
+  snmp_ifType_other=1,                /* none of the following */
+  snmp_ifType_regular1822,
+  snmp_ifType_hdh1822,
+  snmp_ifType_ddn_x25,
+  snmp_ifType_rfc877_x25,
+  snmp_ifType_ethernet_csmacd,
+  snmp_ifType_iso88023_csmacd,
+  snmp_ifType_iso88024_tokenBus,
+  snmp_ifType_iso88025_tokenRing,
+  snmp_ifType_iso88026_man,
+  snmp_ifType_starLan,
+  snmp_ifType_proteon_10Mbit,
+  snmp_ifType_proteon_80Mbit,
+  snmp_ifType_hyperchannel,
+  snmp_ifType_fddi,
+  snmp_ifType_lapb,
+  snmp_ifType_sdlc,
+  snmp_ifType_ds1,                    /* T-1 */
+  snmp_ifType_e1,                     /* european equiv. of T-1 */
+  snmp_ifType_basicISDN,
+  snmp_ifType_primaryISDN,            /* proprietary serial */
+  snmp_ifType_propPointToPointSerial,
+  snmp_ifType_ppp,
+  snmp_ifType_softwareLoopback,
+  snmp_ifType_eon,                    /* CLNP over IP [11] */
+  snmp_ifType_ethernet_3Mbit,
+  snmp_ifType_nsip,                   /* XNS over IP */
+  snmp_ifType_slip,                   /* generic SLIP */
+  snmp_ifType_ultra,                  /* ULTRA technologies */
+  snmp_ifType_ds3,                    /* T-3 */
+  snmp_ifType_sip,                    /* SMDS */
+  snmp_ifType_frame_relay
+};
+
+/** This macro has a precision of ~49 days because sys_now returns u32_t. \#define your own if you want ~490 days. */
+#ifndef MIB2_COPY_SYSUPTIME_TO
+#define MIB2_COPY_SYSUPTIME_TO(ptrToVal) (*(ptrToVal) = (sys_now() / 10))
+#endif
+
+/**
+ * @ingroup netif_mib2
+ * Increment stats member for SNMP MIB2 stats (struct stats_mib2_netif_ctrs)
+ */
+#define MIB2_STATS_NETIF_INC(n, x)      do { ++(n)->mib2_counters.x; } while(0)
+/**
+ * @ingroup netif_mib2
+ * Add value to stats member for SNMP MIB2 stats (struct stats_mib2_netif_ctrs)
+ */
+#define MIB2_STATS_NETIF_ADD(n, x, val) do { (n)->mib2_counters.x += (val); } while(0)
+
+/**
+ * @ingroup netif_mib2
+ * Init MIB2 statistic counters in netif
+ * @param netif Netif to init
+ * @param type one of enum @ref snmp_ifType
+ * @param speed your link speed here (units: bits per second)
+ */
+#define MIB2_INIT_NETIF(netif, type, speed) do { \
+  (netif)->link_type = (type);  \
+  (netif)->link_speed = (speed);\
+  (netif)->ts = 0;              \
+  (netif)->mib2_counters.ifinoctets = 0;      \
+  (netif)->mib2_counters.ifinucastpkts = 0;   \
+  (netif)->mib2_counters.ifinnucastpkts = 0;  \
+  (netif)->mib2_counters.ifindiscards = 0;    \
+  (netif)->mib2_counters.ifinerrors = 0;    \
+  (netif)->mib2_counters.ifinunknownprotos = 0;    \
+  (netif)->mib2_counters.ifoutoctets = 0;     \
+  (netif)->mib2_counters.ifoutucastpkts = 0;  \
+  (netif)->mib2_counters.ifoutnucastpkts = 0; \
+  (netif)->mib2_counters.ifoutdiscards = 0; \
+  (netif)->mib2_counters.ifouterrors = 0; } while(0)
+#else /* MIB2_STATS */
+#ifndef MIB2_COPY_SYSUPTIME_TO
+#define MIB2_COPY_SYSUPTIME_TO(ptrToVal)
+#endif
+#define MIB2_INIT_NETIF(netif, type, speed)
+#define MIB2_STATS_NETIF_INC(n, x)
+#define MIB2_STATS_NETIF_ADD(n, x, val)
+#endif /* MIB2_STATS */
+
+/* LWIP MIB2 callbacks */
+#if LWIP_MIB2_CALLBACKS /* don't build if not configured for use in lwipopts.h */
+/* network interface */
+void mib2_netif_added(struct netif *ni);
+void mib2_netif_removed(struct netif *ni);
+
+#if LWIP_IPV4 && LWIP_ARP
+/* ARP (for atTable and ipNetToMediaTable) */
+void mib2_add_arp_entry(struct netif *ni, ip4_addr_t *ip);
+void mib2_remove_arp_entry(struct netif *ni, ip4_addr_t *ip);
+#else /* LWIP_IPV4 && LWIP_ARP */
+#define mib2_add_arp_entry(ni,ip)
+#define mib2_remove_arp_entry(ni,ip)
+#endif /* LWIP_IPV4 && LWIP_ARP */
+
+/* IP */
+#if LWIP_IPV4
+void mib2_add_ip4(struct netif *ni);
+void mib2_remove_ip4(struct netif *ni);
+void mib2_add_route_ip4(u8_t dflt, struct netif *ni);
+void mib2_remove_route_ip4(u8_t dflt, struct netif *ni);
+#endif /* LWIP_IPV4 */
+
+/* UDP */
+#if LWIP_UDP
+void mib2_udp_bind(struct udp_pcb *pcb);
+void mib2_udp_unbind(struct udp_pcb *pcb);
+#endif /* LWIP_UDP */
+
+#else /* LWIP_MIB2_CALLBACKS */
+/* LWIP_MIB2_CALLBACKS support not available */
+/* define everything to be empty */
+
+/* network interface */
+#define mib2_netif_added(ni)
+#define mib2_netif_removed(ni)
+
+/* ARP */
+#define mib2_add_arp_entry(ni,ip)
+#define mib2_remove_arp_entry(ni,ip)
+
+/* IP */
+#define mib2_add_ip4(ni)
+#define mib2_remove_ip4(ni)
+#define mib2_add_route_ip4(dflt, ni)
+#define mib2_remove_route_ip4(dflt, ni)
+
+/* UDP */
+#define mib2_udp_bind(pcb)
+#define mib2_udp_unbind(pcb)
+#endif /* LWIP_MIB2_CALLBACKS */
+
+/* for source-code compatibility reasons only, can be removed (not used internally) */
+#define NETIF_INIT_SNMP                MIB2_INIT_NETIF
+#define snmp_add_ifinoctets(ni,value)  MIB2_STATS_NETIF_ADD(ni, ifinoctets, value)
+#define snmp_inc_ifinucastpkts(ni)     MIB2_STATS_NETIF_INC(ni, ifinucastpkts)
+#define snmp_inc_ifinnucastpkts(ni)    MIB2_STATS_NETIF_INC(ni, ifinnucastpkts)
+#define snmp_inc_ifindiscards(ni)      MIB2_STATS_NETIF_INC(ni, ifindiscards)
+#define snmp_inc_ifinerrors(ni)        MIB2_STATS_NETIF_INC(ni, ifinerrors)
+#define snmp_inc_ifinunknownprotos(ni) MIB2_STATS_NETIF_INC(ni, ifinunknownprotos)
+#define snmp_add_ifoutoctets(ni,value) MIB2_STATS_NETIF_ADD(ni, ifoutoctets, value)
+#define snmp_inc_ifoutucastpkts(ni)    MIB2_STATS_NETIF_INC(ni, ifoutucastpkts)
+#define snmp_inc_ifoutnucastpkts(ni)   MIB2_STATS_NETIF_INC(ni, ifoutnucastpkts)
+#define snmp_inc_ifoutdiscards(ni)     MIB2_STATS_NETIF_INC(ni, ifoutdiscards)
+#define snmp_inc_ifouterrors(ni)       MIB2_STATS_NETIF_INC(ni, ifouterrors)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_SNMP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/sockets.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/sockets.h
new file mode 100644
index 000000000..2522056db
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/sockets.h
@@ -0,0 +1,593 @@
+/**
+ * @file
+ * Socket API (to be used from non-TCPIP threads)
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+
+#ifndef LWIP_HDR_SOCKETS_H
+#define LWIP_HDR_SOCKETS_H
+
+#include "lwip/opt.h"
+
+#if LWIP_SOCKET /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/ip_addr.h"
+#include "lwip/err.h"
+#include "lwip/inet.h"
+#include "lwip/errno.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* If your port already typedef's sa_family_t, define SA_FAMILY_T_DEFINED
+   to prevent this code from redefining it. */
+#if !defined(sa_family_t) && !defined(SA_FAMILY_T_DEFINED)
+typedef u8_t sa_family_t;
+#endif
+/* If your port already typedef's in_port_t, define IN_PORT_T_DEFINED
+   to prevent this code from redefining it. */
+#if !defined(in_port_t) && !defined(IN_PORT_T_DEFINED)
+typedef u16_t in_port_t;
+#endif
+
+#if LWIP_IPV4
+/* members are in network byte order */
+struct sockaddr_in {
+  u8_t            sin_len;
+  sa_family_t     sin_family;
+  in_port_t       sin_port;
+  struct in_addr  sin_addr;
+#define SIN_ZERO_LEN 8
+  char            sin_zero[SIN_ZERO_LEN];
+};
+#endif /* LWIP_IPV4 */
+
+#if LWIP_IPV6
+struct sockaddr_in6 {
+  u8_t            sin6_len;      /* length of this structure    */
+  sa_family_t     sin6_family;   /* AF_INET6                    */
+  in_port_t       sin6_port;     /* Transport layer port #      */
+  u32_t           sin6_flowinfo; /* IPv6 flow information       */
+  struct in6_addr sin6_addr;     /* IPv6 address                */
+  u32_t           sin6_scope_id; /* Set of interfaces for scope */
+};
+#endif /* LWIP_IPV6 */
+
+struct sockaddr {
+  u8_t        sa_len;
+  sa_family_t sa_family;
+  char        sa_data[14];
+};
+
+struct sockaddr_storage {
+  u8_t        s2_len;
+  sa_family_t ss_family;
+  char        s2_data1[2];
+  u32_t       s2_data2[3];
+#if LWIP_IPV6
+  u32_t       s2_data3[3];
+#endif /* LWIP_IPV6 */
+};
+
+/* If your port already typedef's socklen_t, define SOCKLEN_T_DEFINED
+   to prevent this code from redefining it. */
+#if !defined(socklen_t) && !defined(SOCKLEN_T_DEFINED)
+typedef u32_t socklen_t;
+#endif
+
+struct lwip_sock;
+
+#if !LWIP_TCPIP_CORE_LOCKING
+/** Maximum optlen used by setsockopt/getsockopt */
+#define LWIP_SETGETSOCKOPT_MAXOPTLEN 16
+
+/** This struct is used to pass data to the set/getsockopt_internal
+ * functions running in tcpip_thread context (only a void* is allowed) */
+struct lwip_setgetsockopt_data {
+  /** socket index for which to change options */
+  int s;
+  /** level of the option to process */
+  int level;
+  /** name of the option to process */
+  int optname;
+  /** set: value to set the option to
+    * get: value of the option is stored here */
+#if LWIP_MPU_COMPATIBLE
+  u8_t optval[LWIP_SETGETSOCKOPT_MAXOPTLEN];
+#else
+  union {
+     void *p;
+     const void *pc;
+  } optval;
+#endif
+  /** size of *optval */
+  socklen_t optlen;
+  /** if an error occurs, it is temporarily stored here */
+  err_t err;
+  /** semaphore to wake up the calling task */
+  void* completed_sem;
+};
+#endif /* !LWIP_TCPIP_CORE_LOCKING */
+
+#if !defined(iovec)
+struct iovec {
+  void  *iov_base;
+  size_t iov_len;
+};
+#endif
+
+struct msghdr {
+  void         *msg_name;
+  socklen_t     msg_namelen;
+  struct iovec *msg_iov;
+  int           msg_iovlen;
+  void         *msg_control;
+  socklen_t     msg_controllen;
+  int           msg_flags;
+};
+
+/* Socket protocol types (TCP/UDP/RAW) */
+#define SOCK_STREAM     1
+#define SOCK_DGRAM      2
+#define SOCK_RAW        3
+
+/*
+ * Option flags per-socket. These must match the SOF_ flags in ip.h (checked in init.c)
+ */
+#define SO_REUSEADDR   0x0004 /* Allow local address reuse */
+#define SO_KEEPALIVE   0x0008 /* keep connections alive */
+#define SO_BROADCAST   0x0020 /* permit to send and to receive broadcast messages (see IP_SOF_BROADCAST option) */
+
+
+/*
+ * Additional options, not kept in so_options.
+ */
+#define SO_DEBUG       0x0001 /* Unimplemented: turn on debugging info recording */
+#define SO_ACCEPTCONN  0x0002 /* socket has had listen() */
+#define SO_DONTROUTE   0x0010 /* Unimplemented: just use interface addresses */
+#define SO_USELOOPBACK 0x0040 /* Unimplemented: bypass hardware when possible */
+#define SO_LINGER      0x0080 /* linger on close if data present */
+#define SO_DONTLINGER  ((int)(~SO_LINGER))
+#define SO_OOBINLINE   0x0100 /* Unimplemented: leave received OOB data in line */
+#define SO_REUSEPORT   0x0200 /* Unimplemented: allow local address & port reuse */
+#define SO_SNDBUF      0x1001 /* Unimplemented: send buffer size */
+#define SO_RCVBUF      0x1002 /* receive buffer size */
+#define SO_SNDLOWAT    0x1003 /* Unimplemented: send low-water mark */
+#define SO_RCVLOWAT    0x1004 /* Unimplemented: receive low-water mark */
+#define SO_SNDTIMEO    0x1005 /* send timeout */
+#define SO_RCVTIMEO    0x1006 /* receive timeout */
+#define SO_ERROR       0x1007 /* get error status and clear */
+#define SO_TYPE        0x1008 /* get socket type */
+#define SO_CONTIMEO    0x1009 /* Unimplemented: connect timeout */
+#define SO_NO_CHECK    0x100a /* don't create UDP checksum */
+
+
+/*
+ * Structure used for manipulating linger option.
+ */
+struct linger {
+       int l_onoff;                /* option on/off */
+       int l_linger;               /* linger time in seconds */
+};
+
+/*
+ * Level number for (get/set)sockopt() to apply to socket itself.
+ */
+#define  SOL_SOCKET  0xfff    /* options for socket level */
+
+
+#define AF_UNSPEC       0
+#define AF_INET         2
+#if LWIP_IPV6
+#define AF_INET6        10
+#else /* LWIP_IPV6 */
+#define AF_INET6        AF_UNSPEC
+#endif /* LWIP_IPV6 */
+#define PF_INET         AF_INET
+#define PF_INET6        AF_INET6
+#define PF_UNSPEC       AF_UNSPEC
+
+#define IPPROTO_IP      0
+#define IPPROTO_ICMP    1
+#define IPPROTO_TCP     6
+#define IPPROTO_UDP     17
+#if LWIP_IPV6
+#define IPPROTO_IPV6    41
+#define IPPROTO_ICMPV6  58
+#endif /* LWIP_IPV6 */
+#define IPPROTO_UDPLITE 136
+#define IPPROTO_RAW     255
+
+/* Flags we can use with send and recv. */
+#define MSG_PEEK       0x01    /* Peeks at an incoming message */
+#define MSG_WAITALL    0x02    /* Unimplemented: Requests that the function block until the full amount of data requested can be returned */
+#define MSG_OOB        0x04    /* Unimplemented: Requests out-of-band data. The significance and semantics of out-of-band data are protocol-specific */
+#define MSG_DONTWAIT   0x08    /* Nonblocking i/o for this operation only */
+#define MSG_MORE       0x10    /* Sender will send more */
+
+
+/*
+ * Options for level IPPROTO_IP
+ */
+#define IP_TOS             1
+#define IP_TTL             2
+
+#if LWIP_TCP
+/*
+ * Options for level IPPROTO_TCP
+ */
+#define TCP_NODELAY    0x01    /* don't delay send to coalesce packets */
+#define TCP_KEEPALIVE  0x02    /* send KEEPALIVE probes when idle for pcb->keep_idle milliseconds */
+#define TCP_KEEPIDLE   0x03    /* set pcb->keep_idle  - Same as TCP_KEEPALIVE, but use seconds for get/setsockopt */
+#define TCP_KEEPINTVL  0x04    /* set pcb->keep_intvl - Use seconds for get/setsockopt */
+#define TCP_KEEPCNT    0x05    /* set pcb->keep_cnt   - Use number of probes sent for get/setsockopt */
+#endif /* LWIP_TCP */
+
+#if LWIP_IPV6
+/*
+ * Options for level IPPROTO_IPV6
+ */
+#define IPV6_CHECKSUM       7  /* RFC3542: calculate and insert the ICMPv6 checksum for raw sockets. */
+#define IPV6_V6ONLY         27 /* RFC3493: boolean control to restrict AF_INET6 sockets to IPv6 communications only. */
+#endif /* LWIP_IPV6 */
+
+#if LWIP_UDP && LWIP_UDPLITE
+/*
+ * Options for level IPPROTO_UDPLITE
+ */
+#define UDPLITE_SEND_CSCOV 0x01 /* sender checksum coverage */
+#define UDPLITE_RECV_CSCOV 0x02 /* minimal receiver checksum coverage */
+#endif /* LWIP_UDP && LWIP_UDPLITE*/
+
+
+#if LWIP_MULTICAST_TX_OPTIONS
+/*
+ * Options and types for UDP multicast traffic handling
+ */
+#define IP_MULTICAST_TTL   5
+#define IP_MULTICAST_IF    6
+#define IP_MULTICAST_LOOP  7
+#endif /* LWIP_MULTICAST_TX_OPTIONS */
+
+#if LWIP_IGMP
+/*
+ * Options and types related to multicast membership
+ */
+#define IP_ADD_MEMBERSHIP  3
+#define IP_DROP_MEMBERSHIP 4
+
+typedef struct ip_mreq {
+    struct in_addr imr_multiaddr; /* IP multicast address of group */
+    struct in_addr imr_interface; /* local IP address of interface */
+} ip_mreq;
+#endif /* LWIP_IGMP */
+
+/*
+ * The Type of Service provides an indication of the abstract
+ * parameters of the quality of service desired.  These parameters are
+ * to be used to guide the selection of the actual service parameters
+ * when transmitting a datagram through a particular network.  Several
+ * networks offer service precedence, which somehow treats high
+ * precedence traffic as more important than other traffic (generally
+ * by accepting only traffic above a certain precedence at time of high
+ * load).  The major choice is a three way tradeoff between low-delay,
+ * high-reliability, and high-throughput.
+ * The use of the Delay, Throughput, and Reliability indications may
+ * increase the cost (in some sense) of the service.  In many networks
+ * better performance for one of these parameters is coupled with worse
+ * performance on another.  Except for very unusual cases at most two
+ * of these three indications should be set.
+ */
+#define IPTOS_TOS_MASK          0x1E
+#define IPTOS_TOS(tos)          ((tos) & IPTOS_TOS_MASK)
+#define IPTOS_LOWDELAY          0x10
+#define IPTOS_THROUGHPUT        0x08
+#define IPTOS_RELIABILITY       0x04
+#define IPTOS_LOWCOST           0x02
+#define IPTOS_MINCOST           IPTOS_LOWCOST
+
+/*
+ * The Network Control precedence designation is intended to be used
+ * within a network only.  The actual use and control of that
+ * designation is up to each network. The Internetwork Control
+ * designation is intended for use by gateway control originators only.
+ * If the actual use of these precedence designations is of concern to
+ * a particular network, it is the responsibility of that network to
+ * control the access to, and use of, those precedence designations.
+ */
+#define IPTOS_PREC_MASK                 0xe0
+#define IPTOS_PREC(tos)                ((tos) & IPTOS_PREC_MASK)
+#define IPTOS_PREC_NETCONTROL           0xe0
+#define IPTOS_PREC_INTERNETCONTROL      0xc0
+#define IPTOS_PREC_CRITIC_ECP           0xa0
+#define IPTOS_PREC_FLASHOVERRIDE        0x80
+#define IPTOS_PREC_FLASH                0x60
+#define IPTOS_PREC_IMMEDIATE            0x40
+#define IPTOS_PREC_PRIORITY             0x20
+#define IPTOS_PREC_ROUTINE              0x00
+
+
+/*
+ * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.
+ * lwip_ioctl only supports FIONREAD and FIONBIO, for now
+ *
+ * Ioctl's have the command encoded in the lower word,
+ * and the size of any in or out parameters in the upper
+ * word.  The high 2 bits of the upper word are used
+ * to encode the in/out status of the parameter; for now
+ * we restrict parameters to at most 128 bytes.
+ */
+#if !defined(FIONREAD) || !defined(FIONBIO)
+#define IOCPARM_MASK    0x7fU           /* parameters must be < 128 bytes */
+#define IOC_VOID        0x20000000UL    /* no parameters */
+#define IOC_OUT         0x40000000UL    /* copy out parameters */
+#define IOC_IN          0x80000000UL    /* copy in parameters */
+#define IOC_INOUT       (IOC_IN|IOC_OUT)
+                                        /* 0x20000000 distinguishes new &
+                                           old ioctl's */
+#define _IO(x,y)        (IOC_VOID|((x)<<8)|(y))
+
+#define _IOR(x,y,t)     (IOC_OUT|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))
+
+#define _IOW(x,y,t)     (IOC_IN|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))
+#endif /* !defined(FIONREAD) || !defined(FIONBIO) */
+
+#ifndef FIONREAD
+#define FIONREAD    _IOR('f', 127, unsigned long) /* get # bytes to read */
+#endif
+#ifndef FIONBIO
+#define FIONBIO     _IOW('f', 126, unsigned long) /* set/clear non-blocking i/o */
+#endif
+
+/* Socket I/O Controls: unimplemented */
+#ifndef SIOCSHIWAT
+#define SIOCSHIWAT  _IOW('s',  0, unsigned long)  /* set high watermark */
+#define SIOCGHIWAT  _IOR('s',  1, unsigned long)  /* get high watermark */
+#define SIOCSLOWAT  _IOW('s',  2, unsigned long)  /* set low watermark */
+#define SIOCGLOWAT  _IOR('s',  3, unsigned long)  /* get low watermark */
+#define SIOCATMARK  _IOR('s',  7, unsigned long)  /* at oob mark? */
+#endif
+
+/* commands for fnctl */
+#ifndef F_GETFL
+#define F_GETFL 3
+#endif
+#ifndef F_SETFL
+#define F_SETFL 4
+#endif
+
+/* File status flags and file access modes for fnctl,
+   these are bits in an int. */
+#ifndef O_NONBLOCK
+#define O_NONBLOCK  1 /* nonblocking I/O */
+#endif
+#ifndef O_NDELAY
+#define O_NDELAY    1 /* same as O_NONBLOCK, for compatibility */
+#endif
+
+#ifndef SHUT_RD
+  #define SHUT_RD   0
+  #define SHUT_WR   1
+  #define SHUT_RDWR 2
+#endif
+
+/* FD_SET used for lwip_select */
+#ifndef FD_SET
+#undef  FD_SETSIZE
+/* Make FD_SETSIZE match NUM_SOCKETS in socket.c */
+#define FD_SETSIZE    MEMP_NUM_NETCONN
+#define FDSETSAFESET(n, code) do { \
+  if (((n) - LWIP_SOCKET_OFFSET < MEMP_NUM_NETCONN) && (((int)(n) - LWIP_SOCKET_OFFSET) >= 0)) { \
+  code; }} while(0)
+#define FDSETSAFEGET(n, code) (((n) - LWIP_SOCKET_OFFSET < MEMP_NUM_NETCONN) && (((int)(n) - LWIP_SOCKET_OFFSET) >= 0) ?\
+  (code) : 0)
+#define FD_SET(n, p)  FDSETSAFESET(n, (p)->fd_bits[((n)-LWIP_SOCKET_OFFSET)/8] |=  (1 << (((n)-LWIP_SOCKET_OFFSET) & 7)))
+#define FD_CLR(n, p)  FDSETSAFESET(n, (p)->fd_bits[((n)-LWIP_SOCKET_OFFSET)/8] &= ~(1 << (((n)-LWIP_SOCKET_OFFSET) & 7)))
+#define FD_ISSET(n,p) FDSETSAFEGET(n, (p)->fd_bits[((n)-LWIP_SOCKET_OFFSET)/8] &   (1 << (((n)-LWIP_SOCKET_OFFSET) & 7)))
+#define FD_ZERO(p)    memset((void*)(p), 0, sizeof(*(p)))
+
+typedef struct fd_set
+{
+  unsigned char fd_bits [(FD_SETSIZE+7)/8];
+} fd_set;
+
+#elif LWIP_SOCKET_OFFSET
+#error LWIP_SOCKET_OFFSET does not work with external FD_SET!
+#elif FD_SETSIZE < MEMP_NUM_NETCONN
+#error "external FD_SETSIZE too small for number of sockets"
+#endif /* FD_SET */
+
+/** LWIP_TIMEVAL_PRIVATE: if you want to use the struct timeval provided
+ * by your system, set this to 0 and include <sys/time.h> in cc.h */
+#ifndef LWIP_TIMEVAL_PRIVATE
+#define LWIP_TIMEVAL_PRIVATE 1
+#endif
+
+#if LWIP_TIMEVAL_PRIVATE
+struct timeval {
+  long    tv_sec;         /* seconds */
+  long    tv_usec;        /* and microseconds */
+};
+#endif /* LWIP_TIMEVAL_PRIVATE */
+
+#define lwip_socket_init() /* Compatibility define, no init needed. */
+void lwip_socket_thread_init(void); /* LWIP_NETCONN_SEM_PER_THREAD==1: initialize thread-local semaphore */
+void lwip_socket_thread_cleanup(void); /* LWIP_NETCONN_SEM_PER_THREAD==1: destroy thread-local semaphore */
+
+#if LWIP_COMPAT_SOCKETS == 2
+/* This helps code parsers/code completion by not having the COMPAT functions as defines */
+#define lwip_accept       accept
+#define lwip_bind         bind
+#define lwip_shutdown     shutdown
+#define lwip_getpeername  getpeername
+#define lwip_getsockname  getsockname
+#define lwip_setsockopt   setsockopt
+#define lwip_getsockopt   getsockopt
+#define lwip_close        closesocket
+#define lwip_connect      connect
+#define lwip_listen       listen
+#define lwip_recv         recv
+#define lwip_recvfrom     recvfrom
+#define lwip_send         send
+#define lwip_sendmsg      sendmsg
+#define lwip_sendto       sendto
+#define lwip_socket       socket
+#define lwip_select       select
+#define lwip_ioctlsocket  ioctl
+
+#if LWIP_POSIX_SOCKETS_IO_NAMES
+#define lwip_read         read
+#define lwip_write        write
+#define lwip_writev       writev
+#undef lwip_close
+#define lwip_close        close
+#define closesocket(s)    close(s)
+#define lwip_fcntl        fcntl
+#define lwip_ioctl        ioctl
+#endif /* LWIP_POSIX_SOCKETS_IO_NAMES */
+#endif /* LWIP_COMPAT_SOCKETS == 2 */
+
+int lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen);
+int lwip_bind(int s, const struct sockaddr *name, socklen_t namelen);
+int lwip_shutdown(int s, int how);
+int lwip_getpeername (int s, struct sockaddr *name, socklen_t *namelen);
+int lwip_getsockname (int s, struct sockaddr *name, socklen_t *namelen);
+int lwip_getsockopt (int s, int level, int optname, void *optval, socklen_t *optlen);
+int lwip_setsockopt (int s, int level, int optname, const void *optval, socklen_t optlen);
+int lwip_close(int s);
+int lwip_connect(int s, const struct sockaddr *name, socklen_t namelen);
+int lwip_listen(int s, int backlog);
+int lwip_recv(int s, void *mem, size_t len, int flags);
+int lwip_read(int s, void *mem, size_t len);
+int lwip_recvfrom(int s, void *mem, size_t len, int flags,
+      struct sockaddr *from, socklen_t *fromlen);
+int lwip_send(int s, const void *dataptr, size_t size, int flags);
+int lwip_sendmsg(int s, const struct msghdr *message, int flags);
+int lwip_sendto(int s, const void *dataptr, size_t size, int flags,
+    const struct sockaddr *to, socklen_t tolen);
+int lwip_socket(int domain, int type, int protocol);
+int lwip_write(int s, const void *dataptr, size_t size);
+int lwip_writev(int s, const struct iovec *iov, int iovcnt);
+int lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
+                struct timeval *timeout);
+int lwip_ioctl(int s, long cmd, void *argp);
+int lwip_fcntl(int s, int cmd, int val);
+
+#if LWIP_COMPAT_SOCKETS
+#if LWIP_COMPAT_SOCKETS != 2
+/** @ingroup socket */
+#define accept(s,addr,addrlen)                    lwip_accept(s,addr,addrlen)
+/** @ingroup socket */
+#define bind(s,name,namelen)                      lwip_bind(s,name,namelen)
+/** @ingroup socket */
+#define shutdown(s,how)                           lwip_shutdown(s,how)
+/** @ingroup socket */
+#define getpeername(s,name,namelen)               lwip_getpeername(s,name,namelen)
+/** @ingroup socket */
+#define getsockname(s,name,namelen)               lwip_getsockname(s,name,namelen)
+/** @ingroup socket */
+#define setsockopt(s,level,optname,opval,optlen)  lwip_setsockopt(s,level,optname,opval,optlen)
+/** @ingroup socket */
+#define getsockopt(s,level,optname,opval,optlen)  lwip_getsockopt(s,level,optname,opval,optlen)
+/** @ingroup socket */
+#define closesocket(s)                            lwip_close(s)
+/** @ingroup socket */
+#define connect(s,name,namelen)                   lwip_connect(s,name,namelen)
+/** @ingroup socket */
+#define listen(s,backlog)                         lwip_listen(s,backlog)
+/** @ingroup socket */
+#define recv(s,mem,len,flags)                     lwip_recv(s,mem,len,flags)
+/** @ingroup socket */
+#define recvfrom(s,mem,len,flags,from,fromlen)    lwip_recvfrom(s,mem,len,flags,from,fromlen)
+/** @ingroup socket */
+#define send(s,dataptr,size,flags)                lwip_send(s,dataptr,size,flags)
+/** @ingroup socket */
+#define sendmsg(s,message,flags)                  lwip_sendmsg(s,message,flags)
+/** @ingroup socket */
+#define sendto(s,dataptr,size,flags,to,tolen)     lwip_sendto(s,dataptr,size,flags,to,tolen)
+/** @ingroup socket */
+#define socket(domain,type,protocol)              lwip_socket(domain,type,protocol)
+/** @ingroup socket */
+#define select(maxfdp1,readset,writeset,exceptset,timeout)     lwip_select(maxfdp1,readset,writeset,exceptset,timeout)
+/** @ingroup socket */
+#define ioctlsocket(s,cmd,argp)                   lwip_ioctl(s,cmd,argp)
+
+#if LWIP_POSIX_SOCKETS_IO_NAMES
+/** @ingroup socket */
+#define read(s,mem,len)                           lwip_read(s,mem,len)
+/** @ingroup socket */
+#define write(s,dataptr,len)                      lwip_write(s,dataptr,len)
+/** @ingroup socket */
+#define writev(s,iov,iovcnt)                      lwip_writev(s,iov,iovcnt)
+/** @ingroup socket */
+#define close(s)                                  lwip_close(s)
+/** @ingroup socket */
+#define fcntl(s,cmd,val)                          lwip_fcntl(s,cmd,val)
+/** @ingroup socket */
+#define ioctl(s,cmd,argp)                         lwip_ioctl(s,cmd,argp)
+#endif /* LWIP_POSIX_SOCKETS_IO_NAMES */
+#endif /* LWIP_COMPAT_SOCKETS != 2 */
+
+#if LWIP_IPV4 && LWIP_IPV6
+/** @ingroup socket */
+#define inet_ntop(af,src,dst,size) \
+    (((af) == AF_INET6) ? ip6addr_ntoa_r((const ip6_addr_t*)(src),(dst),(size)) \
+     : (((af) == AF_INET) ? ip4addr_ntoa_r((const ip4_addr_t*)(src),(dst),(size)) : NULL))
+/** @ingroup socket */
+#define inet_pton(af,src,dst) \
+    (((af) == AF_INET6) ? ip6addr_aton((src),(ip6_addr_t*)(dst)) \
+     : (((af) == AF_INET) ? ip4addr_aton((src),(ip4_addr_t*)(dst)) : 0))
+#elif LWIP_IPV4 /* LWIP_IPV4 && LWIP_IPV6 */
+#define inet_ntop(af,src,dst,size) \
+    (((af) == AF_INET) ? ip4addr_ntoa_r((const ip4_addr_t*)(src),(dst),(size)) : NULL)
+#define inet_pton(af,src,dst) \
+    (((af) == AF_INET) ? ip4addr_aton((src),(ip4_addr_t*)(dst)) : 0)
+#else /* LWIP_IPV4 && LWIP_IPV6 */
+#define inet_ntop(af,src,dst,size) \
+    (((af) == AF_INET6) ? ip6addr_ntoa_r((const ip6_addr_t*)(src),(dst),(size)) : NULL)
+#define inet_pton(af,src,dst) \
+    (((af) == AF_INET6) ? ip6addr_aton((src),(ip6_addr_t*)(dst)) : 0)
+#endif /* LWIP_IPV4 && LWIP_IPV6 */
+
+#endif /* LWIP_COMPAT_SOCKETS */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_SOCKET */
+
+#endif /* LWIP_HDR_SOCKETS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/stats.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/stats.h
new file mode 100644
index 000000000..b570dbacf
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/stats.h
@@ -0,0 +1,491 @@
+/**
+ * @file
+ * Statistics API (to be used from TCPIP thread)
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_STATS_H
+#define LWIP_HDR_STATS_H
+
+#include "lwip/opt.h"
+
+#include "lwip/mem.h"
+#include "lwip/memp.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_STATS
+
+#ifndef LWIP_STATS_LARGE
+#define LWIP_STATS_LARGE 0
+#endif
+
+#if LWIP_STATS_LARGE
+#define STAT_COUNTER     u32_t
+#define STAT_COUNTER_F   U32_F
+#else
+#define STAT_COUNTER     u16_t
+#define STAT_COUNTER_F   U16_F
+#endif
+
+/** Protocol related stats */
+struct stats_proto {
+  STAT_COUNTER xmit;             /* Transmitted packets. */
+  STAT_COUNTER recv;             /* Received packets. */
+  STAT_COUNTER fw;               /* Forwarded packets. */
+  STAT_COUNTER drop;             /* Dropped packets. */
+  STAT_COUNTER chkerr;           /* Checksum error. */
+  STAT_COUNTER lenerr;           /* Invalid length error. */
+  STAT_COUNTER memerr;           /* Out of memory error. */
+  STAT_COUNTER rterr;            /* Routing error. */
+  STAT_COUNTER proterr;          /* Protocol error. */
+  STAT_COUNTER opterr;           /* Error in options. */
+  STAT_COUNTER err;              /* Misc error. */
+  STAT_COUNTER cachehit;
+};
+
+/** IGMP stats */
+struct stats_igmp {
+  STAT_COUNTER xmit;             /* Transmitted packets. */
+  STAT_COUNTER recv;             /* Received packets. */
+  STAT_COUNTER drop;             /* Dropped packets. */
+  STAT_COUNTER chkerr;           /* Checksum error. */
+  STAT_COUNTER lenerr;           /* Invalid length error. */
+  STAT_COUNTER memerr;           /* Out of memory error. */
+  STAT_COUNTER proterr;          /* Protocol error. */
+  STAT_COUNTER rx_v1;            /* Received v1 frames. */
+  STAT_COUNTER rx_group;         /* Received group-specific queries. */
+  STAT_COUNTER rx_general;       /* Received general queries. */
+  STAT_COUNTER rx_report;        /* Received reports. */
+  STAT_COUNTER tx_join;          /* Sent joins. */
+  STAT_COUNTER tx_leave;         /* Sent leaves. */
+  STAT_COUNTER tx_report;        /* Sent reports. */
+};
+
+/** Memory stats */
+struct stats_mem {
+#if defined(LWIP_DEBUG) || LWIP_STATS_DISPLAY
+  const char *name;
+#endif /* defined(LWIP_DEBUG) || LWIP_STATS_DISPLAY */
+  STAT_COUNTER err;
+  mem_size_t avail;
+  mem_size_t used;
+  mem_size_t max;
+  STAT_COUNTER illegal;
+};
+
+/** System element stats */
+struct stats_syselem {
+  STAT_COUNTER used;
+  STAT_COUNTER max;
+  STAT_COUNTER err;
+};
+
+/** System stats */
+struct stats_sys {
+  struct stats_syselem sem;
+  struct stats_syselem mutex;
+  struct stats_syselem mbox;
+};
+
+/** SNMP MIB2 stats */
+struct stats_mib2 {
+  /* IP */
+  u32_t ipinhdrerrors;
+  u32_t ipinaddrerrors;
+  u32_t ipinunknownprotos;
+  u32_t ipindiscards;
+  u32_t ipindelivers;
+  u32_t ipoutrequests;
+  u32_t ipoutdiscards;
+  u32_t ipoutnoroutes;
+  u32_t ipreasmoks;
+  u32_t ipreasmfails;
+  u32_t ipfragoks;
+  u32_t ipfragfails;
+  u32_t ipfragcreates;
+  u32_t ipreasmreqds;
+  u32_t ipforwdatagrams;
+  u32_t ipinreceives;
+
+  /* TCP */
+  u32_t tcpactiveopens;
+  u32_t tcppassiveopens;
+  u32_t tcpattemptfails;
+  u32_t tcpestabresets;
+  u32_t tcpoutsegs;
+  u32_t tcpretranssegs;
+  u32_t tcpinsegs;
+  u32_t tcpinerrs;
+  u32_t tcpoutrsts;
+
+  /* UDP */
+  u32_t udpindatagrams;
+  u32_t udpnoports;
+  u32_t udpinerrors;
+  u32_t udpoutdatagrams;
+
+  /* ICMP */
+  u32_t icmpinmsgs;
+  u32_t icmpinerrors;
+  u32_t icmpindestunreachs;
+  u32_t icmpintimeexcds;
+  u32_t icmpinparmprobs;
+  u32_t icmpinsrcquenchs;
+  u32_t icmpinredirects;
+  u32_t icmpinechos;
+  u32_t icmpinechoreps;
+  u32_t icmpintimestamps;
+  u32_t icmpintimestampreps;
+  u32_t icmpinaddrmasks;
+  u32_t icmpinaddrmaskreps;
+  u32_t icmpoutmsgs;
+  u32_t icmpouterrors;
+  u32_t icmpoutdestunreachs;
+  u32_t icmpouttimeexcds;
+  u32_t icmpoutechos; /* can be incremented by user application ('ping') */
+  u32_t icmpoutechoreps;
+};
+
+/**
+ * @ingroup netif_mib2
+ * SNMP MIB2 interface stats
+ */
+struct stats_mib2_netif_ctrs {
+  /** The total number of octets received on the interface, including framing characters */
+  u32_t ifinoctets;
+  /** The number of packets, delivered by this sub-layer to a higher (sub-)layer, which were
+   * not addressed to a multicast or broadcast address at this sub-layer */
+  u32_t ifinucastpkts;
+  /** The number of packets, delivered by this sub-layer to a higher (sub-)layer, which were
+   * addressed to a multicast or broadcast address at this sub-layer */
+  u32_t ifinnucastpkts;
+  /** The number of inbound packets which were chosen to be discarded even though no errors had
+   * been detected to prevent their being deliverable to a higher-layer protocol. One possible
+   * reason for discarding such a packet could be to free up buffer space */
+  u32_t ifindiscards;
+  /** For packet-oriented interfaces, the number of inbound packets that contained errors
+   * preventing them from being deliverable to a higher-layer protocol.  For character-
+   * oriented or fixed-length interfaces, the number of inbound transmission units that
+   * contained errors preventing them from being deliverable to a higher-layer protocol. */
+  u32_t ifinerrors;
+  /** For packet-oriented interfaces, the number of packets received via the interface which
+   * were discarded because of an unknown or unsupported protocol.  For character-oriented
+   * or fixed-length interfaces that support protocol multiplexing the number of transmission
+   * units received via the interface which were discarded because of an unknown or unsupported
+   * protocol. For any interface that does not support protocol multiplexing, this counter will
+   * always be 0 */
+  u32_t ifinunknownprotos;
+  /** The total number of octets transmitted out of the interface, including framing characters. */
+  u32_t ifoutoctets;
+  /** The total number of packets that higher-level protocols requested be transmitted, and
+   * which were not addressed to a multicast or broadcast address at this sub-layer, including
+   * those that were discarded or not sent. */
+  u32_t ifoutucastpkts;
+  /** The total number of packets that higher-level protocols requested be transmitted, and which
+   * were addressed to a multicast or broadcast address at this sub-layer, including
+   * those that were discarded or not sent. */
+  u32_t ifoutnucastpkts;
+  /** The number of outbound packets which were chosen to be discarded even though no errors had
+   * been detected to prevent their being transmitted.  One possible reason for discarding
+   * such a packet could be to free up buffer space. */
+  u32_t ifoutdiscards;
+  /** For packet-oriented interfaces, the number of outbound packets that could not be transmitted
+   * because of errors. For character-oriented or fixed-length interfaces, the number of outbound
+   * transmission units that could not be transmitted because of errors. */
+  u32_t ifouterrors;
+};
+
+/** lwIP stats container */
+struct stats_ {
+#if LINK_STATS
+  /** Link level */
+  struct stats_proto link;
+#endif
+#if ETHARP_STATS
+  /** ARP */
+  struct stats_proto etharp;
+#endif
+#if IPFRAG_STATS
+  /** Fragmentation */
+  struct stats_proto ip_frag;
+#endif
+#if IP_STATS
+  /** IP */
+  struct stats_proto ip;
+#endif
+#if ICMP_STATS
+  /** ICMP */
+  struct stats_proto icmp;
+#endif
+#if IGMP_STATS
+  /** IGMP */
+  struct stats_igmp igmp;
+#endif
+#if UDP_STATS
+  /** UDP */
+  struct stats_proto udp;
+#endif
+#if TCP_STATS
+  /** TCP */
+  struct stats_proto tcp;
+#endif
+#if MEM_STATS
+  /** Heap */
+  struct stats_mem mem;
+#endif
+#if MEMP_STATS
+  /** Internal memory pools */
+  struct stats_mem *memp[MEMP_MAX];
+#endif
+#if SYS_STATS
+  /** System */
+  struct stats_sys sys;
+#endif
+#if IP6_STATS
+  /** IPv6 */
+  struct stats_proto ip6;
+#endif
+#if ICMP6_STATS
+  /** ICMP6 */
+  struct stats_proto icmp6;
+#endif
+#if IP6_FRAG_STATS
+  /** IPv6 fragmentation */
+  struct stats_proto ip6_frag;
+#endif
+#if MLD6_STATS
+  /** Multicast listener discovery */
+  struct stats_igmp mld6;
+#endif
+#if ND6_STATS
+  /** Neighbor discovery */
+  struct stats_proto nd6;
+#endif
+#if MIB2_STATS
+  /** SNMP MIB2 */
+  struct stats_mib2 mib2;
+#endif
+};
+
+/** Global variable containing lwIP internal statistics. Add this to your debugger's watchlist. */
+extern struct stats_ lwip_stats;
+
+/** Init statistics */
+void stats_init(void);
+
+#define STATS_INC(x) ++lwip_stats.x
+#define STATS_DEC(x) --lwip_stats.x
+#define STATS_INC_USED(x, y, type) do { lwip_stats.x.used = (type)(lwip_stats.x.used + y); \
+                                if (lwip_stats.x.max < lwip_stats.x.used) { \
+                                    lwip_stats.x.max = lwip_stats.x.used; \
+                                } \
+                             } while(0)
+#define STATS_GET(x) lwip_stats.x
+#else /* LWIP_STATS */
+#define stats_init()
+#define STATS_INC(x)
+#define STATS_DEC(x)
+#define STATS_INC_USED(x, y, type)
+#endif /* LWIP_STATS */
+
+#if TCP_STATS
+#define TCP_STATS_INC(x) STATS_INC(x)
+#define TCP_STATS_DISPLAY() stats_display_proto(&lwip_stats.tcp, "TCP")
+#else
+#define TCP_STATS_INC(x)
+#define TCP_STATS_DISPLAY()
+#endif
+
+#if UDP_STATS
+#define UDP_STATS_INC(x) STATS_INC(x)
+#define UDP_STATS_DISPLAY() stats_display_proto(&lwip_stats.udp, "UDP")
+#else
+#define UDP_STATS_INC(x)
+#define UDP_STATS_DISPLAY()
+#endif
+
+#if ICMP_STATS
+#define ICMP_STATS_INC(x) STATS_INC(x)
+#define ICMP_STATS_DISPLAY() stats_display_proto(&lwip_stats.icmp, "ICMP")
+#else
+#define ICMP_STATS_INC(x)
+#define ICMP_STATS_DISPLAY()
+#endif
+
+#if IGMP_STATS
+#define IGMP_STATS_INC(x) STATS_INC(x)
+#define IGMP_STATS_DISPLAY() stats_display_igmp(&lwip_stats.igmp, "IGMP")
+#else
+#define IGMP_STATS_INC(x)
+#define IGMP_STATS_DISPLAY()
+#endif
+
+#if IP_STATS
+#define IP_STATS_INC(x) STATS_INC(x)
+#define IP_STATS_DISPLAY() stats_display_proto(&lwip_stats.ip, "IP")
+#else
+#define IP_STATS_INC(x)
+#define IP_STATS_DISPLAY()
+#endif
+
+#if IPFRAG_STATS
+#define IPFRAG_STATS_INC(x) STATS_INC(x)
+#define IPFRAG_STATS_DISPLAY() stats_display_proto(&lwip_stats.ip_frag, "IP_FRAG")
+#else
+#define IPFRAG_STATS_INC(x)
+#define IPFRAG_STATS_DISPLAY()
+#endif
+
+#if ETHARP_STATS
+#define ETHARP_STATS_INC(x) STATS_INC(x)
+#define ETHARP_STATS_DISPLAY() stats_display_proto(&lwip_stats.etharp, "ETHARP")
+#else
+#define ETHARP_STATS_INC(x)
+#define ETHARP_STATS_DISPLAY()
+#endif
+
+#if LINK_STATS
+#define LINK_STATS_INC(x) STATS_INC(x)
+#define LINK_STATS_DISPLAY() stats_display_proto(&lwip_stats.link, "LINK")
+#else
+#define LINK_STATS_INC(x)
+#define LINK_STATS_DISPLAY()
+#endif
+
+#if MEM_STATS
+#define MEM_STATS_AVAIL(x, y) lwip_stats.mem.x = y
+#define MEM_STATS_INC(x) STATS_INC(mem.x)
+#define MEM_STATS_INC_USED(x, y) STATS_INC_USED(mem, y, mem_size_t)
+#define MEM_STATS_DEC_USED(x, y) lwip_stats.mem.x = (mem_size_t)((lwip_stats.mem.x) - (y))
+#define MEM_STATS_DISPLAY() stats_display_mem(&lwip_stats.mem, "HEAP")
+#else
+#define MEM_STATS_AVAIL(x, y)
+#define MEM_STATS_INC(x)
+#define MEM_STATS_INC_USED(x, y)
+#define MEM_STATS_DEC_USED(x, y)
+#define MEM_STATS_DISPLAY()
+#endif
+
+ #if MEMP_STATS
+#define MEMP_STATS_DEC(x, i) STATS_DEC(memp[i]->x)
+#define MEMP_STATS_DISPLAY(i) stats_display_memp(lwip_stats.memp[i], i)
+#define MEMP_STATS_GET(x, i) STATS_GET(memp[i]->x)
+ #else
+#define MEMP_STATS_DEC(x, i)
+#define MEMP_STATS_DISPLAY(i)
+#define MEMP_STATS_GET(x, i) 0
+#endif
+
+#if SYS_STATS
+#define SYS_STATS_INC(x) STATS_INC(sys.x)
+#define SYS_STATS_DEC(x) STATS_DEC(sys.x)
+#define SYS_STATS_INC_USED(x) STATS_INC_USED(sys.x, 1, STAT_COUNTER)
+#define SYS_STATS_DISPLAY() stats_display_sys(&lwip_stats.sys)
+#else
+#define SYS_STATS_INC(x)
+#define SYS_STATS_DEC(x)
+#define SYS_STATS_INC_USED(x)
+#define SYS_STATS_DISPLAY()
+#endif
+
+#if IP6_STATS
+#define IP6_STATS_INC(x) STATS_INC(x)
+#define IP6_STATS_DISPLAY() stats_display_proto(&lwip_stats.ip6, "IPv6")
+#else
+#define IP6_STATS_INC(x)
+#define IP6_STATS_DISPLAY()
+#endif
+
+#if ICMP6_STATS
+#define ICMP6_STATS_INC(x) STATS_INC(x)
+#define ICMP6_STATS_DISPLAY() stats_display_proto(&lwip_stats.icmp6, "ICMPv6")
+#else
+#define ICMP6_STATS_INC(x)
+#define ICMP6_STATS_DISPLAY()
+#endif
+
+#if IP6_FRAG_STATS
+#define IP6_FRAG_STATS_INC(x) STATS_INC(x)
+#define IP6_FRAG_STATS_DISPLAY() stats_display_proto(&lwip_stats.ip6_frag, "IPv6 FRAG")
+#else
+#define IP6_FRAG_STATS_INC(x)
+#define IP6_FRAG_STATS_DISPLAY()
+#endif
+
+#if MLD6_STATS
+#define MLD6_STATS_INC(x) STATS_INC(x)
+#define MLD6_STATS_DISPLAY() stats_display_igmp(&lwip_stats.mld6, "MLDv1")
+#else
+#define MLD6_STATS_INC(x)
+#define MLD6_STATS_DISPLAY()
+#endif
+
+#if ND6_STATS
+#define ND6_STATS_INC(x) STATS_INC(x)
+#define ND6_STATS_DISPLAY() stats_display_proto(&lwip_stats.nd6, "ND")
+#else
+#define ND6_STATS_INC(x)
+#define ND6_STATS_DISPLAY()
+#endif
+
+#if MIB2_STATS
+#define MIB2_STATS_INC(x) STATS_INC(x)
+#else
+#define MIB2_STATS_INC(x)
+#endif
+
+/* Display of statistics */
+#if LWIP_STATS_DISPLAY
+void stats_display(void);
+void stats_display_proto(struct stats_proto *proto, const char *name);
+void stats_display_igmp(struct stats_igmp *igmp, const char *name);
+void stats_display_mem(struct stats_mem *mem, const char *name);
+void stats_display_memp(struct stats_mem *mem, int index);
+void stats_display_sys(struct stats_sys *sys);
+#else /* LWIP_STATS_DISPLAY */
+#define stats_display()
+#define stats_display_proto(proto, name)
+#define stats_display_igmp(igmp, name)
+#define stats_display_mem(mem, name)
+#define stats_display_memp(mem, index)
+#define stats_display_sys(sys)
+#endif /* LWIP_STATS_DISPLAY */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_STATS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/sys.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/sys.h
new file mode 100644
index 000000000..bb4b96061
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/sys.h
@@ -0,0 +1,462 @@
+/**
+ * @file
+ * OS abstraction layer
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ */
+
+#ifndef LWIP_HDR_SYS_H
+#define LWIP_HDR_SYS_H
+
+#include "lwip/opt.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if NO_SYS
+
+/* For a totally minimal and standalone system, we provide null
+   definitions of the sys_ functions. */
+typedef u8_t sys_sem_t;
+typedef u8_t sys_mutex_t;
+typedef u8_t sys_mbox_t;
+
+#define sys_sem_new(s, c) ERR_OK
+#define sys_sem_signal(s)
+#define sys_sem_wait(s)
+#define sys_arch_sem_wait(s,t)
+#define sys_sem_free(s)
+#define sys_sem_valid(s) 0
+#define sys_sem_valid_val(s) 0
+#define sys_sem_set_invalid(s)
+#define sys_sem_set_invalid_val(s)
+#define sys_mutex_new(mu) ERR_OK
+#define sys_mutex_lock(mu)
+#define sys_mutex_unlock(mu)
+#define sys_mutex_free(mu)
+#define sys_mutex_valid(mu) 0
+#define sys_mutex_set_invalid(mu)
+#define sys_mbox_new(m, s) ERR_OK
+#define sys_mbox_fetch(m,d)
+#define sys_mbox_tryfetch(m,d)
+#define sys_mbox_post(m,d)
+#define sys_mbox_trypost(m,d)
+#define sys_mbox_free(m)
+#define sys_mbox_valid(m)
+#define sys_mbox_valid_val(m)
+#define sys_mbox_set_invalid(m)
+#define sys_mbox_set_invalid_val(m)
+
+#define sys_thread_new(n,t,a,s,p)
+#define sys_thread_finish(a,b)
+
+#define sys_msleep(t)
+
+#else /* NO_SYS */
+
+/** Return code for timeouts from sys_arch_mbox_fetch and sys_arch_sem_wait */
+#define SYS_ARCH_TIMEOUT 0xffffffffUL
+
+/** sys_mbox_tryfetch() returns SYS_MBOX_EMPTY if appropriate.
+ * For now we use the same magic value, but we allow this to change in future.
+ */
+#define SYS_MBOX_EMPTY SYS_ARCH_TIMEOUT
+
+#include "lwip/err.h"
+#include "arch/sys_arch.h"
+
+/** Function prototype for thread functions */
+typedef void (*lwip_thread_fn)(void *arg);
+
+/* Function prototypes for functions to be implemented by platform ports
+   (in sys_arch.c) */
+
+/* Mutex functions: */
+
+/** Define LWIP_COMPAT_MUTEX if the port has no mutexes and binary semaphores
+    should be used instead */
+#ifndef LWIP_COMPAT_MUTEX
+#define LWIP_COMPAT_MUTEX 0
+#endif
+
+#if LWIP_COMPAT_MUTEX
+/* for old ports that don't have mutexes: define them to binary semaphores */
+#define sys_mutex_t                   sys_sem_t
+#define sys_mutex_new(mutex)          sys_sem_new(mutex, 1)
+#define sys_mutex_lock(mutex)         sys_sem_wait(mutex)
+#define sys_mutex_unlock(mutex)       sys_sem_signal(mutex)
+#define sys_mutex_free(mutex)         sys_sem_free(mutex)
+#define sys_mutex_valid(mutex)        sys_sem_valid(mutex)
+#define sys_mutex_set_invalid(mutex)  sys_sem_set_invalid(mutex)
+
+#else /* LWIP_COMPAT_MUTEX */
+
+/**
+ * @ingroup sys_mutex
+ * Create a new mutex.
+ * Note that mutexes are expected to not be taken recursively by the lwIP code,
+ * so both implementation types (recursive or non-recursive) should work.
+ * @param mutex pointer to the mutex to create
+ * @return ERR_OK if successful, another err_t otherwise
+ */
+err_t sys_mutex_new(sys_mutex_t *mutex);
+/**
+ * @ingroup sys_mutex
+ * Lock a mutex
+ * @param mutex the mutex to lock
+ */
+void sys_mutex_lock(sys_mutex_t *mutex);
+/**
+ * @ingroup sys_mutex
+ * Unlock a mutex
+ * @param mutex the mutex to unlock
+ */
+void sys_mutex_unlock(sys_mutex_t *mutex);
+/**
+ * @ingroup sys_mutex
+ * Delete a semaphore
+ * @param mutex the mutex to delete
+ */
+void sys_mutex_free(sys_mutex_t *mutex);
+#ifndef sys_mutex_valid
+/**
+ * @ingroup sys_mutex
+ * Check if a mutex is valid/allocated: return 1 for valid, 0 for invalid
+ */
+int sys_mutex_valid(sys_mutex_t *mutex);
+#endif
+#ifndef sys_mutex_set_invalid
+/**
+ * @ingroup sys_mutex
+ * Set a mutex invalid so that sys_mutex_valid returns 0
+ */
+void sys_mutex_set_invalid(sys_mutex_t *mutex);
+#endif
+#endif /* LWIP_COMPAT_MUTEX */
+
+/* Semaphore functions: */
+
+/**
+ * @ingroup sys_sem
+ * Create a new semaphore
+ * @param sem pointer to the semaphore to create
+ * @param count initial count of the semaphore
+ * @return ERR_OK if successful, another err_t otherwise
+ */
+err_t sys_sem_new(sys_sem_t *sem, u8_t count);
+/**
+ * @ingroup sys_sem
+ * Signals a semaphore
+ * @param sem the semaphore to signal
+ */
+void sys_sem_signal(sys_sem_t *sem);
+/**
+ * @ingroup sys_sem
+ * Wait for a semaphore for the specified timeout
+ * @param sem the semaphore to wait for
+ * @param timeout timeout in milliseconds to wait (0 = wait forever)
+ * @return time (in milliseconds) waited for the semaphore
+ *         or SYS_ARCH_TIMEOUT on timeout
+ */
+u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout);
+/**
+ * @ingroup sys_sem
+ * Delete a semaphore
+ * @param sem semaphore to delete
+ */
+void sys_sem_free(sys_sem_t *sem);
+/** Wait for a semaphore - forever/no timeout */
+#define sys_sem_wait(sem)                  sys_arch_sem_wait(sem, 0)
+#ifndef sys_sem_valid
+/**
+ * @ingroup sys_sem
+ * Check if a semaphore is valid/allocated: return 1 for valid, 0 for invalid
+ */
+int sys_sem_valid(sys_sem_t *sem);
+#endif
+#ifndef sys_sem_set_invalid
+/**
+ * @ingroup sys_sem
+ * Set a semaphore invalid so that sys_sem_valid returns 0
+ */
+void sys_sem_set_invalid(sys_sem_t *sem);
+#endif
+#ifndef sys_sem_valid_val
+/**
+ * Same as sys_sem_valid() but taking a value, not a pointer
+ */
+#define sys_sem_valid_val(sem)       sys_sem_valid(&(sem))
+#endif
+#ifndef sys_sem_set_invalid_val
+/**
+ * Same as sys_sem_set_invalid() but taking a value, not a pointer
+ */
+#define sys_sem_set_invalid_val(sem) sys_sem_set_invalid(&(sem))
+#endif
+
+#ifndef sys_msleep
+/**
+ * @ingroup sys_misc
+ * Sleep for specified number of ms
+ */
+void sys_msleep(u32_t ms); /* only has a (close to) 1 ms resolution. */
+#endif
+
+/* Mailbox functions. */
+
+/**
+ * @ingroup sys_mbox
+ * Create a new mbox of specified size
+ * @param mbox pointer to the mbox to create
+ * @param size (minimum) number of messages in this mbox
+ * @return ERR_OK if successful, another err_t otherwise
+ */
+err_t sys_mbox_new(sys_mbox_t *mbox, int size);
+/**
+ * @ingroup sys_mbox
+ * Post a message to an mbox - may not fail
+ * -> blocks if full, only used from tasks not from ISR
+ * @param mbox mbox to posts the message
+ * @param msg message to post (ATTENTION: can be NULL)
+ */
+void sys_mbox_post(sys_mbox_t *mbox, void *msg);
+/**
+ * @ingroup sys_mbox
+ * Try to post a message to an mbox - may fail if full or ISR
+ * @param mbox mbox to posts the message
+ * @param msg message to post (ATTENTION: can be NULL)
+ */
+err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg);
+/**
+ * @ingroup sys_mbox
+ * Wait for a new message to arrive in the mbox
+ * @param mbox mbox to get a message from
+ * @param msg pointer where the message is stored
+ * @param timeout maximum time (in milliseconds) to wait for a message (0 = wait forever)
+ * @return time (in milliseconds) waited for a message, may be 0 if not waited
+           or SYS_ARCH_TIMEOUT on timeout
+ *         The returned time has to be accurate to prevent timer jitter!
+ */
+u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout);
+/* Allow port to override with a macro, e.g. special timeout for sys_arch_mbox_fetch() */
+#ifndef sys_arch_mbox_tryfetch
+/**
+ * @ingroup sys_mbox
+ * Wait for a new message to arrive in the mbox
+ * @param mbox mbox to get a message from
+ * @param msg pointer where the message is stored
+ * @return 0 (milliseconds) if a message has been received
+ *         or SYS_MBOX_EMPTY if the mailbox is empty
+ */
+u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg);
+#endif
+/**
+ * For now, we map straight to sys_arch implementation.
+ */
+#define sys_mbox_tryfetch(mbox, msg) sys_arch_mbox_tryfetch(mbox, msg)
+/**
+ * @ingroup sys_mbox
+ * Delete an mbox
+ * @param mbox mbox to delete
+ */
+void sys_mbox_free(sys_mbox_t *mbox);
+#define sys_mbox_fetch(mbox, msg) sys_arch_mbox_fetch(mbox, msg, 0)
+#ifndef sys_mbox_valid
+/**
+ * @ingroup sys_mbox
+ * Check if an mbox is valid/allocated: return 1 for valid, 0 for invalid
+ */
+int sys_mbox_valid(sys_mbox_t *mbox);
+#endif
+#ifndef sys_mbox_set_invalid
+/**
+ * @ingroup sys_mbox
+ * Set an mbox invalid so that sys_mbox_valid returns 0
+ */
+void sys_mbox_set_invalid(sys_mbox_t *mbox);
+#endif
+#ifndef sys_mbox_valid_val
+/**
+ * Same as sys_mbox_valid() but taking a value, not a pointer
+ */
+#define sys_mbox_valid_val(mbox)       sys_mbox_valid(&(mbox))
+#endif
+#ifndef sys_mbox_set_invalid_val
+/**
+ * Same as sys_mbox_set_invalid() but taking a value, not a pointer
+ */
+#define sys_mbox_set_invalid_val(mbox) sys_mbox_set_invalid(&(mbox))
+#endif
+
+
+/**
+ * @ingroup sys_misc
+ * The only thread function:
+ * Creates a new thread
+ * ATTENTION: although this function returns a value, it MUST NOT FAIL (ports have to assert this!)
+ * @param name human-readable name for the thread (used for debugging purposes)
+ * @param thread thread-function
+ * @param arg parameter passed to 'thread'
+ * @param stacksize stack size in bytes for the new thread (may be ignored by ports)
+ * @param prio priority of the new thread (may be ignored by ports) */
+sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread, void *arg, int stacksize, int prio);
+
+/**
+ * Finishes an existing thread
+ * @param thread identifier returned by sys_thread_new
+ */
+err_t sys_thread_finish(sys_thread_t t);
+
+#endif /* NO_SYS */
+
+/* sys_init() must be called before anything else. */
+void sys_init(void);
+
+#ifndef sys_jiffies
+/**
+ * Ticks/jiffies since power up.
+ */
+u32_t sys_jiffies(void);
+#endif
+
+/**
+ * @ingroup sys_time
+ * Returns the current time in milliseconds,
+ * may be the same as sys_jiffies or at least based on it.
+ */
+u32_t sys_now(void);
+
+/* Critical Region Protection */
+/* These functions must be implemented in the sys_arch.c file.
+   In some implementations they can provide a more light-weight protection
+   mechanism than using semaphores. Otherwise semaphores can be used for
+   implementation */
+#ifndef SYS_ARCH_PROTECT
+/** SYS_LIGHTWEIGHT_PROT
+ * define SYS_LIGHTWEIGHT_PROT in lwipopts.h if you want inter-task protection
+ * for certain critical regions during buffer allocation, deallocation and memory
+ * allocation and deallocation.
+ */
+#if SYS_LIGHTWEIGHT_PROT
+
+/**
+ * @ingroup sys_prot
+ * SYS_ARCH_DECL_PROTECT
+ * declare a protection variable. This macro will default to defining a variable of
+ * type sys_prot_t. If a particular port needs a different implementation, then
+ * this macro may be defined in sys_arch.h.
+ */
+#define SYS_ARCH_DECL_PROTECT(lev) sys_prot_t lev
+/**
+ * @ingroup sys_prot
+ * SYS_ARCH_PROTECT
+ * Perform a "fast" protect. This could be implemented by
+ * disabling interrupts for an embedded system or by using a semaphore or
+ * mutex. The implementation should allow calling SYS_ARCH_PROTECT when
+ * already protected. The old protection level is returned in the variable
+ * "lev". This macro will default to calling the sys_arch_protect() function
+ * which should be implemented in sys_arch.c. If a particular port needs a
+ * different implementation, then this macro may be defined in sys_arch.h
+ */
+#define SYS_ARCH_PROTECT(lev) lev = sys_arch_protect()
+/**
+ * @ingroup sys_prot
+ * SYS_ARCH_UNPROTECT
+ * Perform a "fast" set of the protection level to "lev". This could be
+ * implemented by setting the interrupt level to "lev" within the MACRO or by
+ * using a semaphore or mutex.  This macro will default to calling the
+ * sys_arch_unprotect() function which should be implemented in
+ * sys_arch.c. If a particular port needs a different implementation, then
+ * this macro may be defined in sys_arch.h
+ */
+#define SYS_ARCH_UNPROTECT(lev) sys_arch_unprotect(lev)
+sys_prot_t sys_arch_protect(void);
+void sys_arch_unprotect(sys_prot_t pval);
+
+#else
+
+#define SYS_ARCH_DECL_PROTECT(lev)
+#define SYS_ARCH_PROTECT(lev)
+#define SYS_ARCH_UNPROTECT(lev)
+
+#endif /* SYS_LIGHTWEIGHT_PROT */
+
+#endif /* SYS_ARCH_PROTECT */
+
+/*
+ * Macros to set/get and increase/decrease variables in a thread-safe way.
+ * Use these for accessing variable that are used from more than one thread.
+ */
+
+#ifndef SYS_ARCH_INC
+#define SYS_ARCH_INC(var, val) do { \
+                                SYS_ARCH_DECL_PROTECT(old_level); \
+                                SYS_ARCH_PROTECT(old_level); \
+                                var += val; \
+                                SYS_ARCH_UNPROTECT(old_level); \
+                              } while(0)
+#endif /* SYS_ARCH_INC */
+
+#ifndef SYS_ARCH_DEC
+#define SYS_ARCH_DEC(var, val) do { \
+                                SYS_ARCH_DECL_PROTECT(old_level); \
+                                SYS_ARCH_PROTECT(old_level); \
+                                var -= val; \
+                                SYS_ARCH_UNPROTECT(old_level); \
+                              } while(0)
+#endif /* SYS_ARCH_DEC */
+
+#ifndef SYS_ARCH_GET
+#define SYS_ARCH_GET(var, ret) do { \
+                                SYS_ARCH_DECL_PROTECT(old_level); \
+                                SYS_ARCH_PROTECT(old_level); \
+                                ret = var; \
+                                SYS_ARCH_UNPROTECT(old_level); \
+                              } while(0)
+#endif /* SYS_ARCH_GET */
+
+#ifndef SYS_ARCH_SET
+#define SYS_ARCH_SET(var, val) do { \
+                                SYS_ARCH_DECL_PROTECT(old_level); \
+                                SYS_ARCH_PROTECT(old_level); \
+                                var = val; \
+                                SYS_ARCH_UNPROTECT(old_level); \
+                              } while(0)
+#endif /* SYS_ARCH_SET */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_SYS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/tcp.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/tcp.h
new file mode 100644
index 000000000..91dc6eeaa
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/tcp.h
@@ -0,0 +1,438 @@
+/**
+ * @file
+ * TCP API (to be used from TCPIP thread)\n
+ * See also @ref tcp_raw
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_TCP_H
+#define LWIP_HDR_TCP_H
+
+#include "lwip/opt.h"
+
+#if LWIP_TCP /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/mem.h"
+#include "lwip/pbuf.h"
+#include "lwip/ip.h"
+#include "lwip/icmp.h"
+#include "lwip/err.h"
+#include "lwip/ip6.h"
+#include "lwip/ip6_addr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct tcp_pcb;
+
+/** Function prototype for tcp accept callback functions. Called when a new
+ * connection can be accepted on a listening pcb.
+ *
+ * @param arg Additional argument to pass to the callback function (@see tcp_arg())
+ * @param newpcb The new connection pcb
+ * @param err An error code if there has been an error accepting.
+ *            Only return ERR_ABRT if you have called tcp_abort from within the
+ *            callback function!
+ */
+typedef err_t (*tcp_accept_fn)(void *arg, struct tcp_pcb *newpcb, err_t err);
+
+/** Function prototype for tcp receive callback functions. Called when data has
+ * been received.
+ *
+ * @param arg Additional argument to pass to the callback function (@see tcp_arg())
+ * @param tpcb The connection pcb which received data
+ * @param p The received data (or NULL when the connection has been closed!)
+ * @param err An error code if there has been an error receiving
+ *            Only return ERR_ABRT if you have called tcp_abort from within the
+ *            callback function!
+ */
+typedef err_t (*tcp_recv_fn)(void *arg, struct tcp_pcb *tpcb,
+                             struct pbuf *p, err_t err);
+
+/** Function prototype for tcp sent callback functions. Called when sent data has
+ * been acknowledged by the remote side. Use it to free corresponding resources.
+ * This also means that the pcb has now space available to send new data.
+ *
+ * @param arg Additional argument to pass to the callback function (@see tcp_arg())
+ * @param tpcb The connection pcb for which data has been acknowledged
+ * @param len The amount of bytes acknowledged
+ * @return ERR_OK: try to send some data by calling tcp_output
+ *            Only return ERR_ABRT if you have called tcp_abort from within the
+ *            callback function!
+ */
+typedef err_t (*tcp_sent_fn)(void *arg, struct tcp_pcb *tpcb,
+                              u16_t len);
+
+/** Function prototype for tcp poll callback functions. Called periodically as
+ * specified by @see tcp_poll.
+ *
+ * @param arg Additional argument to pass to the callback function (@see tcp_arg())
+ * @param tpcb tcp pcb
+ * @return ERR_OK: try to send some data by calling tcp_output
+ *            Only return ERR_ABRT if you have called tcp_abort from within the
+ *            callback function!
+ */
+typedef err_t (*tcp_poll_fn)(void *arg, struct tcp_pcb *tpcb);
+
+/** Function prototype for tcp error callback functions. Called when the pcb
+ * receives a RST or is unexpectedly closed for any other reason.
+ *
+ * @note The corresponding pcb is already freed when this callback is called!
+ *
+ * @param arg Additional argument to pass to the callback function (@see tcp_arg())
+ * @param err Error code to indicate why the pcb has been closed
+ *            ERR_ABRT: aborted through tcp_abort or by a TCP timer
+ *            ERR_RST: the connection was reset by the remote host
+ */
+typedef void  (*tcp_err_fn)(void *arg, err_t err);
+
+/** Function prototype for tcp connected callback functions. Called when a pcb
+ * is connected to the remote side after initiating a connection attempt by
+ * calling tcp_connect().
+ *
+ * @param arg Additional argument to pass to the callback function (@see tcp_arg())
+ * @param tpcb The connection pcb which is connected
+ * @param err An unused error code, always ERR_OK currently ;-) @todo!
+ *            Only return ERR_ABRT if you have called tcp_abort from within the
+ *            callback function!
+ *
+ * @note When a connection attempt fails, the error callback is currently called!
+ */
+typedef err_t (*tcp_connected_fn)(void *arg, struct tcp_pcb *tpcb, err_t err);
+
+#if LWIP_WND_SCALE
+#define RCV_WND_SCALE(pcb, wnd) (((wnd) >> (pcb)->rcv_scale))
+#define SND_WND_SCALE(pcb, wnd) (((wnd) << (pcb)->snd_scale))
+#define TCPWND16(x)             ((u16_t)LWIP_MIN((x), 0xFFFF))
+#define TCP_WND_MAX(pcb)        ((tcpwnd_size_t)(((pcb)->flags & TF_WND_SCALE) ? TCP_WND : TCPWND16(TCP_WND)))
+typedef u32_t tcpwnd_size_t;
+#else
+#define RCV_WND_SCALE(pcb, wnd) (wnd)
+#define SND_WND_SCALE(pcb, wnd) (wnd)
+#define TCPWND16(x)             (x)
+#define TCP_WND_MAX(pcb)        TCP_WND
+typedef u16_t tcpwnd_size_t;
+#endif
+
+#if LWIP_WND_SCALE || TCP_LISTEN_BACKLOG || LWIP_TCP_TIMESTAMPS
+typedef u16_t tcpflags_t;
+#else
+typedef u8_t tcpflags_t;
+#endif
+
+enum tcp_state {
+  CLOSED      = 0,
+  LISTEN      = 1,
+  SYN_SENT    = 2,
+  SYN_RCVD    = 3,
+  ESTABLISHED = 4,
+  FIN_WAIT_1  = 5,
+  FIN_WAIT_2  = 6,
+  CLOSE_WAIT  = 7,
+  CLOSING     = 8,
+  LAST_ACK    = 9,
+  TIME_WAIT   = 10
+};
+
+/**
+ * members common to struct tcp_pcb and struct tcp_listen_pcb
+ */
+#define TCP_PCB_COMMON(type) \
+  type *next; /* for the linked list */ \
+  void *callback_arg; \
+  enum tcp_state state; /* TCP state */ \
+  u8_t prio; \
+  /* ports are in host byte order */ \
+  u16_t local_port
+
+
+/** the TCP protocol control block for listening pcbs */
+struct tcp_pcb_listen {
+/** Common members of all PCB types */
+  IP_PCB;
+/** Protocol specific PCB members */
+  TCP_PCB_COMMON(struct tcp_pcb_listen);
+
+#if LWIP_CALLBACK_API
+  /* Function to call when a listener has been connected. */
+  tcp_accept_fn accept;
+#endif /* LWIP_CALLBACK_API */
+
+#if TCP_LISTEN_BACKLOG
+  u8_t backlog;
+  u8_t accepts_pending;
+#endif /* TCP_LISTEN_BACKLOG */
+};
+
+
+/** the TCP protocol control block */
+struct tcp_pcb {
+/** common PCB members */
+  IP_PCB;
+/** protocol specific PCB members */
+  TCP_PCB_COMMON(struct tcp_pcb);
+
+  /* ports are in host byte order */
+  u16_t remote_port;
+
+  tcpflags_t flags;
+#define TF_ACK_DELAY   0x01U   /* Delayed ACK. */
+#define TF_ACK_NOW     0x02U   /* Immediate ACK. */
+#define TF_INFR        0x04U   /* In fast recovery. */
+#define TF_CLOSEPEND   0x08U   /* If this is set, tcp_close failed to enqueue the FIN (retried in tcp_tmr) */
+#define TF_RXCLOSED    0x10U   /* rx closed by tcp_shutdown */
+#define TF_FIN         0x20U   /* Connection was closed locally (FIN segment enqueued). */
+#define TF_NODELAY     0x40U   /* Disable Nagle algorithm */
+#define TF_NAGLEMEMERR 0x80U   /* nagle enabled, memerr, try to output to prevent delayed ACK to happen */
+#if LWIP_WND_SCALE
+#define TF_WND_SCALE   0x0100U /* Window Scale option enabled */
+#endif
+#if TCP_LISTEN_BACKLOG
+#define TF_BACKLOGPEND 0x0200U /* If this is set, a connection pcb has increased the backlog on its listener */
+#endif
+#if LWIP_TCP_TIMESTAMPS
+#define TF_TIMESTAMP   0x0400U   /* Timestamp option enabled */
+#endif
+
+  /* the rest of the fields are in host byte order
+     as we have to do some math with them */
+
+  /* Timers */
+  u8_t polltmr, pollinterval;
+  u8_t last_timer;
+  u32_t tmr;
+
+  /* receiver variables */
+  u32_t rcv_nxt;   /* next seqno expected */
+  tcpwnd_size_t rcv_wnd;   /* receiver window available */
+  tcpwnd_size_t rcv_ann_wnd; /* receiver window to announce */
+  u32_t rcv_ann_right_edge; /* announced right edge of window */
+
+  /* Retransmission timer. */
+  s16_t rtime;
+
+  u16_t mss;   /* maximum segment size */
+
+  /* RTT (round trip time) estimation variables */
+  u32_t rttest; /* RTT estimate in 500ms ticks */
+  u32_t rtseq;  /* sequence number being timed */
+  s16_t sa, sv; /* @todo document this */
+
+  s16_t rto;    /* retransmission time-out */
+  u8_t nrtx;    /* number of retransmissions */
+
+  /* fast retransmit/recovery */
+  u8_t dupacks;
+  u32_t lastack; /* Highest acknowledged seqno. */
+
+  /* congestion avoidance/control variables */
+  tcpwnd_size_t cwnd;
+  tcpwnd_size_t ssthresh;
+
+  /* sender variables */
+  u32_t snd_nxt;   /* next new seqno to be sent */
+  u32_t snd_wl1, snd_wl2; /* Sequence and acknowledgement numbers of last
+                             window update. */
+  u32_t snd_lbb;       /* Sequence number of next byte to be buffered. */
+  tcpwnd_size_t snd_wnd;   /* sender window */
+  tcpwnd_size_t snd_wnd_max; /* the maximum sender window announced by the remote host */
+
+  tcpwnd_size_t snd_buf;   /* Available buffer space for sending (in bytes). */
+#define TCP_SNDQUEUELEN_OVERFLOW (0xffffU-3)
+  u16_t snd_queuelen; /* Number of pbufs currently in the send buffer. */
+
+#if TCP_OVERSIZE
+  /* Extra bytes available at the end of the last pbuf in unsent. */
+  u16_t unsent_oversize;
+#endif /* TCP_OVERSIZE */
+
+  /* These are ordered by sequence number: */
+  struct tcp_seg *unsent;   /* Unsent (queued) segments. */
+  struct tcp_seg *unacked;  /* Sent but unacknowledged segments. */
+#if TCP_QUEUE_OOSEQ
+  struct tcp_seg *ooseq;    /* Received out of sequence segments. */
+#endif /* TCP_QUEUE_OOSEQ */
+
+  struct pbuf *refused_data; /* Data previously received but not yet taken by upper layer */
+
+#if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
+  struct tcp_pcb_listen* listener;
+#endif /* LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG */
+
+#if LWIP_CALLBACK_API
+  /* Function to be called when more send buffer space is available. */
+  tcp_sent_fn sent;
+  /* Function to be called when (in-sequence) data has arrived. */
+  tcp_recv_fn recv;
+  /* Function to be called when a connection has been set up. */
+  tcp_connected_fn connected;
+  /* Function which is called periodically. */
+  tcp_poll_fn poll;
+  /* Function to be called whenever a fatal error occurs. */
+  tcp_err_fn errf;
+#endif /* LWIP_CALLBACK_API */
+
+#if LWIP_TCP_TIMESTAMPS
+  u32_t ts_lastacksent;
+  u32_t ts_recent;
+#endif /* LWIP_TCP_TIMESTAMPS */
+
+  /* idle time before KEEPALIVE is sent */
+  u32_t keep_idle;
+#if LWIP_TCP_KEEPALIVE
+  u32_t keep_intvl;
+  u32_t keep_cnt;
+#endif /* LWIP_TCP_KEEPALIVE */
+
+  /* Persist timer counter */
+  u8_t persist_cnt;
+  /* Persist timer back-off */
+  u8_t persist_backoff;
+
+  /* KEEPALIVE counter */
+  u8_t keep_cnt_sent;
+
+#if LWIP_WND_SCALE
+  u8_t snd_scale;
+  u8_t rcv_scale;
+#endif
+};
+
+#if LWIP_EVENT_API
+
+enum lwip_event {
+  LWIP_EVENT_ACCEPT,
+  LWIP_EVENT_SENT,
+  LWIP_EVENT_RECV,
+  LWIP_EVENT_CONNECTED,
+  LWIP_EVENT_POLL,
+  LWIP_EVENT_ERR
+};
+
+err_t lwip_tcp_event(void *arg, struct tcp_pcb *pcb,
+         enum lwip_event,
+         struct pbuf *p,
+         u16_t size,
+         err_t err);
+
+#endif /* LWIP_EVENT_API */
+
+/* Application program's interface: */
+struct tcp_pcb * tcp_new     (void);
+struct tcp_pcb * tcp_new_ip_type (u8_t type);
+
+void             tcp_arg     (struct tcp_pcb *pcb, void *arg);
+#if LWIP_CALLBACK_API
+void             tcp_recv    (struct tcp_pcb *pcb, tcp_recv_fn recv);
+void             tcp_sent    (struct tcp_pcb *pcb, tcp_sent_fn sent);
+void             tcp_err     (struct tcp_pcb *pcb, tcp_err_fn err);
+void             tcp_accept  (struct tcp_pcb *pcb, tcp_accept_fn accept);
+#endif /* LWIP_CALLBACK_API */
+void             tcp_poll    (struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval);
+
+#define          tcp_set_flags(pcb, set_flags)     do { (pcb)->flags = (tcpflags_t)((pcb)->flags |  (set_flags)); } while(0)
+#define          tcp_clear_flags(pcb, clr_flags)   do { (pcb)->flags = (tcpflags_t)((pcb)->flags & ~(clr_flags)); } while(0)
+#define          tcp_is_flag_set(pcb, flag)        (((pcb)->flags & (flag)) != 0)
+
+#if LWIP_TCP_TIMESTAMPS
+#define          tcp_mss(pcb)             (((pcb)->flags & TF_TIMESTAMP) ? ((pcb)->mss - 12)  : (pcb)->mss)
+#else /* LWIP_TCP_TIMESTAMPS */
+#define          tcp_mss(pcb)             ((pcb)->mss)
+#endif /* LWIP_TCP_TIMESTAMPS */
+#define          tcp_sndbuf(pcb)          (TCPWND16((pcb)->snd_buf))
+#define          tcp_sndqueuelen(pcb)     ((pcb)->snd_queuelen)
+/** @ingroup tcp_raw */
+#define          tcp_nagle_disable(pcb)   tcp_set_flags(pcb, TF_NODELAY)
+/** @ingroup tcp_raw */
+#define          tcp_nagle_enable(pcb)    tcp_clear_flags(pcb, TF_NODELAY)
+/** @ingroup tcp_raw */
+#define          tcp_nagle_disabled(pcb)  tcp_is_flag_set(pcb, TF_NODELAY)
+
+#if TCP_LISTEN_BACKLOG
+#define          tcp_backlog_set(pcb, new_backlog) do { \
+  LWIP_ASSERT("pcb->state == LISTEN (called for wrong pcb?)", (pcb)->state == LISTEN); \
+  ((struct tcp_pcb_listen *)(pcb))->backlog = ((new_backlog) ? (new_backlog) : 1); } while(0)
+void             tcp_backlog_delayed(struct tcp_pcb* pcb);
+void             tcp_backlog_accepted(struct tcp_pcb* pcb);
+#else  /* TCP_LISTEN_BACKLOG */
+#define          tcp_backlog_set(pcb, new_backlog)
+#define          tcp_backlog_delayed(pcb)
+#define          tcp_backlog_accepted(pcb)
+#endif /* TCP_LISTEN_BACKLOG */
+#define          tcp_accepted(pcb) /* compatibility define, not needed any more */
+
+void             tcp_recved  (struct tcp_pcb *pcb, u16_t len);
+err_t            tcp_bind    (struct tcp_pcb *pcb, const ip_addr_t *ipaddr,
+                              u16_t port);
+void             tcp_bind_netif(struct tcp_pcb *pcb, const struct netif *netif);
+err_t            tcp_connect (struct tcp_pcb *pcb, const ip_addr_t *ipaddr,
+                              u16_t port, tcp_connected_fn connected);
+
+struct tcp_pcb * tcp_listen_with_backlog_and_err(struct tcp_pcb *pcb, u8_t backlog, err_t *err);
+struct tcp_pcb * tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog);
+/** @ingroup tcp_raw */
+#define          tcp_listen(pcb) tcp_listen_with_backlog(pcb, TCP_DEFAULT_LISTEN_BACKLOG)
+
+void             tcp_abort (struct tcp_pcb *pcb);
+err_t            tcp_close   (struct tcp_pcb *pcb);
+err_t            tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx);
+
+/* Flags for "apiflags" parameter in tcp_write */
+#define TCP_WRITE_FLAG_COPY 0x01
+#define TCP_WRITE_FLAG_MORE 0x02
+
+err_t            tcp_write   (struct tcp_pcb *pcb, const void *dataptr, u16_t len,
+                              u8_t apiflags);
+
+void             tcp_setprio (struct tcp_pcb *pcb, u8_t prio);
+
+#define TCP_PRIO_MIN    1
+#define TCP_PRIO_NORMAL 64
+#define TCP_PRIO_MAX    127
+
+err_t            tcp_output  (struct tcp_pcb *pcb);
+
+
+const char* tcp_debug_state_str(enum tcp_state s);
+
+/* for compatibility with older implementation */
+#define tcp_new_ip6() tcp_new_ip_type(IPADDR_TYPE_V6)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_TCP */
+
+#endif /* LWIP_HDR_TCP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/tcpip.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/tcpip.h
new file mode 100644
index 000000000..3ebf18df7
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/tcpip.h
@@ -0,0 +1,116 @@
+/**
+ * @file
+ * Functions to sync with TCPIP thread
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_TCPIP_H
+#define LWIP_HDR_TCPIP_H
+
+#include "lwip/opt.h"
+
+#if !NO_SYS /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/err.h"
+#include "lwip/timeouts.h"
+#include "lwip/netif.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if LWIP_TCPIP_CORE_LOCKING
+/** The global semaphore to lock the stack. */
+extern sys_mutex_t lock_tcpip_core;
+/** Lock lwIP core mutex (needs @ref LWIP_TCPIP_CORE_LOCKING 1) */
+#define LOCK_TCPIP_CORE()     sys_mutex_lock(&lock_tcpip_core)
+/** Unlock lwIP core mutex (needs @ref LWIP_TCPIP_CORE_LOCKING 1) */
+#define UNLOCK_TCPIP_CORE()   sys_mutex_unlock(&lock_tcpip_core)
+#else /* LWIP_TCPIP_CORE_LOCKING */
+#define LOCK_TCPIP_CORE()
+#define UNLOCK_TCPIP_CORE()
+#endif /* LWIP_TCPIP_CORE_LOCKING */
+
+struct pbuf;
+struct netif;
+
+#if LWIP_NETCONN
+struct api_msg;
+#endif /* LWIP_NETCONN */
+
+/** Function prototype for the init_done function passed to tcpip_init */
+typedef void (*tcpip_init_done_fn)(void *arg);
+typedef void (*tcpip_will_finish_fn)(void *arg);
+/** Function prototype for functions passed to tcpip_callback() */
+typedef void (*tcpip_callback_fn)(void *ctx);
+
+/* Forward declarations */
+struct tcpip_callback_msg;
+
+void   tcpip_init(tcpip_init_done_fn tcpip_init_done, void *arg);
+err_t  tcpip_finish(tcpip_will_finish_fn tcpip_will_finish, void *arg);
+
+#if LWIP_NETCONN
+err_t  tcpip_apimsg(struct api_msg *apimsg);
+#endif /* LWIP_NETCONN */
+
+err_t  tcpip_inpkt(struct pbuf *p, struct netif *inp, netif_input_fn input_fn);
+err_t  tcpip_input(struct pbuf *p, struct netif *inp);
+
+err_t  tcpip_callback_with_block(tcpip_callback_fn function, void *ctx, u8_t block);
+/**
+ * @ingroup lwip_os
+ * @see tcpip_callback_with_block
+ */
+#define tcpip_callback(f, ctx)  tcpip_callback_with_block(f, ctx, 1)
+
+struct tcpip_callback_msg* tcpip_callbackmsg_new(tcpip_callback_fn function, void *ctx);
+void   tcpip_callbackmsg_delete(struct tcpip_callback_msg* msg);
+err_t  tcpip_trycallback(struct tcpip_callback_msg* msg);
+
+/* free pbufs or heap memory from another context without blocking */
+err_t  pbuf_free_callback(struct pbuf *p);
+err_t  mem_free_callback(void *m);
+
+#if LWIP_TCPIP_TIMEOUT && LWIP_TIMERS
+err_t  tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg);
+err_t  tcpip_untimeout(sys_timeout_handler h, void *arg);
+#endif /* LWIP_TCPIP_TIMEOUT && LWIP_TIMERS */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !NO_SYS */
+
+#endif /* LWIP_HDR_TCPIP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/timeouts.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/timeouts.h
new file mode 100644
index 000000000..c9b93aa02
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/timeouts.h
@@ -0,0 +1,121 @@
+/**
+ * @file
+ * Timer implementations
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *         Simon Goldschmidt
+ *
+ */
+#ifndef LWIP_HDR_TIMEOUTS_H
+#define LWIP_HDR_TIMEOUTS_H
+
+#include "lwip/opt.h"
+#include "lwip/err.h"
+#if !NO_SYS
+#include "lwip/sys.h"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef LWIP_DEBUG_TIMERNAMES
+#ifdef LWIP_DEBUG
+#define LWIP_DEBUG_TIMERNAMES SYS_DEBUG
+#else /* LWIP_DEBUG */
+#define LWIP_DEBUG_TIMERNAMES 0
+#endif /* LWIP_DEBUG*/
+#endif
+
+/** Function prototype for a stack-internal timer function that has to be
+ * called at a defined interval */
+typedef void (* lwip_cyclic_timer_handler)(void);
+
+/** This struct contains information about a stack-internal timer function
+ that has to be called at a defined interval */
+struct lwip_cyclic_timer {
+  u32_t interval_ms;
+  lwip_cyclic_timer_handler handler;
+#if LWIP_DEBUG_TIMERNAMES
+  const char* handler_name;
+#endif /* LWIP_DEBUG_TIMERNAMES */
+};
+
+/** This array contains all stack-internal cyclic timers. To get the number of
+ * timers, use LWIP_ARRAYSIZE() */
+extern const struct lwip_cyclic_timer lwip_cyclic_timers[];
+
+#if LWIP_TIMERS
+
+/** Function prototype for a timeout callback function. Register such a function
+ * using sys_timeout().
+ *
+ * @param arg Additional argument to pass to the function - set up by sys_timeout()
+ */
+typedef void (* sys_timeout_handler)(void *arg);
+
+struct sys_timeo {
+  struct sys_timeo *next;
+  u32_t time;
+  sys_timeout_handler h;
+  void *arg;
+#if LWIP_DEBUG_TIMERNAMES
+  const char* handler_name;
+#endif /* LWIP_DEBUG_TIMERNAMES */
+};
+
+void sys_timeouts_init(void);
+
+#if LWIP_DEBUG_TIMERNAMES
+void sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char* handler_name);
+#define sys_timeout(msecs, handler, arg) sys_timeout_debug(msecs, handler, arg, #handler)
+#else /* LWIP_DEBUG_TIMERNAMES */
+void sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg);
+#endif /* LWIP_DEBUG_TIMERNAMES */
+
+void sys_untimeout(sys_timeout_handler handler, void *arg);
+void sys_restart_timeouts(void);
+#if NO_SYS
+void sys_check_timeouts(void);
+u32_t sys_timeouts_sleeptime(void);
+#else /* NO_SYS */
+void sys_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg);
+#endif /* NO_SYS */
+
+
+#endif /* LWIP_TIMERS */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_HDR_TIMEOUTS_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwip/udp.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/udp.h
new file mode 100644
index 000000000..85fdd3947
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwip/udp.h
@@ -0,0 +1,196 @@
+/**
+ * @file
+ * UDP API (to be used from TCPIP thread)\n
+ * See also @ref udp_raw
+ */
+
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef LWIP_HDR_UDP_H
+#define LWIP_HDR_UDP_H
+
+#include "lwip/opt.h"
+
+#if LWIP_UDP /* don't build if not configured for use in lwipopts.h */
+
+#include "lwip/pbuf.h"
+#include "lwip/netif.h"
+#include "lwip/ip_addr.h"
+#include "lwip/ip.h"
+#include "lwip/ip6_addr.h"
+#include "lwip/prot/udp.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define UDP_FLAGS_NOCHKSUM       0x01U
+#define UDP_FLAGS_UDPLITE        0x02U
+#define UDP_FLAGS_CONNECTED      0x04U
+#define UDP_FLAGS_MULTICAST_LOOP 0x08U
+
+struct udp_pcb;
+
+/** Function prototype for udp pcb receive callback functions
+ * addr and port are in same byte order as in the pcb
+ * The callback is responsible for freeing the pbuf
+ * if it's not used any more.
+ *
+ * ATTENTION: Be aware that 'addr' might point into the pbuf 'p' so freeing this pbuf
+ *            can make 'addr' invalid, too.
+ *
+ * @param arg user supplied argument (udp_pcb.recv_arg)
+ * @param pcb the udp_pcb which received data
+ * @param p the packet buffer that was received
+ * @param addr the remote IP address from which the packet was received
+ * @param port the remote port from which the packet was received
+ */
+typedef void (*udp_recv_fn)(void *arg, struct udp_pcb *pcb, struct pbuf *p,
+    const ip_addr_t *addr, u16_t port);
+
+/** the UDP protocol control block */
+struct udp_pcb {
+/** Common members of all PCB types */
+  IP_PCB;
+
+/* Protocol specific PCB members */
+
+  struct udp_pcb *next;
+  struct netif *intf_filter;
+
+  u8_t flags;
+  /** ports are in host byte order */
+  u16_t local_port, remote_port;
+
+#if LWIP_MULTICAST_TX_OPTIONS
+#if LWIP_IPV4
+  /** outgoing network interface for multicast packets, by IPv4 address (if not 'any') */
+  ip4_addr_t mcast_ip4;
+#endif /* LWIP_IPV4 */
+  /** outgoing network interface for multicast packets, by interface index (if nonzero) */
+  u8_t mcast_ifindex;
+  /** TTL for outgoing multicast packets */
+  u8_t mcast_ttl;
+#endif /* LWIP_MULTICAST_TX_OPTIONS */
+
+#if LWIP_UDPLITE
+  /** used for UDP_LITE only */
+  u16_t chksum_len_rx, chksum_len_tx;
+#endif /* LWIP_UDPLITE */
+
+  /** receive callback function */
+  udp_recv_fn recv;
+  /** user-supplied argument for the recv callback */
+  void *recv_arg;
+};
+/* udp_pcbs export for external reference (e.g. SNMP agent) */
+extern struct udp_pcb *udp_pcbs;
+
+/* The following functions is the application layer interface to the
+   UDP code. */
+struct udp_pcb * udp_new        (void);
+struct udp_pcb * udp_new_ip_type(u8_t type);
+void             udp_remove     (struct udp_pcb *pcb);
+err_t            udp_bind       (struct udp_pcb *pcb, const ip_addr_t *ipaddr,
+                                 u16_t port);
+void             udp_bind_netif (struct udp_pcb *pcb, const struct netif* netif);
+err_t            udp_connect    (struct udp_pcb *pcb, const ip_addr_t *ipaddr,
+                                 u16_t port);
+void             udp_disconnect (struct udp_pcb *pcb);
+void             udp_recv       (struct udp_pcb *pcb, udp_recv_fn recv,
+                                 void *recv_arg);
+err_t            udp_sendto_if  (struct udp_pcb *pcb, struct pbuf *p,
+                                 const ip_addr_t *dst_ip, u16_t dst_port,
+                                 struct netif *netif);
+err_t            udp_sendto_if_src(struct udp_pcb *pcb, struct pbuf *p,
+                                 const ip_addr_t *dst_ip, u16_t dst_port,
+                                 struct netif *netif, const ip_addr_t *src_ip);
+err_t            udp_sendto     (struct udp_pcb *pcb, struct pbuf *p,
+                                 const ip_addr_t *dst_ip, u16_t dst_port);
+err_t            udp_send       (struct udp_pcb *pcb, struct pbuf *p);
+
+#if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
+err_t            udp_sendto_if_chksum(struct udp_pcb *pcb, struct pbuf *p,
+                                 const ip_addr_t *dst_ip, u16_t dst_port,
+                                 struct netif *netif, u8_t have_chksum,
+                                 u16_t chksum);
+err_t            udp_sendto_chksum(struct udp_pcb *pcb, struct pbuf *p,
+                                 const ip_addr_t *dst_ip, u16_t dst_port,
+                                 u8_t have_chksum, u16_t chksum);
+err_t            udp_send_chksum(struct udp_pcb *pcb, struct pbuf *p,
+                                 u8_t have_chksum, u16_t chksum);
+err_t            udp_sendto_if_src_chksum(struct udp_pcb *pcb, struct pbuf *p,
+                                 const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif,
+                                 u8_t have_chksum, u16_t chksum, const ip_addr_t *src_ip);
+#endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
+
+#define          udp_flags(pcb) ((pcb)->flags)
+#define          udp_setflags(pcb, f)  ((pcb)->flags = (f))
+
+#define          udp_set_flags(pcb, set_flags)     do { (pcb)->flags = (u8_t)((pcb)->flags |  (set_flags)); } while(0)
+#define          udp_clear_flags(pcb, clr_flags)   do { (pcb)->flags = (u8_t)((pcb)->flags & ~(clr_flags)); } while(0)
+#define          udp_is_flag_set(pcb, flag)        (((pcb)->flags & (flag)) != 0)
+
+/* The following functions are the lower layer interface to UDP. */
+void             udp_input      (struct pbuf *p, struct netif *inp);
+
+void             udp_init       (void);
+
+/* for compatibility with older implementation */
+#define udp_new_ip6() udp_new_ip_type(IPADDR_TYPE_V6)
+
+#if LWIP_MULTICAST_TX_OPTIONS
+#if LWIP_IPV4
+#define udp_set_multicast_netif_addr(pcb, ip4addr) ip4_addr_copy((pcb)->mcast_ip4, *(ip4addr))
+#define udp_get_multicast_netif_addr(pcb)          (&(pcb)->mcast_ip4)
+#endif /* LWIP_IPV4 */
+#define udp_set_multicast_netif_index(pcb, idx)    ((pcb)->mcast_ifindex = (idx))
+#define udp_get_multicast_netif_index(pcb)         ((pcb)->mcast_ifindex)
+#define udp_set_multicast_ttl(pcb, value)          ((pcb)->mcast_ttl = (value))
+#define udp_get_multicast_ttl(pcb)                 ((pcb)->mcast_ttl)
+#endif /* LWIP_MULTICAST_TX_OPTIONS */
+
+#if UDP_DEBUG
+void udp_debug_print(struct udp_hdr *udphdr);
+#else
+#define udp_debug_print(udphdr)
+#endif
+
+void udp_netif_ip_addr_changed(const ip_addr_t* old_addr, const ip_addr_t* new_addr);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LWIP_UDP */
+
+#endif /* LWIP_HDR_UDP_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/lwipopts.h b/cores/nRF5/nordic/config/nrf52840/configxx/lwipopts.h
new file mode 100644
index 000000000..808e7b76f
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/lwipopts.h
@@ -0,0 +1,174 @@
+/*
+ *
+ *    Copyright (c) 2020 Project CHIP Authors
+ *    Copyright (c) 2018 Nest Labs, Inc.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      Compile-time configuration for LwIP on nRF52 platforms using the
+ *      Nordic nRF5 SDK.
+ *
+ */
+
+#ifndef __LWIPOPTS_H__
+#define __LWIPOPTS_H__
+
+#if CHIP_HAVE_CONFIG_H
+#include <lwip/lwip_buildconfig.h>
+#endif
+
+#include <stdlib.h>
+
+#define NO_SYS 0
+#define MEM_ALIGNMENT (4)
+#define MEMP_NUM_TCP_SEG (TCP_SND_QUEUELEN + 1)
+#define LWIP_TIMEVAL_PRIVATE (0)
+#define MEM_LIBC_MALLOC (0)
+#define LWIP_COMPAT_MUTEX (0)
+#define SYS_LIGHTWEIGHT_PROT (1)
+#define LWIP_AUTOIP (0)
+#define LWIP_DHCP_AUTOIP_COOP (0)
+#define LWIP_SOCKET_SET_ERRNO 0
+#define IP_REASS_MAX_PBUFS 0
+#define IP_REASSEMBLY 0
+#define MEMP_NUM_REASSDATA 0
+#define LWIP_SO_RCVTIMEO 0
+#define SO_REUSE (1)
+#define LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS (1)
+#define LWIP_STATS (0)
+#define LWIP_TCPIP_CORE_LOCKING 1
+#define TCP_QUEUE_OOSEQ 0
+#define ARP_QUEUEING (0)
+#define TCPIP_THREAD_NAME "LWIP"
+
+#define LWIP_SOCKET 0
+
+// TODO: seems like this is unnecessary on Thread-only platforms
+#define LWIP_RAW 1
+#define MEMP_NUM_RAW_PCB (5)
+
+// TODO: verify count
+#define MEMP_NUM_UDP_PCB (7)
+
+#define LWIP_HAVE_LOOPIF (0)
+
+// TODO: not sure why this is disabled
+#define LWIP_NETIF_LOOPBACK (0)
+
+#define MEMP_NUM_NETCONN (0)
+
+#define LWIP_IPV4 0
+#define LWIP_IPV6 1
+#define LWIP_ARP (0)
+#define LWIP_DNS (0)
+#define LWIP_ICMP (0)
+#define LWIP_IGMP (0)
+#define LWIP_DHCP (0)
+#define LWIP_IPV6_REASS (0)
+#define LWIP_IPV6_DHCP6 0
+#define LWIP_IPV6_AUTOCONFIG (0)
+#define LWIP_IPV6_ROUTER_SUPPORT 0
+#define LWIP_ND6_LISTEN_RA 0
+
+#define LWIP_ND6_NUM_NEIGHBORS (0)
+#define LWIP_ND6_NUM_DESTINATIONS (0)
+#define LWIP_ND6_NUM_PREFIXES (0)
+#define LWIP_ND6_NUM_ROUTERS (0)
+#define LWIP_ND6_MAX_MULTICAST_SOLICIT (0)
+#define LWIP_ND6_MAX_UNICAST_SOLICIT (0)
+#define LWIP_ND6_MAX_NEIGHBOR_ADVERTISEMENT (0)
+#define LWIP_ND6_TCP_REACHABILITY_HINTS (0)
+
+#define MEMP_SEPARATE_POOLS (1)
+#define LWIP_PBUF_FROM_CUSTOM_POOLS (0)
+#define MEMP_USE_CUSTOM_POOLS (0)
+#define PBUF_POOL_SIZE (8)
+#define PBUF_POOL_BUFSIZE (1500)
+#define PBUF_POOL_SIZE_LARGE (3)
+#define PBUF_POOL_SIZE_MEDIUM (4)
+#define PBUF_POOL_SIZE_SMALL (5)
+#define PBUF_POOL_BUFSIZE_LARGE (1280)
+#define PBUF_POOL_BUFSIZE_MEDIUM (640)
+#define PBUF_POOL_BUFSIZE_SMALL (256)
+#define PBUF_CUSTOM_POOL_IDX_START (MEMP_PBUF_POOL_SMALL)
+#define PBUF_CUSTOM_POOL_IDX_END (MEMP_PBUF_POOL_LARGE)
+
+#define TCP_MSS (1152)
+#define TCP_SND_BUF (2 * TCP_MSS)
+#define TCP_LISTEN_BACKLOG (1)
+
+#define ETH_PAD_SIZE (0)
+#define SUB_ETHERNET_HEADER_SPACE (0)
+#define PBUF_LINK_HLEN (0)
+
+#define TCPIP_THREAD_STACKSIZE (4096)
+#define TCPIP_THREAD_PRIO (2)
+
+#define NETIF_MAX_HWADDR_LEN 8U
+
+#define LWIP_IPV6_NUM_ADDRESSES 5
+
+#define LWIP_IPV6_ND 0
+#define LWIP_ND6_QUEUEING 0
+
+#define LWIP_MULTICAST_PING 0
+
+#define TCPIP_MBOX_SIZE 6
+#define DEFAULT_RAW_RECVMBOX_SIZE 6
+#define DEFAULT_UDP_RECVMBOX_SIZE 6
+#define DEFAULT_TCP_RECVMBOX_SIZE 6
+
+// TODO: make LWIP_DEBUG conditional on build type
+
+#ifndef LWIP_DEBUG
+#define LWIP_DEBUG 1
+#endif
+
+#define MEMP_OVERFLOW_CHECK (0)
+#define MEMP_SANITY_CHECK (0)
+#define MEM_DEBUG (LWIP_DBG_OFF)
+#define MEMP_DEBUG (LWIP_DBG_OFF)
+#define PBUF_DEBUG (LWIP_DBG_OFF)
+#define API_LIB_DEBUG (LWIP_DBG_OFF)
+#define API_MSG_DEBUG (LWIP_DBG_OFF)
+#define TCPIP_DEBUG (LWIP_DBG_OFF)
+#define NETIF_DEBUG (LWIP_DBG_OFF)
+#define SOCKETS_DEBUG (LWIP_DBG_OFF)
+#define DEMO_DEBUG (LWIP_DBG_OFF)
+#define DHCP_DEBUG (LWIP_DBG_OFF)
+#define AUTOIP_DEBUG (LWIP_DBG_OFF)
+#define ETHARP_DEBUG (LWIP_DBG_OFF)
+#define IP_DEBUG (LWIP_DBG_OFF)
+#define IP_REASS_DEBUG (LWIP_DBG_OFF)
+#define IP6_DEBUG (LWIP_DBG_OFF)
+#define RAW_DEBUG (LWIP_DBG_OFF)
+#define ICMP_DEBUG (LWIP_DBG_OFF)
+#define UDP_DEBUG (LWIP_DBG_OFF)
+#define TCP_DEBUG (LWIP_DBG_OFF)
+#define TCP_INPUT_DEBUG (LWIP_DBG_OFF)
+#define TCP_OUTPUT_DEBUG (LWIP_DBG_OFF)
+#define TCP_RTO_DEBUG (LWIP_DBG_OFF)
+#define TCP_CWND_DEBUG (LWIP_DBG_OFF)
+#define TCP_WND_DEBUG (LWIP_DBG_OFF)
+#define TCP_FR_DEBUG (LWIP_DBG_OFF)
+#define TCP_QLEN_DEBUG (LWIP_DBG_OFF)
+#define TCP_RST_DEBUG (LWIP_DBG_OFF)
+#define PPP_DEBUG (LWIP_DBG_OFF)
+
+#define LWIP_DBG_TYPES_ON                                                                                                          \
+    (LWIP_DBG_ON | LWIP_DBG_TRACE) /* (LWIP_DBG_ON|LWIP_DBG_TRACE|LWIP_DBG_STATE|LWIP_DBG_FRESH|LWIP_DBG_HALT) */
+
+#endif /* __LWIPOPTS_H__ */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/nlassert-internal.h b/cores/nRF5/nordic/config/nrf52840/configxx/nlassert-internal.h
new file mode 100644
index 000000000..174b37fc3
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/nlassert-internal.h
@@ -0,0 +1,489 @@
+/*
+ *   Copyright 2010-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *   Licensed under the Apache License, Version 2.0 (the "License");
+ *   you may not use this file except in compliance with the License.
+ *   You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *   Unless required by applicable law or agreed to in writing, software
+ *   distributed under the License is distributed on an "AS IS" BASIS,
+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *   See the License for the specific language governing permissions and
+ *   limitations under the License.
+ *
+ *    Description:
+ *      This file defines macros internal to the implementation of the
+ *      Nest Labs assertion and exception checking facility.
+ *
+ */
+
+#ifndef NLASSERT_INTERNAL_H
+#define NLASSERT_INTERNAL_H
+
+#if defined(__GNUC__) && (__GNUC__ > 2) && defined(__OPTIMIZE__)
+# define __nlLIKELY(condition)        __builtin_expect(condition, 1)
+# define __nlUNLIKELY(condition)      __builtin_expect(condition, 0)
+#else
+# define __nlLIKELY(condition)        (condition)
+# define __nlUNLIKELY(condition)      (condition)
+#endif /* defined(__GNUC__) && (__GNUC__ > 2) && defined(__OPTIMIZE__) */
+
+// Notes on the unusual design of __nlSHOULD_ASSERT and __nl_ASSERT_UNUSED:
+//
+//
+// For non-production builds (aka "development" or "debug" builds)
+// ===============================================================
+//
+// The nlASSERT(condition) macro evaluates the "condition" expression and, if
+// it is false, calls NL_ASSERT_ABORT() to abort execution (after optionally
+// performing some logging and debugging operations). Partially expanded, for
+// clarity, it looks like this:
+//
+//     if (__nlSHOULD_ASSERT(condition))
+//     {
+//         do
+//         {
+//             /* optional logging, backtrace, and/or trap handling */
+//         } while (0);
+//
+//         {
+//             NL_ASSERT_ABORT();
+//         }
+//     }
+//     else do { /* nothing */ } while (0)
+//
+// NOTE: The "if (foo) / else do { } while (0)" construct is just a more
+//       robust version of the standard "do / while (0)" macro wrapper.
+//       It is explained below, in the comments accompanying __nlCHECK.
+//
+// The __nlSHOULD_ASSERT(condition) macro must evaluate to true if "condition"
+// is false; conceptually, its definition is "!(condition)". But it is not
+// actually defined that way, for this reason:
+//
+// It is not uncommon for an equality test like "if (x == y)" to be accidentally
+// written as an assignment: "if (x = y)". GCC and similar compilers can detect
+// this and emit a warning, but the warning is suppressed if the assignment is
+// surrounded by an extra pair of parentheses to indicate that it is
+// intentional: "if ((x = y))". So if __nlSHOULD_ASSERT(condition) were defined
+// as "!(condition)", the parentheses around "condition" -- required by the "!"
+// operator -- would be seen by the compiler as an indication that the
+// assignment was intentional, so no warning would be emitted if, for example,
+// "nlASSERT(x == y)" were mistakenly written as "nlASSERT(x = y)".
+//
+// Therefore, __nlSHOULD_ASSERT(condition) is defined so that there will be no
+// extra parentheses around "condition" when the nlASSERT(condition) macro is
+// expanded. With this definition, nlASSERT(condition) expands to:
+//
+//     if (condition)
+//     {
+//         /* do nothing */
+//     }
+//     else if (1)
+//     {
+//         do
+//         {
+//             /* optional logging, backtrace, and/or trap handling */
+//         } while (0);
+//
+//         {
+//             NL_ASSERT_ABORT();
+//         }
+//     }
+//     else do { /* nothing */ } while (0)
+//
+// GCC's branch-prediction hinting mechanism ("__builtin_expect(condition,1)")
+// would also suppress the "unintended assignment" warning, so is not used in
+// the macro definition. But the macro compiles to exactly the same assembly
+// code as it would if the hint were included, so omitting the hint incurs no
+// speed or memory cost. This is true for both ARM and x86 ISAs (tested under
+// GCC 4.x.x, with optimization for speed enabled via compiler flag -O3).
+//
+//
+// For production builds (aka "release" builds)
+// ============================================
+//
+// The nlASSERT(condition) macro is disabled by defining it as
+// __nlASSERT_UNUSED(condition).
+//
+// The  __nlASSERT_UNUSED(condition) macro must not perform any logging or
+// debugging operations, and it must not abort program execution even when
+// "condition" is false. It cannot simply be defined as "(void)0", however,
+// because it must allow side effects in "condition", if any, to occur exactly
+// as they would in the non-production version of the macro. And it can't be
+// defined as (void)(condition) because it is desirable for an unintended
+// assignment in "condition" to be caught by the compiler, just as it would be
+// in a non-production build.
+//
+// Therefore, __nl_ASSERT_UNUSED(condition) is defined so that "condition" is
+// treated as a truth value, to ensure that unintended assignment will be
+// caught, and so that "condition" is evaluated at runtime if and only if it
+// would also be evaluated by the non-production version of nlASSERT(condition),
+// to ensure that side effects will occur identically.
+
+#define __nlSHOULD_ASSERT(condition) condition) { /* do nothing */ } else if (1
+
+#define __nlASSERT_UNUSED(condition) do { if (condition) { /* do nothing */ } } while (0)
+
+/** @cond */
+#define __nlSTATIC_ASSERT_CONCAT(aPrefix, aSuffix) aPrefix ## aSuffix
+
+#define _nlSTATIC_ASSERT_CONCAT(aPrefix, aSuffix) __nlSTATIC_ASSERT_CONCAT(aPrefix, aSuffix)
+/** @endcond */
+
+/**
+ *  @def _nlSTATIC_ASSERT(aCondition)
+ *
+ *  @brief
+ *    This checks, at compile-time, for the specified condition, which
+ *    is expected to commonly be true and terminates compilation if the
+ *    condition is false. It is legal, in both C and C++, anywhere that
+ *    a declaration would be.
+ *
+ *  @note This is a package-internal interface. If C++11/C11 or greater is
+ *  available, this falls back to using C++11/C11 intrinsic facilities:
+ *  static_assert or _Static_assert.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion
+ *                          failure. Note, this message is not
+ *                          actually emitted in any meaningful way for
+ *                          non-C11 or -C++11 code. It serves to
+ *                          simply comment or annotate the assertion
+ *                          and to provide interface parallelism with
+ *                          the run-time assertion interfaces.
+ *
+ */
+#if defined(__cplusplus) && (__cplusplus >= 201103L)
+# define _nlSTATIC_ASSERT(aCondition, aMessage) static_assert(aCondition, aMessage)
+#elif defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)
+# define _nlSTATIC_ASSERT(aCondition, aMessage) _Static_assert(aCondition, aMessage)
+#else
+# ifdef __COUNTER__
+#  define _nlSTATIC_ASSERT(aCondition, aMessage) typedef char _nlSTATIC_ASSERT_CONCAT(STATIC_ASSERT_t_, __COUNTER__)[(aCondition) ? 1 : -1] __attribute__ ((unused))
+# else
+#  define _nlSTATIC_ASSERT(aCondition, aMessage) typedef char _nlSTATIC_ASSERT_CONCAT(STATIC_ASSERT_t_, __LINE__)[(aCondition) ? 1 : -1] __attribute__ ((unused))
+# endif
+#endif /* defined(__cplusplus) && (__cplusplus >= 201103L) */
+
+// __nlSTATIC_ASSERT_UNUSED(aCondition)
+//
+// Can be used everywhere that _nlSTATIC_ASSERT can, and behaves exactly the
+// same way except that it never asserts.
+#if defined(__cplusplus) && (__cplusplus >= 201103L)
+# define __nlSTATIC_ASSERT_UNUSED(aCondition, aMessage) static_assert((aCondition) || 1, aMessage)
+#elif defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)
+# define __nlSTATIC_ASSERT_UNUSED(aCondition, aMessage) _Static_assert((aCondition) || 1, aMessage)
+#else
+# ifdef __COUNTER__
+#  define __nlSTATIC_ASSERT_UNUSED(aCondition, aMessage) typedef char _nlSTATIC_ASSERT_CONCAT(STATIC_ASSERT_t_, __COUNTER__)[((aCondition) || 1) ? 1 : -1] __attribute__ ((unused))
+# else
+#  define __nlSTATIC_ASSERT_UNUSED(aCondition, aMessage) typedef char _nlSTATIC_ASSERT_CONCAT(STATIC_ASSERT_t_, __LINE__)[((aCondition) || 1) ? 1 : -1] __attribute__ ((unused))
+# endif
+#endif /* defined(__cplusplus) && (__cplusplus >= 201103L) */
+
+#define __NL_ASSERT_MAYBE_RUN_TRIGGERS(flags, prefix, name, condition, label, file, line, message)             \
+    do                                                                                    \
+    {                                                                                     \
+        if ((flags) & NL_ASSERT_FLAG_LOG) {                                               \
+            NL_ASSERT_LOG(prefix, name, condition, label, file, line, message);           \
+        }                                                                                 \
+        if ((flags) & NL_ASSERT_FLAG_BACKTRACE) {                                         \
+            NL_ASSERT_BACKTRACE();                                                        \
+        }                                                                                 \
+        if ((flags) & NL_ASSERT_FLAG_TRAP) {                                              \
+            NL_ASSERT_TRAP();                                                             \
+        }                                                                                 \
+    } while (0)
+
+#define __NL_ASSERT_MAYBE_RUN_PRE_ACTION_TRIGGERS(flags, prefix, name, condition, label, file, line, message)  \
+    do                                                                                    \
+    {                                                                                     \
+        if ((flags) & NL_ASSERT_FLAG_LOG) {                                               \
+            NL_ASSERT_LOG(prefix, name, condition, label, file, line, message);           \
+        }                                                                                 \
+        if ((flags) & NL_ASSERT_FLAG_BACKTRACE) {                                         \
+            NL_ASSERT_BACKTRACE();                                                        \
+        }                                                                                 \
+    } while (0)
+
+#define __NL_ASSERT_MAYBE_RUN_POST_ACTION_TRIGGERS(flags, prefix, name, condition, label, file, line, message) \
+    do                                                                                    \
+    {                                                                                     \
+        if ((flags) & NL_ASSERT_FLAG_TRAP) {                                              \
+            NL_ASSERT_TRAP();                                                             \
+        }                                                                                 \
+    } while (0)
+
+// __nlEXPECT
+
+#define __nlEXPECT(flags, condition, label)                                               \
+    do                                                                                    \
+    {                                                                                     \
+        if (__nlSHOULD_ASSERT(condition))                                                 \
+        {                                                                                 \
+            __NL_ASSERT_MAYBE_RUN_TRIGGERS((flags),                                       \
+                                           NL_ASSERT_PREFIX_STRING,                       \
+                                           NL_ASSERT_COMPONENT_STRING,                    \
+                                           #condition,                                    \
+                                           #label,                                        \
+                                           NL_ASSERT_FILE,                                \
+                                           __LINE__,                                      \
+                                           0);                                            \
+            goto label;                                                                   \
+        }                                                                                 \
+    } while (0)
+
+#define __nlEXPECT_PRINT(flags, condition, label, message)                                \
+    do                                                                                    \
+    {                                                                                     \
+        if (__nlSHOULD_ASSERT(condition))                                                 \
+        {                                                                                 \
+            __NL_ASSERT_MAYBE_RUN_TRIGGERS((flags),                                       \
+                                           NL_ASSERT_PREFIX_STRING,                       \
+                                           NL_ASSERT_COMPONENT_STRING,                    \
+                                           #condition,                                    \
+                                           #label,                                        \
+                                           NL_ASSERT_FILE,                                \
+                                           __LINE__,                                      \
+                                           message);                                      \
+            goto label;                                                                   \
+        }                                                                                 \
+    } while (0)
+
+#define __nlEXPECT_ACTION(flags, condition, label, action)                                \
+    do                                                                                    \
+    {                                                                                     \
+        if (__nlSHOULD_ASSERT(condition))                                                 \
+        {                                                                                 \
+            __NL_ASSERT_MAYBE_RUN_PRE_ACTION_TRIGGERS((flags),                            \
+                                                      NL_ASSERT_PREFIX_STRING,            \
+                                                      NL_ASSERT_COMPONENT_STRING,         \
+                                                      #condition,                         \
+                                                      #label,                             \
+                                                      NL_ASSERT_FILE,                     \
+                                                      __LINE__,                           \
+                                                      0);                                 \
+            {                                                                             \
+                action;                                                                   \
+            }                                                                             \
+            __NL_ASSERT_MAYBE_RUN_POST_ACTION_TRIGGERS((flags),                           \
+                                                       NL_ASSERT_PREFIX_STRING,           \
+                                                       NL_ASSERT_COMPONENT_STRING,        \
+                                                       #condition,                        \
+                                                       #label,                            \
+                                                       NL_ASSERT_FILE,                    \
+                                                       __LINE__,                          \
+                                                       0);                                \
+            goto label;                                                                   \
+        }                                                                                 \
+    } while (0)
+
+#define __nlEXPECT_ACTION_PRINT(flags, condition, label, action, message)                 \
+    do                                                                                    \
+    {                                                                                     \
+        if (__nlSHOULD_ASSERT(condition))                                                 \
+        {                                                                                 \
+            __NL_ASSERT_MAYBE_RUN_PRE_ACTION_TRIGGERS((flags),                            \
+                                                      NL_ASSERT_PREFIX_STRING,            \
+                                                      NL_ASSERT_COMPONENT_STRING,         \
+                                                      #condition,                         \
+                                                      #label,                             \
+                                                      NL_ASSERT_FILE,                     \
+                                                      __LINE__,                           \
+                                                      message);                           \
+            {                                                                             \
+                action;                                                                   \
+            }                                                                             \
+            __NL_ASSERT_MAYBE_RUN_POST_ACTION_TRIGGERS((flags),                           \
+                                                       NL_ASSERT_PREFIX_STRING,           \
+                                                       NL_ASSERT_COMPONENT_STRING,        \
+                                                       #condition,                        \
+                                                       #label,                            \
+                                                       NL_ASSERT_FILE,                    \
+                                                       __LINE__,                          \
+                                                       message);                          \
+            goto label;                                                                   \
+        }                                                                                 \
+    } while (0)
+
+#define __nlEXPECT_SUCCESS(flags, status, label)                                          __nlEXPECT(flags, status == 0, label)
+#define __nlEXPECT_SUCCESS_PRINT(flags, status, label, message)                           __nlEXPECT_PRINT(flags, status == 0, label, message)
+#define __nlEXPECT_SUCCESS_ACTION(flags, status, label, action)                           __nlEXPECT_ACTION(flags, status == 0, label, action)
+#define __nlEXPECT_SUCCESS_ACTION_PRINT(flags, status, label, action, message)            __nlEXPECT_ACTION_PRINT(flags, status == 0, label, action, message)
+
+#define __nlNEXPECT(flags, condition, label)                                              __nlEXPECT(flags, !(condition), label)
+#define __nlNEXPECT_PRINT(flags, condition, label, message)                               __nlEXPECT_PRINT(flags, !(condition), label, message)
+#define __nlNEXPECT_ACTION(flags, condition, label, action)                               __nlEXPECT_ACTION(flags, !(condition), label, action)
+#define __nlNEXPECT_ACTION_PRINT(flags, condition, label, action, message)                __nlEXPECT_ACTION_PRINT(flags, !(condition), label, action, message)
+
+// __nlCHECK
+//
+// NOTE: Some of these macros take a C statement as a parameter. The unusual
+// "else do {} while(0)" construct allows those macros to work properly when
+// that parameter is set to "continue" or "break" (which isn't unexpected in
+// an assert macro).
+//
+// If the macros were written in the standard way by wrapping them in a
+// "do/while(0)", they could fail silently: A "continue" or "break" statement,
+// intended to break out of one or all iterations of the loop containing the
+// macro invocation -- would instead just break out of the macro's internal
+// do-while.
+
+#define __nlCHECK(flags, condition)                                                       \
+    if (__nlSHOULD_ASSERT(condition))                                                     \
+    {                                                                                     \
+        __NL_ASSERT_MAYBE_RUN_TRIGGERS((flags),                                           \
+                                       NL_ASSERT_PREFIX_STRING,                           \
+                                       NL_ASSERT_COMPONENT_STRING,                        \
+                                       #condition,                                        \
+                                       0,                                                 \
+                                       NL_ASSERT_FILE,                                    \
+                                       __LINE__,                                          \
+                                       0);                                                \
+    }                                                                                     \
+    else do {} while (0)
+
+#define __nlCHECK_ACTION(flags, condition, action)                                        \
+    if (__nlSHOULD_ASSERT(condition))                                                     \
+    {                                                                                     \
+        __NL_ASSERT_MAYBE_RUN_PRE_ACTION_TRIGGERS((flags),                                \
+                                                  NL_ASSERT_PREFIX_STRING,                \
+                                                  NL_ASSERT_COMPONENT_STRING,             \
+                                                  #condition,                             \
+                                                  0,                                      \
+                                                  NL_ASSERT_FILE,                         \
+                                                  __LINE__,                               \
+                                                  0);                                     \
+        {                                                                                 \
+            action;                                                                       \
+        }                                                                                 \
+        __NL_ASSERT_MAYBE_RUN_POST_ACTION_TRIGGERS((flags),                               \
+                                                   NL_ASSERT_PREFIX_STRING,               \
+                                                   NL_ASSERT_COMPONENT_STRING,            \
+                                                   #condition,                            \
+                                                   0,                                     \
+                                                   NL_ASSERT_FILE,                        \
+                                                   __LINE__,                              \
+                                                   0);                                    \
+    }                                                                                     \
+    else do {} while (0) /* This is explained in the comment above __nlCHECK */
+
+#define __nlCHECK_PRINT(flags, condition, message)                                        \
+    if (__nlSHOULD_ASSERT(condition))                                                     \
+    {                                                                                     \
+        __NL_ASSERT_MAYBE_RUN_TRIGGERS((flags),                                           \
+                                       NL_ASSERT_PREFIX_STRING,                           \
+                                       NL_ASSERT_COMPONENT_STRING,                        \
+                                       #condition,                                        \
+                                       0,                                                 \
+                                       NL_ASSERT_FILE,                                    \
+                                       __LINE__,                                          \
+                                       message);                                          \
+    }                                                                                     \
+    else do {} while (0) /* This is explained in the comment above __nlCHECK */
+
+#define __nlCHECK_SUCCESS(flags, status)                                                  __nlCHECK(flags, status == 0)
+#define __nlCHECK_SUCCESS_ACTION(flags, status, action)                                   __nlCHECK_ACTION(flags, status == 0, action)
+#define __nlCHECK_SUCCESS_PRINT(flags, status, message)                                   __nlCHECK_PRINT(flags, status == 0, message)
+
+#define __nlNCHECK(flags, condition)                                                      __nlCHECK(flags, !(condition))
+#define __nlNCHECK_ACTION(flags, condition, action)                                       __nlCHECK_ACTION(flags, !(condition), action)
+#define __nlNCHECK_PRINT(flags, condition, message)                                       __nlCHECK_PRINT(flags, !(condition), message)
+
+// __nlVERIFY
+
+#define __nlVERIFY(flags, condition)                                                      __nlCHECK(flags, condition)
+#define __nlVERIFY_ACTION(flags, condition, action)                                       __nlCHECK_ACTION(flags, condition, action)
+#define __nlVERIFY_PRINT(flags, condition, message)                                       __nlCHECK_PRINT(flags, condition, message)
+
+#define __nlVERIFY_SUCCESS(flags, status)                                                 __nlCHECK_SUCCESS(flags, status)
+#define __nlVERIFY_SUCCESS_ACTION(flags, status, action)                                  __nlCHECK_SUCCESS_ACTION(flags, status, action)
+#define __nlVERIFY_SUCCESS_PRINT(flags, status, message)                                  __nlCHECK_SUCCESS_PRINT(flags, status, message)
+
+#define __nlNVERIFY(flags, condition)                                                     __nlNCHECK(flags, condition)
+#define __nlNVERIFY_ACTION(flags, condition, action)                                      __nlNCHECK_ACTION(flags, condition, action)
+#define __nlNVERIFY_PRINT(flags, condition, message)                                      __nlNCHECK_PRINT(flags, condition, message)
+
+// __nlPRECONDITION
+
+#define __nlPRECONDITION(flags, condition, termination)                                   \
+    if (__nlSHOULD_ASSERT(condition))                                                     \
+    {                                                                                     \
+        __NL_ASSERT_MAYBE_RUN_TRIGGERS((flags),                                           \
+                                       NL_ASSERT_PREFIX_STRING,                           \
+                                       NL_ASSERT_COMPONENT_STRING,                        \
+                                       #condition,                                        \
+                                       0,                                                 \
+                                       NL_ASSERT_FILE,                                    \
+                                       __LINE__,                                          \
+                                       0);                                                \
+        {                                                                                 \
+            termination;                                                                  \
+        }                                                                                 \
+    }                                                                                     \
+    else do {} while (0) /* This is explained in the comment above __nlCHECK */
+
+#define __nlPRECONDITION_ACTION(flags, condition, termination, action)                    \
+    if (__nlSHOULD_ASSERT(condition))                                                     \
+    {                                                                                     \
+        __NL_ASSERT_MAYBE_RUN_PRE_ACTION_TRIGGERS((flags),                                \
+                                                  NL_ASSERT_PREFIX_STRING,                \
+                                                  NL_ASSERT_COMPONENT_STRING,             \
+                                                  #condition,                             \
+                                                  0,                                      \
+                                                  NL_ASSERT_FILE,                         \
+                                                  __LINE__,                               \
+                                                  0);                                     \
+        {                                                                                 \
+            action;                                                                       \
+        }                                                                                 \
+        __NL_ASSERT_MAYBE_RUN_POST_ACTION_TRIGGERS((flags),                               \
+                                                   NL_ASSERT_PREFIX_STRING,               \
+                                                   NL_ASSERT_COMPONENT_STRING,            \
+                                                   #condition,                            \
+                                                   0,                                     \
+                                                   NL_ASSERT_FILE,                        \
+                                                   __LINE__,                              \
+                                                   0);                                    \
+        {                                                                                 \
+            termination;                                                                  \
+        }                                                                                 \
+    }                                                                                     \
+    else do {} while (0) /* This is explained in the comment above __nlCHECK */
+
+#define __nlPRECONDITION_PRINT(flags, condition, termination, message)                    \
+    if (__nlSHOULD_ASSERT(condition))                                                     \
+    {                                                                                     \
+        __NL_ASSERT_MAYBE_RUN_TRIGGERS((flags),                                           \
+                                       NL_ASSERT_PREFIX_STRING,                           \
+                                       NL_ASSERT_COMPONENT_STRING,                        \
+                                       #condition,                                        \
+                                       0,                                                 \
+                                       NL_ASSERT_FILE,                                    \
+                                       __LINE__,                                          \
+                                       message);                                          \
+        {                                                                                 \
+            termination;                                                                  \
+        }                                                                                 \
+    }                                                                                     \
+    else do {} while (0) /* This is explained in the comment above __nlCHECK */
+
+#define __nlPRECONDITION_SUCCESS(flags, status, termination)                              __nlPRECONDITION(flags, status == 0, termination)
+#define __nlPRECONDITION_SUCCESS_ACTION(flags, status, termination, action)               __nlPRECONDITION_ACTION(flags, status == 0, termination, action)
+#define __nlPRECONDITION_SUCCESS_PRINT(flags, status, termination, message)               __nlPRECONDITION_PRINT(flags, status == 0, termination, message)
+
+#define __nlNPRECONDITION(flags, condition, termination)                                  __nlPRECONDITION(flags, !(condition), termination)
+#define __nlNPRECONDITION_ACTION(flags, condition, termination, action)                   __nlPRECONDITION_ACTION(flags, !(condition), termination, action)
+#define __nlNPRECONDITION_PRINT(flags, condition, termination, message)                   __nlPRECONDITION_PRINT(flags, !(condition), termination, message)
+
+// __nlABORT
+
+#define __nlABORT(flags, condition)                                                       __nlPRECONDITION(flags, condition, NL_ASSERT_ABORT())
+
+#define __nlABORT_ACTION(flags, condition, action)                                        __nlPRECONDITION_ACTION(flags, condition, NL_ASSERT_ABORT(), action)
+
+#endif /* NLASSERT_INTERNAL_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/nlassert-nonproduction.h b/cores/nRF5/nordic/config/nrf52840/configxx/nlassert-nonproduction.h
new file mode 100644
index 000000000..9c1d65367
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/nlassert-nonproduction.h
@@ -0,0 +1,2143 @@
+/*
+ *   Copyright 2010-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *   Licensed under the Apache License, Version 2.0 (the "License");
+ *   you may not use this file except in compliance with the License.
+ *   You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *   Unless required by applicable law or agreed to in writing, software
+ *   distributed under the License is distributed on an "AS IS" BASIS,
+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *   See the License for the specific language governing permissions and
+ *   limitations under the License.
+ *
+ */
+
+/**
+ *    @file
+ *      This file defines macros and interfaces for performing
+ *      compile- and run-time assertion checking and run-time
+ *      exception handling when #NL_ASSERT_PRODUCTION is false.
+ *
+ */
+
+#ifndef NLCORE_NLASSERT_NONPRODUCTION_H
+#define NLCORE_NLASSERT_NONPRODUCTION_H
+
+#include "nlassert-internal.h"
+
+/**
+ *  @ingroup check-style
+ *
+ *  @{
+ *
+ */
+
+/**
+ *  @def NL_ASSERT_CHECK_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for check-style
+ *    exception family assertions when #NL_ASSERT_PRODUCTION is
+ *    disabled.
+ *
+ *  This may be used to override #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_CHECK_NONPRODUCTION_FLAGS NL_ASSERT_CHECK_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ */
+#define NL_ASSERT_CHECK_NONPRODUCTION_FLAGS_DEFAULT                             (NL_ASSERT_FLAG_BACKTRACE | NL_ASSERT_FLAG_LOG | NL_ASSERT_FLAG_TRAP)
+
+/**
+ *  @def NL_ASSERT_CHECK_NONPRODUCTION_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags when #NL_ASSERT_PRODUCTION is
+ *    disabled that govern the behavior for check-style exception
+ *    family assertions when the assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_CHECK_NONPRODUCTION_FLAGS                                     NL_ASSERT_CHECK_NONPRODUCTION_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_CHECK_NONPRODUCTION_FLAGS)
+#define NL_ASSERT_CHECK_NONPRODUCTION_FLAGS                                     (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @def nlCHECK(aCondition)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true and takes action, based on configuration, if
+ *    the condition is false.
+ *
+ *  @note If #NL_ASSERT_PRODUCTION is true, the check is made inactive. But
+ *  side-effects, if any, in the asserted expression will still be produced.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *
+ *  @sa #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS
+ *
+ *  @sa #nlVERIFY
+ *
+ */
+#define nlCHECK(aCondition)                                                     __nlCHECK(NL_ASSERT_CHECK_NONPRODUCTION_FLAGS, aCondition)
+
+/**
+ *  @def nlCHECK_ACTION(aCondition, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true and takes action, based on configuration, and
+ *    executes @p anAction if the condition is false.
+ *
+ *  @note If #NL_ASSERT_PRODUCTION is true, the check is made inactive. But
+ *  side-effects, if any, in the asserted expression will still be produced.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS
+ *
+ *  @sa #nlVERIFY_ACTION
+ *
+ */
+#define nlCHECK_ACTION(aCondition, anAction)                                    __nlCHECK_ACTION(NL_ASSERT_CHECK_NONPRODUCTION_FLAGS, aCondition, anAction)
+
+/**
+ *  @def nlCHECK_PRINT(aCondition, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true and takes action, based on configuration, and
+ *    prints @p aMessage if the condition is false.
+ *
+ *  @note If #NL_ASSERT_PRODUCTION is true, the check is made inactive. But
+ *  side-effects, if any, in the asserted expression will still be produced.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS
+ *
+ *  @sa #nlVERIFY_PRINT
+ *
+ */
+#define nlCHECK_PRINT(aCondition, aMessage)                                     __nlCHECK_PRINT(NL_ASSERT_CHECK_NONPRODUCTION_FLAGS, aCondition, aMessage)
+
+/**
+ *  @def nlCHECK_SUCCESS(aStatus)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)) and takes action, based
+ *    on configuration, if the status is unsuccessful.
+ *
+ *  @note If #NL_ASSERT_PRODUCTION is true, the check is made inactive. But
+ *  side-effects, if any, in the asserted expression will still be produced.
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *
+ *  @sa #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS
+ *
+ *  @sa #nlVERIFY_SUCCESS
+ *
+ */
+#define nlCHECK_SUCCESS(aStatus)                                                __nlCHECK_SUCCESS(NL_ASSERT_CHECK_NONPRODUCTION_FLAGS, aStatus)
+
+/**
+ *  @def nlCHECK_SUCCESS_ACTION(aStatus, anAction)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)) and takes action, based
+ *    on configuration, and executes @p anAction if the status is
+ *    unsuccessful.
+ *
+ *  @note If #NL_ASSERT_PRODUCTION is true, the check is made inactive. But
+ *  side-effects, if any, in the asserted expression will still be produced.
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS
+ *
+ *  @sa #nlVERIFY_SUCCESS_ACTION
+ *
+ */
+#define nlCHECK_SUCCESS_ACTION(aStatus, anAction)                               __nlCHECK_SUCCESS_ACTION(NL_ASSERT_CHECK_NONPRODUCTION_FLAGS, aStatus, anAction)
+
+/**
+ *  @def nlCHECK_SUCCESS_PRINT(aStatus, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)) and takes action, based
+ *    on configuration, and prints @p aMessage if the status is
+ *    unsuccessful.
+ *
+ *  @note If #NL_ASSERT_PRODUCTION is true, the check is made inactive. But
+ *  side-effects, if any, in the asserted expression will still be produced.
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS
+ *
+ *  @sa #nlVERIFY_SUCCESS_PRINT
+ *
+ */
+#define nlCHECK_SUCCESS_PRINT(aStatus, aMessage)                                __nlCHECK_SUCCESS_PRINT(NL_ASSERT_CHECK_NONPRODUCTION_FLAGS, aStatus, aMessage)
+
+/**
+ *  @def nlNCHECK(aCondition)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false and takes action, based on configuration, if
+ *    the condition is true.
+ *
+ *  @note This is the logical inverse of #nlCHECK
+ *
+ *  @note If #NL_ASSERT_PRODUCTION is true, the check is made inactive. But
+ *  side-effects, if any, in the asserted expression will still be produced.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *
+ *  @sa #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK
+ *  @sa #nlNVERIFY
+ *
+ */
+#define nlNCHECK(aCondition)                                                    __nlNCHECK(NL_ASSERT_CHECK_NONPRODUCTION_FLAGS, aCondition)
+
+/**
+ *  @def nlNCHECK_ACTION(aCondition, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false and takes action, based on configuration, and
+ *    executes @p anAction if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlCHECK_ACTION
+ *
+ *  @note If #NL_ASSERT_PRODUCTION is true, the check is made inactive. But
+ *  side-effects, if any, in the asserted expression will still be produced.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK_ACTION
+ *  @sa #nlNVERIFY_ACTION
+ *
+ */
+#define nlNCHECK_ACTION(aCondition, anAction)                                   __nlNCHECK_ACTION(NL_ASSERT_CHECK_NONPRODUCTION_FLAGS, aCondition, anAction)
+
+/**
+ *  @def nlNCHECK_PRINT(aCondition, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false and takes action, based on configuration, and
+ *    prints @p aMessage if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlCHECK_PRINT
+ *
+ *  @note If #NL_ASSERT_PRODUCTION is true, the check is made inactive. But
+ *  side-effects, if any, in the asserted expression will still be produced.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK_PRINT
+ *  @sa #nlNVERIFY_PRINT
+ *
+ */
+#define nlNCHECK_PRINT(aCondition, aMessage)                                    __nlNCHECK_PRINT(NL_ASSERT_CHECK_NONPRODUCTION_FLAGS, aCondition, aMessage)
+
+/**
+ *  @}
+ *
+ */
+
+/**
+ *  @ingroup verify-style
+ *
+ *  @{
+ *
+ */
+
+/**
+ *  @def NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for verify-style
+ *    exception family assertions when #NL_ASSERT_PRODUCTION is
+ *    disabled.
+ *
+ *  This may be used to override #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ */
+#define NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS_DEFAULT                            (NL_ASSERT_FLAG_BACKTRACE | NL_ASSERT_FLAG_LOG | NL_ASSERT_FLAG_TRAP)
+
+/**
+ *  @def NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags when #NL_ASSERT_PRODUCTION is
+ *    disabled that govern the behavior for verify-style exception
+ *    family assertions when the assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS                                    NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS)
+#define NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS                                    (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @def nlVERIFY(aCondition)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true and takes action, based on configuration, if
+ *    the condition is false.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *
+ *  @sa #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_VERIFY_PRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK
+ *
+ */
+#define nlVERIFY(aCondition)                                                    __nlVERIFY(NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS, aCondition)
+
+/**
+ *  @def nlVERIFY_ACTION(aCondition, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true and takes action, based on configuration, and
+ *    executes @p anAction if the condition is false.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_VERIFY_PRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK_ACTION
+ *
+ */
+#define nlVERIFY_ACTION(aCondition, anAction)                                   __nlVERIFY_ACTION(NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS, aCondition, anAction)
+
+/**
+ *  @def nlVERIFY_PRINT(aCondition, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true and takes action, based on configuration, and
+ *    prints @p aMessage if the condition is false.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_VERIFY_PRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK_PRINT
+ *
+ */
+#define nlVERIFY_PRINT(aCondition, aMessage)                                    __nlVERIFY_PRINT(NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS, aCondition, aMessage)
+
+/**
+ *  @def nlVERIFY_SUCCESS(aStatus)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)) and takes action, based
+ *    on configuration, if the status is unsuccessful.
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *
+ *  @sa #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_VERIFY_PRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK_SUCCESS
+ *
+ */
+#define nlVERIFY_SUCCESS(aStatus)                                               __nlVERIFY_SUCCESS(NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS, aStatus)
+
+/**
+ *  @def nlVERIFY_SUCCESS_ACTION(aStatus, anAction)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)) and takes action, based
+ *    on configuration, and executes @p anAction if the status is
+ *    unsuccessful.
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_VERIFY_PRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK_SUCCESS_ACTION
+ *
+ */
+#define nlVERIFY_SUCCESS_ACTION(aStatus, anAction)                              __nlVERIFY_SUCCESS_ACTION(NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS, aStatus, anAction)
+
+/**
+ *  @def nlVERIFY_SUCCESS_PRINT(aStatus, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)) and takes action, based
+ *    on configuration, and prints @p aMessage if the status is
+ *    unsuccessful.
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_VERIFY_PRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK_SUCCESS_PRINT
+ *
+ */
+#define nlVERIFY_SUCCESS_PRINT(aStatus, aMessage)                               __nlVERIFY_SUCCESS_PRINT(NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS, aStatus, aMessage)
+
+/**
+ *  @def nlNVERIFY(aCondition)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false and takes action, based on configuration, if
+ *    the condition is true.
+ *
+ *  @note This is the logical inverse of #nlVERIFY
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *
+ *  @sa #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_VERIFY_PRODUCTION_FLAGS
+ *
+ *  @sa #nlVERIFY
+ *  @sa #nlNCHECK
+ *
+ */
+#define nlNVERIFY(aCondition)                                                   __nlNVERIFY(NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS, aCondition)
+
+/**
+ *  @def nlNVERIFY_ACTION(aCondition, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false and takes action, based on configuration, and
+ *    executes @p anAction if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlVERIFY_ACTION
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_VERIFY_PRODUCTION_FLAGS
+ *
+ *  @sa #nlVERIFY_ACTION
+ *  @sa #nlNCHECK_ACTION
+ *
+ */
+#define nlNVERIFY_ACTION(aCondition, anAction)                                  __nlNVERIFY_ACTION(NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS, aCondition, anAction)
+
+/**
+ *  @def nlNVERIFY_PRINT(aCondition, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false and takes action, based on configuration, and
+ *    prints @p aMessage if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlVERIFY_PRINT
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_VERIFY_PRODUCTION_FLAGS
+ *
+ *  @sa #nlVERIFY_PRINT
+ *  @sa #nlNCHECK_PRINT
+ *
+ */
+#define nlNVERIFY_PRINT(aCondition, aMessage)                                   __nlNVERIFY_PRINT(NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS, aCondition, aMessage)
+
+/**
+ *  @}
+ *
+ */
+
+/**
+ *  @ingroup desire-style
+ *
+ *  @{
+ *
+ */
+
+/**
+ *  @def NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for desire-style
+ *    exception family assertions when #NL_ASSERT_PRODUCTION is
+ *    disabled.
+ *
+ *  This may be used to override #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ */
+#define NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS_DEFAULT                            (NL_ASSERT_FLAG_LOG)
+
+/**
+ *  @def NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags when #NL_ASSERT_PRODUCTION is
+ *    disabled that govern the behavior for desire-style exception
+ *    family assertions when the assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS                                    NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS)
+#define NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS                                    (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @def nlDESIRE(aCondition, aLabel)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and branches to @p aLabel if the condition is
+ *    false.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT
+ *  @sa #nlREQUIRE
+ *
+ */
+#define nlDESIRE(aCondition, aLabel)                                            __nlEXPECT(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS, aCondition, aLabel)
+
+/**
+ *  @def nlDESIRE_PRINT(aCondition, aLabel, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and both prints @p aMessage and then branches
+ *    to @p aLabel if the condition is false.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_PRINT
+ *  @sa #nlREQUIRE_PRINT
+ *
+ */
+#define nlDESIRE_PRINT(aCondition, aLabel, aMessage)                            __nlEXPECT_PRINT(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS, aCondition, aLabel, aMessage)
+
+/**
+ *  @def nlDESIRE_ACTION(aCondition, aLabel, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and both executes @p anAction and branches to
+ *    @p aLabel if the condition is false.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_ACTION
+ *  @sa #nlREQUIRE_ACTION
+ *
+ */
+#define nlDESIRE_ACTION(aCondition, aLabel, anAction)                           __nlEXPECT_ACTION(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS, aCondition, aLabel, anAction)
+
+/**
+ *  @def nlDESIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, prints @p aMessage, executes @p anAction, and
+ *    branches to @p aLabel if the condition is false.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_ACTION_PRINT
+ *  @sa #nlREQUIRE_ACTION_PRINT
+ *
+ */
+#define nlDESIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)           __nlEXPECT_ACTION_PRINT(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS, aCondition, aLabel, anAction, aMessage)
+
+/**
+ *  @def nlDESIRE_SUCCESS(aStatus, aLabel)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and branches to @p
+ *    aLabel if the status is unsuccessful.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aStatus does not evaluate to zero
+ *                          (0).
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS
+ *  @sa #nlREQUIRE_SUCCESS
+ *
+ */
+#define nlDESIRE_SUCCESS(aStatus, aLabel)                                       __nlEXPECT_SUCCESS(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS, aStatus, aLabel)
+
+/**
+ *  @def nlDESIRE_SUCCESS_PRINT(aStatus, aLabel, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and both prints @p
+ *    aMessage and then branches to @p aLabel if the status is
+ *    unsuccessful.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aStatus does not evaluate to zero
+ *                          (0).
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS_PRINT
+ *  @sa #nlREQUIRE_SUCCESS_PRINT
+ *
+ */
+#define nlDESIRE_SUCCESS_PRINT(aStatus, aLabel, aMessage)                       __nlEXPECT_SUCCESS_PRINT(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS, aStatus, aLabel, aMessage)
+
+/**
+ *  @def nlDESIRE_SUCCESS_ACTION(aStatus, aLabel, anAction)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and both executes @p
+ *    anAction and branches to @p aLabel if the status is
+ *    unsuccessful.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aStatus does not evaluate to zero
+ *                          (0).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS_ACTION
+ *  @sa #nlREQUIRE_SUCCESS_ACTION
+ *
+ */
+#define nlDESIRE_SUCCESS_ACTION(aStatus, aLabel, anAction)                      __nlEXPECT_SUCCESS_ACTION(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS, aStatus, aLabel, anAction)
+
+/**
+ *  @def nlDESIRE_SUCCESS_ACTION_PRINT(aStatus, aLabel, anAction, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), prints @p aMessage,
+ *    executes @p anAction, and branches to @p aLabel if the status is
+ *    unsuccessful.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aStatus does not evaluate to zero
+ *                          (0).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS_ACTION_PRINT
+ *  @sa #nlREQUIRE_SUCCESS_ACTION_PRINT
+ *
+ */
+#define nlDESIRE_SUCCESS_ACTION_PRINT(aStatus, aLabel, anAction, aMessage)      __nlEXPECT_SUCCESS_ACTION_PRINT(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS, aStatus, aLabel, anAction, aMessage)
+
+/**
+ *  @def nlNDESIRE(aCondition, aLabel)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and branches to @p aLabel if the condition is
+ *    true.
+ *
+ *  @note This is the logical inverse of #nlDESIRE.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlDESIRE
+ *  @sa #nlNEXPECT
+ *  @sa #nlNREQUIRE
+ *
+ */
+#define nlNDESIRE(aCondition, aLabel)                                           __nlNEXPECT(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS, aCondition, aLabel)
+
+/**
+ *  @def nlNDESIRE_PRINT(aCondition, aLabel, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and both prints @p aMessage and then branches
+ *    to @p aLabel if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlDESIRE_PRINT.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlDESIRE_PRINT
+ *  @sa #nlNEXPECT_PRINT
+ *  @sa #nlNREQUIRE_PRINT
+ *
+ */
+#define nlNDESIRE_PRINT(aCondition, aLabel, aMessage)                           __nlNEXPECT_PRINT(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS, aCondition, aLabel, aMessage)
+
+/**
+ *  @def nlNDESIRE_ACTION(aCondition, aLabel, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and both executes @p anAction and branches to
+ *    @p aLabel if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlDESIRE_ACTION.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlDESIRE_ACTION
+ *  @sa #nlNEXPECT_ACTION
+ *  @sa #nlNREQUIRE_ACTION
+ *
+ */
+#define nlNDESIRE_ACTION(aCondition, aLabel, anAction)                          __nlNEXPECT_ACTION(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS, aCondition, aLabel, anAction)
+
+/**
+ *  @def nlNDESIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, prints @p aMessage, executes @p anAction, and
+ *    branches to @p aLabel if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlDESIRE_ACTION_PRINT.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlDESIRE_ACTION_PRINT
+ *  @sa #nlNEXPECT_ACTION_PRINT
+ *  @sa #nlNREQUIRE_ACTION_PRINT
+ *
+ */
+#define nlNDESIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)          __nlNEXPECT_ACTION_PRINT(NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS, aCondition, aLabel, anAction, aMessage)
+
+/**
+ *  @}
+ *
+ */
+
+/**
+ *  @ingroup require-style
+ *
+ *  @{
+ *
+ */
+
+/**
+ *  @def NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for require-style
+ *    exception family assertions when #NL_ASSERT_PRODUCTION is
+ *    disabled.
+ *
+ *  This may be used to override #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ */
+#define NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS_DEFAULT                           (NL_ASSERT_FLAG_BACKTRACE | NL_ASSERT_FLAG_LOG | NL_ASSERT_FLAG_TRAP)
+
+/**
+ *  @def NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags when #NL_ASSERT_PRODUCTION is
+ *    disabled that govern the behavior for require-style exception
+ *    family assertions when the assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS                                   NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS)
+#define NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS                                   (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @def nlREQUIRE(aCondition, aLabel)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and branches to @p aLabel if the condition is
+ *    false.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT
+ *  @sa #nlDESIRE
+ *
+ */
+#define nlREQUIRE(aCondition, aLabel)                                           __nlEXPECT(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS, aCondition, aLabel)
+
+/**
+ *  @def nlREQUIRE_PRINT(aCondition, aLabel, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and both prints @p aMessage and then branches
+ *    to @p aLabel if the condition is false.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_PRINT
+ *  @sa #nlDESIRE_PRINT
+ *
+ */
+#define nlREQUIRE_PRINT(aCondition, aLabel, aMessage)                           __nlEXPECT_PRINT(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS, aCondition, aLabel, aMessage)
+
+/**
+ *  @def nlREQUIRE_ACTION(aCondition, aLabel, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and both executes @p anAction and branches to
+ *    @p aLabel if the condition is false.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_ACTION
+ *  @sa #nlDESIRE_ACTION
+ *
+ */
+#define nlREQUIRE_ACTION(aCondition, aLabel, anAction)                          __nlEXPECT_ACTION(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS, aCondition, aLabel, anAction)
+
+/**
+ *  @def nlREQUIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, prints @p aMessage, executes @p anAction, and
+ *    branches to @p aLabel if the condition is false.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_ACTION_PRINT
+ *  @sa #nlDESIRE_ACTION_PRINT
+ *
+ */
+#define nlREQUIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)          __nlEXPECT_ACTION_PRINT(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS, aCondition, aLabel, anAction, aMessage)
+
+/**
+ *  @def nlREQUIRE_SUCCESS(aStatus, aLabel)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and branches to @p
+ *    aLabel if the status is unsuccessful.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aStatus does not evaluate to zero
+ *                          (0).
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS
+ *  @sa #nlDESIRE_SUCCESS
+ *
+ */
+#define nlREQUIRE_SUCCESS(aStatus, aLabel)                                      __nlEXPECT_SUCCESS(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS, aStatus, aLabel)
+
+/**
+ *  @def nlREQUIRE_SUCCESS_PRINT(aStatus, aLabel, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and both prints @p
+ *    aMessage and then branches to @p aLabel if the status is
+ *    unsuccessful.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aStatus does not evaluate to zero
+ *                          (0).
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS_PRINT
+ *  @sa #nlDESIRE_SUCCESS_PRINT
+ *
+ */
+#define nlREQUIRE_SUCCESS_PRINT(aStatus, aLabel, aMessage)                      __nlEXPECT_SUCCESS_PRINT(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS, aStatus, aLabel, aMessage)
+
+/**
+ *  @def nlREQUIRE_SUCCESS_ACTION(aStatus, aLabel, anAction)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and both executes @p
+ *    anAction and branches to @p aLabel if the status is
+ *    unsuccessful.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aStatus does not evaluate to zero
+ *                          (0).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS_ACTION
+ *  @sa #nlDESIRE_SUCCESS_ACTION
+ *
+ */
+#define nlREQUIRE_SUCCESS_ACTION(aStatus, aLabel, anAction)                     __nlEXPECT_SUCCESS_ACTION(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS, aStatus, aLabel, anAction)
+
+/**
+ *  @def nlREQUIRE_SUCCESS_ACTION_PRINT(aStatus, aLabel, anAction, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), prints @p aMessage,
+ *    executes @p anAction, and branches to @p aLabel if the status is
+ *    unsuccessful.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aStatus does not evaluate to zero
+ *                          (0).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS_ACTION_PRINT
+ *  @sa #nlDESIRE_SUCCESS_ACTION_PRINT
+ *
+ */
+#define nlREQUIRE_SUCCESS_ACTION_PRINT(aStatus, aLabel, anAction, aMessage)     __nlEXPECT_SUCCESS_ACTION_PRINT(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS, aStatus, aLabel, anAction, aMessage)
+
+/**
+ *  @def nlNREQUIRE(aCondition, aLabel)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and branches to @p aLabel if the condition is
+ *    true.
+ *
+ *  @note This is the logical inverse of #nlREQUIRE.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlREQUIRE
+ *  @sa #nlNEXPECT
+ *  @sa #nlNDESIRE
+ *
+ */
+#define nlNREQUIRE(aCondition, aLabel)                                          __nlNEXPECT(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS, aCondition, aLabel)
+
+/**
+ *  @def nlNREQUIRE_PRINT(aCondition, aLabel, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and both prints @p aMessage and then branches
+ *    to @p aLabel if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlREQUIRE_PRINT.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlREQUIRE_PRINT
+ *  @sa #nlNEXPECT_PRINT
+ *  @sa #nlNDESIRE_PRINT
+ *
+ */
+#define nlNREQUIRE_PRINT(aCondition, aLabel, aMessage)                          __nlNEXPECT_PRINT(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS, aCondition, aLabel, aMessage)
+
+/**
+ *  @def nlNREQUIRE_ACTION(aCondition, aLabel, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and both executes @p anAction and branches to
+ *    @p aLabel if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlREQUIRE_ACTION.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlREQUIRE_ACTION
+ *  @sa #nlNEXPECT_ACTION
+ *  @sa #nlNDESIRE_ACTION
+ *
+ */
+#define nlNREQUIRE_ACTION(aCondition, aLabel, anAction)                         __nlNEXPECT_ACTION(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS, aCondition, aLabel, anAction)
+
+/**
+ *  @def nlNREQUIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, prints @p aMessage, executes @p anAction, and
+ *    branches to @p aLabel if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlREQUIRE_ACTION_PRINT.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #nlREQUIRE_ACTION_PRINT
+ *  @sa #nlNEXPECT_ACTION_PRINT
+ *  @sa #nlNDESIRE_ACTION_PRINT
+ *
+ */
+#define nlNREQUIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)         __nlNEXPECT_ACTION_PRINT(NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS, aCondition, aLabel, anAction, aMessage)
+
+/**
+ *  @}
+ *
+ */
+
+/**
+ *  @ingroup precondition-style
+ *
+ *  @{
+ *
+ */
+
+/**
+ *  @def NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for precondition-style
+ *    exception family assertions when #NL_ASSERT_PRODUCTION is
+ *    disabled.
+ *
+ *  This may be used to override #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ */
+#define NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS_DEFAULT                      (NL_ASSERT_FLAG_BACKTRACE | NL_ASSERT_FLAG_LOG | NL_ASSERT_FLAG_TRAP)
+
+/**
+ *  @def NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags when #NL_ASSERT_PRODUCTION is
+ *    disabled that govern the behavior for precondition-style exception
+ *    family assertions when the assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS                              NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS)
+#define NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS                              (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @def nlPRECONDITION(aCondition)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and returns from the enclosing function if the
+ *    condition is false.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT
+ *  @sa #nlDESIRE
+ *  @sa #nlREQUIRE
+ *
+ */
+#define nlPRECONDITION(aCondition)                                              __nlPRECONDITION(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aCondition, return)
+
+/**
+ *  @def nlPRECONDITION_ACTION(aCondition, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and both executes @p anAction and returns from
+ *    the enclosing function if the condition is false.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_ACTION
+ *  @sa #nlDESIRE_ACTION
+ *  @sa #nlREQUIRE_ACTION
+ *
+ */
+#define nlPRECONDITION_ACTION(aCondition, anAction)                             __nlPRECONDITION_ACTION(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aCondition, return, anAction)
+
+/**
+ *  @def nlPRECONDITION_PRINT(aCondition, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and both prints @p aMessage and then returns
+ *    from the enclosing function if the condition is false.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_PRINT
+ *  @sa #nlDESIRE_PRINT
+ *  @sa #nlREQUIRE_PRINT
+ *
+ */
+#define nlPRECONDITION_PRINT(aCondition, aMessage)                              __nlPRECONDITION_PRINT(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aCondition, return, aMessage)
+
+/**
+ *  @def nlPRECONDITION_SUCCESS(aStatus)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and returns from the
+ *    enclosing function if the status is unsuccessful.
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS
+ *  @sa #nlDESIRE_SUCCESS
+ *  @sa #nlREQUIRE_SUCCESS
+ *
+ */
+#define nlPRECONDITION_SUCCESS(aStatus)                                         __nlPRECONDITION_SUCCESS(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aStatus, return)
+
+/**
+ *  @def nlPRECONDITION_SUCCESS_ACTION(aStatus, anAction)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and both executes @p
+ *    anAction and returns from the enclosing function if the status
+ *    is unsuccessful.
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS_ACTION
+ *  @sa #nlDESIRE_SUCCESS_ACTION
+ *  @sa #nlREQUIRE_SUCCESS_ACTION
+ *
+ */
+#define nlPRECONDITION_SUCCESS_ACTION(aStatus, anAction)                        __nlPRECONDITION_SUCCESS_ACTION(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aStatus, return, anAction)
+
+/**
+ *  @def nlPRECONDITION_SUCCESS_PRINT(aStatus, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and both prints @p
+ *    aMessage and then returns from the enclosing function if the
+ *    status is unsuccessful.
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS_PRINT
+ *  @sa #nlDESIRE_SUCCESS_PRINT
+ *  @sa #nlREQUIRE_SUCCESS_PRINT
+ *
+ */
+#define nlPRECONDITION_SUCCESS_PRINT(aStatus, aMessage)                         __nlPRECONDITION_SUCCESS_PRINT(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aStatus, return, aMessage)
+
+/**
+ *  @def nlNPRECONDITION(aCondition)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and returns from the enclosing function if
+ *    the condition is true.
+ *
+ *  @note This is the logical inverse of #nlPRECONDITION.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlPRECONDITION
+ *
+ *  @sa #nlNEXPECT
+ *  @sa #nlNDESIRE
+ *  @sa #nlNREQUIRE
+ *
+ */
+#define nlNPRECONDITION(aCondition)                                             __nlNPRECONDITION(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aCondition, return)
+
+/**
+ *  @def nlNPRECONDITION_ACTION(aCondition, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and both executes @p anAction and returns from
+ *    the enclosing function if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlPRECONDITION_ACTION.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlPRECONDITION_ACTION
+ *
+ *  @sa #nlNEXPECT_ACTION
+ *  @sa #nlNDESIRE_ACTION
+ *  @sa #nlNREQUIRE_ACTION
+ *
+ */
+#define nlNPRECONDITION_ACTION(aCondition, anAction)                            __nlNPRECONDITION_ACTION(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aCondition, return, anAction)
+
+/**
+ *  @def nlNPRECONDITION_PRINT(aCondition, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and both prints @p aMessage and then returns
+ *    from the enclosing function if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlPRECONDITION_PRINT.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlPRECONDITION_PRINT
+ *
+ *  @sa #nlNEXPECT_PRINT
+ *  @sa #nlNDESIRE_PRINT
+ *  @sa #nlNREQUIRE_PRINT
+ *
+ */
+#define nlNPRECONDITION_PRINT(aCondition, aMessage)                             __nlNPRECONDITION_PRINT(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aCondition, return, aMessage)
+
+/**
+ *  @def nlPRECONDITION_VALUE(aCondition, aValue)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and returns @p aValue from the enclosing
+ *    function if the condition is false.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aValue      The value to be returned when the assertion
+ *                          fails.
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT
+ *  @sa #nlDESIRE
+ *  @sa #nlREQUIRE
+ *
+ */
+#define nlPRECONDITION_VALUE(aCondition, aValue)                                __nlPRECONDITION(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aCondition, return aValue)
+
+/**
+ *  @def nlPRECONDITION_VALUE_ACTION(aCondition, aValue, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and both executes @p anAction and returns @p
+ *    aValue from the enclosing function if the condition is false.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aValue      The value to be returned when the assertion
+ *                          fails.
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_ACTION
+ *  @sa #nlDESIRE_ACTION
+ *  @sa #nlREQUIRE_ACTION
+ *
+ */
+#define nlPRECONDITION_VALUE_ACTION(aCondition, aValue, anAction)               __nlPRECONDITION_ACTION(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aCondition, return aValue, anAction)
+
+/**
+ *  @def nlPRECONDITION_VALUE_PRINT(aCondition, aValue, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and both prints @p aMessage and then returns
+ *    @p aValue from the enclosing function if the condition is false.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aValue      The value to be returned when the assertion
+ *                          fails.
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_PRINT
+ *  @sa #nlDESIRE_PRINT
+ *  @sa #nlREQUIRE_PRINT
+ *
+ */
+#define nlPRECONDITION_VALUE_PRINT(aCondition, aValue, aMessage)                __nlPRECONDITION_PRINT(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aCondition, return aValue, aMessage)
+
+/**
+ *  @def nlPRECONDITION_VALUE_SUCCESS(aStatus, aValue)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and returns @p aValue
+ *    from the enclosing function if the status is unsuccessful.
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aValue      The value to be returned when the assertion
+ *                          fails.
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS
+ *  @sa #nlDESIRE_SUCCESS
+ *  @sa #nlREQUIRE_SUCCESS
+ *
+ */
+#define nlPRECONDITION_VALUE_SUCCESS(aStatus, aValue)                           __nlPRECONDITION_SUCCESS(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aStatus, return aValue)
+
+/**
+ *  @def nlPRECONDITION_VALUE_SUCCESS_ACTION(aStatus, aValue, anAction)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and both executes @p
+ *    anAction and returns @p aValue from the enclosing function if
+ *    the status is unsuccessful.
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aValue      The value to be returned when the assertion
+ *                          fails.
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS_ACTION
+ *  @sa #nlDESIRE_SUCCESS_ACTION
+ *  @sa #nlREQUIRE_SUCCESS_ACTION
+ *
+ */
+#define nlPRECONDITION_VALUE_SUCCESS_ACTION(aStatus, aValue, anAction)          __nlPRECONDITION_SUCCESS_ACTION(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aStatus, return aValue, anAction)
+
+/**
+ *  @def nlPRECONDITION_VALUE_SUCCESS_PRINT(aStatus, aValue, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and both prints @p
+ *    aMessage and then returns @p aValue from the enclosing function
+ *    if the status is unsuccessful.
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aValue      The value to be returned when the assertion
+ *                          fails.
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlEXPECT_SUCCESS_PRINT
+ *  @sa #nlDESIRE_SUCCESS_PRINT
+ *  @sa #nlREQUIRE_SUCCESS_PRINT
+ *
+ */
+#define nlPRECONDITION_VALUE_SUCCESS_PRINT(aStatus, aValue, aMessage)           __nlPRECONDITION_SUCCESS_PRINT(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aStatus, return aValue, aMessage)
+
+/**
+ *  @def nlNPRECONDITION_VALUE(aCondition, aValue)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and returns @p aValue from the enclosing
+ *    function if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlPRECONDITION_VALUE.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aValue      The value to be returned when the assertion
+ *                          fails.
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlPRECONDITION_VALUE
+ *
+ *  @sa #nlNEXPECT
+ *  @sa #nlNDESIRE
+ *  @sa #nlNREQUIRE
+ *
+ */
+#define nlNPRECONDITION_VALUE(aCondition, aValue)                               __nlNPRECONDITION(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aCondition, return aValue)
+
+/**
+ *  @def nlNPRECONDITION_VALUE_ACTION(aCondition, aValue, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and both executes @p anAction and returns @p
+ *    aValue from the enclosing function if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlPRECONDITION_VALUE_ACTION.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aValue      The value to be returned when the assertion
+ *                          fails.
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlPRECONDITION_VALUE_ACTION
+ *
+ *  @sa #nlNEXPECT_ACTION
+ *  @sa #nlNDESIRE_ACTION
+ *  @sa #nlNREQUIRE_ACTION
+ *
+ */
+#define nlNPRECONDITION_VALUE_ACTION(aCondition, aValue, anAction)              __nlNPRECONDITION_ACTION(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aCondition, return aValue, anAction)
+
+/**
+ *  @def nlNPRECONDITION_VALUE_PRINT(aCondition, aValue, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and both prints @p aMessage and then returns
+ *    @p aValue from the enclosing function if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlPRECONDITION_VALUE_PRINT.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aValue      The value to be returned when the assertion
+ *                          fails.
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #nlPRECONDITION_VALUE_PRINT
+ *
+ *  @sa #nlNEXPECT_PRINT
+ *  @sa #nlNDESIRE_PRINT
+ *  @sa #nlNREQUIRE_PRINT
+ *
+ */
+#define nlNPRECONDITION_VALUE_PRINT(aCondition, aValue, aMessage)               __nlNPRECONDITION_PRINT(NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS, aCondition, return aValue, aMessage)
+
+/**
+ *  @}
+ *
+ */
+
+/**
+ *  @ingroup assert-style
+ *
+ *  @{
+ *
+ */
+
+/**
+ *  @def NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for assert-style
+ *    exception family assertions when #NL_ASSERT_PRODUCTION is
+ *    disabled.
+ *
+ *  This may be used to override #NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ */
+#define NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS_DEFAULT                            (NL_ASSERT_FLAG_BACKTRACE | NL_ASSERT_FLAG_LOG)
+
+/**
+ *  @def NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags when #NL_ASSERT_PRODUCTION is
+ *    disabled that govern the behavior for assert-style exception
+ *    family assertions when the assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS                                     NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS)
+#define NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS                                    (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @def nlASSERT(aCondition)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true and takes action, based on configuration, and
+ *    invokes #NL_ASSERT_ABORT() if the condition is false.
+ *
+ *  @note If #NL_ASSERT_PRODUCTION is true, the check is made inactive. But
+ *  side-effects, if any, in the asserted expression will still be produced.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *
+ *  @sa #NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK
+ *  @sa #nlVERIFY
+ *  @sa #nlABORT
+ *
+ */
+#define nlASSERT(aCondition)                                                    __nlABORT(NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS, aCondition)
+
+/**
+ *  @def nlASSERT_ACTION(aCondition, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true and takes action, based on configuration, and
+ *    both executes @p anAction and then invokes #NL_ASSERT_ABORT() if
+ *    the condition is false.
+ *
+ *  @note If #NL_ASSERT_PRODUCTION is true, the check is made inactive. But
+ *  side-effects, if any, in the asserted expression will still be produced.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK_ACTION
+ *  @sa #nlVERIFY_ACTION
+ *  @sa #nlABORT_ACTION
+ *
+ */
+#define nlASSERT_ACTION(aCondition, anAction)                                   __nlABORT_ACTION(NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS, aCondition, anAction)
+
+/**
+ *  @}
+ *
+ */
+
+/**
+ *  @ingroup abort-style
+ *
+ *  @{
+ *
+ */
+
+/**
+ *  @def NL_ASSERT_ABORT_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for abort-style
+ *    exception family assertions when #NL_ASSERT_PRODUCTION is
+ *    disabled.
+ *
+ *  This may be used to override #NL_ASSERT_ABORT_NONPRODUCTION_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_ABORT_NONPRODUCTION_FLAGS NL_ASSERT_ABORT_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_ABORT_NONPRODUCTION_FLAGS
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ */
+#define NL_ASSERT_ABORT_NONPRODUCTION_FLAGS_DEFAULT                             (NL_ASSERT_FLAG_BACKTRACE | NL_ASSERT_FLAG_LOG)
+
+/**
+ *  @def NL_ASSERT_ABORT_NONPRODUCTION_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags when #NL_ASSERT_PRODUCTION is
+ *    disabled that govern the behavior for abort-style exception
+ *    family assertions when the assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_ABORT_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_ABORT_NONPRODUCTION_FLAGS                                     NL_ASSERT_ABORT_NONPRODUCTION_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_ABORT_NONPRODUCTION_FLAGS)
+#define NL_ASSERT_ABORT_NONPRODUCTION_FLAGS                                     (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @def nlABORT(aCondition)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true and takes action, based on configuration, and
+ *    invokes #NL_ASSERT_ABORT() if the condition is false.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *
+ *  @sa #NL_ASSERT_ABORT_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_ABORT_PRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK
+ *  @sa #nlVERIFY
+ *  @sa #nlASSERT
+ *
+ */
+#define nlABORT(aCondition)                                                     __nlABORT(NL_ASSERT_ABORT_NONPRODUCTION_FLAGS, aCondition)
+
+/**
+ *  @def nlABORT_ACTION(aCondition, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true and takes action, based on configuration, and
+ *    both executes @p anAction and then invokes #NL_ASSERT_ABORT() if
+ *    the condition is false.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_ABORT_NONPRODUCTION_FLAGS
+ *  @sa #NL_ASSERT_ABORT_PRODUCTION_FLAGS
+ *
+ *  @sa #nlCHECK_ACTION
+ *  @sa #nlVERIFY_ACTION
+ *  @sa #nlASSERT_ACTION
+ *
+ */
+#define nlABORT_ACTION(aCondition, anAction)                                    __nlABORT_ACTION(NL_ASSERT_ABORT_NONPRODUCTION_FLAGS, aCondition, anAction)
+
+/**
+ *  @}
+ *
+ */
+
+#endif /* NLCORE_NLASSERT_NONPRODUCTION_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/nlassert-production.h b/cores/nRF5/nordic/config/nrf52840/configxx/nlassert-production.h
new file mode 100644
index 000000000..43ad869c7
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/nlassert-production.h
@@ -0,0 +1,713 @@
+/*
+ *   Copyright 2010-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *   Licensed under the Apache License, Version 2.0 (the "License");
+ *   you may not use this file except in compliance with the License.
+ *   You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *   Unless required by applicable law or agreed to in writing, software
+ *   distributed under the License is distributed on an "AS IS" BASIS,
+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *   See the License for the specific language governing permissions and
+ *   limitations under the License.
+ *
+ */
+
+/**
+ *    @file
+ *      This file defines macros and interfaces for performing
+ *      compile- and run-time assertion checking and run-time
+ *      exception handling when #NL_ASSERT_PRODUCTION is true.
+ *
+ */
+
+#ifndef NLASSERT_PRODUCTION_H
+#define NLASSERT_PRODUCTION_H
+
+#include "nlassert-internal.h"
+
+// nlCHECK
+
+/**
+ *  @implements nlCHECK(aCondition)
+ *
+ */
+#define nlCHECK(aCondition)                                                     __nlASSERT_UNUSED(aCondition)
+
+/**
+ *  @implements nlCHECK_ACTION(aCondition, anAction)
+ *
+ */
+#define nlCHECK_ACTION(aCondition, anAction)                                    __nlASSERT_UNUSED(aCondition)
+
+/**
+ *  @implements nlCHECK_PRINT(aCondition, aMessage)
+ *
+ */
+#define nlCHECK_PRINT(aCondition, aMessage)                                     __nlASSERT_UNUSED(aCondition)
+
+/**
+ *  @implements nlCHECK_SUCCESS(aStatus)
+ *
+ */
+#define nlCHECK_SUCCESS(aStatus)                                                __nlASSERT_UNUSED(aStatus)
+
+/**
+ *  @implements nlCHECK_SUCCESS_ACTION(aStatus, anAction)
+ *
+ */
+#define nlCHECK_SUCCESS_ACTION(aStatus, anAction)                               __nlASSERT_UNUSED(aStatus)
+
+/**
+ *  @implements nlCHECK_SUCCESS_PRINT(aStatus, aMessage)
+ *
+ */
+#define nlCHECK_SUCCESS_PRINT(aStatus, aMessage)                                __nlASSERT_UNUSED(aStatus)
+
+/**
+ *  @implements nlNCHECK(aCondition)
+ *
+ */
+#define nlNCHECK(aCondition)                                                    __nlASSERT_UNUSED(aCondition)
+
+/**
+ *  @implements nlNCHECK_ACTION(aCondition, anAction)
+ *
+ */
+#define nlNCHECK_ACTION(aCondition, anAction)                                   __nlASSERT_UNUSED(aCondition)
+
+/**
+ *  @implements nlNCHECK_PRINT(aCondition, aMessage)
+ *
+ */
+#define nlNCHECK_PRINT(aCondition, aMessage)                                    __nlASSERT_UNUSED(aCondition)
+
+// nlVERIFY
+
+/**
+ *  @def NL_ASSERT_VERIFY_PRODUCTION_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for verify-style
+ *    exception family assertions when #NL_ASSERT_PRODUCTION is
+ *    enabled.
+ *
+ *  This may be used to override #NL_ASSERT_VERIFY_PRODUCTION_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_VERIFY_PRODUCTION_FLAGS NL_ASSERT_VERIFY_PRODUCTION_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_VERIFY_PRODUCTION_FLAGS
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ *  @ingroup verify-style
+ *
+ */
+#define NL_ASSERT_VERIFY_PRODUCTION_FLAGS_DEFAULT                               (NL_ASSERT_FLAG_BACKTRACE | NL_ASSERT_FLAG_LOG)
+
+/**
+ *  @def NL_ASSERT_VERIFY_PRODUCTION_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags when #NL_ASSERT_PRODUCTION is
+ *    enabled that govern the behavior for verify-style exception
+ *    family assertions when the assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_VERIFY_PRODUCTION_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ *  @ingroup verify-style
+ *
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_VERIFY_PRODUCTION_FLAGS                                       NL_ASSERT_VERIFY_PRODUCTION_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_VERIFY_PRODUCTION_FLAGS)
+#define NL_ASSERT_VERIFY_PRODUCTION_FLAGS                                       (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @implements nlVERIFY(aCondition)
+ *
+ */
+#define nlVERIFY(aCondition)                                                    __nlVERIFY(NL_ASSERT_VERIFY_PRODUCTION_FLAGS, aCondition)
+
+/**
+ *  @implements nlVERIFY_ACTION(aCondition, anAction)
+ *
+ */
+#define nlVERIFY_ACTION(aCondition, anAction)                                   __nlVERIFY_ACTION(NL_ASSERT_VERIFY_PRODUCTION_FLAGS, aCondition, anAction)
+
+/**
+ *  @implements nlVERIFY_PRINT(aCondition, aMessage)
+ *
+ */
+#define nlVERIFY_PRINT(aCondition, aMessage)                                    __nlVERIFY_PRINT(NL_ASSERT_VERIFY_PRODUCTION_FLAGS, aCondition, aMessage)
+
+/**
+ *  @implements nlVERIFY_SUCCESS(aStatus)
+ *
+ */
+#define nlVERIFY_SUCCESS(aStatus)                                               __nlVERIFY_SUCCESS(NL_ASSERT_VERIFY_PRODUCTION_FLAGS, aStatus)
+
+/**
+ *  @implements nlVERIFY_SUCCESS_ACTION(aStatus, anAction)
+ *
+ */
+#define nlVERIFY_SUCCESS_ACTION(aStatus, anAction)                              __nlVERIFY_SUCCESS_ACTION(NL_ASSERT_VERIFY_PRODUCTION_FLAGS, aStatus, anAction)
+
+/**
+ *  @implements nlVERIFY_SUCCESS_PRINT(aStatus, aMessage)
+ *
+ */
+#define nlVERIFY_SUCCESS_PRINT(aStatus, aMessage)                               __nlVERIFY_SUCCESS_PRINT(NL_ASSERT_VERIFY_PRODUCTION_FLAGS, aStatus, aMessage)
+
+/**
+ *  @implements nlNVERIFY(aCondition)
+ *
+ */
+#define nlNVERIFY(aCondition)                                                   __nlNVERIFY(NL_ASSERT_VERIFY_PRODUCTION_FLAGS, aCondition)
+
+/**
+ *  @implements nlNVERIFY_ACTION(aCondition, anAction)
+ *
+ */
+#define nlNVERIFY_ACTION(aCondition, anAction)                                  __nlNVERIFY_ACTION(NL_ASSERT_VERIFY_PRODUCTION_FLAGS, aCondition, anAction)
+
+/**
+ *  @implements nlNVERIFY_PRINT(aCondition, aMessage)
+ *
+ */
+#define nlNVERIFY_PRINT(aCondition, aMessage)                                   __nlNVERIFY_PRINT(NL_ASSERT_VERIFY_PRODUCTION_FLAGS, aCondition, aMessage)
+
+// nlDESIRE
+
+/**
+ *  @def NL_ASSERT_DESIRE_PRODUCTION_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for desire-style
+ *    exception family assertions when #NL_ASSERT_PRODUCTION is
+ *    enabled.
+ *
+ *  This may be used to override #NL_ASSERT_DESIRE_PRODUCTION_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_DESIRE_PRODUCTION_FLAGS NL_ASSERT_DESIRE_PRODUCTION_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ *  @ingroup desire-style
+ *
+ */
+#define NL_ASSERT_DESIRE_PRODUCTION_FLAGS_DEFAULT                               (NL_ASSERT_FLAG_NONE)
+
+/**
+ *  @def NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags when #NL_ASSERT_PRODUCTION is
+ *    enabled that govern the behavior for desire-style exception
+ *    family assertions when the assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_DESIRE_PRODUCTION_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ *  @ingroup desire-style
+ *
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_DESIRE_PRODUCTION_FLAGS                                       NL_ASSERT_DESIRE_PRODUCTION_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_DESIRE_PRODUCTION_FLAGS)
+#define NL_ASSERT_DESIRE_PRODUCTION_FLAGS                                       (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @implements nlDESIRE(aCondition, aLabel)
+ *
+ */
+#define nlDESIRE(aCondition, aLabel)                                            __nlEXPECT(NL_ASSERT_DESIRE_PRODUCTION_FLAGS, aCondition, aLabel)
+
+/**
+ *  @implements nlDESIRE_PRINT(aCondition, aLabel, aMessage)
+ *
+ */
+#define nlDESIRE_PRINT(aCondition, aLabel, aMessage)                            __nlEXPECT_PRINT(NL_ASSERT_DESIRE_PRODUCTION_FLAGS, aCondition, aLabel, aMessage)
+
+/**
+ *  @implements nlDESIRE_ACTION(aCondition, aLabel, anAction)
+ *
+ */
+#define nlDESIRE_ACTION(aCondition, aLabel, anAction)                           __nlEXPECT_ACTION(NL_ASSERT_DESIRE_PRODUCTION_FLAGS, aCondition, aLabel, anAction)
+
+/**
+ *  @implements nlDESIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)
+ *
+ */
+#define nlDESIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)           __nlEXPECT_ACTION_PRINT(NL_ASSERT_DESIRE_PRODUCTION_FLAGS, aCondition, aLabel, anAction, aMessage)
+
+/**
+ *  @implements nlDESIRE_SUCCESS(aStatus, aLabel)
+ *
+ */
+#define nlDESIRE_SUCCESS(aStatus, aLabel)                                       __nlEXPECT_SUCCESS(NL_ASSERT_DESIRE_PRODUCTION_FLAGS, aStatus, aLabel)
+
+/**
+ *  @implements nlDESIRE_SUCCESS_PRINT(aStatus, aLabel, aMessage)
+ *
+ */
+#define nlDESIRE_SUCCESS_PRINT(aStatus, aLabel, aMessage)                       __nlEXPECT_SUCCESS_PRINT(NL_ASSERT_DESIRE_PRODUCTION_FLAGS, aStatus, aLabel, aMessage)
+
+/**
+ *  @implements nlDESIRE_SUCCESS_ACTION(aStatus, aLabel, anAction)
+ *
+ */
+#define nlDESIRE_SUCCESS_ACTION(aStatus, aLabel, anAction)                      __nlEXPECT_SUCCESS_ACTION(NL_ASSERT_DESIRE_PRODUCTION_FLAGS, aStatus, aLabel, anAction)
+
+/**
+ *  @implements nlDESIRE_SUCCESS_ACTION_PRINT(aStatus, aLabel, anAction, aMessage)
+ *
+ */
+#define nlDESIRE_SUCCESS_ACTION_PRINT(aStatus, aLabel, anAction, aMessage)      __nlEXPECT_SUCCESS_ACTION_PRINT(NL_ASSERT_DESIRE_PRODUCTION_FLAGS, aStatus, aLabel, anAction, aMessage)
+
+/**
+ *  @implements nlNDESIRE(aCondition, aLabel)
+ *
+ */
+#define nlNDESIRE(aCondition, aLabel)                                           __nlNEXPECT(NL_ASSERT_DESIRE_PRODUCTION_FLAGS, aCondition, aLabel)
+
+/**
+ *  @implements nlNDESIRE_PRINT(aCondition, aLabel, aMessage)
+ *
+ */
+#define nlNDESIRE_PRINT(aCondition, aLabel, aMessage)                           __nlNEXPECT_PRINT(NL_ASSERT_DESIRE_PRODUCTION_FLAGS, aCondition, aLabel, aMessage)
+
+/**
+ *  @implements nlNDESIRE_ACTION(aCondition, aLabel, anAction)
+ *
+ */
+#define nlNDESIRE_ACTION(aCondition, aLabel, anAction)                          __nlNEXPECT_ACTION(NL_ASSERT_DESIRE_PRODUCTION_FLAGS, aCondition, aLabel, anAction)
+
+/**
+ *  @implements nlNDESIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)
+ *
+ */
+#define nlNDESIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)          __nlNEXPECT_ACTION_PRINT(NL_ASSERT_DESIRE_PRODUCTION_FLAGS, aCondition, aLabel, anAction, aMessage)
+
+// nlREQUIRE
+
+/**
+ *  @def NL_ASSERT_REQUIRE_PRODUCTION_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for require-style
+ *    exception family assertions when #NL_ASSERT_PRODUCTION is
+ *    enabled.
+ *
+ *  This may be used to override #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_REQUIRE_PRODUCTION_FLAGS NL_ASSERT_REQUIRE_PRODUCTION_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ *  @ingroup require-style
+ *
+ */
+#define NL_ASSERT_REQUIRE_PRODUCTION_FLAGS_DEFAULT                              (NL_ASSERT_FLAG_BACKTRACE | NL_ASSERT_FLAG_LOG)
+
+/**
+ *  @def NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags when #NL_ASSERT_PRODUCTION is
+ *    enabled that govern the behavior for require-style exception
+ *    family assertions when the assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ *  @ingroup require-style
+ *
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_REQUIRE_PRODUCTION_FLAGS                                      NL_ASSERT_REQUIRE_PRODUCTION_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS)
+#define NL_ASSERT_REQUIRE_PRODUCTION_FLAGS                                      (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @implements nlREQUIRE(aCondition, aLabel)
+ *
+ */
+#define nlREQUIRE(aCondition, aLabel)                                           __nlEXPECT(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS, aCondition, aLabel)
+
+/**
+ *  @implements nlREQUIRE_PRINT(aCondition, aLabel, aMessage)
+ */
+#define nlREQUIRE_PRINT(aCondition, aLabel, aMessage)                           __nlEXPECT_PRINT(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS, aCondition, aLabel, aMessage)
+
+/**
+ *  @implements nlREQUIRE_ACTION(aCondition, aLabel, anAction)
+ *
+ */
+#define nlREQUIRE_ACTION(aCondition, aLabel, anAction)                          __nlEXPECT_ACTION(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS, aCondition, aLabel, anAction)
+
+/**
+ *  @implements nlREQUIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)
+ *
+ */
+#define nlREQUIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)          __nlEXPECT_ACTION_PRINT(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS, aCondition, aLabel, anAction, aMessage)
+
+/**
+ *  @implements nlREQUIRE_SUCCESS(aStatus, aLabel)
+ *
+ */
+#define nlREQUIRE_SUCCESS(aStatus, aLabel)                                      __nlEXPECT_SUCCESS(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS, aStatus, aLabel)
+
+/**
+ *  @implements nlREQUIRE_SUCCESS_PRINT(aStatus, aLabel, aMessage)
+ *
+ */
+#define nlREQUIRE_SUCCESS_PRINT(aStatus, aLabel, aMessage)                      __nlEXPECT_SUCCESS_PRINT(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS, aStatus, aLabel, aMessage)
+
+/**
+ *  @implements nlREQUIRE_SUCCESS_ACTION(aStatus, aLabel, anAction)
+ *
+ */
+#define nlREQUIRE_SUCCESS_ACTION(aStatus, aLabel, anAction)                     __nlEXPECT_SUCCESS_ACTION(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS, aStatus, aLabel, anAction)
+
+/**
+ *  @implements nlREQUIRE_SUCCESS_ACTION_PRINT(aStatus, aLabel, anAction, aMessage)
+ *
+ */
+#define nlREQUIRE_SUCCESS_ACTION_PRINT(aStatus, aLabel, anAction, aMessage)     __nlEXPECT_SUCCESS_ACTION_PRINT(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS, aStatus, aLabel, anAction, aMessage)
+
+/**
+ *  @implements nlNREQUIRE(aCondition, aLabel)
+ *
+ */
+#define nlNREQUIRE(aCondition, aLabel)                                          __nlNEXPECT(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS, aCondition, aLabel)
+
+/**
+ *  @implements nlNREQUIRE_PRINT(aCondition, aLabel, aMessage)
+ *
+ */
+#define nlNREQUIRE_PRINT(aCondition, aLabel, aMessage)                          __nlNEXPECT_PRINT(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS, aCondition, aLabel, aMessage)
+
+/**
+ *  @implements nlNREQUIRE_ACTION(aCondition, aLabel, anAction)
+ *
+ */
+#define nlNREQUIRE_ACTION(aCondition, aLabel, anAction)                         __nlNEXPECT_ACTION(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS, aCondition, aLabel, anAction)
+
+/**
+ *  @implements nlNREQUIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)
+ *
+ */
+#define nlNREQUIRE_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)         __nlNEXPECT_ACTION_PRINT(NL_ASSERT_REQUIRE_PRODUCTION_FLAGS, aCondition, aLabel, anAction, aMessage)
+
+// nlPRECONDITION
+
+/**
+ *  @def NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for precondition-style
+ *    exception family assertions when #NL_ASSERT_PRODUCTION is
+ *    enabled.
+ *
+ *  This may be used to override #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ *  @ingroup precondition-style
+ *
+ */
+#define NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS_DEFAULT                         (NL_ASSERT_FLAG_BACKTRACE | NL_ASSERT_FLAG_LOG)
+
+/**
+ *  @def NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags when #NL_ASSERT_PRODUCTION is
+ *    disabled that govern the behavior for precondition-style exception
+ *    family assertions when the assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ *  @ingroup precondition-style
+ *
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS                                 NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS)
+#define NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS                                 (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @implements nlPRECONDITION(aCondition)
+ *
+ */
+#define nlPRECONDITION(aCondition)                                              __nlPRECONDITION(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aCondition, return)
+
+/**
+ *  @implements nlPRECONDITION_ACTION(aCondition, anAction)
+ *
+ */
+#define nlPRECONDITION_ACTION(aCondition, anAction)                             __nlPRECONDITION_ACTION(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aCondition, return, anAction)
+
+/**
+ *  @implements nlPRECONDITION_PRINT(aCondition, aMessage)
+ *
+ */
+#define nlPRECONDITION_PRINT(aCondition, aMessage)                              __nlPRECONDITION_PRINT(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aCondition, return, aMessage)
+
+/**
+ *  @implements nlPRECONDITION_SUCCESS(aStatus)
+ *
+ */
+#define nlPRECONDITION_SUCCESS(aStatus)                                         __nlPRECONDITION_SUCCESS(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aStatus, return)
+
+/**
+ *  @implements nlPRECONDITION_SUCCESS_ACTION(aStatus, anAction)
+ *
+ */
+#define nlPRECONDITION_SUCCESS_ACTION(aStatus, anAction)                        __nlPRECONDITION_SUCCESS_ACTION(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aStatus, return, anAction)
+
+/**
+ *  @implements nlPRECONDITION_SUCCESS_PRINT(aStatus, aMessage)
+ *
+ */
+#define nlPRECONDITION_SUCCESS_PRINT(aStatus, aMessage)                         __nlPRECONDITION_SUCCESS_PRINT(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aStatus, return, aMessage)
+
+/**
+ *  @implements nlNPRECONDITION(aCondition)
+ *
+ */
+#define nlNPRECONDITION(aCondition)                                             __nlNPRECONDITION(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aCondition, return)
+
+/**
+ *  @implements nlNPRECONDITION_ACTION(aCondition, anAction)
+ *
+ */
+#define nlNPRECONDITION_ACTION(aCondition, anAction)                            __nlNPRECONDITION_ACTION(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aCondition, return, anAction)
+
+/**
+ *  @implements nlNPRECONDITION_PRINT(aCondition, aMessage)
+ *
+ */
+#define nlNPRECONDITION_PRINT(aCondition, aMessage)                             __nlNPRECONDITION_PRINT(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aCondition, return, aMessage)
+
+/**
+ *  @implements nlPRECONDITION_VALUE(aCondition, aValue)
+ *
+ */
+#define nlPRECONDITION_VALUE(aCondition, aValue)                                __nlPRECONDITION(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aCondition, return aValue)
+
+/**
+ *  @implements nlPRECONDITION_VALUE_ACTION(aCondition, aValue, anAction)
+ *
+ */
+#define nlPRECONDITION_VALUE_ACTION(aCondition, aValue, anAction)               __nlPRECONDITION_ACTION(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aCondition, return aValue, anAction)
+
+/**
+ *  @implements nlPRECONDITION_VALUE_PRINT(aCondition, aValue, aMessage)
+ *
+ */
+#define nlPRECONDITION_VALUE_PRINT(aCondition, aValue, aMessage)                __nlPRECONDITION_PRINT(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aCondition, return aValue, aMessage)
+
+/**
+ *  @implements nlPRECONDITION_VALUE_SUCCESS(aStatus, aValue)
+ *
+ */
+#define nlPRECONDITION_VALUE_SUCCESS(aStatus, aValue)                           __nlPRECONDITION_SUCCESS(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aStatus, return aValue)
+
+/**
+ *  @implements nlPRECONDITION_VALUE_SUCCESS_ACTION(aStatus, aValue, anAction)
+ *
+ */
+#define nlPRECONDITION_VALUE_SUCCESS_ACTION(aStatus, aValue, anAction)          __nlPRECONDITION_SUCCESS_ACTION(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aStatus, return aValue, anAction)
+
+/**
+ *  @implements nlPRECONDITION_VALUE_SUCCESS_PRINT(aStatus, aValue, aMessage)
+ *
+ */
+#define nlPRECONDITION_VALUE_SUCCESS_PRINT(aStatus, aValue, aMessage)           __nlPRECONDITION_SUCCESS_PRINT(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aStatus, return aValue, aMessage)
+
+/**
+ *  @implements nlNPRECONDITION_VALUE(aCondition, aValue)
+ *
+ */
+#define nlNPRECONDITION_VALUE(aCondition, aValue)                               __nlNPRECONDITION(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aCondition, return aValue)
+
+/**
+ *  @implements nlNPRECONDITION_VALUE_ACTION(aCondition, aValue, anAction)
+ *
+ */
+#define nlNPRECONDITION_VALUE_ACTION(aCondition, aValue, anAction)              __nlNPRECONDITION_ACTION(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aCondition, return aValue, anAction)
+
+/**
+ *  @implements nlNPRECONDITION_VALUE_PRINT(aCondition, aValue, aMessage)
+ *
+ */
+#define nlNPRECONDITION_VALUE_PRINT(aCondition, aValue, aMessage)               __nlNPRECONDITION_PRINT(NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS, aCondition, return aValue, aMessage)
+
+// nlASSERT
+
+/**
+ *  @implements nlASSERT(aCondition)
+ *
+ */
+#define nlASSERT(aCondition)                                                    __nlASSERT_UNUSED(aCondition)
+
+/**
+ *  @implements nlASSERT_ACTION(aCondition, anAction)
+ *
+ */
+#define nlASSERT_ACTION(aCondition, anAction)                                   __nlASSERT_UNUSED(aCondition)
+
+// nlABORT
+
+/**
+ *  @def NL_ASSERT_ABORT_PRODUCTION_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for abort-style
+ *    exception family assertions when #NL_ASSERT_PRODUCTION is
+ *    enabled.
+ *
+ *  This may be used to override #NL_ASSERT_ABORT_PRODUCTION_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_ABORT_PRODUCTION_FLAGS NL_ASSERT_ABORT_PRODUCTION_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_ABORT_PRODUCTION_FLAGS
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ *  @ingroup abort-style
+ *
+ */
+#define NL_ASSERT_ABORT_PRODUCTION_FLAGS_DEFAULT                                (NL_ASSERT_FLAG_BACKTRACE | NL_ASSERT_FLAG_LOG)
+
+/**
+ *  @def NL_ASSERT_ABORT_PRODUCTION_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags when #NL_ASSERT_PRODUCTION is
+ *    enabled that govern the behavior for abort-style exception
+ *    family assertions when the assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_ABORT_PRODUCTION_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_PRODUCTION
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ *  @ingroup abort-style
+ *
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_ABORT_PRODUCTION_FLAGS                                        NL_ASSERT_ABORT_PRODUCTION_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_ABORT_PRODUCTION_FLAGS)
+#define NL_ASSERT_ABORT_PRODUCTION_FLAGS                                        (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @implements nlABORT(aCondition)
+ *
+ */
+#define nlABORT(aCondition)                                                     __nlABORT(NL_ASSERT_ABORT_PRODUCTION_FLAGS, aCondition)
+
+/**
+ *  @implements nlABORT_ACTION(aCondition, anAction)
+ *
+ */
+#define nlABORT_ACTION(aCondition, anAction)                                    __nlABORT_ACTION(NL_ASSERT_ABORT_PRODUCTION_FLAGS, aCondition, anAction)
+
+#endif /* NLASSERT_PRODUCTION_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/nlassert.h b/cores/nRF5/nordic/config/nrf52840/configxx/nlassert.h
new file mode 100644
index 000000000..8ba0d1fa0
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/nlassert.h
@@ -0,0 +1,1728 @@
+/*
+ *   Copyright 2010-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *   Licensed under the Apache License, Version 2.0 (the "License");
+ *   you may not use this file except in compliance with the License.
+ *   You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *   Unless required by applicable law or agreed to in writing, software
+ *   distributed under the License is distributed on an "AS IS" BASIS,
+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *   See the License for the specific language governing permissions and
+ *   limitations under the License.
+ *
+ */
+
+/**
+ *    @file
+ *      This file defines macros and interfaces for performing both
+ *      compile- and run-time assertion checking and run-time
+ *      exception handling.
+ *
+ *      Where exception-handing is concerned, the format of the macros
+ *      are inspired by those found in Mac OS Classic and, later, Mac
+ *      OS X. These, in turn, were inspired by "Living In an
+ *      Exceptional World" by Sean Parent (develop, The Apple
+ *      Technical Journal, Issue 11, August/September 1992)
+ *      <http://www.mactech.com/articles/develop/issue_11/Parent_final.html>
+ *      for the methodology behind these error handling and assertion
+ *      macros.
+ *
+ */
+
+/**
+ *  @mainpage notitle
+ *
+ *  @section introduction Introduction
+ *
+ *  This package defines macros and interfaces for performing both
+ *  compile- and run-time assertion checking and run-time exception
+ *  handling.
+ *
+ *  Where exception-handing is concerned, the format of the macros are
+ *  inspired by those found in Mac OS Classic and, later, Mac OS
+ *  X. These, in turn, were inspired by "Living In an Exceptional
+ *  World" by Sean Parent (develop, The Apple Technical Journal, Issue
+ *  11, August/September 1992). See:
+ *
+ *    http://www.mactech.com/articles/develop/issue_11/Parent_final.html
+ *
+ *  for the methodology behind these error handling and assertion
+ *  macros.
+ *
+ *  @section overview Overview
+ *
+ *  The interfaces in this package come in two interface modalities:
+ *
+ *  <dl>
+ *     <dt>[Run-time](@ref run-time)</dt>
+ *         <dd>Interfaces that dynamically check a logical assertion and
+ *             alter run-time execution on assertion firing.</dd>
+ *     <dt>[Compile-time](@ref compile-time)</dt>
+ *         <dd>Interfaces that statically check a logical assertion and
+ *             terminate compile-time execution on assertion firing.</dd>
+ *  </dl>
+ *
+ *  @subsection run-time Run-time
+ *
+ *  The [run-time modality interfaces](@ref run-time-interfaces) in
+ *  this package come in three families:
+ *
+ *  <dl>
+ *      <dt>[Assertion](@ref run-time-assertions)</dt>
+ *          <dd>Similar to the traditional C Standard Library
+ *          [assert()](http://pubs.opengroup.org/onlinepubs/009695399/functions/assert.html).</dd>
+ *
+ *      <dt>[Precondition](@ref preconditions)</dt>
+ *          <dd>Designed to be placed at the head of an interface or
+ *          method to check incoming parameters and return on
+ *          assertion failure.</dd>
+ *
+ *      <dt>[Exception](@ref exceptions)</dt>
+ *          <dd>Designed to jump to a local label on assertion failure
+ *          to support the method of error and exception handling that
+ *          advocates a single function or method return site and, by
+ *          extension, consolidated points of exception and error
+ *          handling as well as resource clean-up.</dd>
+ *  </dl>
+ *
+ *  There are several styles of interfaces within each family and
+ *  several potential variants within each style, all of which are
+ *  summarized below and are described in detail in the following
+ *  sections.
+ *
+ *  @subsection compile-time Compile-time
+ *
+ *  The [compile-time modality interfaces](@ref compile-time-interfaces)
+ *  in this package are simpler and come in a single family with a
+ *  couple of variants.
+ *
+ *  @section run-time-interfaces Run-time Interfaces
+ *
+ *  @subsection triggers Behavior Triggers
+ *
+ *  Unlike the traditional C Standard Library
+ *  [assert()](http://pubs.opengroup.org/onlinepubs/009695399/functions/assert.html)
+ *  or other assertion checking packages, this package offers the
+ *  ability to enable and customize one or more of a few triggers that
+ *  run when an assertion fires, including:
+ *
+ *     * [Abort](@ref abort-behavior)
+ *     * [Backtrace](@ref backtrace-behavior)
+ *     * [Log](@ref log-behavior)
+ *     * [Trap](@ref trap-behavior)
+ *
+ *  @subsubsection abort-behavior Abort
+ *
+ *  The abort behavior trigger allows, on an assertion firing, to
+ *  execute a trigger that terminates overall program or system
+ *  execution.
+ *
+ *  Note, however, the abort behavior trigger is only available in
+ *  some styles of the [assertion-family](@ref run-time-assertions) of
+ *  interfaces.
+ *
+ *  Please see #NL_ASSERT_ABORT() and @ref customization for more
+ *  information about this behavior trigger.
+ *
+ *  @subsubsection backtrace-behavior Backtrace
+ *
+ *  The backtrace behavior trigger allows, on an assertion firing, to
+ *  execute a trigger that generates a stack backtrace.
+ *
+ *  This style of assertion is available, when configured, on all
+ *  interface families.
+ *
+ *  Please see #NL_ASSERT_BACKTRACE() and @ref customization for more
+ *  information about this behavior trigger.
+ *
+ *  @subsubsection log-behavior Log
+ *
+ *  The log behavior trigger allows, on an assertion firing, to
+ *  execute a trigger that logs a message summarizing the assertion
+ *  that fired.
+ *
+ *  This style of assertion is available, when configured, on all
+ *  interface families.
+ *
+ *  Please see #NL_ASSERT_LOG() and @ref customization for more
+ *  information about this behavior trigger.
+ *
+ *  @subsubsection trap-behavior Trap
+ *
+ *  The log behavior trigger allows, on an assertion firing, to
+ *  execute a trigger that generates a debugger trap or exception.
+ *
+ *  This style of assertion is available, when configured, on all
+ *  interface families.
+ *
+ *  Please see #NL_ASSERT_TRAP() and @ref customization for more
+ *  information about this behavior trigger.
+ *
+ *  @subsection run-time-assertions Assertion Interfaces
+ *
+ *  The assertion interfaces are similar to the traditional C
+ *  Standard Library
+ *  [assert()](http://pubs.opengroup.org/onlinepubs/009695399/functions/assert.html).
+ *
+ *  These interfaces include the following styles:
+ *
+ *    * [Assert](@ref run-time-assert)
+ *    * [Abort](@ref run-time-abort)
+ *    * [Check](@ref run-time-check)
+ *    * [Verify](@ref run-time-verify)
+ *
+ *  The following table summarizes the relationship and features among
+ *  the styles:
+
+ *  <table>
+ *      <tr>
+ *          <th rowspan="2">Style</th>
+ *          <th colspan="4">Behaviors</th>
+ *          <th colspan="2">Availability</th>
+ *      </tr>
+ *      <tr>
+ *          <th>Abort</th>
+ *          <th>Backtrace</th>
+ *          <th>Log</th>
+ *          <th>Trap</th>
+ *          <th>Non-production</th>
+ *          <th>Production</th>
+ *      </tr>
+ *      <tr>
+ *          <td>Assert</td>
+ *          <td align="center">Non-production</td>
+ *          <td align="center">Non-production</td>
+ *          <td align="center">Non-production</td>
+ *          <td align="center"></td>
+ *          <td align="center">X</td>
+ *          <td align="center"></td>
+ *      </tr>
+ *      <tr>
+ *          <td>Abort</td>
+ *          <td align="center">X</td>
+ *          <td align="center">X</td>
+ *          <td align="center">X</td>
+ *          <td align="center"></td>
+ *          <td align="center">X</td>
+ *          <td align="center">X</td>
+ *      </tr>
+ *      <tr>
+ *          <td>Check</td>
+ *          <td align="center"></td>
+ *          <td align="center">Non-production</td>
+ *          <td align="center">Non-production</td>
+ *          <td align="center">Non-production</td>
+ *          <td align="center">X</td>
+ *          <td align="center"></td>
+ *      </tr>
+ *      <tr>
+ *          <td>Verify</td>
+ *          <td align="center"></td>
+ *          <td align="center">X</td>
+ *          <td align="center">X</td>
+ *          <td align="center">Non-production</td>
+ *          <td align="center">X</td>
+ *          <td align="center">X</td>
+ *      </tr>
+ *  </table>
+ *
+ *  @note The above described behaviors are only in effect when
+ *        #NL_ASSERT_USE_FLAGS_DEFAULT to 1. See @ref customization
+ *        for more information on configuring and customizing the
+ *        trigger behaviors.
+ *
+ *  @subsubsection run-time-assert Assert
+ *
+ *  These assertions are identical to the traditional C Standard
+ *  Library-style assertion (see
+ *  [assert()](http://pubs.opengroup.org/onlinepubs/009695399/functions/assert.html))
+ *  except that side-effects, if any, in the asserted expression will be
+ *  produced even when the assertion is made inactive, as in production build
+ *  configurations, by setting #NL_ASSERT_PRODUCTION to true.
+ *
+ *  Like the C Standard Library assertion, a trigger of this style of
+ *  assertion interface will invoke #NL_ASSERT_ABORT().
+ *
+ *  @subsubsection run-time-abort Abort
+ *
+ *  These assertions are identical to the @ref run-time-assert style
+ *  assertions; however, they are active in __both__ non-production
+ *  __and__ production build configurations.
+ *
+ *  A trigger of this style of assertion interface will invoke #NL_ASSERT_ABORT().
+ *
+ *  @subsubsection run-time-check Check
+ *
+ *  These assertions are similar to the @ref run-time-assert style; however,
+ *  this style __does not__ abort. Normal program flow and execution
+ *  will continue past this assertion.
+ *
+ *  Side-effects, if any, in the asserted expression will be produced even when
+ *  the assertion is made inactive, as in production build configurations, by
+ *  setting #NL_ASSERT_PRODUCTION to true.
+ *
+ *  @subsubsection run-time-verify Verify
+ *
+ *  These assertions are similar to the @ref run-time-abort style; however,
+ *  this style __does not__ abort. Normal program flow and execution
+ *  will continue past this assertion.
+ *
+ *  These are active in __both__ non-production __and__ production
+ *  build configurations.
+ *
+ *  @subsection preconditions Precondition Interfaces
+ *
+ *  These assertions are designed to be placed at the head of an
+ *  interface or method to check incoming parameters.
+ *
+ *  These assertions implicitly return, either void or a specified
+ *  value for non-void interfaces or methods.
+ *
+ *  @note This family of interfaces may be in violation of your site's
+ *  or project's coding style and best practices by virtue of its
+ *  implicit return. If so, please consider using the
+ *  [exception-style](@ref exceptions) interfaces instead.
+ *
+ *  The following table summarizes the features for this family of interfaces:
+ *
+ *  <table>
+ *      <tr>
+ *          <th rowspan="2">Style</th>
+ *          <th colspan="4">Behaviors</th>
+ *          <th colspan="2">Availability</th>
+ *      </tr>
+ *      <tr>
+ *          <th>Abort</th>
+ *          <th>Backtrace</th>
+ *          <th>Log</th>
+ *          <th>Trap</th>
+ *          <th>Non-production</th>
+ *          <th>Production</th>
+ *      </tr>
+ *      <tr>
+ *          <td>Precondition</td>
+ *          <td align="center"></td>
+ *          <td align="center">X</td>
+ *          <td align="center">X</td>
+ *          <td align="center"></td>
+ *          <td align="center">X</td>
+ *          <td align="center">X</td>
+ *      </tr>
+ *  </table>
+ *
+ *  @note The above described behaviors are only in effect when
+ *        #NL_ASSERT_USE_FLAGS_DEFAULT to 1. See @ref customization
+ *        for more information on configuring and customizing the
+ *        trigger behaviors.
+ *
+ *  @subsection exceptions Exception Interfaces
+ *
+ *  This family of interfaces is designed to support the method of
+ *  error and exception handling that advocates a single function or
+ *  method return site and, by extension, consolidated points of
+ *  exception and error handling as well as resource clean-up.
+ *
+ *  A general example usage of this family of interfaces is:
+ *
+ *  @code
+ *  int Bar(uint8_t **aBuffer, const Foo *aParameter)
+ *  {
+ *      const size_t size   = 1024;
+ *      int          retval = 0;
+ *
+ *      nlREQUIRE(aBuffer != NULL, exit, retval = -EINVAL);
+ *
+ *      *aBuffer = (uint8_t *)malloc(size);
+ *      nlREQUIRE(*aBuffer != NULL, exit, retval = -ENOMEM);
+ *
+ *      memset(*aBuffer, 0, size);
+ *
+ *  exit:
+ *      return retval;
+ *  }
+ *  @endcode
+ *
+ *  As shown in the example, this family checks for the specified
+ *  condition, which is expected to commonly be true, and branches to
+ *  the specified label if the condition is false.
+ *
+ *    * [Expect](@ref expect)
+ *    * [Desire](@ref desire)
+ *    * [Require](@ref require)
+ *
+ *  This family of interfaces are all identical across the styles and
+ *  all styles support an identical set of variants. The only
+ *  difference among them is the default configured trigger action
+ *  behavior, as summarized in the table below:
+ *
+ *  <table>
+ *      <tr>
+ *          <th rowspan="2">Style</th>
+ *          <th colspan="3">Behaviors</th>
+ *          <th colspan="2">Availability</th>
+ *      </tr>
+ *      <tr>
+ *          <th>Backtrace</th>
+ *          <th>Log</th>
+ *          <th>Trap</th>
+ *          <th>Non-production</th>
+ *          <th>Production</th>
+ *      </tr>
+ *      <tr>
+ *          <td>Expect</td>
+ *          <td></td>
+ *          <td></td>
+ *          <td></td>
+ *          <td align="center">X</td>
+ *          <td align="center">X</td>
+ *      </tr>
+ *      <tr>
+ *          <td>Desire</td>
+ *          <td></td>
+ *          <td align="center">Non-production</td>
+ *          <td></td>
+ *          <td align="center">X</td>
+ *          <td align="center">X</td>
+ *      </tr>
+ *      <tr>
+ *          <td>Require</td>
+ *          <td align="center">X</td>
+ *          <td align="center">X</td>
+ *          <td align="center">Non-production</td>
+ *          <td align="center">X</td>
+ *          <td align="center">X</td>
+ *      </tr>
+ *  </table>
+ *
+ *  @note The above described behaviors are only in effect when
+ *        #NL_ASSERT_USE_FLAGS_DEFAULT to 1. See @ref customization
+ *        for more information on configuring and customizing the
+ *        trigger behaviors.
+ *
+ *  @subsubsection expect Expect
+ *
+ *  These assertions are designed to be placed anywhere an exceptional
+ *  condition might occur where handling needs to locally jump to
+ *  error-handling code.
+ *
+ *  These checks are always present and do nothing beyond branching to
+ *  the named exception label. Consequently, they are simply mnemonics
+ *  or syntactic sugar.
+ *
+ *  This style of check should be used where either true or false
+ *  evaluation of the assertion expression are equally likely since
+ *  there is no default configured trigger behavior.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @subsubsection desire Desire
+ *
+ *  These are identical to the @ref expect style checks; except for
+ *  their non-production and production configured behavior.
+ *
+ *  This style of check should be used where false evaluation of the
+ *  assertion expression is expected to be occasional.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Occasional
+ *
+ *  @subsubsection require Require
+ *
+ *  These are identical to the @ref expect style checks; except for
+ *  their non-production and production configured behavior.
+ *
+ *  This style of check should be used where false evaluation of the
+ *  assertion expression is expected to be rare.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Rare
+ *
+ * @subsection variants Variants
+ *
+ * The three families of run-time interface are available in one of several
+ * variants, as summarized below. <em>&lt;STYLE&gt;</em> may be replaced with one of (see [Run-time Availability](@ref run-time-availability) for details):
+ *
+ *   * ASSERT
+ *   * ABORT
+ *   * CHECK
+ *   * VERIFY
+ *   * PRECONDITION
+ *   * EXPECT
+ *   * DESIRE
+ *   * REQUIRE
+ *
+ * to form an actual interface name.
+ *
+ * | Interface Variant                              | Description                                                                                                  |
+ * |:---------------------------------------------- |:------------------------------------------------------------------------------------------------------------ |
+ * | nl<em>&lt;STYLE&gt;</em>                       | Base variant; execute the check.                                                                             |
+ * | nl<em>&lt;STYLE&gt;</em>\_ACTION               | Execute the base check and execute the action if the check fails.                                            |
+ * | nl<em>&lt;STYLE&gt;</em>\_PRINT                | Execute the base check and print the descriptive string if the check fails.                                  |
+ * | nl<em>&lt;STYLE&gt;</em>\_ACTION_PRINT         | Execute the base check and both execute the action and print the descriptive string if the check fails.      |
+ * | nl<em>&lt;STYLE&gt;</em>\_SUCCESS              | Adds a check against zero (0) as the logical condition to assert.                                            |
+ * | nl<em>&lt;STYLE&gt;</em>\_SUCCESS_ACTION       | Execute the success check and execute the action if the check fails.                                         |
+ * | nl<em>&lt;STYLE&gt;</em>\_SUCCESS_PRINT        | Execute the success check and print the descriptive string if the check fails.                               |
+ * | nl<em>&lt;STYLE&gt;</em>\_SUCCESS_ACTION_PRINT | Execute the success check and both execute the action and print the descriptive string if the check fails.   |
+ * | nlN<em>&lt;STYLE&gt;</em>                      | Inverts the logical sense of the base check; execute the check.                                              |
+ * | nlN<em>&lt;STYLE&gt;</em>\_ACTION              | Execute the inversion check and execute the action if the check fails.                                       |
+ * | nlN<em>&lt;STYLE&gt;</em>\_PRINT               | Execute the inversion check and print the descriptive string if the check fails.                             |
+ * | nlN<em>&lt;STYLE&gt;</em>\_ACTION_PRINT        | Execute the inversion check and both execute the action and print the descriptive string if the check fails. |
+ *
+ * @section run-time-availability Run-time Availability
+ *
+ * The following table indicates the availability of the run-time interface
+ * variants for each style.
+ *
+ * <table>
+ *     <tr>
+ *         <th rowspan="2">Interface Variant</th>
+ *         <th colspan="8">Style</th>
+ *     </tr>
+ *     <tr>
+ *         <th>Assert</th>
+ *         <th>Abort</th>
+ *         <th>Check</th>
+ *         <th>Verify</th>
+ *         <th>Precondition</th>
+ *         <th>Expect</th>
+ *         <th>Desire</th>
+ *         <th>Require</th>
+ *     </tr>
+ *     <tr>
+ *         <td>nl<em>&lt;STYLE&gt;</em></td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ *     <tr>
+ *         <td>nl<em>&lt;STYLE&gt;</em>\_ACTION</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ *     <tr>
+ *         <td>nl<em>&lt;STYLE&gt;</em>\_PRINT</td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ *     <tr>
+ *         <td>nl<em>&lt;STYLE&gt;</em>\_ACTION_PRINT</td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ *     <tr>
+ *         <td>nl<em>&lt;STYLE&gt;</em>\_SUCCESS</td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ *     <tr>
+ *         <td>nl<em>&lt;STYLE&gt;</em>\_SUCCESS_ACTION</td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ *     <tr>
+ *         <td>nl<em>&lt;STYLE&gt;</em>\_SUCCESS_PRINT</td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ *     <tr>
+ *         <td>nl<em>&lt;STYLE&gt;</em>\_SUCCESS_ACTION_PRINT</td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ *     <tr>
+ *         <td>nlN<em>&lt;STYLE&gt;</em></td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ *     <tr>
+ *         <td>nlN<em>&lt;STYLE&gt;</em>\_ACTION</td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ *     <tr>
+ *         <td>nlN<em>&lt;STYLE&gt;</em>\_PRINT</td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ *     <tr>
+ *         <td>nlN<em>&lt;STYLE&gt;</em>\_ACTION_PRINT</td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center"></td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ * </table>
+ *
+ * @section customization Customization
+ *
+ * The Nest Labs Assertion library is designed "out of the box" to
+ * provide a high degree of utility. However, there are a number of
+ * aspects that can be tuned on a per-module, -project, or -site basis
+ * to customize the appearance and behavior through user-definable
+ * attributes via the C preprocessor.
+ *
+ * @subsection userattrs User-definable Attributes
+ *
+ * The following attributes may be defined by the user before
+ * the nlassert.h header is included by the preprocessor, overriding
+ * the default behavior:
+ *
+ *   * #NL_ASSERT_PRODUCTION
+ *   * #NL_ASSERT_PREFIX_STRING
+ *   * #NL_ASSERT_COMPONENT_STRING
+ *   * #NL_ASSERT_FILE
+ *   * #NL_ASSERT_ABORT
+ *   * #NL_ASSERT_BACKTRACE
+ *   * #NL_ASSERT_LOG
+ *   * #NL_ASSERT_TRAP
+ *
+ * Without any customization, all of the interface styles are set to
+ * use __no__ trigger behaviors (i.e. #NL_ASSERT_FLAG_NONE). However, a
+ * set of default trigger behaviors (as documented in the tables
+ * above) may be enabled by setting #NL_ASSERT_USE_FLAGS_DEFAULT to 1
+ * before nlassert.h is included by the preprocessor.
+ *
+ * Otherwise, the following attributes may be overridden, customizing
+ * the trigger behavior of each assertion interface family for both
+ * non-production and production configurations:
+ *
+ *   * #NL_ASSERT_EXPECT_FLAGS
+ *
+ *   * #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS
+ *   * #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS
+ *   * #NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS
+ *   * #NL_ASSERT_ABORT_NONPRODUCTION_FLAGS
+ *   * #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS
+ *   * #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS
+ *   * #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS
+ *
+ *   * #NL_ASSERT_VERIFY_PRODUCTION_FLAGS
+ *   * #NL_ASSERT_ABORT_PRODUCTION_FLAGS
+ *   * #NL_ASSERT_DESIRE_PRODUCTION_FLAGS
+ *   * #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS
+ *   * #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS
+ *
+ *  @section compile-time-interfaces Compile-time Interfaces
+ *
+ *  The compile-time interfaces are a limited subset of their run-time
+ *  counterparts. Rather than altering run-time execution on assertion
+ *  firing against a dynamically-checked run-time condition, these
+ *  interfaces terminate compilation against a statically-checked
+ *  compile-time condition.
+ *
+ *  @subsection compile-time-assertions Assertion Interfaces
+ *
+ *  These interfaces have only one style:
+ *
+ *    * [Assert](@ref compile-time-assert)
+ *
+ *  <table>
+ *      <tr>
+ *          <th rowspan="2">Style</th>
+ *          <th colspan="2">Availability</th>
+ *      </tr>
+ *      <tr>
+ *          <th>Non-production</th>
+ *          <th>Production</th>
+ *      </tr>
+ *      <tr>
+ *          <td>Assert</td>
+ *          <td align="center">X</td>
+ *          <td align="center">X</td>
+ *      </tr>
+ *  </table>
+ *
+ *  @subsubsection compile-time-assert Assert
+ *
+ *  These assertions are active in __both__ non-production
+ *  __and__ production build configurations. This behavior
+ *  is unconventional with respect to the [run-time assert-style assertions](@ref run-time-assert)
+ *  but very conventional with respect to the similar
+ *  C11/C++11 static-assertion standards.
+ *
+ * @subsection compile-time-variants Variants
+ *
+ * The compile-time interfaces are available in two variants:
+ *
+ * | Interface Variant                              | Description                                                                                                  |
+ * |:---------------------------------------------- |:------------------------------------------------------------------------------------------------------------ |
+ * | nlSTATIC\_ASSERT                               | Base variant; execute the check.                                                                             |
+ * | nlSTATIC\_ASSERT\_PRINT                        | Execute the base check with a descriptive string. Note, this string is not actually emitted in any meaningful way. It serves to simply comment or annotate the assertion and to provide interface parallelism with the run-time assertion interfaces.                                  |
+ *
+ * @section compile-time-availability Compile-time Availability
+ *
+ * The following table indicates the availability of the compile-time interface
+ * variants.
+ *
+ * <table>
+ *     <tr>
+ *         <th rowspan="2">Interface Variant</th>
+ *         <th colspan="2">Availability</th>
+ *     </tr>
+ *     <tr>
+ *         <th>Non-Production</th>
+ *         <th>Production</th>
+ *     </tr>
+ *     <tr>
+ *         <td>nlSTATIC\_ASSERT</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ *     <tr>
+ *         <td>nlSTATIC\_ASSERT\_PRINT</td>
+ *         <td align="center">X</td>
+ *         <td align="center">X</td>
+ *     </tr>
+ * </table>
+ *
+ * @section compatibility Standard C Library Compatibility
+ *
+ * This package also provides an ISO/IEC 9899:1999-, C89-, and
+ * C99-compatible Standard C Library header (via assert.h) and
+ * assertion interface definition (assert()), implemented atop Nest
+ * Labs assertion checking and runtime exception interfaces such that
+ * consistent platform and system capabilities, behavior, and output
+ * may be implemented and enforced across the two interfaces.
+ *
+ * Systems wishing to use this compatibility header and interface in
+ * lieu of their Standard C Library header of the same name should
+ * ensure that their toolchain is configured to either ignore or
+ * deprioritize standard search paths while placing the directory this
+ * header is contained in among the preferred header search paths.
+ *
+ */
+
+#ifndef NLCORE_NLASSERT_H
+#define NLCORE_NLASSERT_H
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+/**
+ *  @name Behavioral Control Flags
+ *
+ *  @brief
+ *    These flags are used to influence the behavior of the various
+ *    classes and styles of assertion macros.
+ *
+ *  @{
+ *
+ */
+
+/**
+ *  @def NL_ASSERT_FLAG_NONE
+ *
+ *  @brief
+ *    Perform no actions when an assertion expression evaluates to
+ *    false.
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ */
+#define NL_ASSERT_FLAG_NONE             0x00000000
+
+/**
+ *  @def NL_ASSERT_FLAG_BACKTRACE
+ *
+ *  @brief
+ *    Invoke #NL_ASSERT_BACKTRACE() when an assertion expression
+ *    evaluates to false.
+ *
+ *  @note For the *_ACTION*-style assertion variants,
+ *        #NL_ASSERT_BACKTRACE() is a pre-action trigger and will run
+ *        before the specified action.
+ *
+ *  @sa #NL_ASSERT_FLAG_NONE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ *  @sa #NL_ASSERT_BACKTRACE
+ *
+ */
+#define NL_ASSERT_FLAG_BACKTRACE        0x00000001
+
+/**
+ *  @def NL_ASSERT_FLAG_LOG
+ *
+ *  @brief
+ *    Invoke #NL_ASSERT_LOG() when an assertion expression evaluates
+ *    to false.
+ *
+ *  @note For the *_ACTION*-style assertion variants,
+ *        #NL_ASSERT_LOG() is a pre-action trigger and will run
+ *        before the specified action.
+ *
+ *  @sa #NL_ASSERT_FLAG_NONE
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ *  @sa #NL_ASSERT_LOG
+ *
+ */
+#define NL_ASSERT_FLAG_LOG              0x00000002
+
+/**
+ *  @def NL_ASSERT_FLAG_TRAP
+ *
+ *  @brief
+ *    Invoke #NL_ASSERT_TRAP() when an assertion expression evaluates
+ *    to false.
+ *
+ *  @note For the *_ACTION*-style assertion variants,
+ *        #NL_ASSERT_TRAP() is a post-action trigger and will run
+ *        after the specified action.
+ *
+ *  @sa #NL_ASSERT_FLAG_NONE
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *
+ *  @sa #NL_ASSERT_TRAP
+ *
+ */
+#define NL_ASSERT_FLAG_TRAP             0x00000004
+
+/**
+ *  @}
+ *
+ */
+
+/**
+ *  @def NL_ASSERT_USE_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    Enable (1) or disable (0) use of the default trigger behavior flags.
+ *
+ *  This enables or disables the use of the default trigger behavior
+ *  flags as specified by:
+ *
+ *   * #NL_ASSERT_EXPECT_FLAGS_DEFAULT
+ *
+ *   * #NL_ASSERT_CHECK_NONPRODUCTION_FLAGS_DEFAULT
+ *   * #NL_ASSERT_VERIFY_NONPRODUCTION_FLAGS_DEFAULT
+ *   * #NL_ASSERT_ASSERT_NONPRODUCTION_FLAGS_DEFAULT
+ *   * #NL_ASSERT_ABORT_NONPRODUCTION_FLAGS_DEFAULT
+ *   * #NL_ASSERT_DESIRE_NONPRODUCTION_FLAGS_DEFAULT
+ *   * #NL_ASSERT_REQUIRE_NONPRODUCTION_FLAGS_DEFAULT
+ *   * #NL_ASSERT_PRECONDITION_NONPRODUCTION_FLAGS_DEFAULT
+ *
+ *   * #NL_ASSERT_VERIFY_PRODUCTION_FLAGS_DEFAULT
+ *   * #NL_ASSERT_ABORT_PRODUCTION_FLAGS_DEFAULT
+ *   * #NL_ASSERT_DESIRE_PRODUCTION_FLAGS_DEFAULT
+ *   * #NL_ASSERT_REQUIRE_PRODUCTION_FLAGS_DEFAULT
+ *   * #NL_ASSERT_PRECONDITION_PRODUCTION_FLAGS_DEFAULT
+ *
+ *  Setting this to 1, effectively does the following:
+ *
+ *  @code
+ *  #define NL_ASSERT_<STYLE>_<CONFIGURATION>_FLAGS NL_ASSERT_<STYLE>_<CONFIGURATION>_FLAGS_DEFAULT
+ *  @endcode
+ *
+ *  for each assertion interface <em>&lt;STYLE&gt;</em> for both
+ *  non-production and production (see #NL_ASSERT_PRODUCTION) <em>&lt;CONFIGURATION&gt;</em> .
+ *
+ */
+#if !defined(NL_ASSERT_USE_FLAGS_DEFAULT)
+#define NL_ASSERT_USE_FLAGS_DEFAULT     0
+#endif /* !defined(NL_ASSERT_USE_FLAGS_DEFAULT) */
+
+/**
+ *  @def NL_ASSERT_PRODUCTION
+ *
+ *  @brief
+ *    Enable (1) or disable (0) when production (or non-production)
+ *    assertion behavior is desired.
+ *
+ *  When production behavior is asserted, a number of interface
+ *  families are elided entirely and for others, the default behavior
+ *  changes (default: ((defined(NDEBUG) && NDEBUG) || (defined(DEBUG)
+ *  && !DEBUG) || 1)).
+ *
+ */
+#if !defined(NL_ASSERT_PRODUCTION)
+#if defined(NDEBUG)
+#define NL_ASSERT_PRODUCTION            NDEBUG
+#elif defined(DEBUG)
+#define NL_ASSERT_PRODUCTION            !DEBUG
+#else
+#define NL_ASSERT_PRODUCTION            1
+#endif /* defined(NDEBUG) */
+#endif /* !defined(NL_ASSERT_PRODUCTION) */
+
+/**
+ *  @name Log Output Definitions
+ *
+ *  @brief
+ *    These definitions control how the output of assertion log
+ *    messages appear, when so configured, on assertion expression
+ *    failure evaluation.
+ *
+ *  @{
+ *
+ */
+
+/**
+ *  @def NL_ASSERT_PREFIX_STRING
+ *
+ *  @brief
+ *    This is the string printed at the beginning of the assertion
+ *    printed (default: 'ASSERT: ').
+ *
+ *    Developers may, but are generally not encouraged to, override
+ *    this by defining #NL_ASSERT_PREFIX_STRING before nlassert.h is
+ *    included by the preprocessor, as shown in the following example:
+ *
+ *  @code
+ *    #define NL_ASSERT_PREFIX_STRING   "assertion: "
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_PREFIX_STRING
+ */
+#if !defined(NL_ASSERT_PREFIX_STRING)
+#define NL_ASSERT_PREFIX_STRING         "ASSERT: "
+#endif /* !defined(NL_ASSERT_PREFIX_STRING) */
+
+/**
+ *  @def NL_ASSERT_COMPONENT_STRING
+ *
+ *  @brief
+ *    This is the string printed following the prefix string (see
+ *    #NL_ASSERT_PREFIX_STRING) that indicates what module, program,
+ *    application or subsystem the assertion occurred in (default:
+ *    '').
+ *
+ *    Developers may override this by defining
+ *    #NL_ASSERT_COMPONENT_STRING before nlassert.h is included by the
+ *    preprocessor, as shown in the following example:
+ *
+ *  @code
+ *    #define NL_ASSERT_COMPONENT_STRING   "nlbar"
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_PREFIX_STRING
+ *
+ */
+#if !defined(NL_ASSERT_COMPONENT_STRING)
+#define NL_ASSERT_COMPONENT_STRING      ""
+#endif  /* !defined(NL_ASSERT_COMPONENT_STRING) */
+
+/**
+ *  @}
+ *
+ */
+
+/**
+ *  @def NL_ASSERT_ABORT()
+ *
+ *  @brief
+ *    This macro is invoked when an nlASSERT- or nlABORT-style
+ *    assertion expression evaluates to false.
+ *
+ *    By default, this is defined to the C Standard Library
+ *    [abort()](http://pubs.opengroup.org/onlinepubs/009695399/functions/abort.html). When
+ *    overridden, this should generally provide similar functionality,
+ *    terminating the overall process or system execution.
+ *
+ *    Developers may override and customize this by defining
+ *    #NL_ASSERT_ABORT() before nlassert.h is included by the
+ *    preprocessor.
+ *
+ */
+#if !defined(NL_ASSERT_ABORT)
+#define NL_ASSERT_ABORT()               abort()
+#endif /* !defined(NL_ASSERT_ABORT) */
+
+/**
+ *  @def NL_ASSERT_BACKTRACE()
+ *
+ *  @brief
+ *    This macro is invoked when an assertion expression evaluates to
+ *    false when the macro has been configured with / passed
+ *    #NL_ASSERT_FLAG_BACKTRACE.
+ *
+ *  By default, this is defined to do nothing. However, when defined,
+ *  this should generally generate a stack back trace when invoked.
+ *
+ *  Developers may override and customize this by defining
+ *  #NL_ASSERT_BACKTRACE() before nlassert.h is included by the
+ *  preprocessor.
+ *
+ *  @note For the *_ACTION*-style assertion variants,
+ *        #NL_ASSERT_BACKTRACE() is a pre-action trigger and will run
+ *        before the specified action.
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *
+ */
+#if !defined(NL_ASSERT_BACKTRACE)
+#define NL_ASSERT_BACKTRACE()
+#endif /* !defined(NL_ASSERT_BACKTRACE) */
+
+/**
+ *  @def NL_ASSERT_TRAP()
+ *
+ *  @brief
+ *    This macro is invoked when an assertion expression evaluates to
+ *    false when the macro has been configured with / passed
+ *    #NL_ASSERT_FLAG_TRAP.
+ *
+ *  By default, this is defined to do nothing. However, when defined,
+ *  this should generally generate a debug trap or breakpoint such that
+ *  when the assertion expression evaluates to false an attached
+ *  debugger will stop at the assertion point.
+ *
+ *  Developers may override and customize this by defining
+ *  #NL_ASSERT_TRAP() before nlassert.h is included by the
+ *  preprocessor, as shown in the following example:
+ *
+ *  @code
+ *    #if defined(__i386__) || defined(__x86_64__)
+ *    #define DEBUGGER_TRAP    __asm__ __volatile__("int3")
+ *    #elif defined(__arm__)
+ *    #define DEBUGGER_TRAP    __asm__ __volatile__("bkpt")
+ *    #endif
+ *
+ *    #define NL_ASSERT_TRAP()                               \
+ *        do                                                 \
+ *        {                                                  \
+ *            if (IsDebuggerAttached())                      \
+ *            {                                              \
+ *                DEBUGGER_TRAP;                             \
+ *            }                                              \
+ *        } while (0)
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @note For the *_ACTION*-style assertion variants,
+ *        #NL_ASSERT_TRAP() is a post-action trigger and will run
+ *        after the specified action.
+ *
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ */
+#if !defined(NL_ASSERT_TRAP)
+#define NL_ASSERT_TRAP()
+#endif /* !defined(NL_ASSERT_TRAP) */
+
+/**
+ *  @def NL_ASSERT_LOG_FORMAT_DEFAULT
+ *
+ *  @brief
+ *    This is the NULL-terminated C string literal with C Standard
+ *    Library-style format specifiers used by #NL_ASSERT_LOG_DEFAULT.
+ *
+ *  This may be used by overrides to #NL_ASSERT_LOG that want to use a
+ *  consistent output formatting.
+ *
+ *  @sa #NL_ASSERT_LOG_DEFAULT
+ *
+ */
+#define NL_ASSERT_LOG_FORMAT_DEFAULT                           "%s%s%s%s, %s%sfile: %s, line: %d\n"
+
+/**
+ *  @def NL_ASSERT_LOG_DEFAULT(aPrefix, aName, aCondition, aLabel, aFile, aLine, aMessage)
+ *
+ *  @brief
+ *    This macro conforms to #NL_ASSERT_LOG and may be assigned to
+ *    #NL_ASSERT_LOG, as shown in the following example, to display an
+ *    assertion message when the assertion triggers, via the C
+ *    Standard I/O Library error stream.
+ *
+ *  @code
+ *    #define NL_ASSERT_LOG(aPrefix, aName, aCondition, aLabel, aFile, aLine, aMessage) \
+ *        NL_ASSERT_LOG_DEFAULT(aPrefix, aName, aCondition, aLabel, aFile, aLine, aMessage)
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @param[in]  aPrefix     A pointer to a NULL-terminated C string printed
+ *                          at the beginning of the logged assertion
+ *                          message. Typically this is and should be
+ *                          #NL_ASSERT_PREFIX_STRING.
+ *  @param[in]  aName       A pointer to a NULL-terminated C string printed
+ *                          following @p aPrefix that indicates what
+ *                          module, program, application or subsystem
+ *                          the assertion occurred in Typically this
+ *                          is and should be
+ *                          #NL_ASSERT_COMPONENT_STRING.
+ *  @param[in]  aCondition  A pointer to a NULL-terminated C string indicating
+ *                          the expression that evaluated to false in
+ *                          the assertion. Typically this is a
+ *                          stringified version of the actual
+ *                          assertion expression.
+ *  @param[in]  aLabel      An optional pointer to a NULL-terminated C string
+ *                          indicating, for exception-style
+ *                          assertions, the label that will be
+ *                          branched to when the assertion expression
+ *                          evaluates to false.
+ *  @param[in]  aFile       A pointer to a NULL-terminated C string indicating
+ *                          the file in which the exception
+ *                          occurred. Typically this is and should be
+ *                          \_\_FILE\_\_ from the C preprocessor or
+ *                          #NL_ASSERT_FILE.
+ *  @param[in]  aLine       The line number in @p aFile on which the assertion
+ *                          expression evaluated to false. Typically
+ *                          this is and should be \_\_LINE\_\_ from the C
+ *                          preprocessor.
+ *  @param[in]  aMessage    An optional pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_LOG
+ *
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *
+ *  @sa #NL_ASSERT_PREFIX_STRING
+ *  @sa #NL_ASSERT_COMPONENT_STRING
+ *  @sa #NL_ASSERT_LOG_FORMAT_DEFAULT
+ *
+ *  @sa #NL_ASSERT_FILE
+ *
+ */
+#define NL_ASSERT_LOG_DEFAULT(aPrefix, aName, aCondition, aLabel, aFile, aLine, aMessage) \
+    do                                                                                    \
+    {                                                                                     \
+        fprintf(stderr,                                                                   \
+                NL_ASSERT_LOG_FORMAT_DEFAULT,                                             \
+                aPrefix,                                                                  \
+                (((aName) == 0) || (*(aName) == '\0')) ? "" : aName,                      \
+                (((aName) == 0) || (*(aName) == '\0')) ? "" : ": ",                       \
+                aCondition,                                                               \
+                ((aMessage == 0) ? "" : aMessage),                                        \
+                ((aMessage == 0) ? "" : ", "),                                            \
+                aFile,                                                                    \
+                aLine);                                                                   \
+    } while (0)
+
+/**
+ *  @def NL_ASSERT_LOG(aPrefix, aName, aCondition, aLabel, aFile, aLine, aMessage)
+ *
+ *  @brief
+ *    This macro is invoked when an assertion expression evaluates to
+ *    false when the macro has been configured with / passed
+ *    #NL_ASSERT_FLAG_LOG.
+ *
+ *  This is intended to display a message, to an appropriate log stream, informing the developer where the assertion was and what expression failed, similar to:
+ *
+ *      "ASSERT: MyComponent: aPointer != NULL, bad pointer, file: foo.c, line: 453"
+ *
+ *  Developers may override and customize this by defining
+ *  #NL_ASSERT_LOG() before nlassert.h is included by the
+ *  preprocessor.
+ *
+ *  @note For the *_ACTION*-style assertion variants, #NL_ASSERT_LOG()
+ *        is a pre-action trigger and will run before the specified action.
+ *
+ *  @param[in]  aPrefix     A pointer to a NULL-terminated C string printed
+ *                          at the beginning of the logged assertion
+ *                          message. Typically this is and should be
+ *                          #NL_ASSERT_PREFIX_STRING.
+ *  @param[in]  aName       A pointer to a NULL-terminated C string printed
+ *                          following @p aPrefix that indicates what
+ *                          module, program, application or subsystem
+ *                          the assertion occurred in Typically this
+ *                          is and should be
+ *                          #NL_ASSERT_COMPONENT_STRING.
+ *  @param[in]  aCondition  A pointer to a NULL-terminated C string indicating
+ *                          the expression that evaluated to false in
+ *                          the assertion. Typically this is a
+ *                          stringified version of the actual
+ *                          assertion expression.
+ *  @param[in]  aLabel      An optional pointer to a NULL-terminated C string
+ *                          indicating, for exception-style
+ *                          assertions, the label that will be
+ *                          branched to when the assertion expression
+ *                          evaluates to false.
+ *  @param[in]  aFile       A pointer to a NULL-terminated C string indicating
+ *                          the file in which the exception
+ *                          occurred. Typically this is and should be
+ *                          \_\_FILE\_\_ from the C preprocessor or
+ *                          #NL_ASSERT_FILE.
+ *  @param[in]  aLine       The line number in @p aFile on which the assertion
+ *                          expression evaluated to false. Typically
+ *                          this is and should be \_\_LINE\_\_ from the C
+ *                          preprocessor.
+ *  @param[in]  aMessage    An optional pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_LOG_DEFAULT
+ *
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *
+ *  @sa #NL_ASSERT_PREFIX_STRING
+ *  @sa #NL_ASSERT_COMPONENT_STRING
+ *
+ *  @sa #NL_ASSERT_FILE
+ *
+ */
+#if !defined(NL_ASSERT_LOG)
+#define NL_ASSERT_LOG(aPrefix, aName, aCondition, aLabel, aFile, aLine, aMessage)
+#endif /* !defined(NL_ASSERT_LOG) */
+
+/**
+ *  @def NL_ASSERT_FILE
+ *
+ *  @brief
+ *    This is the NULL-terminated C string literal with the fully-,
+ *    partially-, or non-qualified path of the file name in which an
+ *    assertion occurred (default \_\_FILE\_\_).
+ *
+ *  This may be used by developers to override the C preprocessor default,
+ *  potentially shortening the size of string literals used for
+ *  assertion file names and, consequently, decreasing the size of a
+ *  particular target image.
+ *
+ */
+#if !defined(NL_ASSERT_FILE)
+#define NL_ASSERT_FILE __FILE__
+#endif /* !defined(NL_ASSERT_FILE) */
+
+/**
+ *  @defgroup static-modality Static
+ *  @defgroup assert-style Assert
+ *  @defgroup abort-style Abort
+ *  @defgroup check-style Check
+ *  @defgroup verify-style Verify
+ *  @defgroup precondition-style Precondition
+ *  @defgroup expect-style Expect
+ *  @defgroup desire-style Desire
+ *  @defgroup require-style Require
+ *
+ */
+
+/**
+ *  @ingroup static-modality
+ *
+ *  @{
+ *
+ */
+
+/**
+ *  @def nlSTATIC_ASSERT(aCondition)
+ *
+ *  @brief
+ *    This checks, at compile-time, for the specified condition, which
+ *    is expected to commonly be true, and terminates compilation if
+ *    the condition is false.
+ *
+ *  @note Unlike the runtime assert macros, this compile-time macro is active
+ *        regardless of the state of #NL_ASSERT_PRODUCTION.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *
+ *  @sa #nlSTATIC_ASSERT_PRINT
+ *
+ */
+#define nlSTATIC_ASSERT(aCondition)                                             _nlSTATIC_ASSERT(aCondition, #aCondition)
+
+/**
+ *  @def nlSTATIC_ASSERT_PRINT(aCondition, aMessage)
+ *
+ *  @brief
+ *    This checks, at compile-time, for the specified condition, which
+ *    is expected to commonly be true, and terminates compilation if
+ *    the condition is false.
+ *
+ *  @note Unlike the runtime assert macros, this compile-time macro is active
+ *        regardless of the state of #NL_ASSERT_PRODUCTION.
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion
+ *                          failure. Note, this message is not
+ *                          actually emitted in any meaningful way for
+ *                          non-C11 or -C++11 code. It serves to
+ *                          simply comment or annotate the assertion
+ *                          and to provide interface parallelism with
+ *                          the run-time assertion interfaces.
+ *
+ *  @sa #nlSTATIC_ASSERT
+ *
+ */
+#define nlSTATIC_ASSERT_PRINT(aCondition, aMessage)                             _nlSTATIC_ASSERT(aCondition, aMessage)
+
+/**
+ *  @}
+ *
+ */
+
+/**
+ *  @ingroup expect-style
+ *
+ *  @{
+ *
+ */
+
+/**
+ *  @def NL_ASSERT_EXPECT_FLAGS_DEFAULT
+ *
+ *  @brief
+ *    This defines the default behavioral flags for expect-style
+ *    exception family assertions.
+ *
+ *  This may be used to override #NL_ASSERT_EXPECT_FLAGS as follows:
+ *
+ *  @code
+ *    #define NL_ASSERT_EXPECT_FLAGS NL_ASSERT_EXPECT_FLAGS_DEFAULT
+ *
+ *    #include <nlassert.h>
+ *  @endcode
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ *
+ */
+#define NL_ASSERT_EXPECT_FLAGS_DEFAULT                                          (NL_ASSERT_FLAG_NONE)
+
+/**
+ *  @def NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @brief
+ *    This defines the behavioral flags that govern the behavior for
+ *    expect-style exception family assertions when the assertion
+ *    expression evaluates to false.
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS_DEFAULT
+ *
+ *  @sa #NL_ASSERT_FLAG_BACKTRACE
+ *  @sa #NL_ASSERT_FLAG_LOG
+ *  @sa #NL_ASSERT_FLAG_TRAP
+ */
+#if NL_ASSERT_USE_FLAGS_DEFAULT
+#define NL_ASSERT_EXPECT_FLAGS                                                  NL_ASSERT_EXPECT_FLAGS_DEFAULT
+#elif !defined(NL_ASSERT_EXPECT_FLAGS)
+#define NL_ASSERT_EXPECT_FLAGS                                                  (NL_ASSERT_FLAG_NONE)
+#endif
+
+/**
+ *  @def nlEXPECT(aCondition, aLabel)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and branches to @p aLabel if the condition is
+ *    false.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #nlDESIRE
+ *  @sa #nlREQUIRE
+ *
+ */
+#define nlEXPECT(aCondition, aLabel)                                            __nlEXPECT(NL_ASSERT_EXPECT_FLAGS, aCondition, aLabel)
+
+/**
+ *  @def nlEXPECT_PRINT(aCondition, aLabel, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and both prints @p aMessage and then branches
+ *    to @p aLabel if the condition is false.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #nlDESIRE_PRINT
+ *  @sa #nlREQUIRE_PRINT
+ *
+ */
+#define nlEXPECT_PRINT(aCondition, aLabel, aMessage)                            __nlEXPECT_PRINT(NL_ASSERT_EXPECT_FLAGS, aCondition, aLabel, aMessage)
+
+/**
+ *  @def nlEXPECT_ACTION(aCondition, aLabel, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, and both executes @p anAction and branches to
+ *    @p aLabel if the condition is false.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #nlDESIRE_ACTION
+ *  @sa #nlREQUIRE_ACTION
+ *
+ */
+#define nlEXPECT_ACTION(aCondition, aLabel, anAction)                           __nlEXPECT_ACTION(NL_ASSERT_EXPECT_FLAGS, aCondition, aLabel, anAction)
+
+/**
+ *  @def nlEXPECT_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be true, prints @p aMessage, executes @p anAction, and
+ *    branches to @p aLabel if the condition is false.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #nlDESIRE_ACTION_PRINT
+ *  @sa #nlREQUIRE_ACTION_PRINT
+ *
+ */
+#define nlEXPECT_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)           __nlEXPECT_ACTION_PRINT(NL_ASSERT_EXPECT_FLAGS, aCondition, aLabel, anAction, aMessage)
+
+/**
+ *  @def nlEXPECT_SUCCESS(aStatus, aLabel)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and branches to @p
+ *    aLabel if the status is unsuccessful.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aStatus does not evaluate to zero
+ *                          (0).
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #nlDESIRE_SUCCESS
+ *  @sa #nlREQUIRE_SUCCESS
+ *
+ */
+#define nlEXPECT_SUCCESS(aStatus, aLabel)                                       __nlEXPECT_SUCCESS(NL_ASSERT_EXPECT_FLAGS, aStatus, aLabel)
+
+/**
+ *  @def nlEXPECT_SUCCESS_PRINT(aStatus, aLabel, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and both prints @p
+ *    aMessage and then branches to @p aLabel if the status is
+ *    unsuccessful.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aStatus does not evaluate to zero
+ *                          (0).
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #nlDESIRE_SUCCESS_PRINT
+ *  @sa #nlREQUIRE_SUCCESS_PRINT
+ *
+ */
+#define nlEXPECT_SUCCESS_PRINT(aStatus, aLabel, aMessage)                       __nlEXPECT_SUCCESS_PRINT(NL_ASSERT_EXPECT_FLAGS, aStatus, aLabel, aMessage)
+
+/**
+ *  @def nlEXPECT_SUCCESS_ACTION(aStatus, aLabel, anAction)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), and both executes @p
+ *    anAction and branches to @p aLabel if the status is unsuccessful.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aStatus does not evaluate to zero
+ *                          (0).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #nlDESIRE_SUCCESS_ACTION
+ *  @sa #nlREQUIRE_SUCCESS_ACTION
+ *
+ */
+#define nlEXPECT_SUCCESS_ACTION(aStatus, aLabel, anAction)                      __nlEXPECT_SUCCESS_ACTION(NL_ASSERT_EXPECT_FLAGS, aStatus, aLabel, anAction)
+
+/**
+ *  @def nlEXPECT_SUCCESS_ACTION_PRINT(aStatus, aLabel, anAction, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified status, which is expected to
+ *    commonly be successful (i.e. zero (0)), prints @p aMessage,
+ *    executes @p anAction, and branches to @p aLabel if the status is
+ *    unsuccessful.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @param[in]  aStatus     A scalar status to be evaluated against zero (0).
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aStatus does not evaluate to zero
+ *                          (0).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #nlDESIRE_SUCCESS_ACTION_PRINT
+ *  @sa #nlREQUIRE_SUCCESS_ACTION_PRINT
+ *
+ */
+#define nlEXPECT_SUCCESS_ACTION_PRINT(aStatus, aLabel, anAction, aMessage)      __nlEXPECT_SUCCESS_ACTION_PRINT(NL_ASSERT_EXPECT_FLAGS, aStatus, aLabel, anAction, aMessage)
+
+/**
+ *  @def nlNEXPECT(aCondition, aLabel)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and branches to @p aLabel if the condition is
+ *    true.
+ *
+ *  @note This is the logical inverse of #nlEXPECT.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #nlEXPECT
+ *  @sa #nlNDESIRE
+ *  @sa #nlNREQUIRE
+ *
+ */
+#define nlNEXPECT(aCondition, aLabel)                                           __nlNEXPECT(NL_ASSERT_EXPECT_FLAGS, aCondition, aLabel)
+
+/**
+ *  @def nlNEXPECT_PRINT(aCondition, aLabel, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and both prints @p aMessage and then branches
+ *    to @p aLabel if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlEXPECT_PRINT.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #nlEXPECT_PRINT
+ *  @sa #nlNDESIRE_PRINT
+ *  @sa #nlNREQUIRE_PRINT
+ *
+ */
+#define nlNEXPECT_PRINT(aCondition, aLabel, aMessage)                           __nlNEXPECT_PRINT(NL_ASSERT_EXPECT_FLAGS, aCondition, aLabel, aMessage)
+
+/**
+ *  @def nlNEXPECT_ACTION(aCondition, aLabel, anAction)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, and both executes @p anAction and branches to
+ *    @p aLabel if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlEXPECT_ACTION.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #nlEXPECT_ACTION
+ *  @sa #nlNDESIRE_ACTION
+ *  @sa #nlNREQUIRE_ACTION
+ *
+ */
+#define nlNEXPECT_ACTION(aCondition, aLabel, anAction)                          __nlNEXPECT_ACTION(NL_ASSERT_EXPECT_FLAGS, aCondition, aLabel, anAction)
+
+/**
+ *  @def nlNEXPECT_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)
+ *
+ *  @brief
+ *    This checks for the specified condition, which is expected to
+ *    commonly be false, prints @p aMessage, executes @p anAction, and
+ *    branches to @p aLabel if the condition is true.
+ *
+ *  @note This is the logical inverse of #nlEXPECT_ACTION_PRINT.
+ *
+ *  __Anticipated Assertion Firing Frequency:__ Frequent
+ *
+ *  @param[in]  aCondition  A Boolean expression to be evaluated.
+ *  @param[in]  aLabel      The local label to which execution branches
+ *                          when @p aCondition evaluates to false (i.e.
+ *                          compares equal to zero).
+ *  @param[in]  anAction    An expression or block to execute when the
+ *                          assertion fails. This will be executed
+ *                          after #NL_ASSERT_LOG() and
+ *                          #NL_ASSERT_BACKTRACE() but before
+ *                          #NL_ASSERT_TRAP().
+ *  @param[in]  aMessage    A pointer to a NULL-terminated C string
+ *                          containing a caller-specified message
+ *                          further describing the assertion failure.
+ *
+ *  @sa #NL_ASSERT_EXPECT_FLAGS
+ *
+ *  @sa #nlEXPECT_ACTION_PRINT
+ *  @sa #nlNDESIRE_ACTION_PRINT
+ *  @sa #nlNREQUIRE_ACTION_PRINT
+ *
+ */
+#define nlNEXPECT_ACTION_PRINT(aCondition, aLabel, anAction, aMessage)          __nlNEXPECT_ACTION_PRINT(NL_ASSERT_EXPECT_FLAGS, aCondition, aLabel, anAction, aMessage)
+
+/**
+ *  @}
+ *
+ */
+
+#if !NL_ASSERT_PRODUCTION
+#include "nlassert-nonproduction.h"
+#else
+#include "nlassert-production.h"
+#endif /* !NL_ASSERT_PRODUCTION */
+
+#endif /* NLCORE_NLASSERT_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/nlbyteorder-big.h b/cores/nRF5/nordic/config/nrf52840/configxx/nlbyteorder-big.h
new file mode 100644
index 000000000..db13462d8
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/nlbyteorder-big.h
@@ -0,0 +1,247 @@
+/**
+ *    Copyright (c) 2020 nlio Authors. All Rights Reserved.
+ *    Copyright 2012-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines defines functions for performing by value
+ *      byte reordering for 16-, 32-, and 64-bit quantities both
+ *      to-and-from the target system (i.e. host) byte ordering
+ *      to-and-from both little and big endian byte ordering,
+ *      specifically for big endian target systems.
+ */
+
+#ifndef NLBYTEORDER_BIG_H
+#define NLBYTEORDER_BIG_H
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 16-bit value, presumed to
+ * be in little endian byte ordering to the target system (i.e. host)
+ * byte ordering.
+ *
+ * Consequently, on little endian target systems, this is a no-op and
+ * on big endian target systems, this performs a reordering.
+ *
+ * @param[in]  inValue  The 16-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint16_t nlByteOrderSwap16LittleToHost(uint16_t inValue)
+{
+    return nlByteOrderValueSwap16(inValue);
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 32-bit value, presumed to
+ * be in little endian byte ordering to the target system (i.e. host)
+ * byte ordering.
+ *
+ * Consequently, on little endian target systems, this is a no-op and
+ * on big endian target systems, this performs a reordering.
+ *
+ * @param[in]  inValue  The 32-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint32_t nlByteOrderSwap32LittleToHost(uint32_t inValue)
+{
+    return nlByteOrderValueSwap32(inValue);
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 64-bit value, presumed to
+ * be in little endian byte ordering to the target system (i.e. host)
+ * byte ordering.
+ *
+ * Consequently, on little endian target systems, this is a no-op and
+ * on big endian target systems, this performs a reordering.
+ *
+ * @param[in]  inValue  The 64-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint64_t nlByteOrderSwap64LittleToHost(uint64_t inValue)
+{
+    return nlByteOrderValueSwap64(inValue);
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 16-bit value, presumed to
+ * be in target system (i.e. host) byte ordering to little endian byte
+ * ordering.
+ *
+ * Consequently, on little endian target systems, this is a no-op and
+ * on big endian target systems, this performs a reordering.
+ *
+ * @param[in]  inValue  The 16-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint16_t nlByteOrderSwap16HostToLittle(uint16_t inValue)
+{
+    return nlByteOrderValueSwap16(inValue);
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 32-bit value, presumed to
+ * be in target system (i.e. host) byte ordering to little endian byte
+ * ordering.
+ *
+ * Consequently, on little endian target systems, this is a no-op and
+ * on big endian target systems, this performs a reordering.
+ *
+ * @param[in]  inValue  The 32-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint32_t nlByteOrderSwap32HostToLittle(uint32_t inValue)
+{
+    return nlByteOrderValueSwap32(inValue);
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 64-bit value, presumed to
+ * be in target system (i.e. host) byte ordering to little endian byte
+ * ordering.
+ *
+ * Consequently, on little endian target systems, this is a no-op and
+ * on big endian target systems, this performs a reordering.
+ *
+ * @param[in]  inValue  The 64-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint64_t nlByteOrderSwap64HostToLittle(uint64_t inValue)
+{
+    return nlByteOrderValueSwap64(inValue);
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 16-bit value, presumed to
+ * be in big endian byte ordering to the target system (i.e. host)
+ * byte ordering.
+ *
+ * Consequently, on little endian target systems, this performs a
+ * reordering and on big endian target systems, this is a no-op.
+ *
+ * @param[in]  inValue  The 16-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint16_t nlByteOrderSwap16BigToHost(uint16_t inValue)
+{
+    return inValue;
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 32-bit value, presumed to
+ * be in big endian byte ordering to the target system (i.e. host)
+ * byte ordering.
+ *
+ * Consequently, on little endian target systems, this performs a
+ * reordering and on big endian target systems, this is a no-op.
+ *
+ * @param[in]  inValue  The 32-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint32_t nlByteOrderSwap32BigToHost(uint32_t inValue)
+{
+    return inValue;
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 64-bit value, presumed to
+ * be in big endian byte ordering to the target system (i.e. host)
+ * byte ordering.
+ *
+ * Consequently, on little endian target systems, this performs a
+ * reordering and on big endian target systems, this is a no-op.
+ *
+ * @param[in]  inValue  The 64-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint64_t nlByteOrderSwap64BigToHost(uint64_t inValue)
+{
+    return inValue;
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 16-bit value, presumed to
+ * be in target system (i.e. host) byte ordering to big endian byte
+ * ordering.
+ *
+ * Consequently, on little endian target systems, this performs a
+ * reordering and on big endian target systems, this is a no-op.
+ *
+ * @param[in]  inValue  The 16-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint16_t nlByteOrderSwap16HostToBig(uint16_t inValue)
+{
+    return inValue;
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 32-bit value, presumed to
+ * be in target system (i.e. host) byte ordering to big endian byte
+ * ordering.
+ *
+ * Consequently, on little endian target systems, this performs a
+ * reordering and on big endian target systems, this is a no-op.
+ *
+ * @param[in]  inValue  The 32-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint32_t nlByteOrderSwap32HostToBig(uint32_t inValue)
+{
+    return inValue;
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 64-bit value, presumed to
+ * be in target system (i.e. host) byte ordering to big endian byte
+ * ordering.
+ *
+ * Consequently, on little endian target systems, this performs a
+ * reordering and on big endian target systems, this is a no-op.
+ *
+ * @param[in]  inValue  The 64-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint64_t nlByteOrderSwap64HostToBig(uint64_t inValue)
+{
+    return inValue;
+}
+
+#endif /* NLBYTEORDER_BIG_H */
+
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/nlbyteorder-little.h b/cores/nRF5/nordic/config/nrf52840/configxx/nlbyteorder-little.h
new file mode 100644
index 000000000..72236ba5e
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/nlbyteorder-little.h
@@ -0,0 +1,246 @@
+/**
+ *    Copyright 2012-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines defines functions for performing by value
+ *      byte reordering for 16-, 32-, and 64-bit quantities both
+ *      to-and-from the target system (i.e. host) byte ordering
+ *      to-and-from both little and big endian byte ordering,
+ *      specifically for little endian target systems.
+ */
+
+#ifndef NLBYTEORDER_LITTLE_H
+#define NLBYTEORDER_LITTLE_H
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 16-bit value, presumed to
+ * be in little endian byte ordering to the target system (i.e. host)
+ * byte ordering.
+ *
+ * Consequently, on little endian target systems, this is a no-op and
+ * on big endian target systems, this performs a reordering.
+ *
+ * @param[in]  inValue  The 16-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint16_t nlByteOrderSwap16LittleToHost(uint16_t inValue)
+{
+    return inValue;
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 32-bit value, presumed to
+ * be in little endian byte ordering to the target system (i.e. host)
+ * byte ordering.
+ *
+ * Consequently, on little endian target systems, this is a no-op and
+ * on big endian target systems, this performs a reordering.
+ *
+ * @param[in]  inValue  The 32-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint32_t nlByteOrderSwap32LittleToHost(uint32_t inValue)
+{
+    return inValue;
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 64-bit value, presumed to
+ * be in little endian byte ordering to the target system (i.e. host)
+ * byte ordering.
+ *
+ * Consequently, on little endian target systems, this is a no-op and
+ * on big endian target systems, this performs a reordering.
+ *
+ * @param[in]  inValue  The 64-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint64_t nlByteOrderSwap64LittleToHost(uint64_t inValue)
+{
+    return inValue;
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 16-bit value, presumed to
+ * be in target system (i.e. host) byte ordering to little endian byte
+ * ordering.
+ *
+ * Consequently, on little endian target systems, this is a no-op and
+ * on big endian target systems, this performs a reordering.
+ *
+ * @param[in]  inValue  The 16-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint16_t nlByteOrderSwap16HostToLittle(uint16_t inValue)
+{
+    return inValue;
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 32-bit value, presumed to
+ * be in target system (i.e. host) byte ordering to little endian byte
+ * ordering.
+ *
+ * Consequently, on little endian target systems, this is a no-op and
+ * on big endian target systems, this performs a reordering.
+ *
+ * @param[in]  inValue  The 32-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint32_t nlByteOrderSwap32HostToLittle(uint32_t inValue)
+{
+    return inValue;
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 64-bit value, presumed to
+ * be in target system (i.e. host) byte ordering to little endian byte
+ * ordering.
+ *
+ * Consequently, on little endian target systems, this is a no-op and
+ * on big endian target systems, this performs a reordering.
+ *
+ * @param[in]  inValue  The 64-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint64_t nlByteOrderSwap64HostToLittle(uint64_t inValue)
+{
+    return inValue;
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 16-bit value, presumed to
+ * be in big endian byte ordering to the target system (i.e. host)
+ * byte ordering.
+ *
+ * Consequently, on little endian target systems, this performs a
+ * reordering and on big endian target systems, this is a no-op.
+ *
+ * @param[in]  inValue  The 16-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint16_t nlByteOrderSwap16BigToHost(uint16_t inValue)
+{
+    return nlByteOrderValueSwap16(inValue);
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 32-bit value, presumed to
+ * be in big endian byte ordering to the target system (i.e. host)
+ * byte ordering.
+ *
+ * Consequently, on little endian target systems, this performs a
+ * reordering and on big endian target systems, this is a no-op.
+ *
+ * @param[in]  inValue  The 32-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint32_t nlByteOrderSwap32BigToHost(uint32_t inValue)
+{
+    return nlByteOrderValueSwap32(inValue);
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 64-bit value, presumed to
+ * be in big endian byte ordering to the target system (i.e. host)
+ * byte ordering.
+ *
+ * Consequently, on little endian target systems, this performs a
+ * reordering and on big endian target systems, this is a no-op.
+ *
+ * @param[in]  inValue  The 64-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint64_t nlByteOrderSwap64BigToHost(uint64_t inValue)
+{
+    return nlByteOrderValueSwap64(inValue);
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 16-bit value, presumed to
+ * be in target system (i.e. host) byte ordering to big endian byte
+ * ordering.
+ *
+ * Consequently, on little endian target systems, this performs a
+ * reordering and on big endian target systems, this is a no-op.
+ *
+ * @param[in]  inValue  The 16-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint16_t nlByteOrderSwap16HostToBig(uint16_t inValue)
+{
+    return nlByteOrderValueSwap16(inValue);
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 32-bit value, presumed to
+ * be in target system (i.e. host) byte ordering to big endian byte
+ * ordering.
+ *
+ * Consequently, on little endian target systems, this performs a
+ * reordering and on big endian target systems, this is a no-op.
+ *
+ * @param[in]  inValue  The 32-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint32_t nlByteOrderSwap32HostToBig(uint32_t inValue)
+{
+    return nlByteOrderValueSwap32(inValue);
+}
+
+/**
+ * This conditionally performs, as necessary for the target system, a
+ * byte order swap by value of the specified 64-bit value, presumed to
+ * be in target system (i.e. host) byte ordering to big endian byte
+ * ordering.
+ *
+ * Consequently, on little endian target systems, this performs a
+ * reordering and on big endian target systems, this is a no-op.
+ *
+ * @param[in]  inValue  The 64-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint64_t nlByteOrderSwap64HostToBig(uint64_t inValue)
+{
+    return nlByteOrderValueSwap64(inValue);
+}
+
+#endif /* NLBYTEORDER_LITTLE_H */
+
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/nlbyteorder.h b/cores/nRF5/nordic/config/nrf52840/configxx/nlbyteorder.h
new file mode 100644
index 000000000..f4ba9bf9a
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/nlbyteorder.h
@@ -0,0 +1,329 @@
+/**
+ *    Copyright (c) 2020 nlio Authors. All Rights Reserved.
+ *    Copyright 2012-2017 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines macros for performing in place byte-
+ *      swapping of compile-time constants via the C preprocessor as
+ *      well as functions for performing byte-swapping by value and in
+ *      place by pointer for 16-, 32-, and 64-bit types.
+ */
+
+#ifndef NLBYTEORDER_H
+#define NLBYTEORDER_H
+
+#include <nlio-private.h>
+
+#include <stdint.h>
+
+/*
+ * If we are compiling under clang, GCC, or any such compatible
+ * compiler, in which -fno-builtins or -ffreestanding might be
+ * asserted, thereby eliminating built-in function optimization, we
+ * STILL want to leverage built-in bswap{16,32,64}, if available. We
+ * want this because it allows the compiler to use
+ * architecture-specific machine instructions or inline code
+ * generation to optimize an otherwise-generic and non-optimized code
+ * for byte reordering, which is exactly the kind of efficiency that
+ * would be expected of nlByteOrder.
+ */
+
+#if __nlIOHasBuiltin(__builtin_bswap16)
+#define __nlBYTEORDER_BSWAP16 __builtin_bswap16
+#else
+#define __nlBYTEORDER_BSWAP16 nlByteOrderConstantSwap16
+#endif
+
+#if __nlIOHasBuiltin(__builtin_bswap32)
+#define __nlBYTEORDER_BSWAP32 __builtin_bswap32
+#else
+#define __nlBYTEORDER_BSWAP32 nlByteOrderConstantSwap32
+#endif
+
+#if __nlIOHasBuiltin(__builtin_bswap64)
+#define __nlBYTEORDER_BSWAP64 __builtin_bswap64
+#else
+#define __nlBYTEORDER_BSWAP64 nlByteOrderConstantSwap64
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ *  @def nlByteOrderConstantSwap16
+ *
+ *  @brief
+ *     Performs a preprocessor-compatible in place byte swap of the
+ *     provided 16-bit value.
+ *
+ */
+#define nlByteOrderConstantSwap16(c)                                 \
+    ((uint16_t)                                                      \
+        ((((uint16_t)(c) & (uint16_t)0x00ffU) << 8) |                \
+         (((uint16_t)(c) & (uint16_t)0xff00U) >> 8)))
+
+/**
+ *  @def nlByteOrderConstantSwap32
+ *
+ *  @brief
+ *     Performs a preprocessor-compatible in place byte swap of the
+ *     provided 32-bit value.
+ *
+ */
+#define nlByteOrderConstantSwap32(c)                                 \
+    ((uint32_t)                                                      \
+        ((((uint32_t)(c) & (uint32_t)0x000000ffUL) << 24) |          \
+         (((uint32_t)(c) & (uint32_t)0x0000ff00UL) <<  8) |          \
+         (((uint32_t)(c) & (uint32_t)0x00ff0000UL) >>  8) |          \
+         (((uint32_t)(c) & (uint32_t)0xff000000UL) >> 24)))
+
+/**
+ *  @def nlByteOrderConstantSwap64
+ *
+ *  @brief
+ *     Performs a preprocessor-compatible in place byte swap of the
+ *     provided 64-bit value.
+ *
+ */
+#define nlByteOrderConstantSwap64(c)                                 \
+    ((uint64_t)                                                      \
+        ((((uint64_t)(c) & (uint64_t)0x00000000000000ffULL) << 56) | \
+         (((uint64_t)(c) & (uint64_t)0x000000000000ff00ULL) << 40) | \
+         (((uint64_t)(c) & (uint64_t)0x0000000000ff0000ULL) << 24) | \
+         (((uint64_t)(c) & (uint64_t)0x00000000ff000000ULL) <<  8) | \
+         (((uint64_t)(c) & (uint64_t)0x000000ff00000000ULL) >>  8) | \
+         (((uint64_t)(c) & (uint64_t)0x0000ff0000000000ULL) >> 24) | \
+         (((uint64_t)(c) & (uint64_t)0x00ff000000000000ULL) >> 40) | \
+         (((uint64_t)(c) & (uint64_t)0xff00000000000000ULL) >> 56)))
+
+/**
+ *  @def NLBYTEORDER_LITTLE_ENDIAN
+ *
+ *  @brief
+ *     Constant preprocessor definition used to test #NLBYTEORDER
+ *     against to determine whether the target system uses little
+ *     endian byte ordering.
+ *
+ *  @code
+ *  #if NLBYTEORDER == NLBYTEORDER_LITTLE_ENDIAN
+ *  
+ *      Do something that is little endian byte ordering-specific.
+ *
+ *  #endif
+ *  @endcode
+ *
+ */
+#define NLBYTEORDER_LITTLE_ENDIAN       0x1234
+
+/**
+ *  @def NLBYTEORDER_BIG_ENDIAN
+ *
+ *  @brief
+ *     Constant preprocessor definition used to test #NLBYTEORDER
+ *     against to determine whether the target system uses big
+ *     endian byte ordering.
+ *
+ *  @code
+ *  #if NLBYTEORDER == NLBYTEORDER_BIG_ENDIAN
+ *  
+ *      Do something that is little endian byte ordering-specific.
+ *
+ *  #endif
+ *  @endcode
+ *
+ */
+#define NLBYTEORDER_BIG_ENDIAN          0x4321
+
+/**
+ *  @def NLBYTEORDER_UNKNOWN_ENDIAN
+ *
+ *  @brief
+ *     Constant preprocessor definition used to test #NLBYTEORDER
+ *     against to determine whether the target system uses unknown
+ *     byte ordering.
+ *
+ *  @code
+ *  #elif NLBYTEORDER == NLBYTEORDER_UNKNOWN_ENDIAN
+ *  #error "Unknown byte ordering!"
+ *  #endif
+ *  @endcode
+ *
+ */
+#define NLBYTEORDER_UNKNOWN_ENDIAN      0xFFFF
+
+/**
+ *  @def NLBYTEORDER
+ *
+ *  @brief
+ *     Constant preprocessor definition containing the target system
+ *     byte ordering. May be one of:
+ *
+ *       - NLBYTEORDER_BIG_ENDIAN
+ *       - NLBYTEORDER_LITTLE_ENDIAN
+ *       - NLBYTEORDER_UNKNOWN_ENDIAN
+ *
+ */
+#if defined(__BYTE_ORDER__)
+# if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+#  define NLBYTEORDER NLBYTEORDER_LITTLE_ENDIAN
+# elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+#  define NLBYTEORDER NLBYTEORDER_BIG_ENDIAN
+# endif /* __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__ */
+#elif defined(__LITTLE_ENDIAN__) && (__LITTLE_ENDIAN__ == 1)
+#define NLBYTEORDER NLBYTEORDER_LITTLE_ENDIAN
+#elif defined(__BIG_ENDIAN__) && (__BIG_ENDIAN__ == 1)
+#define NLBYTEORDER NLBYTEORDER_BIG_ENDIAN
+#else
+#error "Endianness undefined!"
+#define NLBYTEORDER NLBYTEORDER_UNKNOWN_ENDIAN
+#endif /* defined(__BYTE_ORDER__) */
+
+enum {
+    nlByteOrderUnknown	    = NLBYTEORDER_UNKNOWN_ENDIAN,
+    nlByteOrderLittleEndian = NLBYTEORDER_LITTLE_ENDIAN,
+    nlByteOrderBigEndian    = NLBYTEORDER_BIG_ENDIAN
+};
+
+/**
+ * This represents a type for a byte ordering.
+ */
+typedef uint16_t nlByteOrder;
+
+/**
+ * This returns the byte order of the current system.
+ *
+ * @return The byte order of the current system.
+ */
+static inline nlByteOrder nlByteOrderGetCurrent(void)
+{
+#if (NLBYTEORDER == NLBYTEORDER_LITTLE_ENDIAN)
+    return nlByteOrderLittleEndian;
+#elif (NLBYTEORDER == NLBYTEORDER_BIG_ENDIAN)
+    return nlByteOrderBigEndian;
+#else
+    return nlByteOrderUnknown;
+#endif
+}
+
+/**
+ * This unconditionally performs a byte order swap by value of the
+ * specified 16-bit value.
+ *
+ * @param[in]  inValue  The 16-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint16_t nlByteOrderValueSwap16(uint16_t inValue)
+{
+    return __nlBYTEORDER_BSWAP16(inValue);
+}
+
+/**
+ * This unconditionally performs a byte order swap by value of the
+ * specified 32-bit value.
+ *
+ * @param[in]  inValue  The 32-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint32_t nlByteOrderValueSwap32(uint32_t inValue)
+{
+    return __nlBYTEORDER_BSWAP32(inValue);
+}
+
+/**
+ * This unconditionally performs a byte order swap by value of the
+ * specified 64-bit value.
+ *
+ * @param[in]  inValue  The 64-bit value to be byte order swapped.
+ *
+ * @return The input value, byte order swapped.
+ */
+static inline uint64_t nlByteOrderValueSwap64(uint64_t inValue)
+{
+    return __nlBYTEORDER_BSWAP64(inValue);
+}
+
+/**
+ * This unconditionally performs a byte order swap by pointer in place
+ * of the specified 16-bit value.
+ *
+ * @warning  The input value is assumed to be on a natural alignment
+ * boundary for the target system. It is the responsibility of the
+ * caller to perform any necessary alignment to avoid system faults
+ * for systems that do not support unaligned accesses.
+ *
+ * @param[inout]  inValue  A pointer to the 16-bit value to be byte
+ *                         order swapped.
+ */
+static inline void nlByteOrderPointerSwap16(uint16_t *inValue)
+{
+    *inValue = nlByteOrderValueSwap16(*inValue);
+}
+
+/**
+ * This unconditionally performs a byte order swap by pointer in place
+ * of the specified 32-bit value.
+ *
+ * @warning  The input value is assumed to be on a natural alignment
+ * boundary for the target system. It is the responsibility of the
+ * caller to perform any necessary alignment to avoid system faults
+ * for systems that do not support unaligned accesses.
+ *
+ * @param[inout]  inValue  A pointer to the 32-bit value to be byte
+ *                         order swapped.
+ */
+static inline void nlByteOrderPointerSwap32(uint32_t *inValue)
+{
+    *inValue = nlByteOrderValueSwap32(*inValue);
+}
+
+/**
+ * This unconditionally performs a byte order swap by pointer in place
+ * of the specified 64-bit value.
+ *
+ * @warning  The input value is assumed to be on a natural alignment
+ * boundary for the target system. It is the responsibility of the
+ * caller to perform any necessary alignment to avoid system faults
+ * for systems that do not support unaligned accesses.
+ *
+ * @param[inout]  inValue  A pointer to the 64-bit value to be byte
+ *                         order swapped.
+ */
+static inline void nlByteOrderPointerSwap64(uint64_t *inValue)
+{
+    *inValue = nlByteOrderValueSwap64(*inValue);
+}
+
+#if (NLBYTEORDER == NLBYTEORDER_LITTLE_ENDIAN)
+#include <nlbyteorder-little.h>
+#elif (NLBYTEORDER == NLBYTEORDER_BIG_ENDIAN)
+#include <nlbyteorder-big.h>
+#endif /* (NLBYTEORDER == NLBYTEORDER_LITTLE_ENDIAN) */
+
+#ifdef __cplusplus
+}
+#endif
+
+#undef __nlBYTEORDER_BSWAP16
+#undef __nlBYTEORDER_BSWAP32
+#undef __nlBYTEORDER_BSWAP64
+
+#endif /* NLBYTEORDER_H */
+
+
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/nlbyteorder.hpp b/cores/nRF5/nordic/config/nrf52840/configxx/nlbyteorder.hpp
new file mode 100644
index 000000000..7ce41ff53
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/nlbyteorder.hpp
@@ -0,0 +1,378 @@
+/**
+ *    Copyright 2012-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines C++ functions for performing byte-swapping
+ *      by value and in place by pointer for 16-, 32-, and 64-bit
+ *      types.
+ *
+ */
+
+#ifndef NLBYTEORDER_HPP
+#define NLBYTEORDER_HPP
+
+#include <nlbyteorder.h>
+
+namespace nl
+{
+
+    namespace ByteOrder
+    {
+        enum {
+            Unknown	 = nlByteOrderUnknown,
+            LittleEndian = nlByteOrderLittleEndian,
+            BigEndian    = nlByteOrderBigEndian    
+        };
+
+        /**
+         * This represents a type for a byte ordering.
+         */
+        typedef nlByteOrder ByteOrder;
+
+        /**
+         * This returns the byte order of the current system.
+         *
+         * @return The byte order of the current system.
+         */
+        inline ByteOrder GetCurrent(void)
+        {
+            return nlByteOrderGetCurrent();
+        }
+
+        /**
+         * This unconditionally performs a byte order swap by value of the
+         * specified 16-bit value.
+         *
+         * @param[in]  inValue  The 16-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint16_t Swap16(uint16_t inValue)
+        {
+            return nlByteOrderValueSwap16(inValue);
+        }
+
+        /**
+         * This unconditionally performs a byte order swap by value of the
+         * specified 32-bit value.
+         *
+         * @param[in]  inValue  The 32-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint32_t Swap32(uint32_t inValue)
+        {
+            return nlByteOrderValueSwap32(inValue);
+        }
+
+        /**
+         * This unconditionally performs a byte order swap by value of the
+         * specified 64-bit value.
+         *
+         * @param[in]  inValue  The 64-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint64_t Swap64(uint64_t inValue)
+        {
+            return nlByteOrderValueSwap64(inValue);
+        }
+
+        /**
+         * This unconditionally performs a byte order swap by pointer in place
+         * of the specified 16-bit value.
+         *
+         * @warning  The input value is assumed to be on a natural alignment
+         * boundary for the target system. It is the responsibility of the
+         * caller to perform any necessary alignment to avoid system faults
+         * for systems that do not support unaligned accesses.
+         *
+         * @param[inout]  inValue  A pointer to the 16-bit value to be byte
+         *                         order swapped.
+         */
+        inline void Swap16(uint16_t *inValue)
+        {
+            nlByteOrderPointerSwap16(inValue);
+        }
+
+        /**
+         * This unconditionally performs a byte order swap by pointer in place
+         * of the specified 32-bit value.
+         *
+         * @warning  The input value is assumed to be on a natural alignment
+         * boundary for the target system. It is the responsibility of the
+         * caller to perform any necessary alignment to avoid system faults
+         * for systems that do not support unaligned accesses.
+         *
+         * @param[inout]  inValue  A pointer to the 32-bit value to be byte
+         *                         order swapped.
+         */
+        inline void Swap32(uint32_t *inValue)
+        {
+            nlByteOrderPointerSwap32(inValue);
+        }
+
+        /**
+         * This unconditionally performs a byte order swap by pointer in place
+         * of the specified 64-bit value.
+         *
+         * @warning  The input value is assumed to be on a natural alignment
+         * boundary for the target system. It is the responsibility of the
+         * caller to perform any necessary alignment to avoid system faults
+         * for systems that do not support unaligned accesses.
+         *
+         * @param[inout]  inValue  A pointer to the 64-bit value to be byte
+         *                         order swapped.
+         */
+        inline void Swap64(uint64_t *inValue)
+        {
+            nlByteOrderPointerSwap64(inValue);
+        }
+
+        /**
+         * This conditionally performs, as necessary for the target system, a
+         * byte order swap by value of the specified 16-bit value, presumed to
+         * be in little endian byte ordering to the target system (i.e. host)
+         * byte ordering.
+         *
+         * Consequently, on little endian target systems, this is a no-op and
+         * on big endian target systems, this performs a reordering.
+         *
+         * @param[in]  inValue  The 16-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint16_t Swap16LittleToHost(uint16_t inValue)
+        {
+            return nlByteOrderSwap16LittleToHost(inValue);
+        }
+
+        /**
+         * This conditionally performs, as necessary for the target system, a
+         * byte order swap by value of the specified 32-bit value, presumed to
+         * be in little endian byte ordering to the target system (i.e. host)
+         * byte ordering.
+         *
+         * Consequently, on little endian target systems, this is a no-op and
+         * on big endian target systems, this performs a reordering.
+         *
+         * @param[in]  inValue  The 32-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint32_t Swap32LittleToHost(uint32_t inValue)
+        {
+            return nlByteOrderSwap32LittleToHost(inValue);
+        }
+
+        /**
+         * This conditionally performs, as necessary for the target system, a
+         * byte order swap by value of the specified 64-bit value, presumed to
+         * be in little endian byte ordering to the target system (i.e. host)
+         * byte ordering.
+         *
+         * Consequently, on little endian target systems, this is a no-op and
+         * on big endian target systems, this performs a reordering.
+         *
+         * @param[in]  inValue  The 64-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint64_t Swap64LittleToHost(uint64_t inValue)
+        {
+            return nlByteOrderSwap64LittleToHost(inValue);
+        }
+
+        /**
+         * This conditionally performs, as necessary for the target system, a
+         * byte order swap by value of the specified 16-bit value, presumed to
+         * be in target system (i.e. host) byte ordering to little endian byte
+         * ordering.
+         *
+         * Consequently, on little endian target systems, this is a no-op and
+         * on big endian target systems, this performs a reordering.
+         *
+         * @param[in]  inValue  The 16-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint16_t Swap16HostToLittle(uint16_t inValue)
+        {
+            return nlByteOrderSwap16HostToLittle(inValue);
+        }
+
+        /**
+         * This conditionally performs, as necessary for the target system, a
+         * byte order swap by value of the specified 32-bit value, presumed to
+         * be in target system (i.e. host) byte ordering to little endian byte
+         * ordering.
+         *
+         * Consequently, on little endian target systems, this is a no-op and
+         * on big endian target systems, this performs a reordering.
+         *
+         * @param[in]  inValue  The 32-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint32_t Swap32HostToLittle(uint32_t inValue)
+        {
+            return nlByteOrderSwap32HostToLittle(inValue);
+        }
+
+        /**
+         * This conditionally performs, as necessary for the target system, a
+         * byte order swap by value of the specified 64-bit value, presumed to
+         * be in target system (i.e. host) byte ordering to little endian byte
+         * ordering.
+         *
+         * Consequently, on little endian target systems, this is a no-op and
+         * on big endian target systems, this performs a reordering.
+         *
+         * @param[in]  inValue  The 64-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint64_t Swap64HostToLittle(uint64_t inValue)
+        {
+            return nlByteOrderSwap64HostToLittle(inValue);
+        }
+
+        /**
+         * This conditionally performs, as necessary for the target system, a
+         * byte order swap by value of the specified 16-bit value, presumed to
+         * be in big endian byte ordering to the target system (i.e. host)
+         * byte ordering.
+         *
+         * Consequently, on little endian target systems, this performs a
+         * reordering and on big endian target systems, this is a no-op.
+         *
+         * @param[in]  inValue  The 16-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint16_t Swap16BigToHost(uint16_t inValue)
+        {
+            return nlByteOrderSwap16BigToHost(inValue);
+        }
+
+        /**
+         * This conditionally performs, as necessary for the target system, a
+         * byte order swap by value of the specified 32-bit value, presumed to
+         * be in big endian byte ordering to the target system (i.e. host)
+         * byte ordering.
+         *
+         * Consequently, on little endian target systems, this performs a
+         * reordering and on big endian target systems, this is a no-op.
+         *
+         * @param[in]  inValue  The 32-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint32_t Swap32BigToHost(uint32_t inValue)
+        {
+            return nlByteOrderSwap32BigToHost(inValue);
+        }
+
+        /**
+         * This conditionally performs, as necessary for the target system, a
+         * byte order swap by value of the specified 64-bit value, presumed to
+         * be in big endian byte ordering to the target system (i.e. host)
+         * byte ordering.
+         *
+         * Consequently, on little endian target systems, this performs a
+         * reordering and on big endian target systems, this is a no-op.
+         *
+         * @param[in]  inValue  The 64-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint64_t Swap64BigToHost(uint64_t inValue)
+        {
+            return nlByteOrderSwap64BigToHost(inValue);
+        }
+
+        /**
+         * This conditionally performs, as necessary for the target system, a
+         * byte order swap by value of the specified 16-bit value, presumed to
+         * be in target system (i.e. host) byte ordering to big endian byte
+         * ordering.
+         *
+         * Consequently, on little endian target systems, this performs a
+         * reordering and on big endian target systems, this is a no-op.
+         *
+         * @param[in]  inValue  The 16-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint16_t Swap16HostToBig(uint16_t inValue)
+        {
+            return nlByteOrderSwap16HostToBig(inValue);
+        }
+
+        /**
+         * This conditionally performs, as necessary for the target system, a
+         * byte order swap by value of the specified 32-bit value, presumed to
+         * be in target system (i.e. host) byte ordering to big endian byte
+         * ordering.
+         *
+         * Consequently, on little endian target systems, this performs a
+         * reordering and on big endian target systems, this is a no-op.
+         *
+         * @param[in]  inValue  The 32-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint32_t Swap32HostToBig(uint32_t inValue)
+        {
+            return nlByteOrderSwap32HostToBig(inValue);
+        }
+
+        /**
+         * This conditionally performs, as necessary for the target system, a
+         * byte order swap by value of the specified 64-bit value, presumed to
+         * be in target system (i.e. host) byte ordering to big endian byte
+         * ordering.
+         *
+         * Consequently, on little endian target systems, this performs a
+         * reordering and on big endian target systems, this is a no-op.
+         *
+         * @param[in]  inValue  The 64-bit value to be byte order swapped.
+         *
+         * @return The input value, byte order swapped.
+         */
+        inline uint64_t Swap64HostToBig(uint64_t inValue)
+        {
+            return nlByteOrderSwap64HostToBig(inValue);
+        }
+
+    } // namespace ByteOrder
+
+} // namespace nl
+
+#endif // NLBYTEORDER_HPP
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/nlio-base.h b/cores/nRF5/nordic/config/nrf52840/configxx/nlio-base.h
new file mode 100644
index 000000000..f24a51e49
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/nlio-base.h
@@ -0,0 +1,1108 @@
+/**
+ *    Copyright 2013-2017 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines C functions for safely performing simple,
+ *      memory-mapped accesses, potentially to unaligned memory
+ *      locations.
+ */
+
+#ifndef NLIO_BASE_H
+#define NLIO_BASE_H
+
+#include <nlio-private.h>
+
+#include <stdbool.h>
+#include <stdint.h>
+#include <string.h>
+
+/*
+ * If we are compiling under clang, GCC, or any such compatible
+ * compiler, in which -fno-builtins or -ffreestanding might be
+ * asserted, thereby eliminating built-in function optimization, we
+ * STILL want built-in memcpy. We want this because it allows the
+ * compiler to use architecture-specific machine instructions or
+ * inline code generation to optimize an otherwise-expensive memcpy
+ * for unaligned reads and writes, which is exactly the kind of
+ * efficiency that would be expected of nlIO.
+ */
+#if __nlIOHasBuiltin(__builtin_memcpy)
+#define __nlIO_MEMCPY __builtin_memcpy
+#else
+#define __nlIO_MEMCPY memcpy
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * This determines whether the specified pointer is aligned on the
+ * indicated size boundary.
+ *
+ * @note The size should be a power of 2 (e.g. 1, 2, 4, 8, 16, etc.).
+ *
+ * @param[in]  p     The pointer to check the alignment of.
+ * @param[in]  size  The size, in bytes, boundary to check
+ *                   the alignment against.
+ *
+ * @return True if the pointer is aligned to the specified size;
+ *         otherwise, false.
+ */
+static inline bool nlIOIsAligned(const void *p, size_t size)
+{
+    const uintptr_t value = (uintptr_t)(p);
+    const uintptr_t mask  = size - 1;
+
+    return ((value & mask) == 0);
+}
+
+/**
+ * Perform an aligned memory read of the 8-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 8-bit value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOGetAligned8(const void *p)
+{
+    return *(const uint8_t *)(p);
+}
+
+/**
+ * Perform an aligned memory read of the 16-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 16-bit value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOGetAligned16(const void *p)
+{
+    return *(const uint16_t *)(p);
+}
+
+/**
+ * Perform an aligned memory read of the 32-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 32-bit value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOGetAligned32(const void *p)
+{
+    return *(const uint32_t *)(p);
+}
+
+/**
+ * Perform an aligned memory read of the 64-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 64-bit value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOGetAligned64(const void *p)
+{
+    return *(const uint64_t *)(p);
+}
+
+/**
+ * Perform an unaligned memory read of the 8-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 8-bit value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOGetUnaligned8(const void *p)
+{
+    return nlIOGetAligned8(p);
+}
+
+/**
+ * Perform an unaligned memory read of the 16-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 16-bit value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOGetUnaligned16(const void *p)
+{
+    uint16_t temp;
+
+    __nlIO_MEMCPY(&temp, p, sizeof(uint16_t));
+
+    return temp;
+}
+
+/**
+ * Perform an unaligned memory read of the 32-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 32-bit value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOGetUnaligned32(const void *p)
+{
+    uint32_t temp;
+
+    __nlIO_MEMCPY(&temp, p, sizeof(uint32_t));
+
+    return temp;
+}
+
+/**
+ * Perform an unaligned memory read of the 64-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 64-bit value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOGetUnaligned64(const void *p)
+{
+    uint64_t temp;
+
+    __nlIO_MEMCPY(&temp, p, sizeof(uint64_t));
+
+    return temp;
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 8-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 8-bit value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOGetMaybeAligned8(const void *p)
+{
+    return nlIOGetAligned8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 16-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 16-bit value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOGetMaybeAligned16(const void *p)
+{
+    if (nlIOIsAligned(p, sizeof (uint16_t)))
+        return nlIOGetAligned16(p);
+    else
+        return nlIOGetUnaligned16(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 32-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 32-bit value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOGetMaybeAligned32(const void *p)
+{
+    if (nlIOIsAligned(p, sizeof (uint32_t)))
+        return nlIOGetAligned32(p);
+    else
+        return nlIOGetUnaligned32(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 64-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 64-bit value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOGetMaybeAligned64(const void *p)
+{
+    if (nlIOIsAligned(p, sizeof (uint64_t)))
+        return nlIOGetAligned64(p);
+    else
+        return nlIOGetUnaligned64(p);
+}
+
+/**
+ * Perform an aligned memory write of the 8-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 8-bit value to.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOPutAligned8(void *p, const uint8_t v)
+{
+    *(uint8_t *)(p) = v;
+}
+
+/**
+ * Perform an aligned memory write of the 16-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 16-bit value to.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOPutAligned16(void *p, const uint16_t v)
+{
+    *(uint16_t *)(p) = v;
+}
+
+/**
+ * Perform an aligned memory write of the 32-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 32-bit value to.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOPutAligned32(void *p, const uint32_t v)
+{
+    *(uint32_t *)(p) = v;
+}
+
+/**
+ * Perform an aligned memory write of the 64-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 64-bit value to.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOPutAligned64(void *p, const uint64_t v)
+{
+    *(uint64_t *)(p) = v;
+}
+
+/**
+ * Perform an unaligned memory write of the 8-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 8-bit value to.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOPutUnaligned8(void *p, const uint8_t v)
+{
+    nlIOPutAligned8(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the 16-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 16-bit value to.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOPutUnaligned16(void *p, const uint16_t v)
+{
+    __nlIO_MEMCPY(p, &v, sizeof(uint16_t));
+}
+
+/**
+ * Perform an unaligned memory write of the 32-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 32-bit value to.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOPutUnaligned32(void *p, const uint32_t v)
+{
+    __nlIO_MEMCPY(p, &v, sizeof(uint32_t));
+}
+
+/**
+ * Perform an unaligned memory write of the 64-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 64-bit value to.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOPutUnaligned64(void *p, const uint64_t v)
+{
+    __nlIO_MEMCPY(p, &v, sizeof(uint64_t));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 8-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 8-bit value to.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOPutMaybeAligned8(void *p, const uint8_t v)
+{
+    nlIOPutAligned8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 16-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 16-bit value to.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOPutMaybeAligned16(void *p, const uint16_t v)
+{
+    if (nlIOIsAligned(p, sizeof (uint16_t)))
+        nlIOPutAligned16(p, v);
+    else
+        nlIOPutUnaligned16(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 32-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 32-bit value to.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOPutMaybeAligned32(void *p, const uint32_t v)
+{
+    if (nlIOIsAligned(p, sizeof (uint32_t)))
+        nlIOPutAligned32(p, v);
+    else
+        nlIOPutUnaligned32(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 64-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 64-bit value to.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOPutMaybeAligned64(void *p, const uint64_t v)
+{
+    if (nlIOIsAligned(p, sizeof (uint64_t)))
+        nlIOPutAligned64(p, v);
+    else
+        nlIOPutUnaligned64(p, v);
+}
+
+/**
+ * Perform an aligned memory read of the 8-bit value at the specified
+ * pointer address and increment the pointer by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the
+ *                    8-bit value from and to then increment by
+ *                    8-bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOReadAligned8(const void **p)
+{
+    const uint8_t temp = nlIOGetAligned8(*p);
+
+    *(const uint8_t **)(p) += sizeof (uint8_t);
+
+    return temp;
+}
+
+/**
+ * Perform an aligned memory read of the 16-bit value at the specified
+ * pointer address and increment the pointer by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the
+ *                    16-bit value from and to then increment by
+ *                    16-bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOReadAligned16(const void **p)
+{
+    const uint16_t temp = nlIOGetAligned16(*p);
+
+    *(const uint8_t **)(p) += sizeof (uint16_t);
+
+    return temp;
+}
+
+/**
+ * Perform an aligned memory read of the 32-bit value at the specified
+ * pointer address and increment the pointer by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the
+ *                    32-bit value from and to then increment by
+ *                    32-bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOReadAligned32(const void **p)
+{
+    const uint32_t temp = nlIOGetAligned32(*p);
+
+    *(const uint8_t **)(p) += sizeof (uint32_t);
+
+    return temp;
+}
+
+/**
+ * Perform an aligned memory read of the 64-bit value at the specified
+ * pointer address and increment the pointer by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the
+ *                    64-bit value from and to then increment by
+ *                    64-bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOReadAligned64(const void **p)
+{
+    const uint64_t temp = nlIOGetAligned64(*p);
+
+    *(const uint8_t **)(p) += sizeof (uint64_t);
+
+    return temp;
+}
+
+/**
+ * Perform an unaligned memory read of the 8-bit value at the specified
+ * pointer address and increment the pointer by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the
+ *                    8-bit value from and to then increment by
+ *                    8-bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t nlIOReadUnaligned8(const void **p)
+{
+    const uint8_t temp = nlIOGetUnaligned8(*p);
+
+    *(const uint8_t **)(p) += sizeof (uint8_t);
+
+    return temp;
+}
+
+/**
+ * Perform an unaligned memory read of the 16-bit value at the specified
+ * pointer address and increment the pointer by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the
+ *                    16-bit value from and to then increment by
+ *                    16-bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOReadUnaligned16(const void **p)
+{
+    const uint16_t temp = nlIOGetUnaligned16(*p);
+
+    *(const uint8_t **)(p) += sizeof (uint16_t);
+
+    return temp;
+}
+
+/**
+ * Perform an aligned memory read of the 32-bit value at the specified
+ * pointer address and increment the pointer by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the
+ *                    32-bit value from and to then increment by
+ *                    32-bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOReadUnaligned32(const void **p)
+{
+    const uint32_t temp = nlIOGetUnaligned32(*p);
+
+    *(const uint8_t **)(p) += sizeof (uint32_t);
+
+    return temp;
+}
+
+/**
+ * Perform an unaligned memory read of the 64-bit value at the specified
+ * pointer address and increment the pointer by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the
+ *                    64-bit value from and to then increment by
+ *                    64-bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOReadUnaligned64(const void **p)
+{
+    const uint64_t temp = nlIOGetUnaligned64(*p);
+
+    *(const uint8_t **)(p) += sizeof (uint64_t);
+
+    return temp;
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 8-bit value
+ * from the specified pointer address and increment the pointer by
+ * 8-bits (1 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 8-bit value from and to
+ *                    then increment by 8-bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOReadMaybeAligned8(const void **p)
+{
+    const uint8_t temp = nlIOGetMaybeAligned8(*p);
+
+    *(const uint8_t **)(p) += sizeof (uint8_t);
+
+    return temp;
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 16-bit value
+ * from the specified pointer address and increment the pointer by
+ * 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 16-bit value from and to
+ *                    then increment by 16-bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOReadMaybeAligned16(const void **p)
+{
+    const uint16_t temp = nlIOGetMaybeAligned16(*p);
+
+    *(const uint8_t **)(p) += sizeof (uint16_t);
+
+    return temp;
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 32-bit value
+ * from the specified pointer address and increment the pointer by
+ * 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 32-bit value from and to
+ *                    then increment by 32-bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOReadMaybeAligned32(const void **p)
+{
+    const uint32_t temp = nlIOGetMaybeAligned32(*p);
+
+    *(const uint8_t **)(p) += sizeof (uint32_t);
+
+    return temp;
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 64-bit value
+ * from the specified pointer address and increment the pointer by
+ * 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 64-bit value from and to
+ *                    then increment by 64-bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOReadMaybeAligned64(const void **p)
+{
+    const uint64_t temp = nlIOGetMaybeAligned64(*p);
+
+    *(const uint8_t **)(p) += sizeof (uint64_t);
+
+    return temp;
+}
+
+/**
+ * Perform an aligned memory write of the 8-bit value to the specified
+ * pointer address and increment the pointer by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the 8-bit
+ *                    value from and to then increment by 8-bits (1 byte).
+ *
+ * @param[in]     v   The 8-bit value to write.
+ *
+ */
+static inline void     nlIOWriteAligned8(void **p, const uint8_t v)
+{
+    nlIOPutAligned8(*p, v);       *(const uint8_t **)(p) += sizeof (uint8_t);
+}
+
+/**
+ * Perform an aligned memory write of the 16-bit value to the specified
+ * pointer address and increment the pointer by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the 16-bit
+ *                    value from and to then increment by 16-bits (2 bytes).
+ *
+ * @param[in]     v   The 16-bit value to write.
+ *
+ */
+static inline void     nlIOWriteAligned16(void **p, const uint16_t v)
+{
+    nlIOPutAligned16(*p, v);      *(const uint8_t **)(p) += sizeof (uint16_t);
+}
+
+/**
+ * Perform an aligned memory write of the 32-bit value to the specified
+ * pointer address and increment the pointer by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the 32-bit
+ *                    value from and to then increment by 32-bits (4 bytes).
+ *
+ * @param[in]     v   The 32-bit value to write.
+ *
+ */
+static inline void     nlIOWriteAligned32(void **p, const uint32_t v)
+{
+    nlIOPutAligned32(*p, v);      *(const uint8_t **)(p) += sizeof (uint32_t);
+}
+
+/**
+ * Perform an aligned memory write of the 64-bit value to the specified
+ * pointer address and increment the pointer by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the 64-bit
+ *                    value from and to then increment by 64-bits (8 bytes).
+ *
+ * @param[in]     v   The 64-bit value to write.
+ *
+ */
+static inline void     nlIOWriteAligned64(void **p, const uint64_t v)
+{
+    nlIOPutAligned64(*p, v);      *(const uint8_t **)(p) += sizeof (uint64_t);
+}
+
+/**
+ * Perform an unaligned memory write of the 8-bit value to the specified
+ * pointer address and increment the pointer by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the 8-bit
+ *                    value from and to then increment by 8-bits (1 byte).
+ *
+ * @param[in]     v   The 8-bit value to write.
+ *
+ */
+static inline void     nlIOWriteUnaligned8(void **p, const uint8_t v)
+{
+    nlIOPutUnaligned8(*p, v);     *(const uint8_t **)(p) += sizeof (uint8_t);
+}
+
+/**
+ * Perform an unaligned memory write of the 16-bit value to the specified
+ * pointer address and increment the pointer by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the 16-bit
+ *                    value from and to then increment by 16-bits (2 bytes).
+ *
+ * @param[in]     v   The 16-bit value to write.
+ *
+ */
+static inline void     nlIOWriteUnaligned16(void **p, const uint16_t v)
+{
+    nlIOPutUnaligned16(*p, v);    *(const uint8_t **)(p) += sizeof (uint16_t);
+}
+
+/**
+ * Perform an unaligned memory write of the 32-bit value to the specified
+ * pointer address and increment the pointer by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the 32-bit
+ *                    value from and to then increment by 32-bits (4 bytes).
+ *
+ * @param[in]     v   The 32-bit value to write.
+ *
+ */
+static inline void     nlIOWriteUnaligned32(void **p, const uint32_t v)
+{
+    nlIOPutUnaligned32(*p, v);    *(const uint8_t **)(p) += sizeof (uint32_t);
+}
+
+/**
+ * Perform an unaligned memory write of the 64-bit value to the specified
+ * pointer address and increment the pointer by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address to read the 64-bit
+ *                    value from and to then increment by 64-bits (8 bytes).
+ *
+ * @param[in]     v   The 64-bit value to write.
+ *
+ */
+static inline void     nlIOWriteUnaligned64(void **p, const uint64_t v)
+{
+    nlIOPutUnaligned64(*p, v);    *(const uint8_t **)(p) += sizeof (uint64_t);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 8-bit value
+ * to the specified pointer address and increment the pointer by
+ * 8-bits (2 byte).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 8-bit value from and to
+ *                    then increment by 8-bits (1 byte).
+ *
+ * @param[in]     v   The 8-bit value to write.
+ *
+ */
+static inline void     nlIOWriteMaybeAligned8(void **p, const uint8_t v)
+{
+    nlIOPutMaybeAligned8(*p, v);  *(const uint8_t **)(p) += sizeof (uint8_t);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 16-bit value
+ * to the specified pointer address and increment the pointer by
+ * 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 16-bit value from and to
+ *                    then increment by 16-bits (2 bytes).
+ *
+ * @param[in]     v   The 16-bit value to write.
+ *
+ */
+static inline void     nlIOWriteMaybeAligned16(void **p, const uint16_t v)
+{
+    nlIOPutMaybeAligned16(*p, v); *(const uint8_t **)(p) += sizeof (uint16_t);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 32-bit value
+ * to the specified pointer address and increment the pointer by
+ * 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 32-bit value from and to
+ *                    then increment by 32-bits (4 bytes).
+ *
+ * @param[in]     v   The 32-bit value to write.
+ *
+ */
+static inline void     nlIOWriteMaybeAligned32(void **p, const uint32_t v)
+{
+    nlIOPutMaybeAligned32(*p, v); *(const uint8_t **)(p) += sizeof (uint32_t);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 64-bit value
+ * to the specified pointer address and increment the pointer by
+ * 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 64-bit value from and to
+ *                    then increment by 64-bits (8 bytes).
+ *
+ * @param[in]     v   The 64-bit value to write.
+ *
+ */
+static inline void     nlIOWriteMaybeAligned64(void **p, const uint64_t v)
+{
+    nlIOPutMaybeAligned64(*p, v); *(const uint8_t **)(p) += sizeof (uint64_t);
+}
+
+/**
+ * Perform a memory read of the 8-bit value at the specified pointer
+ * address.
+ *
+ * @param[in]  p      A pointer address to read the 8-bit value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t nlIOGet8(const void *p)
+{
+    return nlIOGetAligned8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 16-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 16-bit value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOGet16(const void *p)
+{
+    return nlIOGetMaybeAligned16(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 32-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 32-bit value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOGet32(const void *p)
+{
+    return nlIOGetMaybeAligned32(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 64-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 64-bit value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOGet64(const void *p)
+{
+    return nlIOGetMaybeAligned64(p);
+}
+
+/**
+ * Perform a memory write of the 8-bit value to the specified pointer
+ * address.
+ *
+ * @param[in]  p      A pointer address to write the 8-bit value to.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void nlIOPut8(void *p, uint8_t v)
+{
+    nlIOPutAligned8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 16-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 16-bit value to.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void nlIOPut16(void *p, uint16_t v)
+{
+    nlIOPutMaybeAligned16(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 32-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 32-bit value to.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void nlIOPut32(void *p, uint32_t v)
+{
+    nlIOPutMaybeAligned32(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 64-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 64-bit value to.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void nlIOPut64(void *p, uint64_t v)
+{
+    nlIOPutMaybeAligned64(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 16-bit value
+ * from the specified pointer address and increment the pointer by
+ * 8-bits (1 byte).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 8-bit value from and to
+ *                    then increment by 8-bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIORead8(const void **p)
+{
+    return nlIOReadAligned8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 16-bit value
+ * from the specified pointer address and increment the pointer by
+ * 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 16-bit value from and to
+ *                    then increment by 16-bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIORead16(const void **p)
+{
+    return nlIOReadMaybeAligned16(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 32-bit value
+ * from the specified pointer address and increment the pointer by
+ * 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 32-bit value from and to
+ *                    then increment by 32-bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIORead32(const void **p)
+{
+    return nlIOReadMaybeAligned32(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 64-bit value
+ * from the specified pointer address and increment the pointer by
+ * 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 64-bit value from and to
+ *                    then increment by 64-bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIORead64(const void **p)
+{
+    return nlIOReadMaybeAligned64(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 8-bit value
+ * to the specified pointer address and increment the pointer by
+ * 8-bits (1 byte).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 8-bit value from and to
+ *                    then increment by 8-bits (1 byte).
+ *
+ * @param[in]     v   The 8-bit value to write.
+ *
+ */
+static inline void nlIOWrite8(void **p, uint8_t v)
+{
+    nlIOWriteAligned8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 16-bit value
+ * to the specified pointer address and increment the pointer by
+ * 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 16-bit value from and to
+ *                    then increment by 16-bits (2 bytes).
+ *
+ * @param[in]     v   The 16-bit value to write.
+ *
+ */
+static inline void nlIOWrite16(void **p, uint16_t v)
+{
+    nlIOWriteMaybeAligned16(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 32-bit value
+ * to the specified pointer address and increment the pointer by
+ * 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 32-bit value from and to
+ *                    then increment by 32-bits (4 bytes).
+ *
+ * @param[in]     v   The 32-bit value to write.
+ *
+ */
+static inline void nlIOWrite32(void **p, uint32_t v)
+{
+    nlIOWriteMaybeAligned32(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 64-bit value
+ * to the specified pointer address and increment the pointer by
+ * 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 64-bit value from and to
+ *                    then increment by 64-bits (8 bytes).
+ *
+ * @param[in]     v   The 64-bit value to write.
+ *
+ */
+static inline void nlIOWrite64(void **p, uint64_t v)
+{
+    nlIOWriteMaybeAligned64(p, v);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#undef __nlIO_MEMCPY
+
+#endif /* NLIO_BASE_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/nlio-base.hpp b/cores/nRF5/nordic/config/nrf52840/configxx/nlio-base.hpp
new file mode 100644
index 000000000..e176c353a
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/nlio-base.hpp
@@ -0,0 +1,1025 @@
+/**
+ *    Copyright 2013-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines C++ functions for safely performing simple,
+ *      memory-mapped accesses, potentially to unaligned memory
+ *      locations.
+ */
+
+#ifndef NLIO_BASE_HPP
+#define NLIO_BASE_HPP
+
+#include <nlio-base.h>
+
+namespace nl
+{
+
+namespace IO
+{
+
+/**
+ * This determines whether the specified pointer is aligned on the
+ * indicated size boundary.
+ *
+ * @note The size should be a power of 2 (e.g. 1, 2, 4, 8, 16, etc.).
+ *
+ * @param[in]  p     The pointer to check the alignment of.
+ * @param[in]  size  The size, in bytes, boundary to check
+ *                   the alignment against.
+ *
+ * @return True if the pointer is aligned to the specified size;
+ *         otherwise, false.
+ */
+static inline bool IsAligned(const void *p, size_t size)
+{
+    return nlIOIsAligned(p, size);
+}
+
+/**
+ * This determines whether the specified pointer is aligned on the
+ * size boundary for the template type, T.
+ *
+ * @tparam     T     The type of pointer to check the alignment of.
+ *
+ * @param[in]  p     The pointer to check the alignment of.
+ *
+ * @return True if the pointer is aligned to size of the type;
+ *         otherwise, false.
+ */
+template <typename T>
+static inline bool IsAligned(const T *p)
+{
+    return nlIOIsAligned(p, sizeof(T));
+}
+
+/**
+ * Perform an aligned memory read of the 8-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 8-bit value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  GetAligned8(const void *p)
+{
+    return nlIOGetAligned8(p);
+}
+
+/**
+ * Perform an aligned memory read of the 16-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 16-bit value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t GetAligned16(const void *p)
+{
+    return nlIOGetAligned16(p);
+}
+
+/**
+ * Perform an aligned memory read of the 32-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 32-bit value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t GetAligned32(const void *p)
+{
+    return nlIOGetAligned32(p);
+}
+
+/**
+ * Perform an aligned memory read of the 64-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 64-bit value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t GetAligned64(const void *p)
+{
+    return nlIOGetAligned64(p);
+}
+
+/**
+ * Perform an unaligned memory read of the 8-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 8-bit value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  GetUnaligned8(const void *p)
+{
+    return nlIOGetUnaligned8(p);
+}
+
+/**
+ * Perform an unaligned memory read of the 16-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 16-bit value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t GetUnaligned16(const void *p)
+{
+    return nlIOGetUnaligned16(p);
+}
+
+/**
+ * Perform an unaligned memory read of the 32-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 32-bit value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t GetUnaligned32(const void *p)
+{
+    return nlIOGetUnaligned32(p);
+}
+
+/**
+ * Perform an unaligned memory read of the 64-bit value at the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to read the 64-bit value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t GetUnaligned64(const void *p)
+{
+    return nlIOGetUnaligned64(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 8-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 8-bit value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  GetMaybeAligned8(const void *p)
+{
+    return nlIOGetMaybeAligned8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 16-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 16-bit value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t GetMaybeAligned16(const void *p)
+{
+    return nlIOGetMaybeAligned16(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 32-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 32-bit value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t GetMaybeAligned32(const void *p)
+{
+    return nlIOGetMaybeAligned32(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 64-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 64-bit value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t GetMaybeAligned64(const void *p)
+{
+    return nlIOGetMaybeAligned64(p);
+}
+
+/**
+ * Perform an aligned memory write of the 8-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 8-bit value to.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     PutAligned8(void *p, const uint8_t v)
+{
+    nlIOPutAligned8(p, v);
+}
+
+/**
+ * Perform an aligned memory write of the 16-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 16-bit value to.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     PutAligned16(void *p, const uint16_t v)
+{
+    nlIOPutAligned16(p, v);
+}
+
+/**
+ * Perform an aligned memory write of the 32-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 32-bit value to.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     PutAligned32(void *p, const uint32_t v)
+{
+    nlIOPutAligned32(p, v);
+}
+
+/**
+ * Perform an aligned memory write of the 64-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 64-bit value to.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     PutAligned64(void *p, const uint64_t v)
+{
+    nlIOPutAligned64(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the 8-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 8-bit value to.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     PutUnaligned8(void *p, const uint8_t v)
+{
+    nlIOPutUnaligned8(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the 16-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 16-bit value to.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     PutUnaligned16(void *p, const uint16_t v)
+{
+    nlIOPutUnaligned16(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the 32-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 32-bit value to.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     PutUnaligned32(void *p, const uint32_t v)
+{
+    nlIOPutUnaligned32(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the 64-bit value to the specified
+ * pointer address.
+ *
+ * @param[in]  p      A pointer address to write the 64-bit value to.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     PutUnaligned64(void *p, const uint64_t v)
+{
+    nlIOPutUnaligned64(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 8-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 8-bit value to.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     PutMaybeAligned8(void *p, const uint8_t v)
+{
+    nlIOPutMaybeAligned8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 16-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 16-bit value to.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     PutMaybeAligned16(void *p, const uint16_t v)
+{
+    nlIOPutMaybeAligned16(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 32-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 32-bit value to.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     PutMaybeAligned32(void *p, const uint32_t v)
+{
+    nlIOPutMaybeAligned32(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 64-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 64-bit value to.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     PutMaybeAligned64(void *p, const uint64_t v)
+{
+    nlIOPutMaybeAligned64(p, v);
+}
+
+/**
+ * Perform an aligned memory read of the 8-bit value at the specified
+ * pointer address and increment the pointer by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the
+ *                    8-bit value from and to then increment by
+ *                    8-bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  ReadAligned8(const void *&p)
+{
+    return nlIOReadAligned8(&p);
+}
+
+/**
+ * Perform an aligned memory read of the 16-bit value at the specified
+ * pointer address and increment the pointer by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the
+ *                    16-bit value from and to then increment by
+ *                    16-bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t ReadAligned16(const void *&p)
+{
+    return nlIOReadAligned16(&p);
+}
+
+/**
+ * Perform an aligned memory read of the 32-bit value at the specified
+ * pointer address and increment the pointer by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the
+ *                    32-bit value from and to then increment by
+ *                    32-bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t ReadAligned32(const void *&p)
+{
+    return nlIOReadAligned32(&p);
+}
+
+/**
+ * Perform an aligned memory read of the 64-bit value at the specified
+ * pointer address and increment the pointer by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the
+ *                    64-bit value from and to then increment by
+ *                    64-bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t ReadAligned64(const void *&p)
+{
+    return nlIOReadAligned64(&p);
+}
+
+/**
+ * Perform an unaligned memory read of the 8-bit value at the specified
+ * pointer address and increment the pointer by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the
+ *                    8-bit value from and to then increment by
+ *                    8-bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t ReadUnaligned8(const void *&p)
+{
+    return nlIOReadUnaligned8(&p);
+}
+
+/**
+ * Perform an unaligned memory read of the 16-bit value at the specified
+ * pointer address and increment the pointer by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the
+ *                    16-bit value from and to then increment by
+ *                    16-bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t ReadUnaligned16(const void *&p)
+{
+    return nlIOReadUnaligned16(&p);
+}
+
+/**
+ * Perform an aligned memory read of the 32-bit value at the specified
+ * pointer address and increment the pointer by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the
+ *                    32-bit value from and to then increment by
+ *                    32-bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t ReadUnaligned32(const void *&p)
+{
+    return nlIOReadUnaligned32(&p);
+}
+
+/**
+ * Perform an unaligned memory read of the 64-bit value at the specified
+ * pointer address and increment the pointer by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the
+ *                    64-bit value from and to then increment by
+ *                    64-bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t ReadUnaligned64(const void *&p)
+{
+    return nlIOReadUnaligned64(&p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 8-bit value
+ * from the specified pointer address and increment the pointer by
+ * 8-bits (1 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 8-bit value from and to
+ *                    then increment by 8-bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  ReadMaybeAligned8(const void *&p)
+{
+    return nlIOReadMaybeAligned8(&p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 16-bit value
+ * from the specified pointer address and increment the pointer by
+ * 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 16-bit value from and to
+ *                    then increment by 16-bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t ReadMaybeAligned16(const void *&p)
+{
+    return nlIOReadMaybeAligned16(&p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 32-bit value
+ * from the specified pointer address and increment the pointer by
+ * 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 32-bit value from and to
+ *                    then increment by 32-bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t ReadMaybeAligned32(const void *&p)
+{
+    return nlIOReadMaybeAligned32(&p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 64-bit value
+ * from the specified pointer address and increment the pointer by
+ * 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 64-bit value from and to
+ *                    then increment by 64-bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t ReadMaybeAligned64(const void *&p)
+{
+    return nlIOReadMaybeAligned64(&p);
+}
+
+/**
+ * Perform an aligned memory write of the 8-bit value to the specified
+ * pointer address and increment the pointer by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the 8-bit
+ *                    value from and to then increment by 8-bits (1 byte).
+ *
+ * @param[in]     v   The 8-bit value to write.
+ *
+ */
+static inline void     WriteAligned8(void *&p, const uint8_t v)
+{
+    nlIOWriteAligned8(&p, v);
+}
+
+/**
+ * Perform an aligned memory write of the 16-bit value to the specified
+ * pointer address and increment the pointer by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the 16-bit
+ *                    value from and to then increment by 16-bits (2 bytes).
+ *
+ * @param[in]     v   The 16-bit value to write.
+ *
+ */
+static inline void     WriteAligned16(void *&p, const uint16_t v)
+{
+    nlIOWriteAligned16(&p, v);
+}
+
+/**
+ * Perform an aligned memory write of the 32-bit value to the specified
+ * pointer address and increment the pointer by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the 32-bit
+ *                    value from and to then increment by 32-bits (4 bytes).
+ *
+ * @param[in]     v   The 32-bit value to write.
+ *
+ */
+static inline void     WriteAligned32(void *&p, const uint32_t v)
+{
+    nlIOWriteAligned32(&p, v);
+}
+
+/**
+ * Perform an aligned memory write of the 64-bit value to the specified
+ * pointer address and increment the pointer by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the 64-bit
+ *                    value from and to then increment by 64-bits (8 bytes).
+ *
+ * @param[in]     v   The 64-bit value to write.
+ *
+ */
+static inline void     WriteAligned64(void *&p, const uint64_t v)
+{
+    nlIOWriteAligned64(&p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the 8-bit value to the specified
+ * pointer address and increment the pointer by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the 8-bit
+ *                    value from and to then increment by 8-bits (1 byte).
+ *
+ * @param[in]     v   The 8-bit value to write.
+ *
+ */
+static inline void     WriteUnaligned8(void *&p, const uint8_t v)
+{
+    nlIOWriteUnaligned8(&p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the 16-bit value to the specified
+ * pointer address and increment the pointer by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the 16-bit
+ *                    value from and to then increment by 16-bits (2 bytes).
+ *
+ * @param[in]     v   The 16-bit value to write.
+ *
+ */
+static inline void     WriteUnaligned16(void *&p, const uint16_t v)
+{
+    nlIOWriteUnaligned16(&p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the 32-bit value to the specified
+ * pointer address and increment the pointer by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the 32-bit
+ *                    value from and to then increment by 32-bits (4 bytes).
+ *
+ * @param[in]     v   The 32-bit value to write.
+ *
+ */
+static inline void     WriteUnaligned32(void *&p, const uint32_t v)
+{
+    nlIOWriteUnaligned32(&p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the 64-bit value to the specified
+ * pointer address and increment the pointer by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address to read the 64-bit
+ *                    value from and to then increment by 64-bits (8 bytes).
+ *
+ * @param[in]     v   The 64-bit value to write.
+ *
+ */
+static inline void     WriteUnaligned64(void *&p, const uint64_t v)
+{
+    nlIOWriteUnaligned64(&p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 8-bit value
+ * to the specified pointer address and increment the pointer by
+ * 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 8-bit value from and to
+ *                    then increment by 8-bits (1 byte).
+ *
+ * @param[in]     v   The 8-bit value to write.
+ *
+ */
+static inline void     WriteMaybeAligned8(void *&p, const uint8_t v)
+{
+    nlIOWriteMaybeAligned8(&p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 16-bit value
+ * to the specified pointer address and increment the pointer by
+ * 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 16-bit value from and to
+ *                    then increment by 16-bits (2 bytes).
+ *
+ * @param[in]     v   The 16-bit value to write.
+ *
+ */
+static inline void     WriteMaybeAligned16(void *&p, const uint16_t v)
+{
+    nlIOWriteMaybeAligned16(&p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 32-bit value
+ * to the specified pointer address and increment the pointer by
+ * 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 32-bit value from and to
+ *                    then increment by 32-bits (4 bytes).
+ *
+ * @param[in]     v   The 32-bit value to write.
+ *
+ */
+static inline void     WriteMaybeAligned32(void *&p, const uint32_t v)
+{
+    nlIOWriteMaybeAligned32(&p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 64-bit value
+ * to the specified pointer address and increment the pointer by
+ * 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 64-bit value from and to
+ *                    then increment by 64-bits (8 bytes).
+ *
+ * @param[in]     v   The 64-bit value to write.
+ *
+ */
+static inline void     WriteMaybeAligned64(void *&p, const uint64_t v)
+{
+    nlIOWriteMaybeAligned64(&p, v);
+}
+
+/**
+ * Perform a memory read of the 8-bit value at the specified pointer
+ * address.
+ *
+ * @param[in]  p      A pointer address to read the 8-bit value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  Get8(const void *p)
+{
+    return nlIOGet8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 16-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 16-bit value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t Get16(const void *p)
+{
+    return nlIOGet16(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 32-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 32-bit value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t Get32(const void *p)
+{
+    return nlIOGet32(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 64-bit value
+ * from the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 64-bit value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t Get64(const void *p)
+{
+    return nlIOGet64(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 8-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 8-bit value to.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void Put8(void *p, const uint8_t v)
+{
+    nlIOPut8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 16-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 16-bit value to.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void Put16(void *p, const uint16_t v)
+{
+    nlIOPut16(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 32-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 32-bit value to.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void Put32(void *p, const uint32_t v)
+{
+    nlIOPut32(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 64-bit value
+ * to the specified pointer address.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the 64-bit value to.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void Put64(void *p, const uint64_t v)
+{
+    nlIOPut64(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 16-bit value
+ * from the specified pointer address and increment the pointer by
+ * 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 8-bit value from and to
+ *                    then increment by 8-bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  Read8(const void *&p)
+{
+    return nlIORead8(&p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 16-bit value
+ * from the specified pointer address and increment the pointer by
+ * 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 16-bit value from and to
+ *                    then increment by 16-bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t Read16(const void *&p)
+{
+    return nlIORead16(&p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 32-bit value
+ * from the specified pointer address and increment the pointer by
+ * 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 32-bit value from and to
+ *                    then increment by 32-bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t Read32(const void *&p)
+{
+    return nlIORead32(&p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the 64-bit value
+ * from the specified pointer address and increment the pointer by
+ * 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 64-bit value from and to
+ *                    then increment by 64-bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t Read64(const void *&p)
+{
+    return nlIORead64(&p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 8-bit value
+ * to the specified pointer address and increment the pointer by
+ * 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 8-bit value from and to
+ *                    then increment by 8-bits (1 byte).
+ *
+ * @param[in]     v   The 8-bit value to write.
+ *
+ */
+static inline void Write8(void *&p, const uint8_t v)
+{
+    nlIOWrite8(&p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 16-bit value
+ * to the specified pointer address and increment the pointer by
+ * 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 16-bit value from and to
+ *                    then increment by 16-bits (2 bytes).
+ *
+ * @param[in]     v   The 16-bit value to write.
+ *
+ */
+static inline void Write16(void *&p, const uint16_t v)
+{
+    nlIOWrite16(&p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 32-bit value
+ * to the specified pointer address and increment the pointer by
+ * 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 32-bit value from and to
+ *                    then increment by 32-bits (4 bytes).
+ *
+ * @param[in]     v   The 32-bit value to write.
+ *
+ */
+static inline void Write32(void *&p, const uint32_t v)
+{
+    nlIOWrite32(&p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the 64-bit value
+ * to the specified pointer address and increment the pointer by
+ * 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 64-bit value from and to
+ *                    then increment by 64-bits (8 bytes).
+ *
+ * @param[in]     v   The 64-bit value to write.
+ *
+ */
+static inline void Write64(void *&p, const uint64_t v)
+{
+    nlIOWrite64(&p, v);
+}
+
+} // namespace IO
+
+} // namespace nl
+
+#endif // NLIO_BASE_HPP
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/nlio-byteorder-big.h b/cores/nRF5/nordic/config/nrf52840/configxx/nlio-byteorder-big.h
new file mode 100644
index 000000000..a9ab69c36
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/nlio-byteorder-big.h
@@ -0,0 +1,915 @@
+/**
+ *    Copyright 2013-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines C functions for safely performing simple,
+ *      memory-mapped accesses, potentially to unaligned, aligned, and
+ *      unaligned memory locations with byte reordering, specifically
+ *      for big endian target systems.
+ */
+
+#ifndef NLIO_BYTEORDER_BIG_H
+#define NLIO_BYTEORDER_BIG_H
+
+#include <nlio-base.h>
+#include <nlbyteorder.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 8-bit big endian byte ordered value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOBigEndianGet8(const void *p)
+{
+    return nlIOGet8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 16-bit big endian byte ordered value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOBigEndianGet16(const void *p)
+{
+    return nlByteOrderSwap16BigToHost(nlIOGet16(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 32-bit big endian byte ordered value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOBigEndianGet32(const void *p)
+{
+    return nlByteOrderSwap32BigToHost(nlIOGet32(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 64-bit big endian byte ordered value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOBigEndianGet64(const void *p)
+{
+    return nlByteOrderSwap64BigToHost(nlIOGet64(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 8-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianPut8(void *p, uint8_t v)
+{
+    nlIOPut8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 16-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianPut16(void *p, uint16_t v)
+{
+    nlIOPut16(p, nlByteOrderSwap16HostToBig(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 32-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianPut32(void *p, uint32_t v)
+{
+    nlIOPut32(p, nlByteOrderSwap32HostToBig(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 64-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianPut64(void *p, uint64_t v)
+{
+    nlIOPut64(p, nlByteOrderSwap64HostToBig(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 8-bit big endian byte
+ *                    ordered value from and to then increment by 8-
+ *                    bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOBigEndianRead8(const void **p)
+{
+    return nlIORead8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 16-bit big endian byte
+ *                    ordered value from and to then increment by 16-
+ *                    bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOBigEndianRead16(const void **p)
+{
+    return nlByteOrderSwap16BigToHost(nlIORead16(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 32-bit big endian byte
+ *                    ordered value from and to then increment by 32-
+ *                    bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOBigEndianRead32(const void **p)
+{
+    return nlByteOrderSwap32BigToHost(nlIORead32(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 64-bit big endian byte
+ *                    ordered value from and to then increment by 64-
+ *                    bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOBigEndianRead64(const void **p)
+{
+    return nlByteOrderSwap64BigToHost(nlIORead64(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A pointer to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 8-bit value to in big endian byte
+ *                    ordering and to then increment by 8-bits (1
+ *                    byte).
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianWrite8(void **p, uint8_t v)
+{
+    nlIOWrite8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A pointer to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 16-bit value to in big endian byte
+ *                    ordering and to then increment by 16-bits (2
+ *                    bytes).
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianWrite16(void **p, uint16_t v)
+{
+    nlIOWrite16(p, nlByteOrderSwap16HostToBig(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A pointer to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 32-bit value to in big endian byte
+ *                    ordering and to then increment by 16-bits (4
+ *                    bytes).
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianWrite32(void **p, uint32_t v)
+{
+    nlIOWrite32(p, nlByteOrderSwap32HostToBig(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A pointer to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 64-bit value to in big endian byte
+ *                    ordering and to then increment by 64-bits (8
+ *                    bytes).
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianWrite64(void **p, uint64_t v)
+{
+    nlIOWrite64(p, nlByteOrderSwap64HostToBig(v));
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 8-bit big endian byte ordered value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOBigEndianGetAligned8(const void *p)
+{
+    return nlIOGetAligned8(p);
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 16-bit big endian byte ordered value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOBigEndianGetAligned16(const void *p)
+{
+    return nlByteOrderSwap16BigToHost(nlIOGetAligned16(p));
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 32-bit big endian byte ordered value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOBigEndianGetAligned32(const void *p)
+{
+    return nlByteOrderSwap32BigToHost(nlIOGetAligned32(p));
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 64-bit big endian byte ordered value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOBigEndianGetAligned64(const void *p)
+{
+    return nlByteOrderSwap64BigToHost(nlIOGetAligned64(p));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 8-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianPutAligned8(void *p, uint8_t v)
+{
+    nlIOPutAligned8(p, v);
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 16-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianPutAligned16(void *p, uint16_t v)
+{
+    nlIOPutAligned16(p, nlByteOrderSwap16HostToBig(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 32-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianPutAligned32(void *p, uint32_t v)
+{
+    nlIOPutAligned32(p, nlByteOrderSwap32HostToBig(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 64-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianPutAligned64(void *p, uint64_t v)
+{
+    nlIOPutAligned64(p, nlByteOrderSwap64HostToBig(v));
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to read the 8-bit big endian byte
+ *                    ordered value from and to then increment by 8-
+ *                    bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOBigEndianReadAligned8(const void **p)
+{
+    return nlIOReadAligned8(p);
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to read the 16-bit big endian byte
+ *                    ordered value from and to then increment by 16-
+ *                    bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOBigEndianReadAligned16(const void **p)
+{
+    return nlByteOrderSwap16BigToHost(nlIOReadAligned16(p));
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to read the 32-bit big endian byte
+ *                    ordered value from and to then increment by 32-
+ *                    bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOBigEndianReadAligned32(const void **p)
+{
+    return nlByteOrderSwap32BigToHost(nlIOReadAligned32(p));
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to read the 64-bit big endian byte
+ *                    ordered value from and to then increment by 64-
+ *                    bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOBigEndianReadAligned64(const void **p)
+{
+    return nlByteOrderSwap64BigToHost(nlIOReadAligned64(p));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to write the target system byte
+ *                    ordered 8-bit value to in big endian byte
+ *                    ordering and to then increment by 8-bits (1
+ *                    byte).
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianWriteAligned8(void **p, uint8_t v)
+{
+    nlIOWriteAligned8(p, v);
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to write the target system byte
+ *                    ordered 16-bit value to in big endian byte
+ *                    ordering and to then increment by 16-bits (2
+ *                    bytes).
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianWriteAligned16(void **p, uint16_t v)
+{
+    nlIOWriteAligned16(p, nlByteOrderSwap16HostToBig(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to write the target system byte
+ *                    ordered 32-bit value to in big endian byte
+ *                    ordering and to then increment by 16-bits (4
+ *                    bytes).
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianWriteAligned32(void **p, uint32_t v)
+{
+    nlIOWriteAligned32(p, nlByteOrderSwap32HostToBig(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to write the target system byte
+ *                    ordered 64-bit value to in big endian byte
+ *                    ordering and to then increment by 64-bits (8
+ *                    bytes).
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianWriteAligned64(void **p, uint64_t v)
+{
+    nlIOWriteAligned64(p, nlByteOrderSwap64HostToBig(v));
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 8-bit big endian byte ordered value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOBigEndianGetUnaligned8(const void *p)
+{
+    return nlIOGetUnaligned8(p);
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 16-bit big endian byte ordered value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOBigEndianGetUnaligned16(const void *p)
+{
+    return nlByteOrderSwap16BigToHost(nlIOGetUnaligned16(p));
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 32-bit big endian byte ordered value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOBigEndianGetUnaligned32(const void *p)
+{
+    return nlByteOrderSwap32BigToHost(nlIOGetUnaligned32(p));
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 64-bit big endian byte ordered value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOBigEndianGetUnaligned64(const void *p)
+{
+    return nlByteOrderSwap64BigToHost(nlIOGetUnaligned64(p));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 8-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianPutUnaligned8(void *p, uint8_t v)
+{
+    nlIOPutUnaligned8(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 16-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianPutUnaligned16(void *p, uint16_t v)
+{
+    nlIOPutUnaligned16(p, nlByteOrderSwap16HostToBig(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 32-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianPutUnaligned32(void *p, uint32_t v)
+{
+    nlIOPutUnaligned32(p, nlByteOrderSwap32HostToBig(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 64-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianPutUnaligned64(void *p, uint64_t v)
+{
+    nlIOPutUnaligned64(p, nlByteOrderSwap64HostToBig(v));
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to read the 8-bit big endian byte
+ *                    ordered value from and to then increment by 8-
+ *                    bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOBigEndianReadUnaligned8(const void **p)
+{
+    return nlIOReadUnaligned8(p);
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to read the 16-bit big endian byte
+ *                    ordered value from and to then increment by 16-
+ *                    bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOBigEndianReadUnaligned16(const void **p)
+{
+    return nlByteOrderSwap16BigToHost(nlIOReadUnaligned16(p));
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to read the 32-bit big endian byte
+ *                    ordered value from and to then increment by 32-
+ *                    bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOBigEndianReadUnaligned32(const void **p)
+{
+    return nlByteOrderSwap32BigToHost(nlIOReadUnaligned32(p));
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to read the 64-bit big endian byte
+ *                    ordered value from and to then increment by 64-
+ *                    bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOBigEndianReadUnaligned64(const void **p)
+{
+    return nlByteOrderSwap64BigToHost(nlIOReadUnaligned64(p));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to write the target system byte
+ *                    ordered 8-bit value to in big endian byte
+ *                    ordering and to then increment by 8-bits (1
+ *                    byte).
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianWriteUnaligned8(void **p, uint8_t v)
+{
+    nlIOWriteUnaligned8(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to write the target system byte
+ *                    ordered 16-bit value to in big endian byte
+ *                    ordering and to then increment by 16-bits (2
+ *                    bytes).
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianWriteUnaligned16(void **p, uint16_t v)
+{
+    nlIOWriteUnaligned16(p, nlByteOrderSwap16HostToBig(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to write the target system byte
+ *                    ordered 32-bit value to in big endian byte
+ *                    ordering and to then increment by 32-bits (4
+ *                    bytes).
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianWriteUnaligned32(void **p, uint32_t v)
+{
+    nlIOWriteUnaligned32(p, nlByteOrderSwap32HostToBig(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to write the target system byte
+ *                    ordered 64-bit value to in big endian byte
+ *                    ordering and to then increment by 64-bits (8
+ *                    bytes).
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOBigEndianWriteUnaligned64(void **p, uint64_t v)
+{
+    nlIOWriteUnaligned64(p, nlByteOrderSwap64HostToBig(v));
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NLIO_BYTEORDER_BIG_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/nlio-byteorder-big.hpp b/cores/nRF5/nordic/config/nrf52840/configxx/nlio-byteorder-big.hpp
new file mode 100644
index 000000000..0d1e96f10
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/nlio-byteorder-big.hpp
@@ -0,0 +1,922 @@
+/**
+ *    Copyright 2013-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines C++ functions for safely performing simple,
+ *      memory-mapped accesses, potentially to unaligned, aligned, and
+ *      unaligned memory locations with byte reordering, specifically
+ *      for big endian target systems.
+ */
+
+#ifndef NLIO_BYTEORDER_BIG_HPP
+#define NLIO_BYTEORDER_BIG_HPP
+
+#include <nlio-base.hpp>
+#include <nlbyteorder.hpp>
+
+namespace nl
+{
+
+namespace IO
+{
+
+namespace BigEndian
+{
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 8-bit big endian byte ordered value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  Get8(const void *p)
+{
+    return IO::Get8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 16-bit big endian byte ordered value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t Get16(const void *p)
+{
+    return ByteOrder::Swap16BigToHost(IO::Get16(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 32-bit big endian byte ordered value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t Get32(const void *p)
+{
+    return ByteOrder::Swap32BigToHost(IO::Get32(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 64-bit big endian byte ordered value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t Get64(const void *p)
+{
+    return ByteOrder::Swap64BigToHost(IO::Get64(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 8-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     Put8(void *p, uint8_t v)
+{
+    IO::Put8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 16-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     Put16(void *p, uint16_t v)
+{
+    IO::Put16(p, ByteOrder::Swap16HostToBig(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 32-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     Put32(void *p, uint32_t v)
+{
+    IO::Put32(p, ByteOrder::Swap32HostToBig(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 64-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     Put64(void *p, uint64_t v)
+{
+    IO::Put64(p, ByteOrder::Swap64HostToBig(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 8-bit big endian byte
+ *                    ordered value from and to then increment by 8-
+ *                    bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  Read8(const void *&p)
+{
+    return IO::Read8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 16-bit big endian byte
+ *                    ordered value from and to then increment by 16-
+ *                    bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t Read16(const void *&p)
+{
+    return ByteOrder::Swap16BigToHost(IO::Read16(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 32-bit big endian byte
+ *                    ordered value from and to then increment by 32-
+ *                    bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t Read32(const void *&p)
+{
+    return ByteOrder::Swap32BigToHost(IO::Read32(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the big endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 64-bit big endian byte
+ *                    ordered value from and to then increment by 64-
+ *                    bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t Read64(const void *&p)
+{
+    return ByteOrder::Swap64BigToHost(IO::Read64(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A reference to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 8-bit value to in big endian byte
+ *                    ordering and to then increment by 8-bits (1
+ *                    byte).
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     Write8(void *&p, uint8_t v)
+{
+    IO::Write8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A reference to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 16-bit value to in big endian byte
+ *                    ordering and to then increment by 16-bits (2
+ *                    bytes).
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     Write16(void *&p, uint16_t v)
+{
+    IO::Write16(p, ByteOrder::Swap16HostToBig(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A reference to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 32-bit value to in big endian byte
+ *                    ordering and to then increment by 16-bits (4
+ *                    bytes).
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     Write32(void *&p, uint32_t v)
+{
+    IO::Write32(p, ByteOrder::Swap32HostToBig(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      A reference to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 64-bit value to in big endian byte
+ *                    ordering and to then increment by 64-bits (8
+ *                    bytes).
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     Write64(void *&p, uint64_t v)
+{
+    IO::Write64(p, ByteOrder::Swap64HostToBig(v));
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 8-bit big endian byte ordered value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  GetAligned8(const void *p)
+{
+    return IO::GetAligned8(p);
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 16-bit big endian byte ordered value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t GetAligned16(const void *p)
+{
+    return ByteOrder::Swap16BigToHost(IO::GetAligned16(p));
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 32-bit big endian byte ordered value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t GetAligned32(const void *p)
+{
+    return ByteOrder::Swap32BigToHost(IO::GetAligned32(p));
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 64-bit big endian byte ordered value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t GetAligned64(const void *p)
+{
+    return ByteOrder::Swap64BigToHost(IO::GetAligned64(p));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 8-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     PutAligned8(void *p, uint8_t v)
+{
+    IO::PutAligned8(p, v);
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 16-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     PutAligned16(void *p, uint16_t v)
+{
+    IO::PutAligned16(p, ByteOrder::Swap16HostToBig(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 32-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     PutAligned32(void *p, uint32_t v)
+{
+    IO::PutAligned32(p, ByteOrder::Swap32HostToBig(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 64-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     PutAligned64(void *p, uint64_t v)
+{
+    IO::PutAligned64(p, ByteOrder::Swap64HostToBig(v));
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to read the 8-bit big endian byte
+ *                    ordered value from and to then increment by 8-
+ *                    bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  ReadAligned8(const void *&p)
+{
+    return IO::ReadAligned8(p);
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to read the 16-bit big endian byte
+ *                    ordered value from and to then increment by 16-
+ *                    bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t ReadAligned16(const void *&p)
+{
+    return ByteOrder::Swap16BigToHost(IO::ReadAligned16(p));
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to read the 32-bit big endian byte
+ *                    ordered value from and to then increment by 32-
+ *                    bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t ReadAligned32(const void *&p)
+{
+    return ByteOrder::Swap32BigToHost(IO::ReadAligned32(p));
+}
+
+/**
+ * Perform an aligned memory read of the big endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to read the 64-bit big endian byte
+ *                    ordered value from and to then increment by 64-
+ *                    bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t ReadAligned64(const void *&p)
+{
+    return ByteOrder::Swap64BigToHost(IO::ReadAligned64(p));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to write the target system byte
+ *                    ordered 8-bit value to in big endian byte
+ *                    ordering and to then increment by 8-bits (1
+ *                    byte).
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     WriteAligned8(void *&p, uint8_t v)
+{
+    IO::WriteAligned8(p, v);
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to write the target system byte
+ *                    ordered 16-bit value to in big endian byte
+ *                    ordering and to then increment by 16-bits (2
+ *                    bytes).
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     WriteAligned16(void *&p, uint16_t v)
+{
+    IO::WriteAligned16(p, ByteOrder::Swap16HostToBig(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to write the target system byte
+ *                    ordered 32-bit value to in big endian byte
+ *                    ordering and to then increment by 16-bits (4
+ *                    bytes).
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     WriteAligned32(void *&p, uint32_t v)
+{
+    IO::WriteAligned32(p, ByteOrder::Swap32HostToBig(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to write the target system byte
+ *                    ordered 64-bit value to in big endian byte
+ *                    ordering and to then increment by 64-bits (8
+ *                    bytes).
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     WriteAligned64(void *&p, uint64_t v)
+{
+    IO::WriteAligned64(p, ByteOrder::Swap64HostToBig(v));
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 8-bit big endian byte ordered value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  GetUnaligned8(const void *p)
+{
+    return IO::GetUnaligned8(p);
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 16-bit big endian byte ordered value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t GetUnaligned16(const void *p)
+{
+    return ByteOrder::Swap16BigToHost(IO::GetUnaligned16(p));
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 32-bit big endian byte ordered value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t GetUnaligned32(const void *p)
+{
+    return ByteOrder::Swap32BigToHost(IO::GetUnaligned32(p));
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 64-bit big endian byte ordered value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t GetUnaligned64(const void *p)
+{
+    return ByteOrder::Swap64BigToHost(IO::GetUnaligned64(p));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 8-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     PutUnaligned8(void *p, uint8_t v)
+{
+    IO::PutUnaligned8(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 16-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     PutUnaligned16(void *p, uint16_t v)
+{
+    IO::PutUnaligned16(p, ByteOrder::Swap16HostToBig(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 32-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     PutUnaligned32(void *p, uint32_t v)
+{
+    IO::PutUnaligned32(p, ByteOrder::Swap32HostToBig(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 64-bit value to in big
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     PutUnaligned64(void *p, uint64_t v)
+{
+    IO::PutUnaligned64(p, ByteOrder::Swap64HostToBig(v));
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to read the 8-bit big endian byte
+ *                    ordered value from and to then increment by 8-
+ *                    bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  ReadUnaligned8(const void *&p)
+{
+    return IO::ReadUnaligned8(p);
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to read the 16-bit big endian byte
+ *                    ordered value from and to then increment by 16-
+ *                    bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t ReadUnaligned16(const void *&p)
+{
+    return ByteOrder::Swap16BigToHost(IO::ReadUnaligned16(p));
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to read the 32-bit big endian byte
+ *                    ordered value from and to then increment by 32-
+ *                    bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t ReadUnaligned32(const void *&p)
+{
+    return ByteOrder::Swap32BigToHost(IO::ReadUnaligned32(p));
+}
+
+/**
+ * Perform an unaligned memory read of the big endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to read the 64-bit big endian byte
+ *                    ordered value from and to then increment by 64-
+ *                    bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t ReadUnaligned64(const void *&p)
+{
+    return ByteOrder::Swap64BigToHost(IO::ReadUnaligned64(p));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to write the target system byte
+ *                    ordered 8-bit value to in big endian byte
+ *                    ordering and to then increment by 8-bits (1
+ *                    byte).
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     WriteUnaligned8(void *&p, uint8_t v)
+{
+    IO::WriteUnaligned8(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to write the target system byte
+ *                    ordered 16-bit value to in big endian byte
+ *                    ordering and to then increment by 16-bits (2
+ *                    bytes).
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     WriteUnaligned16(void *&p, uint16_t v)
+{
+    IO::WriteUnaligned16(p, ByteOrder::Swap16HostToBig(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to write the target system byte
+ *                    ordered 32-bit value to in big endian byte
+ *                    ordering and to then increment by 16-bits (4
+ *                    bytes).
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     WriteUnaligned32(void *&p, uint32_t v)
+{
+    IO::WriteUnaligned32(p, ByteOrder::Swap32HostToBig(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in big endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to write the target system byte
+ *                    ordered 64-bit value to in big endian byte
+ *                    ordering and to then increment by 64-bits (8
+ *                    bytes).
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     WriteUnaligned64(void *&p, uint64_t v)
+{
+    IO::WriteUnaligned64(p, ByteOrder::Swap64HostToBig(v));
+}
+
+} // namespace BigEndian
+
+} // namespace IO
+
+} // namespace nl
+
+#endif // NLIO_BYTEORDER_BIG_HPP
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/nlio-byteorder-little.h b/cores/nRF5/nordic/config/nrf52840/configxx/nlio-byteorder-little.h
new file mode 100644
index 000000000..06c477e16
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/nlio-byteorder-little.h
@@ -0,0 +1,915 @@
+/**
+ *    Copyright 2013-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines C functions for safely performing simple,
+ *      memory-mapped accesses, potentially to unaligned, aligned, and
+ *      unaligned memory locations with byte reordering, specifically
+ *      for little endian target systems.
+ */
+
+#ifndef NLIO_BYTEORDER_LITTLE_H
+#define NLIO_BYTEORDER_LITTLE_H
+
+#include <nlio-base.h>
+#include <nlbyteorder.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 8-bit little endian byte ordered value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOLittleEndianGet8(const void *p)
+{
+    return nlIOGet8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 16-bit little endian byte ordered value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOLittleEndianGet16(const void *p)
+{
+    return nlByteOrderSwap16LittleToHost(nlIOGet16(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 32-bit little endian byte ordered value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOLittleEndianGet32(const void *p)
+{
+    return nlByteOrderSwap32LittleToHost(nlIOGet32(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 64-bit little endian byte ordered value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOLittleEndianGet64(const void *p)
+{
+    return nlByteOrderSwap64LittleToHost(nlIOGet64(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 8-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianPut8(void *p, uint8_t v)
+{
+    nlIOPut8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 16-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianPut16(void *p, uint16_t v)
+{
+    nlIOPut16(p, nlByteOrderSwap16HostToLittle(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 32-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianPut32(void *p, uint32_t v)
+{
+    nlIOPut32(p, nlByteOrderSwap32HostToLittle(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 64-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianPut64(void *p, uint64_t v)
+{
+    nlIOPut64(p, nlByteOrderSwap64HostToLittle(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 8-bit little endian byte
+ *                    ordered value from and to then increment by 8-
+ *                    bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOLittleEndianRead8(const void **p)
+{
+    return nlIORead8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 16-bit little endian byte
+ *                    ordered value from and to then increment by 16-
+ *                    bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOLittleEndianRead16(const void **p)
+{
+    return nlByteOrderSwap16LittleToHost(nlIORead16(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 32-bit little endian byte
+ *                    ordered value from and to then increment by 32-
+ *                    bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOLittleEndianRead32(const void **p)
+{
+    return nlByteOrderSwap32LittleToHost(nlIORead32(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to a pointer address, potentially
+ *                    unaligned, to read the 64-bit little endian byte
+ *                    ordered value from and to then increment by 64-
+ *                    bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOLittleEndianRead64(const void **p)
+{
+    return nlByteOrderSwap64LittleToHost(nlIORead64(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A pointer to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 8-bit value to in little endian byte
+ *                    ordering and to then increment by 8-bits (1
+ *                    byte).
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianWrite8(void **p, uint8_t v)
+{
+    nlIOWrite8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A pointer to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 16-bit value to in little endian byte
+ *                    ordering and to then increment by 16-bits (2
+ *                    bytes).
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianWrite16(void **p, uint16_t v)
+{
+    nlIOWrite16(p, nlByteOrderSwap16HostToLittle(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A pointer to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 32-bit value to in little endian byte
+ *                    ordering and to then increment by 16-bits (4
+ *                    bytes).
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianWrite32(void **p, uint32_t v)
+{
+    nlIOWrite32(p, nlByteOrderSwap32HostToLittle(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A pointer to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 64-bit value to in little endian byte
+ *                    ordering and to then increment by 64-bits (8
+ *                    bytes).
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianWrite64(void **p, uint64_t v)
+{
+    nlIOWrite64(p, nlByteOrderSwap64HostToLittle(v));
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 8-bit little endian byte ordered value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOLittleEndianGetAligned8(const void *p)
+{
+    return nlIOGetAligned8(p);
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 16-bit little endian byte ordered value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOLittleEndianGetAligned16(const void *p)
+{
+    return nlByteOrderSwap16LittleToHost(nlIOGetAligned16(p));
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 32-bit little endian byte ordered value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOLittleEndianGetAligned32(const void *p)
+{
+    return nlByteOrderSwap32LittleToHost(nlIOGetAligned32(p));
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 64-bit little endian byte ordered value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOLittleEndianGetAligned64(const void *p)
+{
+    return nlByteOrderSwap64LittleToHost(nlIOGetAligned64(p));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 8-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianPutAligned8(void *p, uint8_t v)
+{
+    nlIOPutAligned8(p, v);
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 16-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianPutAligned16(void *p, uint16_t v)
+{
+    nlIOPutAligned16(p, nlByteOrderSwap16HostToLittle(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 32-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianPutAligned32(void *p, uint32_t v)
+{
+    nlIOPutAligned32(p, nlByteOrderSwap32HostToLittle(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 64-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianPutAligned64(void *p, uint64_t v)
+{
+    nlIOPutAligned64(p, nlByteOrderSwap64HostToLittle(v));
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to read the 8-bit little endian byte
+ *                    ordered value from and to then increment by 8-
+ *                    bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOLittleEndianReadAligned8(const void **p)
+{
+    return nlIOReadAligned8(p);
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to read the 16-bit little endian byte
+ *                    ordered value from and to then increment by 16-
+ *                    bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOLittleEndianReadAligned16(const void **p)
+{
+    return nlByteOrderSwap16LittleToHost(nlIOReadAligned16(p));
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to read the 32-bit little endian byte
+ *                    ordered value from and to then increment by 32-
+ *                    bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOLittleEndianReadAligned32(const void **p)
+{
+    return nlByteOrderSwap32LittleToHost(nlIOReadAligned32(p));
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to read the 64-bit little endian byte
+ *                    ordered value from and to then increment by 64-
+ *                    bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOLittleEndianReadAligned64(const void **p)
+{
+    return nlByteOrderSwap64LittleToHost(nlIOReadAligned64(p));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to write the target system byte
+ *                    ordered 8-bit value to in little endian byte
+ *                    ordering and to then increment by 8-bits (1
+ *                    byte).
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianWriteAligned8(void **p, uint8_t v)
+{
+    nlIOWriteAligned8(p, v);
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to write the target system byte
+ *                    ordered 16-bit value to in little endian byte
+ *                    ordering and to then increment by 16-bits (2
+ *                    bytes).
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianWriteAligned16(void **p, uint16_t v)
+{
+    nlIOWriteAligned16(p, nlByteOrderSwap16HostToLittle(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to write the target system byte
+ *                    ordered 32-bit value to in little endian byte
+ *                    ordering and to then increment by 16-bits (4
+ *                    bytes).
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianWriteAligned32(void **p, uint32_t v)
+{
+    nlIOWriteAligned32(p, nlByteOrderSwap32HostToLittle(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an aligned pointer address, 
+ *                    to write the target system byte
+ *                    ordered 64-bit value to in little endian byte
+ *                    ordering and to then increment by 64-bits (8
+ *                    bytes).
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianWriteAligned64(void **p, uint64_t v)
+{
+    nlIOWriteAligned64(p, nlByteOrderSwap64HostToLittle(v));
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 8-bit little endian byte ordered value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOLittleEndianGetUnaligned8(const void *p)
+{
+    return nlIOGetUnaligned8(p);
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 16-bit little endian byte ordered value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOLittleEndianGetUnaligned16(const void *p)
+{
+    return nlByteOrderSwap16LittleToHost(nlIOGetUnaligned16(p));
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 32-bit little endian byte ordered value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOLittleEndianGetUnaligned32(const void *p)
+{
+    return nlByteOrderSwap32LittleToHost(nlIOGetUnaligned32(p));
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 64-bit little endian byte ordered value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOLittleEndianGetUnaligned64(const void *p)
+{
+    return nlByteOrderSwap64LittleToHost(nlIOGetUnaligned64(p));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 8-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianPutUnaligned8(void *p, uint8_t v)
+{
+    nlIOPutUnaligned8(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 16-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianPutUnaligned16(void *p, uint16_t v)
+{
+    nlIOPutUnaligned16(p, nlByteOrderSwap16HostToLittle(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 32-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianPutUnaligned32(void *p, uint32_t v)
+{
+    nlIOPutUnaligned32(p, nlByteOrderSwap32HostToLittle(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 64-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianPutUnaligned64(void *p, uint64_t v)
+{
+    nlIOPutUnaligned64(p, nlByteOrderSwap64HostToLittle(v));
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to read the 8-bit little endian byte
+ *                    ordered value from and to then increment by 8-
+ *                    bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  nlIOLittleEndianReadUnaligned8(const void **p)
+{
+    return nlIOReadUnaligned8(p);
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to read the 16-bit little endian byte
+ *                    ordered value from and to then increment by 16-
+ *                    bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t nlIOLittleEndianReadUnaligned16(const void **p)
+{
+    return nlByteOrderSwap16LittleToHost(nlIOReadUnaligned16(p));
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to read the 32-bit little endian byte
+ *                    ordered value from and to then increment by 32-
+ *                    bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t nlIOLittleEndianReadUnaligned32(const void **p)
+{
+    return nlByteOrderSwap32LittleToHost(nlIOReadUnaligned32(p));
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to read the 64-bit little endian byte
+ *                    ordered value from and to then increment by 64-
+ *                    bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t nlIOLittleEndianReadUnaligned64(const void **p)
+{
+    return nlByteOrderSwap64LittleToHost(nlIOReadUnaligned64(p));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to write the target system byte
+ *                    ordered 8-bit value to in little endian byte
+ *                    ordering and to then increment by 8-bits (1
+ *                    byte).
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianWriteUnaligned8(void **p, uint8_t v)
+{
+    nlIOWriteUnaligned8(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to write the target system byte
+ *                    ordered 16-bit value to in little endian byte
+ *                    ordering and to then increment by 16-bits (2
+ *                    bytes).
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianWriteUnaligned16(void **p, uint16_t v)
+{
+    nlIOWriteUnaligned16(p, nlByteOrderSwap16HostToLittle(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to write the target system byte
+ *                    ordered 32-bit value to in little endian byte
+ *                    ordering and to then increment by 32-bits (4
+ *                    bytes).
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianWriteUnaligned32(void **p, uint32_t v)
+{
+    nlIOWriteUnaligned32(p, nlByteOrderSwap32HostToLittle(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A pointer to an unaligined pointer address, 
+ *                    to write the target system byte
+ *                    ordered 64-bit value to in little endian byte
+ *                    ordering and to then increment by 64-bits (8
+ *                    bytes).
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     nlIOLittleEndianWriteUnaligned64(void **p, uint64_t v)
+{
+    nlIOWriteUnaligned64(p, nlByteOrderSwap64HostToLittle(v));
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NLIO_BYTEORDER_LITTLE_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/nlio-byteorder-little.hpp b/cores/nRF5/nordic/config/nrf52840/configxx/nlio-byteorder-little.hpp
new file mode 100644
index 000000000..47d8fce65
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/nlio-byteorder-little.hpp
@@ -0,0 +1,922 @@
+/**
+ *    Copyright 2013-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines C++ functions for safely performing simple,
+ *      memory-mapped accesses, potentially to unaligned, aligned, and
+ *      unaligned memory locations with byte reordering, specifically
+ *      for little endian target systems.
+ */
+
+#ifndef NLIO_BYTEORDER_LITTLE_HPP
+#define NLIO_BYTEORDER_LITTLE_HPP
+
+#include <nlio-base.hpp>
+#include <nlbyteorder.hpp>
+
+namespace nl
+{
+
+namespace IO
+{
+
+namespace LittleEndian
+{
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 8-bit little endian byte ordered value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  Get8(const void *p)
+{
+    return IO::Get8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 16-bit little endian byte ordered value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t Get16(const void *p)
+{
+    return ByteOrder::Swap16LittleToHost(IO::Get16(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 32-bit little endian byte ordered value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t Get32(const void *p)
+{
+    return ByteOrder::Swap32LittleToHost(IO::Get32(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to read
+ *                    the 64-bit little endian byte ordered value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t Get64(const void *p)
+{
+    return ByteOrder::Swap64LittleToHost(IO::Get64(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 8-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     Put8(void *p, uint8_t v)
+{
+    IO::Put8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 16-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     Put16(void *p, uint16_t v)
+{
+    IO::Put16(p, ByteOrder::Swap16HostToLittle(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 32-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     Put32(void *p, uint32_t v)
+{
+    IO::Put32(p, ByteOrder::Swap32HostToLittle(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A pointer address, potentially unaligned, to write
+ *                    the target system byte ordered 64-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     Put64(void *p, uint64_t v)
+{
+    IO::Put64(p, ByteOrder::Swap64HostToLittle(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 8-bit little endian byte
+ *                    ordered value from and to then increment by 8-
+ *                    bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  Read8(const void *&p)
+{
+    return IO::Read8(p);
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 16-bit little endian byte
+ *                    ordered value from and to then increment by 16-
+ *                    bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t Read16(const void *&p)
+{
+    return ByteOrder::Swap16LittleToHost(IO::Read16(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 32-bit little endian byte
+ *                    ordered value from and to then increment by 32-
+ *                    bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t Read32(const void *&p)
+{
+    return ByteOrder::Swap32LittleToHost(IO::Read32(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory read of the little endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to a pointer address, potentially
+ *                    unaligned, to read the 64-bit little endian byte
+ *                    ordered value from and to then increment by 64-
+ *                    bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t Read64(const void *&p)
+{
+    return ByteOrder::Swap64LittleToHost(IO::Read64(p));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A reference to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 8-bit value to in little endian byte
+ *                    ordering and to then increment by 8-bits (1
+ *                    byte).
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     Write8(void *&p, uint8_t v)
+{
+    IO::Write8(p, v);
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A reference to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 16-bit value to in little endian byte
+ *                    ordering and to then increment by 16-bits (2
+ *                    bytes).
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     Write16(void *&p, uint16_t v)
+{
+    IO::Write16(p, ByteOrder::Swap16HostToLittle(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A reference to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 32-bit value to in little endian byte
+ *                    ordering and to then increment by 16-bits (4
+ *                    bytes).
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     Write32(void *&p, uint32_t v)
+{
+    IO::Write32(p, ByteOrder::Swap32HostToLittle(v));
+}
+
+/**
+ * Perform a, potentially unaligned, memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      A reference to a pointer address, potentially
+ *                    unaligned, to write the target system byte
+ *                    ordered 64-bit value to in little endian byte
+ *                    ordering and to then increment by 64-bits (8
+ *                    bytes).
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     Write64(void *&p, uint64_t v)
+{
+    IO::Write64(p, ByteOrder::Swap64HostToLittle(v));
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 8-bit little endian byte ordered value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  GetAligned8(const void *p)
+{
+    return IO::GetAligned8(p);
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 16-bit little endian byte ordered value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t GetAligned16(const void *p)
+{
+    return ByteOrder::Swap16LittleToHost(IO::GetAligned16(p));
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 32-bit little endian byte ordered value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t GetAligned32(const void *p)
+{
+    return ByteOrder::Swap32LittleToHost(IO::GetAligned32(p));
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to read
+ *                    the 64-bit little endian byte ordered value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t GetAligned64(const void *p)
+{
+    return ByteOrder::Swap64LittleToHost(IO::GetAligned64(p));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 8-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     PutAligned8(void *p, uint8_t v)
+{
+    IO::PutAligned8(p, v);
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 16-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     PutAligned16(void *p, uint16_t v)
+{
+    IO::PutAligned16(p, ByteOrder::Swap16HostToLittle(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 32-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     PutAligned32(void *p, uint32_t v)
+{
+    IO::PutAligned32(p, ByteOrder::Swap32HostToLittle(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An aligned pointer address to write
+ *                    the target system byte ordered 64-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     PutAligned64(void *p, uint64_t v)
+{
+    IO::PutAligned64(p, ByteOrder::Swap64HostToLittle(v));
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to read the 8-bit little endian byte
+ *                    ordered value from and to then increment by 8-
+ *                    bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  ReadAligned8(const void *&p)
+{
+    return IO::ReadAligned8(p);
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to read the 16-bit little endian byte
+ *                    ordered value from and to then increment by 16-
+ *                    bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t ReadAligned16(const void *&p)
+{
+    return ByteOrder::Swap16LittleToHost(IO::ReadAligned16(p));
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to read the 32-bit little endian byte
+ *                    ordered value from and to then increment by 32-
+ *                    bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t ReadAligned32(const void *&p)
+{
+    return ByteOrder::Swap32LittleToHost(IO::ReadAligned32(p));
+}
+
+/**
+ * Perform an aligned memory read of the little endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to read the 64-bit little endian byte
+ *                    ordered value from and to then increment by 64-
+ *                    bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t ReadAligned64(const void *&p)
+{
+    return ByteOrder::Swap64LittleToHost(IO::ReadAligned64(p));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to write the target system byte
+ *                    ordered 8-bit value to in little endian byte
+ *                    ordering and to then increment by 8-bits (1
+ *                    byte).
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     WriteAligned8(void *&p, uint8_t v)
+{
+    IO::WriteAligned8(p, v);
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to write the target system byte
+ *                    ordered 16-bit value to in little endian byte
+ *                    ordering and to then increment by 16-bits (2
+ *                    bytes).
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     WriteAligned16(void *&p, uint16_t v)
+{
+    IO::WriteAligned16(p, ByteOrder::Swap16HostToLittle(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to write the target system byte
+ *                    ordered 32-bit value to in little endian byte
+ *                    ordering and to then increment by 16-bits (4
+ *                    bytes).
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     WriteAligned32(void *&p, uint32_t v)
+{
+    IO::WriteAligned32(p, ByteOrder::Swap32HostToLittle(v));
+}
+
+/**
+ * Perform an aligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an aligned pointer address
+ *                    to write the target system byte
+ *                    ordered 64-bit value to in little endian byte
+ *                    ordering and to then increment by 64-bits (8
+ *                    bytes).
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     WriteAligned64(void *&p, uint64_t v)
+{
+    IO::WriteAligned64(p, ByteOrder::Swap64HostToLittle(v));
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 8-bit little endian byte ordered value from.
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  GetUnaligned8(const void *p)
+{
+    return IO::GetUnaligned8(p);
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 16-bit little endian byte ordered value from.
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t GetUnaligned16(const void *p)
+{
+    return ByteOrder::Swap16LittleToHost(IO::GetUnaligned16(p));
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 32-bit little endian byte ordered value from.
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t GetUnaligned32(const void *p)
+{
+    return ByteOrder::Swap32LittleToHost(IO::GetUnaligned32(p));
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in target system byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to read
+ *                    the 64-bit little endian byte ordered value from.
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t GetUnaligned64(const void *p)
+{
+    return ByteOrder::Swap64LittleToHost(IO::GetUnaligned64(p));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 8-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     PutUnaligned8(void *p, uint8_t v)
+{
+    IO::PutUnaligned8(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 16-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     PutUnaligned16(void *p, uint16_t v)
+{
+    IO::PutUnaligned16(p, ByteOrder::Swap16HostToLittle(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 32-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     PutUnaligned32(void *p, uint32_t v)
+{
+    IO::PutUnaligned32(p, ByteOrder::Swap32HostToLittle(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[in]  p      An unaligned pointer address to write
+ *                    the target system byte ordered 64-bit value to in little
+ *                    endian byte ordering.
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     PutUnaligned64(void *p, uint64_t v)
+{
+    IO::PutUnaligned64(p, ByteOrder::Swap64HostToLittle(v));
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 8-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 8-bits (1 byte).
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to read the 8-bit little endian byte
+ *                    ordered value from and to then increment by 8-
+ *                    bits (1 byte).
+ *
+ * @return The 8-bit value at the specified pointer address.
+ */
+static inline uint8_t  ReadUnaligned8(const void *&p)
+{
+    return IO::ReadUnaligned8(p);
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 16-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 16-bits (2 bytes).
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to read the 16-bit little endian byte
+ *                    ordered value from and to then increment by 16-
+ *                    bits (2 bytes).
+ *
+ * @return The 16-bit value at the specified pointer address.
+ */
+static inline uint16_t ReadUnaligned16(const void *&p)
+{
+    return ByteOrder::Swap16LittleToHost(IO::ReadUnaligned16(p));
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 32-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 32-bits (4 bytes).
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to read the 32-bit little endian byte
+ *                    ordered value from and to then increment by 32-
+ *                    bits (4 bytes).
+ *
+ * @return The 32-bit value at the specified pointer address.
+ */
+static inline uint32_t ReadUnaligned32(const void *&p)
+{
+    return ByteOrder::Swap32LittleToHost(IO::ReadUnaligned32(p));
+}
+
+/**
+ * Perform an unaligned memory read of the little endian
+ * byte ordered 64-bit value from the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to put
+ * the value in target system byte ordering, and increment the pointer
+ * by 64-bits (8 bytes).
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to read the 64-bit little endian byte
+ *                    ordered value from and to then increment by 64-
+ *                    bits (8 bytes).
+ *
+ * @return The 64-bit value at the specified pointer address.
+ */
+static inline uint64_t ReadUnaligned64(const void *&p)
+{
+    return ByteOrder::Swap64LittleToHost(IO::ReadUnaligned64(p));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 8-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to write the target system byte
+ *                    ordered 8-bit value to in little endian byte
+ *                    ordering and to then increment by 8-bits (1
+ *                    byte).
+ *
+ * @param[in]  v      The 8-bit value to write.
+ *
+ */
+static inline void     WriteUnaligned8(void *&p, uint8_t v)
+{
+    IO::WriteUnaligned8(p, v);
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 16-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to write the target system byte
+ *                    ordered 16-bit value to in little endian byte
+ *                    ordering and to then increment by 16-bits (2
+ *                    bytes).
+ *
+ * @param[in]  v      The 16-bit value to write.
+ *
+ */
+static inline void     WriteUnaligned16(void *&p, uint16_t v)
+{
+    IO::WriteUnaligned16(p, ByteOrder::Swap16HostToLittle(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 32-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to write the target system byte
+ *                    ordered 32-bit value to in little endian byte
+ *                    ordering and to then increment by 16-bits (4
+ *                    bytes).
+ *
+ * @param[in]  v      The 32-bit value to write.
+ *
+ */
+static inline void     WriteUnaligned32(void *&p, uint32_t v)
+{
+    IO::WriteUnaligned32(p, ByteOrder::Swap32HostToLittle(v));
+}
+
+/**
+ * Perform an unaligned memory write of the target system
+ * byte ordered 64-bit value to the specified pointer address,
+ * perform byte reordering, as necessary, for the target system to
+ * put the value in little endian byte ordering.
+ *
+ * @param[inout]  p   A reference to an unaligned pointer address
+ *                    to write the target system byte
+ *                    ordered 64-bit value to in little endian byte
+ *                    ordering and to then increment by 64-bits (8
+ *                    bytes).
+ *
+ * @param[in]  v      The 64-bit value to write.
+ *
+ */
+static inline void     WriteUnaligned64(void *&p, uint64_t v)
+{
+    IO::WriteUnaligned64(p, ByteOrder::Swap64HostToLittle(v));
+}
+
+} // namespace LittleEndian
+
+} // namespace IO
+
+} // namespace nl
+
+#endif // NLIO_BYTEORDER_LITTLE_HPP
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/nlio-byteorder.h b/cores/nRF5/nordic/config/nrf52840/configxx/nlio-byteorder.h
new file mode 100644
index 000000000..9e6700121
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/nlio-byteorder.h
@@ -0,0 +1,33 @@
+/**
+ *    Copyright 2013-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines C functions for safely performing simple,
+ *      memory-mapped accesses, potentially to unaligned memory
+ *      locations with byte reordering.
+ */
+
+#ifndef NLIO_BYTEORDER_H
+#define NLIO_BYTEORDER_H
+
+#include <nlio-base.h>
+#include <nlbyteorder.h>
+
+#include <nlio-byteorder-big.h>
+#include <nlio-byteorder-little.h>
+
+#endif /* NLIO_BYTEORDER_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/nlio-byteorder.hpp b/cores/nRF5/nordic/config/nrf52840/configxx/nlio-byteorder.hpp
new file mode 100644
index 000000000..e44256ba4
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/nlio-byteorder.hpp
@@ -0,0 +1,33 @@
+/**
+ *    Copyright 2013-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines C++ functions for safely performing simple,
+ *      memory-mapped accesses, potentially to unaligned memory
+ *      locations with byte reordering.
+ */
+
+#ifndef NLIO_BYTEORDER_HPP
+#define NLIO_BYTEORDER_HPP
+
+#include <nlio-base.hpp>
+#include <nlbyteorder.hpp>
+
+#include <nlio-byteorder-big.hpp>
+#include <nlio-byteorder-little.hpp>
+
+#endif // NLIO_BYTEORDER_HPP
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/nlio-config.h.in b/cores/nRF5/nordic/config/nrf52840/configxx/nlio-config.h.in
new file mode 100644
index 000000000..06cf75832
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/nlio-config.h.in
@@ -0,0 +1,133 @@
+/* include/nlio-config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if your C++ compiler doesn't accept -c and -o together. */
+#undef CXX_NO_MINUS_C_MINUS_O
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you have the <endian.h> header file. */
+#undef HAVE_ENDIAN_H
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the <machine/endian.h> header file. */
+#undef HAVE_MACHINE_ENDIAN_H
+
+/* Define to 1 if you have the `memcpy' function. */
+#undef HAVE_MEMCPY
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the <nlunit-test.h> header file. */
+#undef HAVE_NLUNIT_TEST_H
+
+/* Define to 1 if stdbool.h conforms to C99. */
+#undef HAVE_STDBOOL_H
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define to 1 if the system has the type `_Bool'. */
+#undef HAVE__BOOL
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#undef LT_OBJDIR
+
+/* Define to 1 if your C compiler doesn't accept -c and -o together. */
+#undef NO_MINUS_C_MINUS_O
+
+/* Name of package */
+#undef PACKAGE
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the home page for this package. */
+#undef PACKAGE_URL
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* Version number of package */
+#undef VERSION
+
+/* Define for Solaris 2.5.1 so the uint32_t typedef from <sys/synch.h>,
+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
+   #define below would cause a syntax error. */
+#undef _UINT32_T
+
+/* Define for Solaris 2.5.1 so the uint64_t typedef from <sys/synch.h>,
+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
+   #define below would cause a syntax error. */
+#undef _UINT64_T
+
+/* Define for Solaris 2.5.1 so the uint8_t typedef from <sys/synch.h>,
+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
+   #define below would cause a syntax error. */
+#undef _UINT8_T
+
+/* Define to the type of a signed integer type of width exactly 16 bits if
+   such a type exists and the standard includes do not define it. */
+#undef int16_t
+
+/* Define to the type of a signed integer type of width exactly 32 bits if
+   such a type exists and the standard includes do not define it. */
+#undef int32_t
+
+/* Define to the type of a signed integer type of width exactly 64 bits if
+   such a type exists and the standard includes do not define it. */
+#undef int64_t
+
+/* Define to the type of a signed integer type of width exactly 8 bits if such
+   a type exists and the standard includes do not define it. */
+#undef int8_t
+
+/* Define to the type of an unsigned integer type of width exactly 16 bits if
+   such a type exists and the standard includes do not define it. */
+#undef uint16_t
+
+/* Define to the type of an unsigned integer type of width exactly 32 bits if
+   such a type exists and the standard includes do not define it. */
+#undef uint32_t
+
+/* Define to the type of an unsigned integer type of width exactly 64 bits if
+   such a type exists and the standard includes do not define it. */
+#undef uint64_t
+
+/* Define to the type of an unsigned integer type of width exactly 8 bits if
+   such a type exists and the standard includes do not define it. */
+#undef uint8_t
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/nlio-private.h b/cores/nRF5/nordic/config/nrf52840/configxx/nlio-private.h
new file mode 100644
index 000000000..22dc4d0de
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/nlio-private.h
@@ -0,0 +1,50 @@
+/**
+ *    Copyright 2017 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file defines private macros and interfaces.
+ */
+
+#ifndef NLIO_PRIVATE_H
+#define NLIO_PRIVATE_H
+
+/*
+ * If we are compiling under clang, GCC, or any such compatible
+ * compiler, in which -fno-builtins or -ffreestanding might be
+ * asserted, thereby eliminating built-in function optimization, we
+ * may STILL want to leverage built-ins.
+ *
+ * Provide an internal convenience macro to do so.
+ */
+
+/**
+ *  @def __nlIOHasBuiltin
+ *
+ *  @brief
+ *     Determines whether or not the compiler in effect has support
+ *     for the specified built-in function.
+ *
+ */
+#ifdef __clang__
+#define __nlIOHasBuiltin(...) __has_builtin(__VA_ARGS__)
+#elif defined __GNUC__
+#define __nlIOHasBuiltin(...) 1
+#else
+#define __nlIOHasBuiltin(...) 0
+#endif /* __clang__ */
+
+#endif /* NLIO_PRIVATE_H */
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/nlio.h b/cores/nRF5/nordic/config/nrf52840/configxx/nlio.h
new file mode 100644
index 000000000..b7068265b
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/nlio.h
@@ -0,0 +1,38 @@
+/**
+ *    Copyright 2013-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file is an umbrella header for the C language definitions
+ *      of functions for safely performing simple, memory-mapped
+ *      accesses, potentially to unaligned memory locations, with or
+ *      without byte reordering.
+ */
+
+#ifndef NLIO_H
+#define NLIO_H
+
+#include <nlio-base.h>
+#include <nlio-byteorder.h>
+
+#endif /* NLIO_H */
+
+
+
+
+
+
+
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/nlio.hpp b/cores/nRF5/nordic/config/nrf52840/configxx/nlio.hpp
new file mode 100644
index 000000000..47487f373
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/nlio.hpp
@@ -0,0 +1,38 @@
+/**
+ *    Copyright 2013-2016 Nest Labs Inc. All Rights Reserved.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+/**
+ *    @file
+ *      This file is an umbrella header for the C++ language
+ *      definitions of functions for safely performing simple,
+ *      memory-mapped accesses, potentially to unaligned memory
+ *      locations, with or without byte reordering.
+ */
+
+#ifndef NLIO_HPP
+#define NLIO_HPP
+
+#include <nlio-base.hpp>
+#include <nlio-byteorder.hpp>
+
+#endif // NLIO_HPP
+
+
+
+
+
+
+
diff --git a/cores/nRF5/nordic/config/nrf52840/config/openthread-config-generic.h b/cores/nRF5/nordic/config/nrf52840/configxx/openthread-config-generic.h
similarity index 100%
rename from cores/nRF5/nordic/config/nrf52840/config/openthread-config-generic.h
rename to cores/nRF5/nordic/config/nrf52840/configxx/openthread-config-generic.h
diff --git a/cores/nRF5/nordic/config/nrf52840/config/openthread-config-wrap.h b/cores/nRF5/nordic/config/nrf52840/configxx/openthread-config-wrap.h
similarity index 100%
rename from cores/nRF5/nordic/config/nrf52840/config/openthread-config-wrap.h
rename to cores/nRF5/nordic/config/nrf52840/configxx/openthread-config-wrap.h
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/platform/CHIPDeviceBuildConfig.h b/cores/nRF5/nordic/config/nrf52840/configxx/platform/CHIPDeviceBuildConfig.h
new file mode 100644
index 000000000..127a13ec9
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/platform/CHIPDeviceBuildConfig.h
@@ -0,0 +1,23 @@
+// Generated by write_buildconfig_header.py
+// From "//third_party/connectedhomeip/src/platform:gen_platform_buildconfig"
+
+#ifndef PLATFORM_CHIPDEVICEBUILDCONFIG_H_
+#define PLATFORM_CHIPDEVICEBUILDCONFIG_H_
+
+#define CHIP_DEVICE_CONFIG_ENABLE_WPA 0
+#define CHIP_ENABLE_OPENTHREAD 1
+#define CHIP_WITH_GIO 0
+#define OPENTHREAD_CONFIG_ENABLE_TOBLE 0
+#define CONFIG_USE_CLUSTERS_FOR_IP_COMMISSIONING 0
+#define CHIP_DEVICE_CONFIG_ENABLE_MDNS 0
+#define CHIP_BYPASS_RENDEZVOUS 0
+#define CHIP_STACK_LOCK_TRACKING_ENABLED 0
+#define CHIP_STACK_LOCK_TRACKING_ERROR_FATAL 0
+#define CHIP_ENABLE_ADDITIONAL_DATA_ADVERTISING 1
+#define CHIP_ENABLE_ROTATING_DEVICE_ID 1
+#define CHIP_DEVICE_PROJECT_CONFIG_INCLUDE <CHIPProjectConfig.h>
+#define CHIP_DEVICE_PLATFORM_CONFIG_INCLUDE <platform/nRF5/CHIPDevicePlatformConfig.h>
+#define CHIP_DEVICE_LAYER_TARGET_NRF5 1
+#define CHIP_DEVICE_LAYER_TARGET nRF5
+
+#endif  // PLATFORM_CHIPDEVICEBUILDCONFIG_H_
diff --git a/cores/nRF5/nordic/config/nrf52840/config/sdk_config.h b/cores/nRF5/nordic/config/nrf52840/configxx/sdk_config.h
similarity index 100%
rename from cores/nRF5/nordic/config/nrf52840/config/sdk_config.h
rename to cores/nRF5/nordic/config/nrf52840/configxx/sdk_config.h
diff --git a/cores/nRF5/nordic/config/nrf52840/configxx/system/SystemBuildConfig.h b/cores/nRF5/nordic/config/nrf52840/configxx/system/SystemBuildConfig.h
new file mode 100644
index 000000000..57a02da64
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/configxx/system/SystemBuildConfig.h
@@ -0,0 +1,33 @@
+// Generated by write_buildconfig_header.py
+// From "//third_party/connectedhomeip/src/system:gen_system_buildconfig"
+
+#ifndef SYSTEM_SYSTEMBUILDCONFIG_H_
+#define SYSTEM_SYSTEMBUILDCONFIG_H_
+
+#define CONFIG_DEVICE_LAYER 1
+#define CHIP_SYSTEM_CONFIG_TEST 0
+#define CHIP_WITH_NLFAULTINJECTION 1
+#define CHIP_SYSTEM_CONFIG_USE_DISPATCH 0
+#define CHIP_SYSTEM_CONFIG_USE_LWIP 1
+#define CHIP_SYSTEM_CONFIG_USE_SOCKETS 0
+#define CHIP_SYSTEM_CONFIG_USE_NETWORK_FRAMEWORK 0
+#define CHIP_SYSTEM_CONFIG_POSIX_LOCKING 0
+#define CHIP_SYSTEM_CONFIG_FREERTOS_LOCKING 1
+#define CHIP_SYSTEM_CONFIG_MBED_LOCKING 0
+#define CHIP_SYSTEM_CONFIG_NO_LOCKING 0
+#define CHIP_SYSTEM_CONFIG_PROVIDE_STATISTICS 0
+#define HAVE_CLOCK_GETTIME 1
+#define HAVE_CLOCK_SETTIME 1
+#define HAVE_GETTIMEOFDAY 0
+#define HAVE_SYS_TIME_H 1
+#define HAVE_NETINET_ICMP6_H 1
+#define HAVE_ICMP6_FILTER 1
+#define CONFIG_HAVE_VCBPRINTF 0
+#define CONFIG_HAVE_VSNPRINTF_EX 0
+#define HAVE_SYS_SOCKET_H 0
+#define CHIP_PROJECT_CONFIG_INCLUDE <CHIPProjectConfig.h>
+#define CHIP_PLATFORM_CONFIG_INCLUDE <platform/nRF5/CHIPPlatformConfig.h>
+#define SYSTEM_PROJECT_CONFIG_INCLUDE <CHIPProjectConfig.h>
+#define SYSTEM_PLATFORM_CONFIG_INCLUDE <platform/nRF5/SystemPlatformConfig.h>
+
+#endif  // SYSTEM_SYSTEMBUILDCONFIG_H_
diff --git a/cores/nRF5/nordic/config/nrf52840/gen/CHIPClientCallbacks.h b/cores/nRF5/nordic/config/nrf52840/gen/CHIPClientCallbacks.h
new file mode 100644
index 000000000..302d36ce5
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/gen/CHIPClientCallbacks.h
@@ -0,0 +1,20 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+// THIS FILE IS GENERATED BY ZAP
+
+// List specific responses
diff --git a/cores/nRF5/nordic/config/nrf52840/gen/CHIPClusters.h b/cores/nRF5/nordic/config/nrf52840/gen/CHIPClusters.h
new file mode 100644
index 000000000..759d13c50
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/gen/CHIPClusters.h
@@ -0,0 +1,18 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+// THIS FILE IS GENERATED BY ZAP
diff --git a/cores/nRF5/nordic/config/nrf52840/gen/af-gen-event.h b/cores/nRF5/nordic/config/nrf52840/gen/af-gen-event.h
new file mode 100644
index 000000000..e69de29bb
diff --git a/cores/nRF5/nordic/config/nrf52840/gen/callback.h b/cores/nRF5/nordic/config/nrf52840/gen/callback.h
new file mode 100644
index 000000000..9d01a5587
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/gen/callback.h
@@ -0,0 +1,1538 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+// THIS FILE IS GENERATED BY ZAP
+
+// Prevent multiple inclusion
+#pragma once
+
+#include <app/common/gen/af-structs.h>
+#include <app/util/af-types.h>
+#include <app/util/basic-types.h>
+
+#include <app/Command.h>
+#include <lib/support/Span.h>
+
+/** @brief Cluster Init
+ *
+ * This function is called when a specific cluster is initialized. It gives the
+ * application an opportunity to take care of cluster initialization procedures.
+ * It is called exactly once for each endpoint where cluster is present.
+ *
+ * @param endpoint   Ver.: always
+ * @param clusterId   Ver.: always
+ */
+void emberAfClusterInitCallback(chip::EndpointId endpoint, chip::ClusterId clusterId);
+
+// Cluster Init Functions
+
+/** @brief Basic Cluster Init
+ *
+ * Cluster Init
+ *
+ * @param endpoint    Endpoint that is being initialized
+ */
+void emberAfBasicClusterInitCallback(chip::EndpointId endpoint);
+
+/** @brief Diagnostic Logs Cluster Init
+ *
+ * Cluster Init
+ *
+ * @param endpoint    Endpoint that is being initialized
+ */
+void emberAfDiagnosticLogsClusterInitCallback(chip::EndpointId endpoint);
+
+/** @brief Ethernet Network Diagnostics Cluster Init
+ *
+ * Cluster Init
+ *
+ * @param endpoint    Endpoint that is being initialized
+ */
+void emberAfEthernetNetworkDiagnosticsClusterInitCallback(chip::EndpointId endpoint);
+
+/** @brief General Commissioning Cluster Init
+ *
+ * Cluster Init
+ *
+ * @param endpoint    Endpoint that is being initialized
+ */
+void emberAfGeneralCommissioningClusterInitCallback(chip::EndpointId endpoint);
+
+/** @brief General Diagnostics Cluster Init
+ *
+ * Cluster Init
+ *
+ * @param endpoint    Endpoint that is being initialized
+ */
+void emberAfGeneralDiagnosticsClusterInitCallback(chip::EndpointId endpoint);
+
+/** @brief Network Commissioning Cluster Init
+ *
+ * Cluster Init
+ *
+ * @param endpoint    Endpoint that is being initialized
+ */
+void emberAfNetworkCommissioningClusterInitCallback(chip::EndpointId endpoint);
+
+/** @brief On/off Cluster Init
+ *
+ * Cluster Init
+ *
+ * @param endpoint    Endpoint that is being initialized
+ */
+void emberAfOnOffClusterInitCallback(chip::EndpointId endpoint);
+
+/** @brief Operational Credentials Cluster Init
+ *
+ * Cluster Init
+ *
+ * @param endpoint    Endpoint that is being initialized
+ */
+void emberAfOperationalCredentialsClusterInitCallback(chip::EndpointId endpoint);
+
+/** @brief Software Diagnostics Cluster Init
+ *
+ * Cluster Init
+ *
+ * @param endpoint    Endpoint that is being initialized
+ */
+void emberAfSoftwareDiagnosticsClusterInitCallback(chip::EndpointId endpoint);
+
+/** @brief Thread Network Diagnostics Cluster Init
+ *
+ * Cluster Init
+ *
+ * @param endpoint    Endpoint that is being initialized
+ */
+void emberAfThreadNetworkDiagnosticsClusterInitCallback(chip::EndpointId endpoint);
+
+/** @brief WiFi Network Diagnostics Cluster Init
+ *
+ * Cluster Init
+ *
+ * @param endpoint    Endpoint that is being initialized
+ */
+void emberAfWiFiNetworkDiagnosticsClusterInitCallback(chip::EndpointId endpoint);
+
+// Cluster Server/Client Init Functions
+
+//
+// Basic Cluster server
+//
+
+/** @brief Basic Cluster Server Init
+ *
+ * Server Init
+ *
+ * @param endpoint    Endpoint that is being initialized
+ */
+void emberAfBasicClusterServerInitCallback(chip::EndpointId endpoint);
+
+/** @brief Basic Cluster Server Attribute Changed
+ *
+ * Server Attribute Changed
+ *
+ * @param endpoint    Endpoint that is being initialized
+ * @param attributeId Attribute that changed
+ */
+void emberAfBasicClusterServerAttributeChangedCallback(chip::EndpointId endpoint, chip::AttributeId attributeId);
+
+/** @brief Basic Cluster Server Manufacturer Specific Attribute Changed
+ *
+ * Server Manufacturer Specific Attribute Changed
+ *
+ * @param endpoint          Endpoint that is being initialized
+ * @param attributeId       Attribute that changed
+ * @param manufacturerCode  Manufacturer Code of the attribute that changed
+ */
+void emberAfBasicClusterServerManufacturerSpecificAttributeChangedCallback(chip::EndpointId endpoint, chip::AttributeId attributeId,
+                                                                           uint16_t manufacturerCode);
+
+/** @brief Basic Cluster Server Message Sent
+ *
+ * Server Message Sent
+ *
+ * @param type               The type of message sent
+ * @param destination        The destination to which the message was sent
+ * @param apsFrame           The APS frame for the message
+ * @param msgLen             The length of the message
+ * @param message            The message that was sent
+ * @param status             The status of the sent message
+ */
+void emberAfBasicClusterServerMessageSentCallback(const chip::MessageSendDestination & destination, EmberApsFrame * apsFrame,
+                                                  uint16_t msgLen, uint8_t * message, EmberStatus status);
+
+/** @brief Basic Cluster Server Pre Attribute Changed
+ *
+ * server Pre Attribute Changed
+ *
+ * @param endpoint      Endpoint that is being initialized
+ * @param attributeId   Attribute to be changed
+ * @param attributeType Attribute type
+ * @param size          Attribute size
+ * @param value         Attribute value
+ */
+EmberAfStatus emberAfBasicClusterServerPreAttributeChangedCallback(chip::EndpointId endpoint, chip::AttributeId attributeId,
+                                                                   EmberAfAttributeType attributeType, uint16_t size,
+                                                                   uint8_t * value);
+
+/** @brief Basic Cluster Server Tick
+ *
+ * server Tick
+ *
+ * @param endpoint  Endpoint that is being served
+ */
+void emberAfBasicClusterServerTickCallback(chip::EndpointId endpoint);
+
+//
+// Diagnostic Logs Cluster server
+//
+
+/** @brief Diagnostic Logs Cluster Server Init
+ *
+ * Server Init
+ *
+ * @param endpoint    Endpoint that is being initialized
+ */
+void emberAfDiagnosticLogsClusterServerInitCallback(chip::EndpointId endpoint);
+
+/** @brief Diagnostic Logs Cluster Server Attribute Changed
+ *
+ * Server Attribute Changed
+ *
+ * @param endpoint    Endpoint that is being initialized
+ * @param attributeId Attribute that changed
+ */
+void emberAfDiagnosticLogsClusterServerAttributeChangedCallback(chip::EndpointId endpoint, chip::AttributeId attributeId);
+
+/** @brief Diagnostic Logs Cluster Server Manufacturer Specific Attribute Changed
+ *
+ * Server Manufacturer Specific Attribute Changed
+ *
+ * @param endpoint          Endpoint that is being initialized
+ * @param attributeId       Attribute that changed
+ * @param manufacturerCode  Manufacturer Code of the attribute that changed
+ */
+void emberAfDiagnosticLogsClusterServerManufacturerSpecificAttributeChangedCallback(chip::EndpointId endpoint,
+                                                                                    chip::AttributeId attributeId,
+                                                                                    uint16_t manufacturerCode);
+
+/** @brief Diagnostic Logs Cluster Server Message Sent
+ *
+ * Server Message Sent
+ *
+ * @param type               The type of message sent
+ * @param destination        The destination to which the message was sent
+ * @param apsFrame           The APS frame for the message
+ * @param msgLen             The length of the message
+ * @param message            The message that was sent
+ * @param status             The status of the sent message
+ */
+void emberAfDiagnosticLogsClusterServerMessageSentCallback(const chip::MessageSendDestination & destination,
+                                                           EmberApsFrame * apsFrame, uint16_t msgLen, uint8_t * message,
+                                                           EmberStatus status);
+
+/** @brief Diagnostic Logs Cluster Server Pre Attribute Changed
+ *
+ * server Pre Attribute Changed
+ *
+ * @param endpoint      Endpoint that is being initialized
+ * @param attributeId   Attribute to be changed
+ * @param attributeType Attribute type
+ * @param size          Attribute size
+ * @param value         Attribute value
+ */
+EmberAfStatus emberAfDiagnosticLogsClusterServerPreAttributeChangedCallback(chip::EndpointId endpoint,
+                                                                            chip::AttributeId attributeId,
+                                                                            EmberAfAttributeType attributeType, uint16_t size,
+                                                                            uint8_t * value);
+
+/** @brief Diagnostic Logs Cluster Server Tick
+ *
+ * server Tick
+ *
+ * @param endpoint  Endpoint that is being served
+ */
+void emberAfDiagnosticLogsClusterServerTickCallback(chip::EndpointId endpoint);
+
+//
+// Ethernet Network Diagnostics Cluster server
+//
+
+/** @brief Ethernet Network Diagnostics Cluster Server Init
+ *
+ * Server Init
+ *
+ * @param endpoint    Endpoint that is being initialized
+ */
+void emberAfEthernetNetworkDiagnosticsClusterServerInitCallback(chip::EndpointId endpoint);
+
+/** @brief Ethernet Network Diagnostics Cluster Server Attribute Changed
+ *
+ * Server Attribute Changed
+ *
+ * @param endpoint    Endpoint that is being initialized
+ * @param attributeId Attribute that changed
+ */
+void emberAfEthernetNetworkDiagnosticsClusterServerAttributeChangedCallback(chip::EndpointId endpoint,
+                                                                            chip::AttributeId attributeId);
+
+/** @brief Ethernet Network Diagnostics Cluster Server Manufacturer Specific Attribute Changed
+ *
+ * Server Manufacturer Specific Attribute Changed
+ *
+ * @param endpoint          Endpoint that is being initialized
+ * @param attributeId       Attribute that changed
+ * @param manufacturerCode  Manufacturer Code of the attribute that changed
+ */
+void emberAfEthernetNetworkDiagnosticsClusterServerManufacturerSpecificAttributeChangedCallback(chip::EndpointId endpoint,
+                                                                                                chip::AttributeId attributeId,
+                                                                                                uint16_t manufacturerCode);
+
+/** @brief Ethernet Network Diagnostics Cluster Server Message Sent
+ *
+ * Server Message Sent
+ *
+ * @param type               The type of message sent
+ * @param destination        The destination to which the message was sent
+ * @param apsFrame           The APS frame for the message
+ * @param msgLen             The length of the message
+ * @param message            The message that was sent
+ * @param status             The status of the sent message
+ */
+void emberAfEthernetNetworkDiagnosticsClusterServerMessageSentCallback(const chip::MessageSendDestination & destination,
+                                                                       EmberApsFrame * apsFrame, uint16_t msgLen, uint8_t * message,
+                                                                       EmberStatus status);
+
+/** @brief Ethernet Network Diagnostics Cluster Server Pre Attribute Changed
+ *
+ * server Pre Attribute Changed
+ *
+ * @param endpoint      Endpoint that is being initialized
+ * @param attributeId   Attribute to be changed
+ * @param attributeType Attribute type
+ * @param size          Attribute size
+ * @param value         Attribute value
+ */
+EmberAfStatus emberAfEthernetNetworkDiagnosticsClusterServerPreAttributeChangedCallback(chip::EndpointId endpoint,
+                                                                                        chip::AttributeId attributeId,
+                                                                                        EmberAfAttributeType attributeType,
+                                                                                        uint16_t size, uint8_t * value);
+
+/** @brief Ethernet Network Diagnostics Cluster Server Tick
+ *
+ * server Tick
+ *
+ * @param endpoint  Endpoint that is being served
+ */
+void emberAfEthernetNetworkDiagnosticsClusterServerTickCallback(chip::EndpointId endpoint);
+
+//
+// General Commissioning Cluster server
+//
+
+/** @brief General Commissioning Cluster Server Init
+ *
+ * Server Init
+ *
+ * @param endpoint    Endpoint that is being initialized
+ */
+void emberAfGeneralCommissioningClusterServerInitCallback(chip::EndpointId endpoint);
+
+/** @brief General Commissioning Cluster Server Attribute Changed
+ *
+ * Server Attribute Changed
+ *
+ * @param endpoint    Endpoint that is being initialized
+ * @param attributeId Attribute that changed
+ */
+void emberAfGeneralCommissioningClusterServerAttributeChangedCallback(chip::EndpointId endpoint, chip::AttributeId attributeId);
+
+/** @brief General Commissioning Cluster Server Manufacturer Specific Attribute Changed
+ *
+ * Server Manufacturer Specific Attribute Changed
+ *
+ * @param endpoint          Endpoint that is being initialized
+ * @param attributeId       Attribute that changed
+ * @param manufacturerCode  Manufacturer Code of the attribute that changed
+ */
+void emberAfGeneralCommissioningClusterServerManufacturerSpecificAttributeChangedCallback(chip::EndpointId endpoint,
+                                                                                          chip::AttributeId attributeId,
+                                                                                          uint16_t manufacturerCode);
+
+/** @brief General Commissioning Cluster Server Message Sent
+ *
+ * Server Message Sent
+ *
+ * @param type               The type of message sent
+ * @param destination        The destination to which the message was sent
+ * @param apsFrame           The APS frame for the message
+ * @param msgLen             The length of the message
+ * @param message            The message that was sent
+ * @param status             The status of the sent message
+ */
+void emberAfGeneralCommissioningClusterServerMessageSentCallback(const chip::MessageSendDestination & destination,
+                                                                 EmberApsFrame * apsFrame, uint16_t msgLen, uint8_t * message,
+                                                                 EmberStatus status);
+
+/** @brief General Commissioning Cluster Server Pre Attribute Changed
+ *
+ * server Pre Attribute Changed
+ *
+ * @param endpoint      Endpoint that is being initialized
+ * @param attributeId   Attribute to be changed
+ * @param attributeType Attribute type
+ * @param size          Attribute size
+ * @param value         Attribute value
+ */
+EmberAfStatus emberAfGeneralCommissioningClusterServerPreAttributeChangedCallback(chip::EndpointId endpoint,
+                                                                                  chip::AttributeId attributeId,
+                                                                                  EmberAfAttributeType attributeType, uint16_t size,
+                                                                                  uint8_t * value);
+
+/** @brief General Commissioning Cluster Server Tick
+ *
+ * server Tick
+ *
+ * @param endpoint  Endpoint that is being served
+ */
+void emberAfGeneralCommissioningClusterServerTickCallback(chip::EndpointId endpoint);
+
+//
+// General Diagnostics Cluster server
+//
+
+/** @brief General Diagnostics Cluster Server Init
+ *
+ * Server Init
+ *
+ * @param endpoint    Endpoint that is being initialized
+ */
+void emberAfGeneralDiagnosticsClusterServerInitCallback(chip::EndpointId endpoint);
+
+/** @brief General Diagnostics Cluster Server Attribute Changed
+ *
+ * Server Attribute Changed
+ *
+ * @param endpoint    Endpoint that is being initialized
+ * @param attributeId Attribute that changed
+ */
+void emberAfGeneralDiagnosticsClusterServerAttributeChangedCallback(chip::EndpointId endpoint, chip::AttributeId attributeId);
+
+/** @brief General Diagnostics Cluster Server Manufacturer Specific Attribute Changed
+ *
+ * Server Manufacturer Specific Attribute Changed
+ *
+ * @param endpoint          Endpoint that is being initialized
+ * @param attributeId       Attribute that changed
+ * @param manufacturerCode  Manufacturer Code of the attribute that changed
+ */
+void emberAfGeneralDiagnosticsClusterServerManufacturerSpecificAttributeChangedCallback(chip::EndpointId endpoint,
+                                                                                        chip::AttributeId attributeId,
+                                                                                        uint16_t manufacturerCode);
+
+/** @brief General Diagnostics Cluster Server Message Sent
+ *
+ * Server Message Sent
+ *
+ * @param type               The type of message sent
+ * @param destination        The destination to which the message was sent
+ * @param apsFrame           The APS frame for the message
+ * @param msgLen             The length of the message
+ * @param message            The message that was sent
+ * @param status             The status of the sent message
+ */
+void emberAfGeneralDiagnosticsClusterServerMessageSentCallback(const chip::MessageSendDestination & destination,
+                                                               EmberApsFrame * apsFrame, uint16_t msgLen, uint8_t * message,
+                                                               EmberStatus status);
+
+/** @brief General Diagnostics Cluster Server Pre Attribute Changed
+ *
+ * server Pre Attribute Changed
+ *
+ * @param endpoint      Endpoint that is being initialized
+ * @param attributeId   Attribute to be changed
+ * @param attributeType Attribute type
+ * @param size          Attribute size
+ * @param value         Attribute value
+ */
+EmberAfStatus emberAfGeneralDiagnosticsClusterServerPreAttributeChangedCallback(chip::EndpointId endpoint,
+                                                                                chip::AttributeId attributeId,
+                                                                                EmberAfAttributeType attributeType, uint16_t size,
+                                                                                uint8_t * value);
+
+/** @brief General Diagnostics Cluster Server Tick
+ *
+ * server Tick
+ *
+ * @param endpoint  Endpoint that is being served
+ */
+void emberAfGeneralDiagnosticsClusterServerTickCallback(chip::EndpointId endpoint);
+
+//
+// Network Commissioning Cluster server
+//
+
+/** @brief Network Commissioning Cluster Server Init
+ *
+ * Server Init
+ *
+ * @param endpoint    Endpoint that is being initialized
+ */
+void emberAfNetworkCommissioningClusterServerInitCallback(chip::EndpointId endpoint);
+
+/** @brief Network Commissioning Cluster Server Attribute Changed
+ *
+ * Server Attribute Changed
+ *
+ * @param endpoint    Endpoint that is being initialized
+ * @param attributeId Attribute that changed
+ */
+void emberAfNetworkCommissioningClusterServerAttributeChangedCallback(chip::EndpointId endpoint, chip::AttributeId attributeId);
+
+/** @brief Network Commissioning Cluster Server Manufacturer Specific Attribute Changed
+ *
+ * Server Manufacturer Specific Attribute Changed
+ *
+ * @param endpoint          Endpoint that is being initialized
+ * @param attributeId       Attribute that changed
+ * @param manufacturerCode  Manufacturer Code of the attribute that changed
+ */
+void emberAfNetworkCommissioningClusterServerManufacturerSpecificAttributeChangedCallback(chip::EndpointId endpoint,
+                                                                                          chip::AttributeId attributeId,
+                                                                                          uint16_t manufacturerCode);
+
+/** @brief Network Commissioning Cluster Server Message Sent
+ *
+ * Server Message Sent
+ *
+ * @param type               The type of message sent
+ * @param destination        The destination to which the message was sent
+ * @param apsFrame           The APS frame for the message
+ * @param msgLen             The length of the message
+ * @param message            The message that was sent
+ * @param status             The status of the sent message
+ */
+void emberAfNetworkCommissioningClusterServerMessageSentCallback(const chip::MessageSendDestination & destination,
+                                                                 EmberApsFrame * apsFrame, uint16_t msgLen, uint8_t * message,
+                                                                 EmberStatus status);
+
+/** @brief Network Commissioning Cluster Server Pre Attribute Changed
+ *
+ * server Pre Attribute Changed
+ *
+ * @param endpoint      Endpoint that is being initialized
+ * @param attributeId   Attribute to be changed
+ * @param attributeType Attribute type
+ * @param size          Attribute size
+ * @param value         Attribute value
+ */
+EmberAfStatus emberAfNetworkCommissioningClusterServerPreAttributeChangedCallback(chip::EndpointId endpoint,
+                                                                                  chip::AttributeId attributeId,
+                                                                                  EmberAfAttributeType attributeType, uint16_t size,
+                                                                                  uint8_t * value);
+
+/** @brief Network Commissioning Cluster Server Tick
+ *
+ * server Tick
+ *
+ * @param endpoint  Endpoint that is being served
+ */
+void emberAfNetworkCommissioningClusterServerTickCallback(chip::EndpointId endpoint);
+
+//
+// On/off Cluster server
+//
+
+/** @brief On/off Cluster Server Init
+ *
+ * Server Init
+ *
+ * @param endpoint    Endpoint that is being initialized
+ */
+void emberAfOnOffClusterServerInitCallback(chip::EndpointId endpoint);
+
+/** @brief On/off Cluster Server Attribute Changed
+ *
+ * Server Attribute Changed
+ *
+ * @param endpoint    Endpoint that is being initialized
+ * @param attributeId Attribute that changed
+ */
+void emberAfOnOffClusterServerAttributeChangedCallback(chip::EndpointId endpoint, chip::AttributeId attributeId);
+
+/** @brief On/off Cluster Server Manufacturer Specific Attribute Changed
+ *
+ * Server Manufacturer Specific Attribute Changed
+ *
+ * @param endpoint          Endpoint that is being initialized
+ * @param attributeId       Attribute that changed
+ * @param manufacturerCode  Manufacturer Code of the attribute that changed
+ */
+void emberAfOnOffClusterServerManufacturerSpecificAttributeChangedCallback(chip::EndpointId endpoint, chip::AttributeId attributeId,
+                                                                           uint16_t manufacturerCode);
+
+/** @brief On/off Cluster Server Message Sent
+ *
+ * Server Message Sent
+ *
+ * @param type               The type of message sent
+ * @param destination        The destination to which the message was sent
+ * @param apsFrame           The APS frame for the message
+ * @param msgLen             The length of the message
+ * @param message            The message that was sent
+ * @param status             The status of the sent message
+ */
+void emberAfOnOffClusterServerMessageSentCallback(const chip::MessageSendDestination & destination, EmberApsFrame * apsFrame,
+                                                  uint16_t msgLen, uint8_t * message, EmberStatus status);
+
+/** @brief On/off Cluster Server Pre Attribute Changed
+ *
+ * server Pre Attribute Changed
+ *
+ * @param endpoint      Endpoint that is being initialized
+ * @param attributeId   Attribute to be changed
+ * @param attributeType Attribute type
+ * @param size          Attribute size
+ * @param value         Attribute value
+ */
+EmberAfStatus emberAfOnOffClusterServerPreAttributeChangedCallback(chip::EndpointId endpoint, chip::AttributeId attributeId,
+                                                                   EmberAfAttributeType attributeType, uint16_t size,
+                                                                   uint8_t * value);
+
+/** @brief On/off Cluster Server Tick
+ *
+ * server Tick
+ *
+ * @param endpoint  Endpoint that is being served
+ */
+void emberAfOnOffClusterServerTickCallback(chip::EndpointId endpoint);
+
+//
+// Operational Credentials Cluster server
+//
+
+/** @brief Operational Credentials Cluster Server Init
+ *
+ * Server Init
+ *
+ * @param endpoint    Endpoint that is being initialized
+ */
+void emberAfOperationalCredentialsClusterServerInitCallback(chip::EndpointId endpoint);
+
+/** @brief Operational Credentials Cluster Server Attribute Changed
+ *
+ * Server Attribute Changed
+ *
+ * @param endpoint    Endpoint that is being initialized
+ * @param attributeId Attribute that changed
+ */
+void emberAfOperationalCredentialsClusterServerAttributeChangedCallback(chip::EndpointId endpoint, chip::AttributeId attributeId);
+
+/** @brief Operational Credentials Cluster Server Manufacturer Specific Attribute Changed
+ *
+ * Server Manufacturer Specific Attribute Changed
+ *
+ * @param endpoint          Endpoint that is being initialized
+ * @param attributeId       Attribute that changed
+ * @param manufacturerCode  Manufacturer Code of the attribute that changed
+ */
+void emberAfOperationalCredentialsClusterServerManufacturerSpecificAttributeChangedCallback(chip::EndpointId endpoint,
+                                                                                            chip::AttributeId attributeId,
+                                                                                            uint16_t manufacturerCode);
+
+/** @brief Operational Credentials Cluster Server Message Sent
+ *
+ * Server Message Sent
+ *
+ * @param type               The type of message sent
+ * @param destination        The destination to which the message was sent
+ * @param apsFrame           The APS frame for the message
+ * @param msgLen             The length of the message
+ * @param message            The message that was sent
+ * @param status             The status of the sent message
+ */
+void emberAfOperationalCredentialsClusterServerMessageSentCallback(const chip::MessageSendDestination & destination,
+                                                                   EmberApsFrame * apsFrame, uint16_t msgLen, uint8_t * message,
+                                                                   EmberStatus status);
+
+/** @brief Operational Credentials Cluster Server Pre Attribute Changed
+ *
+ * server Pre Attribute Changed
+ *
+ * @param endpoint      Endpoint that is being initialized
+ * @param attributeId   Attribute to be changed
+ * @param attributeType Attribute type
+ * @param size          Attribute size
+ * @param value         Attribute value
+ */
+EmberAfStatus emberAfOperationalCredentialsClusterServerPreAttributeChangedCallback(chip::EndpointId endpoint,
+                                                                                    chip::AttributeId attributeId,
+                                                                                    EmberAfAttributeType attributeType,
+                                                                                    uint16_t size, uint8_t * value);
+
+/** @brief Operational Credentials Cluster Server Tick
+ *
+ * server Tick
+ *
+ * @param endpoint  Endpoint that is being served
+ */
+void emberAfOperationalCredentialsClusterServerTickCallback(chip::EndpointId endpoint);
+
+//
+// Software Diagnostics Cluster server
+//
+
+/** @brief Software Diagnostics Cluster Server Init
+ *
+ * Server Init
+ *
+ * @param endpoint    Endpoint that is being initialized
+ */
+void emberAfSoftwareDiagnosticsClusterServerInitCallback(chip::EndpointId endpoint);
+
+/** @brief Software Diagnostics Cluster Server Attribute Changed
+ *
+ * Server Attribute Changed
+ *
+ * @param endpoint    Endpoint that is being initialized
+ * @param attributeId Attribute that changed
+ */
+void emberAfSoftwareDiagnosticsClusterServerAttributeChangedCallback(chip::EndpointId endpoint, chip::AttributeId attributeId);
+
+/** @brief Software Diagnostics Cluster Server Manufacturer Specific Attribute Changed
+ *
+ * Server Manufacturer Specific Attribute Changed
+ *
+ * @param endpoint          Endpoint that is being initialized
+ * @param attributeId       Attribute that changed
+ * @param manufacturerCode  Manufacturer Code of the attribute that changed
+ */
+void emberAfSoftwareDiagnosticsClusterServerManufacturerSpecificAttributeChangedCallback(chip::EndpointId endpoint,
+                                                                                         chip::AttributeId attributeId,
+                                                                                         uint16_t manufacturerCode);
+
+/** @brief Software Diagnostics Cluster Server Message Sent
+ *
+ * Server Message Sent
+ *
+ * @param type               The type of message sent
+ * @param destination        The destination to which the message was sent
+ * @param apsFrame           The APS frame for the message
+ * @param msgLen             The length of the message
+ * @param message            The message that was sent
+ * @param status             The status of the sent message
+ */
+void emberAfSoftwareDiagnosticsClusterServerMessageSentCallback(const chip::MessageSendDestination & destination,
+                                                                EmberApsFrame * apsFrame, uint16_t msgLen, uint8_t * message,
+                                                                EmberStatus status);
+
+/** @brief Software Diagnostics Cluster Server Pre Attribute Changed
+ *
+ * server Pre Attribute Changed
+ *
+ * @param endpoint      Endpoint that is being initialized
+ * @param attributeId   Attribute to be changed
+ * @param attributeType Attribute type
+ * @param size          Attribute size
+ * @param value         Attribute value
+ */
+EmberAfStatus emberAfSoftwareDiagnosticsClusterServerPreAttributeChangedCallback(chip::EndpointId endpoint,
+                                                                                 chip::AttributeId attributeId,
+                                                                                 EmberAfAttributeType attributeType, uint16_t size,
+                                                                                 uint8_t * value);
+
+/** @brief Software Diagnostics Cluster Server Tick
+ *
+ * server Tick
+ *
+ * @param endpoint  Endpoint that is being served
+ */
+void emberAfSoftwareDiagnosticsClusterServerTickCallback(chip::EndpointId endpoint);
+
+//
+// Thread Network Diagnostics Cluster server
+//
+
+/** @brief Thread Network Diagnostics Cluster Server Init
+ *
+ * Server Init
+ *
+ * @param endpoint    Endpoint that is being initialized
+ */
+void emberAfThreadNetworkDiagnosticsClusterServerInitCallback(chip::EndpointId endpoint);
+
+/** @brief Thread Network Diagnostics Cluster Server Attribute Changed
+ *
+ * Server Attribute Changed
+ *
+ * @param endpoint    Endpoint that is being initialized
+ * @param attributeId Attribute that changed
+ */
+void emberAfThreadNetworkDiagnosticsClusterServerAttributeChangedCallback(chip::EndpointId endpoint, chip::AttributeId attributeId);
+
+/** @brief Thread Network Diagnostics Cluster Server Manufacturer Specific Attribute Changed
+ *
+ * Server Manufacturer Specific Attribute Changed
+ *
+ * @param endpoint          Endpoint that is being initialized
+ * @param attributeId       Attribute that changed
+ * @param manufacturerCode  Manufacturer Code of the attribute that changed
+ */
+void emberAfThreadNetworkDiagnosticsClusterServerManufacturerSpecificAttributeChangedCallback(chip::EndpointId endpoint,
+                                                                                              chip::AttributeId attributeId,
+                                                                                              uint16_t manufacturerCode);
+
+/** @brief Thread Network Diagnostics Cluster Server Message Sent
+ *
+ * Server Message Sent
+ *
+ * @param type               The type of message sent
+ * @param destination        The destination to which the message was sent
+ * @param apsFrame           The APS frame for the message
+ * @param msgLen             The length of the message
+ * @param message            The message that was sent
+ * @param status             The status of the sent message
+ */
+void emberAfThreadNetworkDiagnosticsClusterServerMessageSentCallback(const chip::MessageSendDestination & destination,
+                                                                     EmberApsFrame * apsFrame, uint16_t msgLen, uint8_t * message,
+                                                                     EmberStatus status);
+
+/** @brief Thread Network Diagnostics Cluster Server Pre Attribute Changed
+ *
+ * server Pre Attribute Changed
+ *
+ * @param endpoint      Endpoint that is being initialized
+ * @param attributeId   Attribute to be changed
+ * @param attributeType Attribute type
+ * @param size          Attribute size
+ * @param value         Attribute value
+ */
+EmberAfStatus emberAfThreadNetworkDiagnosticsClusterServerPreAttributeChangedCallback(chip::EndpointId endpoint,
+                                                                                      chip::AttributeId attributeId,
+                                                                                      EmberAfAttributeType attributeType,
+                                                                                      uint16_t size, uint8_t * value);
+
+/** @brief Thread Network Diagnostics Cluster Server Tick
+ *
+ * server Tick
+ *
+ * @param endpoint  Endpoint that is being served
+ */
+void emberAfThreadNetworkDiagnosticsClusterServerTickCallback(chip::EndpointId endpoint);
+
+//
+// WiFi Network Diagnostics Cluster server
+//
+
+/** @brief WiFi Network Diagnostics Cluster Server Init
+ *
+ * Server Init
+ *
+ * @param endpoint    Endpoint that is being initialized
+ */
+void emberAfWiFiNetworkDiagnosticsClusterServerInitCallback(chip::EndpointId endpoint);
+
+/** @brief WiFi Network Diagnostics Cluster Server Attribute Changed
+ *
+ * Server Attribute Changed
+ *
+ * @param endpoint    Endpoint that is being initialized
+ * @param attributeId Attribute that changed
+ */
+void emberAfWiFiNetworkDiagnosticsClusterServerAttributeChangedCallback(chip::EndpointId endpoint, chip::AttributeId attributeId);
+
+/** @brief WiFi Network Diagnostics Cluster Server Manufacturer Specific Attribute Changed
+ *
+ * Server Manufacturer Specific Attribute Changed
+ *
+ * @param endpoint          Endpoint that is being initialized
+ * @param attributeId       Attribute that changed
+ * @param manufacturerCode  Manufacturer Code of the attribute that changed
+ */
+void emberAfWiFiNetworkDiagnosticsClusterServerManufacturerSpecificAttributeChangedCallback(chip::EndpointId endpoint,
+                                                                                            chip::AttributeId attributeId,
+                                                                                            uint16_t manufacturerCode);
+
+/** @brief WiFi Network Diagnostics Cluster Server Message Sent
+ *
+ * Server Message Sent
+ *
+ * @param type               The type of message sent
+ * @param destination        The destination to which the message was sent
+ * @param apsFrame           The APS frame for the message
+ * @param msgLen             The length of the message
+ * @param message            The message that was sent
+ * @param status             The status of the sent message
+ */
+void emberAfWiFiNetworkDiagnosticsClusterServerMessageSentCallback(const chip::MessageSendDestination & destination,
+                                                                   EmberApsFrame * apsFrame, uint16_t msgLen, uint8_t * message,
+                                                                   EmberStatus status);
+
+/** @brief WiFi Network Diagnostics Cluster Server Pre Attribute Changed
+ *
+ * server Pre Attribute Changed
+ *
+ * @param endpoint      Endpoint that is being initialized
+ * @param attributeId   Attribute to be changed
+ * @param attributeType Attribute type
+ * @param size          Attribute size
+ * @param value         Attribute value
+ */
+EmberAfStatus emberAfWiFiNetworkDiagnosticsClusterServerPreAttributeChangedCallback(chip::EndpointId endpoint,
+                                                                                    chip::AttributeId attributeId,
+                                                                                    EmberAfAttributeType attributeType,
+                                                                                    uint16_t size, uint8_t * value);
+
+/** @brief WiFi Network Diagnostics Cluster Server Tick
+ *
+ * server Tick
+ *
+ * @param endpoint  Endpoint that is being served
+ */
+void emberAfWiFiNetworkDiagnosticsClusterServerTickCallback(chip::EndpointId endpoint);
+
+// Cluster Commands Callback
+
+/**
+ * @brief Diagnostic Logs Cluster RetrieveLogsRequest Command callback
+ */
+
+bool emberAfDiagnosticLogsClusterRetrieveLogsRequestCallback(chip::app::Command * commandObj, uint8_t intent,
+                                                             uint8_t requestedProtocol, chip::ByteSpan transferFileDesignator);
+
+/**
+ * @brief General Commissioning Cluster ArmFailSafe Command callback
+ */
+
+bool emberAfGeneralCommissioningClusterArmFailSafeCallback(chip::app::Command * commandObj, uint16_t expiryLengthSeconds,
+                                                           uint64_t breadcrumb, uint32_t timeoutMs);
+
+/**
+ * @brief General Commissioning Cluster CommissioningComplete Command callback
+ */
+
+bool emberAfGeneralCommissioningClusterCommissioningCompleteCallback(chip::app::Command * commandObj);
+
+/**
+ * @brief General Commissioning Cluster SetRegulatoryConfig Command callback
+ */
+
+bool emberAfGeneralCommissioningClusterSetRegulatoryConfigCallback(chip::app::Command * commandObj, uint8_t location,
+                                                                   uint8_t * countryCode, uint64_t breadcrumb, uint32_t timeoutMs);
+
+/**
+ * @brief Network Commissioning Cluster AddThreadNetwork Command callback
+ */
+
+bool emberAfNetworkCommissioningClusterAddThreadNetworkCallback(chip::app::Command * commandObj, chip::ByteSpan operationalDataset,
+                                                                uint64_t breadcrumb, uint32_t timeoutMs);
+
+/**
+ * @brief Network Commissioning Cluster AddWiFiNetwork Command callback
+ */
+
+bool emberAfNetworkCommissioningClusterAddWiFiNetworkCallback(chip::app::Command * commandObj, chip::ByteSpan ssid,
+                                                              chip::ByteSpan credentials, uint64_t breadcrumb, uint32_t timeoutMs);
+
+/**
+ * @brief Network Commissioning Cluster DisableNetwork Command callback
+ */
+
+bool emberAfNetworkCommissioningClusterDisableNetworkCallback(chip::app::Command * commandObj, chip::ByteSpan networkID,
+                                                              uint64_t breadcrumb, uint32_t timeoutMs);
+
+/**
+ * @brief Network Commissioning Cluster EnableNetwork Command callback
+ */
+
+bool emberAfNetworkCommissioningClusterEnableNetworkCallback(chip::app::Command * commandObj, chip::ByteSpan networkID,
+                                                             uint64_t breadcrumb, uint32_t timeoutMs);
+
+/**
+ * @brief Network Commissioning Cluster GetLastNetworkCommissioningResult Command callback
+ */
+
+bool emberAfNetworkCommissioningClusterGetLastNetworkCommissioningResultCallback(chip::app::Command * commandObj,
+                                                                                 uint32_t timeoutMs);
+
+/**
+ * @brief Network Commissioning Cluster RemoveNetwork Command callback
+ */
+
+bool emberAfNetworkCommissioningClusterRemoveNetworkCallback(chip::app::Command * commandObj, chip::ByteSpan NetworkID,
+                                                             uint64_t Breadcrumb, uint32_t TimeoutMs);
+
+/**
+ * @brief Network Commissioning Cluster ScanNetworks Command callback
+ */
+
+bool emberAfNetworkCommissioningClusterScanNetworksCallback(chip::app::Command * commandObj, chip::ByteSpan ssid,
+                                                            uint64_t breadcrumb, uint32_t timeoutMs);
+
+/**
+ * @brief Network Commissioning Cluster UpdateThreadNetwork Command callback
+ */
+
+bool emberAfNetworkCommissioningClusterUpdateThreadNetworkCallback(chip::app::Command * commandObj,
+                                                                   chip::ByteSpan operationalDataset, uint64_t breadcrumb,
+                                                                   uint32_t timeoutMs);
+
+/**
+ * @brief Network Commissioning Cluster UpdateWiFiNetwork Command callback
+ */
+
+bool emberAfNetworkCommissioningClusterUpdateWiFiNetworkCallback(chip::app::Command * commandObj, chip::ByteSpan ssid,
+                                                                 chip::ByteSpan credentials, uint64_t breadcrumb,
+                                                                 uint32_t timeoutMs);
+
+/**
+ * @brief On/off Cluster Off Command callback
+ */
+
+bool emberAfOnOffClusterOffCallback(chip::app::Command * commandObj);
+
+/**
+ * @brief On/off Cluster On Command callback
+ */
+
+bool emberAfOnOffClusterOnCallback(chip::app::Command * commandObj);
+
+/**
+ * @brief On/off Cluster Toggle Command callback
+ */
+
+bool emberAfOnOffClusterToggleCallback(chip::app::Command * commandObj);
+
+/**
+ * @brief Operational Credentials Cluster AddOpCert Command callback
+ */
+
+bool emberAfOperationalCredentialsClusterAddOpCertCallback(chip::app::Command * commandObj, chip::ByteSpan NOCArray,
+                                                           chip::ByteSpan IPKValue, chip::NodeId CaseAdminNode,
+                                                           uint16_t AdminVendorId);
+
+/**
+ * @brief Operational Credentials Cluster AddTrustedRootCertificate Command callback
+ */
+
+bool emberAfOperationalCredentialsClusterAddTrustedRootCertificateCallback(chip::app::Command * commandObj,
+                                                                           chip::ByteSpan RootCertificate);
+
+/**
+ * @brief Operational Credentials Cluster OpCSRRequest Command callback
+ */
+
+bool emberAfOperationalCredentialsClusterOpCSRRequestCallback(chip::app::Command * commandObj, chip::ByteSpan CSRNonce);
+
+/**
+ * @brief Operational Credentials Cluster RemoveAllFabrics Command callback
+ */
+
+bool emberAfOperationalCredentialsClusterRemoveAllFabricsCallback(chip::app::Command * commandObj);
+
+/**
+ * @brief Operational Credentials Cluster RemoveFabric Command callback
+ */
+
+bool emberAfOperationalCredentialsClusterRemoveFabricCallback(chip::app::Command * commandObj, chip::FabricId FabricId,
+                                                              chip::NodeId NodeId, uint16_t VendorId);
+
+/**
+ * @brief Operational Credentials Cluster RemoveTrustedRootCertificate Command callback
+ */
+
+bool emberAfOperationalCredentialsClusterRemoveTrustedRootCertificateCallback(chip::app::Command * commandObj,
+                                                                              chip::ByteSpan TrustedRootIdentifier);
+
+/**
+ * @brief Operational Credentials Cluster SetFabric Command callback
+ */
+
+bool emberAfOperationalCredentialsClusterSetFabricCallback(chip::app::Command * commandObj, uint16_t VendorId);
+
+/**
+ * @brief Operational Credentials Cluster UpdateFabricLabel Command callback
+ */
+
+bool emberAfOperationalCredentialsClusterUpdateFabricLabelCallback(chip::app::Command * commandObj, uint8_t * Label);
+
+//
+// Non-Cluster Related Callbacks
+//
+
+/** @brief Add To Current App Tasks
+ *
+ * This function is only useful to sleepy end devices.  This function will note
+ * the passed item as part of a set of tasks the application has outstanding
+ * (e.g. message sent requiring APS acknwoledgement).  This will affect how the
+ * application behaves with regard to sleeping and polling.  Until the
+ * outstanding task is completed, the device may poll more frequently and sleep
+ * less often.
+ *
+ * @param tasks   Ver.: always
+ */
+void emberAfAddToCurrentAppTasksCallback(EmberAfApplicationTask tasks);
+
+/** @brief Remove From Current App Tasks
+ *
+ * This function is only useful to sleepy end devices.  This function will
+ * remove the passed item from the set of tasks the application has outstanding
+ * (e.g. message sent requiring APS acknwoledgement).  This will affect how the
+ * application behaves with regard to sleeping and polling.  Removing the item
+ * from the list of outstanding tasks may allow the device to sleep longer and
+ * poll less frequently.  If there are other outstanding tasks the system may
+ * still have to stay away and poll more often.
+ *
+ * @param tasks   Ver.: always
+ */
+void emberAfRemoveFromCurrentAppTasksCallback(EmberAfApplicationTask tasks);
+
+/** @brief Allow Network Write Attribute
+ *
+ * This function is called by the application framework before it writes an
+ * attribute in response to a write attribute request from an external device.
+ * The value passed into this callback is the value to which the attribute is to
+ * be set by the framework.
+        Example:	In mirroring simple metering data
+ * on an Energy Services Interface (ESI) (formerly called Energy Service Portal
+ * (ESP) in SE 1.0).), a mirrored simple meter needs to write read-only
+ * attributes on its mirror. The-meter-mirror sample application, located in
+ * app/framework/sample-apps, uses this callback to allow the mirrored device to
+ * write simple metering attributes on the mirror regardless of the fact that
+ * most simple metering attributes are defined as read-only by the ZigBee
+ * specification.
+        Note:	The ZCL specification does not (as of this
+ * writing) specify any permission-level security for writing writeable
+ * attributes. As far as the ZCL specification is concerned, if an attribute is
+ * writeable, any device that has a link key for the device should be able to
+ * write that attribute. Furthermore if an attribute is read only, it should not
+ * be written over the air. Thus, if you implement permissions for writing
+ * attributes as a feature, you MAY be operating outside the specification. This
+ * is unlikely to be a problem for writing read-only attributes, but it may be a
+ * problem for attributes that are writeable according to the specification but
+ * restricted by the application implementing this callback.
+ *
+ * @param endpoint   Ver.: always
+ * @param clusterId   Ver.: always
+ * @param attributeId   Ver.: always
+ * @param mask   Ver.: always
+ * @param manufacturerCode   Ver.: always
+ * @param value   Ver.: always
+ * @param type   Ver.: always
+ */
+EmberAfAttributeWritePermission emberAfAllowNetworkWriteAttributeCallback(chip::EndpointId endpoint, chip::ClusterId clusterId,
+                                                                          chip::AttributeId attributeId, uint8_t mask,
+                                                                          uint16_t manufacturerCode, uint8_t * value, uint8_t type);
+
+/** @brief Attribute Read Access
+ *
+ * This function is called whenever the Application Framework needs to check
+ * access permission for an attribute read.
+ *
+ * @param endpoint   Ver.: always
+ * @param clusterId   Ver.: always
+ * @param manufacturerCode   Ver.: always
+ * @param attributeId   Ver.: always
+ */
+bool emberAfAttributeReadAccessCallback(chip::EndpointId endpoint, chip::ClusterId clusterId, uint16_t manufacturerCode,
+                                        chip::AttributeId attributeId);
+
+/** @brief Attribute Write Access
+ *
+ * This function is called whenever the Application Framework needs to check
+ * access permission for an attribute write.
+ *
+ * @param endpoint   Ver.: always
+ * @param clusterId   Ver.: always
+ * @param manufacturerCode   Ver.: always
+ * @param attributeId   Ver.: always
+ */
+bool emberAfAttributeWriteAccessCallback(chip::EndpointId endpoint, chip::ClusterId clusterId, uint16_t manufacturerCode,
+                                         chip::AttributeId attributeId);
+
+/** @brief Default Response
+ *
+ * This function is called by the application framework when a Default Response
+ * command is received from an external device.  The application should return
+ * true if the message was processed or false if it was not.
+ *
+ * @param clusterId The cluster identifier of this response.  Ver.: always
+ * @param commandId The command identifier to which this is a response.  Ver.:
+ * always
+ * @param status Specifies either SUCCESS or the nature of the error that was
+ * detected in the received command.  Ver.: always
+ */
+bool emberAfDefaultResponseCallback(chip::ClusterId clusterId, chip::CommandId commandId, EmberAfStatus status);
+
+/** @brief Configure Reporting Response
+ *
+ * This function is called by the application framework when a Configure
+ * Reporting Response command is received from an external device.  The
+ * application should return true if the message was processed or false if it
+ * was not.
+ *
+ * @param clusterId The cluster identifier of this response.  Ver.: always
+ * @param buffer Buffer containing the list of attribute status records.  Ver.:
+ * always
+ * @param bufLen The length in bytes of the list.  Ver.: always
+ */
+bool emberAfConfigureReportingResponseCallback(chip::ClusterId clusterId, uint8_t * buffer, uint16_t bufLen);
+
+/** @brief Read Reporting Configuration Response
+ *
+ * This function is called by the application framework when a Read Reporting
+ * Configuration Response command is received from an external device.  The
+ * application should return true if the message was processed or false if it
+ * was not.
+ *
+ * @param clusterId The cluster identifier of this response.  Ver.: always
+ * @param buffer Buffer containing the list of attribute reporting configuration
+ * records.  Ver.: always
+ * @param bufLen The length in bytes of the list.  Ver.: always
+ */
+bool emberAfReadReportingConfigurationResponseCallback(chip::ClusterId clusterId, uint8_t * buffer, uint16_t bufLen);
+
+/** @brief Discover Attributes Response
+ *
+ * This function is called by the application framework when a Discover
+ * Attributes Response or Discover Attributes Extended Response command is
+ * received from an external device.  The Discover Attributes Response command
+ * contains a bool indicating if discovery is complete and a list of zero or
+ * more attribute identifier/type records. The final argument indicates whether
+ * the response is in the extended format or not.  The application should return
+ * true if the message was processed or false if it was not.
+ *
+ * @param clusterId The cluster identifier of this response.  Ver.: always
+ * @param discoveryComplete Indicates whether there are more attributes to be
+ * discovered.  true if there are no more attributes to be discovered.  Ver.:
+ * always
+ * @param buffer Buffer containing the list of attribute identifier/type
+ * records.  Ver.: always
+ * @param bufLen The length in bytes of the list.  Ver.: always
+ * @param extended Indicates whether the response is in the extended format or
+ * not.  Ver.: always
+ */
+bool emberAfDiscoverAttributesResponseCallback(chip::ClusterId clusterId, bool discoveryComplete, uint8_t * buffer, uint16_t bufLen,
+                                               bool extended);
+
+/** @brief Discover Commands Generated Response
+ *
+ * This function is called by the framework when Discover Commands Generated
+ * Response is received.
+ *
+ * @param clusterId The cluster identifier of this response.  Ver.: always
+ * @param manufacturerCode Manufacturer code  Ver.: always
+ * @param discoveryComplete Indicates whether there are more commands to be
+ * discovered.  Ver.: always
+ * @param commandIds Buffer containing the list of command identifiers.  Ver.:
+ * always
+ * @param commandIdCount The length of bytes of the list, whish is the same as
+ * the number of identifiers.  Ver.: always
+ */
+bool emberAfDiscoverCommandsGeneratedResponseCallback(chip::ClusterId clusterId, uint16_t manufacturerCode, bool discoveryComplete,
+                                                      chip::CommandId * commandIds, uint16_t commandIdCount);
+
+/** @brief Discover Commands Received Response
+ *
+ * This function is called by the framework when Discover Commands Received
+ * Response is received.
+ *
+ * @param clusterId The cluster identifier of this response.  Ver.: always
+ * @param manufacturerCode Manufacturer code  Ver.: always
+ * @param discoveryComplete Indicates whether there are more commands to be
+ * discovered.  Ver.: always
+ * @param commandIds Buffer containing the list of command identifiers.  Ver.:
+ * always
+ * @param commandIdCount The length of bytes of the list, whish is the same as
+ * the number of identifiers.  Ver.: always
+ */
+bool emberAfDiscoverCommandsReceivedResponseCallback(chip::ClusterId clusterId, uint16_t manufacturerCode, bool discoveryComplete,
+                                                     chip::CommandId * commandIds, uint16_t commandIdCount);
+
+/** @brief Pre Command Received
+ *
+ * This callback is the second in the Application Framework's message processing
+ * chain. At this point in the processing of incoming over-the-air messages, the
+ * application has determined that the incoming message is a ZCL command. It
+ * parses enough of the message to populate an EmberAfClusterCommand struct. The
+ * Application Framework defines this struct value in a local scope to the
+ * command processing but also makes it available through a global pointer
+ * called emberAfCurrentCommand, in app/framework/util/util.c. When command
+ * processing is complete, this pointer is cleared.
+ *
+ * @param cmd   Ver.: always
+ */
+bool emberAfPreCommandReceivedCallback(EmberAfClusterCommand * cmd);
+
+/** @brief Pre Message Send
+ *
+ * This function is called by the framework when it is about to pass a message
+ * to the stack primitives for sending.   This message may or may not be ZCL,
+ * ZDO, or some other protocol.  This is called prior to
+        any ZigBee
+ * fragmentation that may be done.  If the function returns true it is assumed
+ * the callback has consumed and processed the message.  The callback must also
+ * set the EmberStatus status code to be passed back to the caller.  The
+ * framework will do no further processing on the message.
+        If the
+ * function returns false then it is assumed that the callback has not processed
+ * the mesasge and the framework will continue to process accordingly.
+ *
+ * @param messageStruct The structure containing the parameters of the APS
+ * message to be sent.  Ver.: always
+ * @param status A pointer to the status code value that will be returned to the
+ * caller.  Ver.: always
+ */
+bool emberAfPreMessageSendCallback(EmberAfMessageStruct * messageStruct, EmberStatus * status);
+
+/** @brief Message Sent
+ *
+ * This function is called by the application framework from the message sent
+ * handler, when it is informed by the stack regarding the message sent status.
+ * All of the values passed to the emberMessageSentHandler are passed on to this
+ * callback. This provides an opportunity for the application to verify that its
+ * message has been sent successfully and take the appropriate action. This
+ * callback should return a bool value of true or false. A value of true
+ * indicates that the message sent notification has been handled and should not
+ * be handled by the application framework.
+ *
+ * @param type   Ver.: always
+ * @param destination   Ver.: always
+ * @param apsFrame   Ver.: always
+ * @param msgLen   Ver.: always
+ * @param message   Ver.: always
+ * @param status   Ver.: always
+ */
+bool emberAfMessageSentCallback(const chip::MessageSendDestination & destination, EmberApsFrame * apsFrame, uint16_t msgLen,
+                                uint8_t * message, EmberStatus status);
+
+/** @brief Pre Attribute Change
+ *
+ * This function is called by the application framework before it changes an
+ * attribute value.  The value passed into this callback is the value to which
+ * the attribute is to be set by the framework.  The application should return
+ * ::EMBER_ZCL_STATUS_SUCCESS to permit the change or any other ::EmberAfStatus
+ * to reject it.
+ *
+ * @param endpoint   Ver.: always
+ * @param clusterId   Ver.: always
+ * @param attributeId   Ver.: always
+ * @param mask   Ver.: always
+ * @param manufacturerCode   Ver.: always
+ * @param type   Ver.: always
+ * @param size   Ver.: always
+ * @param value   Ver.: always
+ */
+EmberAfStatus emberAfPreAttributeChangeCallback(chip::EndpointId endpoint, chip::ClusterId clusterId, chip::AttributeId attributeId,
+                                                uint8_t mask, uint16_t manufacturerCode, uint8_t type, uint16_t size,
+                                                uint8_t * value);
+
+/** @brief Post Attribute Change
+ *
+ * This function is called by the application framework after it changes an
+ * attribute value. The value passed into this callback is the value to which
+ * the attribute was set by the framework.
+ *
+ * @param endpoint   Ver.: always
+ * @param clusterId   Ver.: always
+ * @param attributeId   Ver.: always
+ * @param mask   Ver.: always
+ * @param manufacturerCode   Ver.: always
+ * @param type   Ver.: always
+ * @param size   Ver.: always
+ * @param value   Ver.: always
+ */
+void emberAfPostAttributeChangeCallback(chip::EndpointId endpoint, chip::ClusterId clusterId, chip::AttributeId attributeId,
+                                        uint8_t mask, uint16_t manufacturerCode, uint8_t type, uint16_t size, uint8_t * value);
+
+/** @brief External Attribute Read
+ *
+ * Like emberAfExternalAttributeWriteCallback above, this function is called
+ * when the framework needs to read an attribute that is not stored within the
+ * Application Framework's data structures.
+        All of the important
+ * information about the attribute itself is passed as a pointer to an
+ * EmberAfAttributeMetadata struct, which is stored within the application and
+ * used to manage the attribute. A complete description of the
+ * EmberAfAttributeMetadata struct is provided in
+ * app/framework/include/af-types.h
+        This function assumes that the
+ * application is able to read the attribute, write it into the passed buffer,
+ * and return immediately. Any attributes that require a state machine for
+ * reading and writing are not really candidates for externalization at the
+ * present time. The Application Framework does not currently include a state
+ * machine for reading or writing attributes that must take place across a
+ * series of application ticks. Attributes that cannot be read in a timely
+ * manner should be stored within the Application Framework and updated
+ * occasionally by the application code from within the
+ * emberAfMainTickCallback.
+        If the application was successfully able to
+ * read the attribute and write it into the passed buffer, it should return a
+ * value of EMBER_ZCL_STATUS_SUCCESS. Ensure that the size of the externally
+ * managed attribute value is smaller than what the buffer can hold. In the case
+ * of a buffer overflow throw an appropriate error such as
+ * EMBER_ZCL_STATUS_INSUFFICIENT_SPACE. Any other return value indicates the
+ * application was not able to read the attribute.
+ *
+ * @param endpoint   Ver.: always
+ * @param clusterId   Ver.: always
+ * @param attributeMetadata   Ver.: always
+ * @param manufacturerCode   Ver.: always
+ * @param buffer   Ver.: always
+ * @param maxReadLength   Ver.: always
+ * @param index   Ver.: always
+ */
+EmberAfStatus emberAfExternalAttributeReadCallback(chip::EndpointId endpoint, chip::ClusterId clusterId,
+                                                   EmberAfAttributeMetadata * attributeMetadata, uint16_t manufacturerCode,
+                                                   uint8_t * buffer, uint16_t maxReadLength, int32_t index = -1);
+
+/** @brief Write Attributes Response
+ *
+ * This function is called by the application framework when a Write Attributes
+ * Response command is received from an external device.  The application should
+ * return true if the message was processed or false if it was not.
+ *
+ * @param clusterId The cluster identifier of this response.  Ver.: always
+ * @param buffer Buffer containing the list of write attribute status records.
+ * Ver.: always
+ * @param bufLen The length in bytes of the list.  Ver.: always
+ */
+bool emberAfWriteAttributesResponseCallback(chip::ClusterId clusterId, uint8_t * buffer, uint16_t bufLen);
+
+/** @brief External Attribute Write
+ *
+ * This function is called whenever the Application Framework needs to write an
+ * attribute which is not stored within the data structures of the Application
+ * Framework itself. One of the new features in Version 2 is the ability to
+ * store attributes outside the Framework. This is particularly useful for
+ * attributes that do not need to be stored because they can be read off the
+ * hardware when they are needed, or are stored in some central location used by
+ * many modules within the system. In this case, you can indicate that the
+ * attribute is stored externally. When the framework needs to write an external
+ * attribute, it makes a call to this callback.
+        This callback is very
+ * useful for host micros which need to store attributes in persistent memory.
+ * Because each host micro (used with an Ember NCP) has its own type of
+ * persistent memory storage, the Application Framework does not include the
+ * ability to mark attributes as stored in flash the way that it does for Ember
+ * SoCs like the EM35x. On a host micro, any attributes that need to be stored
+ * in persistent memory should be marked as external and accessed through the
+ * external read and write callbacks. Any host code associated with the
+ * persistent storage should be implemented within this callback.
+        All of
+ * the important information about the attribute itself is passed as a pointer
+ * to an EmberAfAttributeMetadata struct, which is stored within the application
+ * and used to manage the attribute. A complete description of the
+ * EmberAfAttributeMetadata struct is provided in
+ * app/framework/include/af-types.h.
+        This function assumes that the
+ * application is able to write the attribute and return immediately. Any
+ * attributes that require a state machine for reading and writing are not
+ * candidates for externalization at the present time. The Application Framework
+ * does not currently include a state machine for reading or writing attributes
+ * that must take place across a series of application ticks. Attributes that
+ * cannot be written immediately should be stored within the Application
+ * Framework and updated occasionally by the application code from within the
+ * emberAfMainTickCallback.
+        If the application was successfully able to
+ * write the attribute, it returns a value of EMBER_ZCL_STATUS_SUCCESS. Any
+ * other return value indicates the application was not able to write the
+ * attribute.
+ *
+ * @param endpoint   Ver.: always
+ * @param clusterId   Ver.: always
+ * @param attributeMetadata   Ver.: always
+ * @param manufacturerCode   Ver.: always
+ * @param buffer   Ver.: always
+ * @param index   Ver.: always
+ */
+EmberAfStatus emberAfExternalAttributeWriteCallback(chip::EndpointId endpoint, chip::ClusterId clusterId,
+                                                    EmberAfAttributeMetadata * attributeMetadata, uint16_t manufacturerCode,
+                                                    uint8_t * buffer, int32_t index = -1);
+
+/** @brief Report Attributes
+ *
+ * This function is called by the application framework when a Report Attributes
+ * command is received from an external device.  The application should return
+ * true if the message was processed or false if it was not.
+ *
+ * @param clusterId The cluster identifier of this command.  Ver.: always
+ * @param buffer Buffer containing the list of attribute report records.  Ver.:
+ * always
+ * @param bufLen The length in bytes of the list.  Ver.: always
+ */
+bool emberAfReportAttributesCallback(chip::ClusterId clusterId, uint8_t * buffer, uint16_t bufLen);
+
+/** @brief Get Current Time
+ *
+ * This callback is called when device attempts to get current time from the
+ * hardware. If this device has means to retrieve exact time, then this method
+ * should implement it. If the callback can't provide the exact time it should
+ * return 0 to indicate failure. Default action is to return 0, which indicates
+ * that device does not have access to real time.
+ *
+ */
+uint32_t emberAfGetCurrentTimeCallback();
+
+/** @brief Get Endpoint Info
+ *
+ * This function is a callback to an application implemented endpoint that
+ * operates outside the normal application framework.  When the framework wishes
+ * to perform operations with that endpoint it uses this callback to retrieve
+ * the endpoint's information.  If the endpoint exists and the application can
+ * provide data then true shall be returned.  Otherwise the callback must return
+ * false.
+ *
+ * @param endpoint The endpoint to retrieve data for.  Ver.: always
+ * @param returnNetworkIndex The index corresponding to the ZigBee network the
+ * endpoint belongs to.  If not using a multi-network device, 0 must be
+ * returned.  Otherwise on a multi-network device the stack will switch to this
+ * network before sending the message.  Ver.: always
+ * @param returnEndpointInfo A pointer to a data struct that will be written
+ * with information about the endpoint.  Ver.: always
+ */
+bool emberAfGetEndpointInfoCallback(chip::EndpointId endpoint, uint8_t * returnNetworkIndex,
+                                    EmberAfEndpointInfoStruct * returnEndpointInfo);
+
+/** @brief Registration Abort
+ *
+ * This callback is called when the device should abort the registration
+ * process.
+ *
+ */
+void emberAfRegistrationAbortCallback();
+
+/** @brief Interpan Send Message
+ *
+ * This function will send a raw MAC message with interpan frame format using
+ * the passed parameters.
+ *
+ * @param header Interpan header info  Ver.: always
+ * @param messageLength The length of the message received or to send  Ver.:
+ * always
+ * @param message The message data received or to send.  Ver.: always
+ */
+EmberStatus emberAfInterpanSendMessageCallback(EmberAfInterpanHeader * header, uint16_t messageLength, uint8_t * message);
+
+/** @brief Start Move
+ *
+ * This function is called to initiate the process for a device to move (rejoin)
+ * to a new parent.
+ *
+ */
+bool emberAfStartMoveCallback();
diff --git a/cores/nRF5/nordic/config/nrf52840/gen/chip-zcl-zpro-codec-api.h b/cores/nRF5/nordic/config/nrf52840/gen/chip-zcl-zpro-codec-api.h
new file mode 100644
index 000000000..759d13c50
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/gen/chip-zcl-zpro-codec-api.h
@@ -0,0 +1,18 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+// THIS FILE IS GENERATED BY ZAP
diff --git a/cores/nRF5/nordic/config/nrf52840/gen/endpoint_config.h b/cores/nRF5/nordic/config/nrf52840/gen/endpoint_config.h
new file mode 100644
index 000000000..d6ae18469
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/gen/endpoint_config.h
@@ -0,0 +1,936 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+// THIS FILE IS GENERATED BY ZAP
+
+// Prevent multiple inclusion
+#pragma once
+
+// Default values for the attributes longer than a pointer,
+// in a form of a binary blob
+// Separate block is generated for big-endian and little-endian cases.
+#if BIGENDIAN_CPU
+#define GENERATED_DEFAULTS                                                                                                         \
+    {                                                                                                                              \
+                                                                                                                                   \
+        /* Endpoint: 0, Cluster: Basic (server), big-endian */                                                                     \
+                                                                                                                                   \
+        /* 0 - VendorName, */                                                                                                      \
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                \
+                                                                                                                                   \
+            /* 32 - ProductName, */                                                                                                \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                          \
+                                                                                                                                   \
+            /* 64 - UserLabel, */                                                                                                  \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                          \
+                                                                                                                                   \
+            /* 96 - HardwareVersionString, */                                                                                      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                              \
+                                                                                                                                   \
+            /* 160 - SoftwareVersion, */                                                                                           \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 164 - SoftwareVersionString, */                                                                                     \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                              \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: General Commissioning (server), big-endian */                                                 \
+                                                                                                                                   \
+            /* 228 - FabricId, */                                                                                                  \
+            1, 'o', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                            \
+                                                                                                                                   \
+            /* 236 - Breadcrumb, */                                                                                                \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                        \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: General Diagnostics (server), big-endian */                                                   \
+                                                                                                                                   \
+            /* 244 - NetworkInterfaces, */                                                                                         \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                              \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: Software Diagnostics (server), big-endian */                                                  \
+                                                                                                                                   \
+            /* 498 - CurrentHeapHighWatermark, */                                                                                  \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                        \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: Thread Network Diagnostics (server), big-endian */                                            \
+                                                                                                                                   \
+            /* 506 - NetworkName, */                                                                                               \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                        \
+                                                                                                                                   \
+            /* 522 - ExtendedPanId, */                                                                                             \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                        \
+                                                                                                                                   \
+            /* 530 - MeshLocalPrefix, */                                                                                           \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                  \
+                                                                                                                                   \
+            /* 547 - OverrunCount, */                                                                                              \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                        \
+                                                                                                                                   \
+            /* 555 - NeighborTableList, */                                                                                         \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                              \
+                                                                                                                                   \
+            /* 809 - RouteTableList, */                                                                                            \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                              \
+                                                                                                                                   \
+            /* 1063 - PartitionId, */                                                                                              \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1067 - TxTotalCount, */                                                                                             \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1071 - TxUnicastCount, */                                                                                           \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1075 - TxBroadcastCount, */                                                                                         \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1079 - TxAckRequestedCount, */                                                                                      \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1083 - TxAckedCount, */                                                                                             \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1087 - TxNoAckRequestedCount, */                                                                                    \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1091 - TxDataCount, */                                                                                              \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1095 - TxDataPollCount, */                                                                                          \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1099 - TxBeaconCount, */                                                                                            \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1103 - TxBeaconRequestCount, */                                                                                     \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1107 - TxOtherCount, */                                                                                             \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1111 - TxRetryCount, */                                                                                             \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1115 - TxDirectMaxRetryExpiryCount, */                                                                              \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1119 - TxIndirectMaxRetryExpiryCount, */                                                                            \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1123 - TxErrCcaCount, */                                                                                            \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1127 - TxErrAbortCount, */                                                                                          \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1131 - TxErrBusyChannelCount, */                                                                                    \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1135 - RxTotalCount, */                                                                                             \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1139 - RxUnicastCount, */                                                                                           \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1143 - RxBroadcastCount, */                                                                                         \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1147 - RxDataCount, */                                                                                              \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1151 - RxDataPollCount, */                                                                                          \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1155 - RxBeaconCount, */                                                                                            \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1159 - RxBeaconRequestCount, */                                                                                     \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1163 - RxOtherCount, */                                                                                             \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1167 - RxAddressFilteredCount, */                                                                                   \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1171 - RxDestAddrFilteredCount, */                                                                                  \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1175 - RxDuplicatedCount, */                                                                                        \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1179 - RxErrNoFrameCount, */                                                                                        \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1183 - RxErrUnknownNeighborCount, */                                                                                \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1187 - RxErrInvalidSrcAddrCount, */                                                                                 \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1191 - RxErrSecCount, */                                                                                            \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1195 - RxErrFcsCount, */                                                                                            \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1199 - RxErrOtherCount, */                                                                                          \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1203 - SecurityPolicy, */                                                                                           \
+            0x00, 0x00, 0x00, 0x00, 0x00,                                                                                          \
+                                                                                                                                   \
+            /* 1208 - OperationalDatasetComponents, */                                                                             \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                    \
+                                                                                                                                   \
+            /* 1222 - ActiveNetworkFaultsList, */                                                                                  \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: WiFi Network Diagnostics (server), big-endian */                                              \
+                                                                                                                                   \
+            /* 1226 - bssid, */                                                                                                    \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                                    \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: Ethernet Network Diagnostics (server), big-endian */                                          \
+                                                                                                                                   \
+            /* 1232 - PacketRxCount, */                                                                                            \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                        \
+                                                                                                                                   \
+            /* 1240 - PacketTxCount, */                                                                                            \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                        \
+                                                                                                                                   \
+            /* 1248 - TxErrCount, */                                                                                               \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                        \
+                                                                                                                                   \
+            /* 1256 - CollisionCount, */                                                                                           \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                        \
+                                                                                                                                   \
+            /* 1264 - OverrunCount, */                                                                                             \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                        \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: Operational Credentials (server), big-endian */                                               \
+                                                                                                                                   \
+            /* 1272 - fabrics list, */                                                                                             \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                              \
+    }
+
+#else // !BIGENDIAN_CPU
+#define GENERATED_DEFAULTS                                                                                                         \
+    {                                                                                                                              \
+                                                                                                                                   \
+        /* Endpoint: 0, Cluster: Basic (server), little-endian */                                                                  \
+                                                                                                                                   \
+        /* 0 - VendorName, */                                                                                                      \
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                \
+                                                                                                                                   \
+            /* 32 - ProductName, */                                                                                                \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                          \
+                                                                                                                                   \
+            /* 64 - UserLabel, */                                                                                                  \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                          \
+                                                                                                                                   \
+            /* 96 - HardwareVersionString, */                                                                                      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                              \
+                                                                                                                                   \
+            /* 160 - SoftwareVersion, */                                                                                           \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 164 - SoftwareVersionString, */                                                                                     \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                              \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: General Commissioning (server), little-endian */                                              \
+                                                                                                                                   \
+            /* 228 - FabricId, */                                                                                                  \
+            1, 'o', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                            \
+                                                                                                                                   \
+            /* 236 - Breadcrumb, */                                                                                                \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                        \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: General Diagnostics (server), little-endian */                                                \
+                                                                                                                                   \
+            /* 244 - NetworkInterfaces, */                                                                                         \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                              \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: Software Diagnostics (server), little-endian */                                               \
+                                                                                                                                   \
+            /* 498 - CurrentHeapHighWatermark, */                                                                                  \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                        \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: Thread Network Diagnostics (server), little-endian */                                         \
+                                                                                                                                   \
+            /* 506 - NetworkName, */                                                                                               \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                        \
+                                                                                                                                   \
+            /* 522 - ExtendedPanId, */                                                                                             \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                        \
+                                                                                                                                   \
+            /* 530 - MeshLocalPrefix, */                                                                                           \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                  \
+                                                                                                                                   \
+            /* 547 - OverrunCount, */                                                                                              \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                        \
+                                                                                                                                   \
+            /* 555 - NeighborTableList, */                                                                                         \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                              \
+                                                                                                                                   \
+            /* 809 - RouteTableList, */                                                                                            \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                              \
+                                                                                                                                   \
+            /* 1063 - PartitionId, */                                                                                              \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1067 - TxTotalCount, */                                                                                             \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1071 - TxUnicastCount, */                                                                                           \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1075 - TxBroadcastCount, */                                                                                         \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1079 - TxAckRequestedCount, */                                                                                      \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1083 - TxAckedCount, */                                                                                             \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1087 - TxNoAckRequestedCount, */                                                                                    \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1091 - TxDataCount, */                                                                                              \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1095 - TxDataPollCount, */                                                                                          \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1099 - TxBeaconCount, */                                                                                            \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1103 - TxBeaconRequestCount, */                                                                                     \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1107 - TxOtherCount, */                                                                                             \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1111 - TxRetryCount, */                                                                                             \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1115 - TxDirectMaxRetryExpiryCount, */                                                                              \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1119 - TxIndirectMaxRetryExpiryCount, */                                                                            \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1123 - TxErrCcaCount, */                                                                                            \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1127 - TxErrAbortCount, */                                                                                          \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1131 - TxErrBusyChannelCount, */                                                                                    \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1135 - RxTotalCount, */                                                                                             \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1139 - RxUnicastCount, */                                                                                           \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1143 - RxBroadcastCount, */                                                                                         \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1147 - RxDataCount, */                                                                                              \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1151 - RxDataPollCount, */                                                                                          \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1155 - RxBeaconCount, */                                                                                            \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1159 - RxBeaconRequestCount, */                                                                                     \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1163 - RxOtherCount, */                                                                                             \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1167 - RxAddressFilteredCount, */                                                                                   \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1171 - RxDestAddrFilteredCount, */                                                                                  \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1175 - RxDuplicatedCount, */                                                                                        \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1179 - RxErrNoFrameCount, */                                                                                        \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1183 - RxErrUnknownNeighborCount, */                                                                                \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1187 - RxErrInvalidSrcAddrCount, */                                                                                 \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1191 - RxErrSecCount, */                                                                                            \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1195 - RxErrFcsCount, */                                                                                            \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1199 - RxErrOtherCount, */                                                                                          \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* 1203 - SecurityPolicy, */                                                                                           \
+            0x00, 0x00, 0x00, 0x00, 0x00,                                                                                          \
+                                                                                                                                   \
+            /* 1208 - OperationalDatasetComponents, */                                                                             \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                    \
+                                                                                                                                   \
+            /* 1222 - ActiveNetworkFaultsList, */                                                                                  \
+            0x00, 0x00, 0x00, 0x00,                                                                                                \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: WiFi Network Diagnostics (server), little-endian */                                           \
+                                                                                                                                   \
+            /* 1226 - bssid, */                                                                                                    \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                                    \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: Ethernet Network Diagnostics (server), little-endian */                                       \
+                                                                                                                                   \
+            /* 1232 - PacketRxCount, */                                                                                            \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                        \
+                                                                                                                                   \
+            /* 1240 - PacketTxCount, */                                                                                            \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                        \
+                                                                                                                                   \
+            /* 1248 - TxErrCount, */                                                                                               \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                        \
+                                                                                                                                   \
+            /* 1256 - CollisionCount, */                                                                                           \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                        \
+                                                                                                                                   \
+            /* 1264 - OverrunCount, */                                                                                             \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                        \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: Operational Credentials (server), little-endian */                                            \
+                                                                                                                                   \
+            /* 1272 - fabrics list, */                                                                                             \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,      \
+            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                                              \
+    }
+
+#endif // BIGENDIAN_CPU
+
+#define GENERATED_DEFAULTS_COUNT (61)
+
+#define ZAP_TYPE(type) ZCL_##type##_ATTRIBUTE_TYPE
+#define ZAP_LONG_DEFAULTS_INDEX(index)                                                                                             \
+    {                                                                                                                              \
+        (uint8_t *) (&generatedDefaults[index])                                                                                    \
+    }
+#define ZAP_MIN_MAX_DEFAULTS_INDEX(index)                                                                                          \
+    {                                                                                                                              \
+        (uint8_t *) (&minMaxDefault[index])                                                                                        \
+    }
+#define ZAP_EMPTY_DEFAULT()                                                                                                        \
+    {                                                                                                                              \
+        (uint16_t) 0                                                                                                               \
+    }
+#define ZAP_SIMPLE_DEFAULT(x)                                                                                                      \
+    {                                                                                                                              \
+        (uint16_t) x                                                                                                               \
+    }
+
+// This is an array of EmberAfAttributeMinMaxValue structures.
+#define GENERATED_MIN_MAX_DEFAULT_COUNT 0
+#define GENERATED_MIN_MAX_DEFAULTS                                                                                                 \
+    {                                                                                                                              \
+    }
+
+#define ZAP_ATTRIBUTE_MASK(mask) ATTRIBUTE_MASK_##mask
+// This is an array of EmberAfAttributeMetadata structures.
+#define GENERATED_ATTRIBUTE_COUNT 98
+#define GENERATED_ATTRIBUTES                                                                                                       \
+    {                                                                                                                              \
+                                                                                                                                   \
+        /* Endpoint: 0, Cluster: Basic (server) */                                                                                 \
+        { 0x0000, ZAP_TYPE(INT16U), 2, ZAP_ATTRIBUTE_MASK(SINGLETON), ZAP_EMPTY_DEFAULT() }, /* InteractionModelVersion */         \
+            { 0x0001, ZAP_TYPE(CHAR_STRING), 32, ZAP_ATTRIBUTE_MASK(SINGLETON), ZAP_LONG_DEFAULTS_INDEX(0) },  /* VendorName */    \
+            { 0x0002, ZAP_TYPE(INT16U), 2, ZAP_ATTRIBUTE_MASK(SINGLETON), ZAP_EMPTY_DEFAULT() },               /* VendorID */      \
+            { 0x0003, ZAP_TYPE(CHAR_STRING), 32, ZAP_ATTRIBUTE_MASK(SINGLETON), ZAP_LONG_DEFAULTS_INDEX(32) }, /* ProductName */   \
+            { 0x0004, ZAP_TYPE(INT16U), 2, ZAP_ATTRIBUTE_MASK(SINGLETON), ZAP_EMPTY_DEFAULT() },               /* ProductID */     \
+            { 0x0005, ZAP_TYPE(CHAR_STRING), 32, ZAP_ATTRIBUTE_MASK(SINGLETON) | ZAP_ATTRIBUTE_MASK(WRITABLE),                     \
+              ZAP_LONG_DEFAULTS_INDEX(64) }, /* UserLabel */                                                                       \
+            { 0x0006, ZAP_TYPE(CHAR_STRING), 2, ZAP_ATTRIBUTE_MASK(SINGLETON) | ZAP_ATTRIBUTE_MASK(WRITABLE),                      \
+              ZAP_EMPTY_DEFAULT() },                                                                  /* Location */               \
+            { 0x0007, ZAP_TYPE(INT16U), 2, ZAP_ATTRIBUTE_MASK(SINGLETON), ZAP_SIMPLE_DEFAULT(0x00) }, /* HardwareVersion */        \
+            { 0x0008, ZAP_TYPE(CHAR_STRING), 64, ZAP_ATTRIBUTE_MASK(SINGLETON),                                                    \
+              ZAP_LONG_DEFAULTS_INDEX(96) }, /* HardwareVersionString */                                                           \
+            { 0x0009, ZAP_TYPE(INT32U), 4, ZAP_ATTRIBUTE_MASK(SINGLETON), ZAP_LONG_DEFAULTS_INDEX(160) }, /* SoftwareVersion */    \
+            { 0x000A, ZAP_TYPE(CHAR_STRING), 64, ZAP_ATTRIBUTE_MASK(SINGLETON),                                                    \
+              ZAP_LONG_DEFAULTS_INDEX(164) },                                                      /* SoftwareVersionString */     \
+            { 0xFFFD, ZAP_TYPE(INT16U), 2, ZAP_ATTRIBUTE_MASK(SINGLETON), ZAP_SIMPLE_DEFAULT(3) }, /* cluster revision */          \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: General Commissioning (server) */                                                             \
+            { 0x0000, ZAP_TYPE(OCTET_STRING), 8, 0, ZAP_LONG_DEFAULTS_INDEX(228) },                      /* FabricId */            \
+            { 0x0001, ZAP_TYPE(INT64U), 8, ZAP_ATTRIBUTE_MASK(WRITABLE), ZAP_LONG_DEFAULTS_INDEX(236) }, /* Breadcrumb */          \
+            { 0xFFFD, ZAP_TYPE(INT16U), 2, 0, ZAP_SIMPLE_DEFAULT(0x0001) },                              /* cluster revision */    \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: Network Commissioning (server) */                                                             \
+            { 0xFFFD, ZAP_TYPE(INT16U), 2, 0, ZAP_SIMPLE_DEFAULT(0x0001) }, /* cluster revision */                                 \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: General Diagnostics (server) */                                                               \
+            { 0x0000, ZAP_TYPE(ARRAY), 254, 0, ZAP_LONG_DEFAULTS_INDEX(244) }, /* NetworkInterfaces */                             \
+            { 0x0001, ZAP_TYPE(INT16U), 2, 0, ZAP_SIMPLE_DEFAULT(0x0000) },    /* RebootCount */                                   \
+            { 0xFFFD, ZAP_TYPE(INT16U), 2, 0, ZAP_SIMPLE_DEFAULT(0x0001) },    /* cluster revision */                              \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: Software Diagnostics (server) */                                                              \
+            { 0x0003, ZAP_TYPE(INT64U), 8, 0, ZAP_LONG_DEFAULTS_INDEX(498) }, /* CurrentHeapHighWatermark */                       \
+            { 0xFFFD, ZAP_TYPE(INT16U), 2, 0, ZAP_SIMPLE_DEFAULT(0x0001) },   /* cluster revision */                               \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: Thread Network Diagnostics (server) */                                                        \
+            { 0x0000, ZAP_TYPE(INT8U), 1, 0, ZAP_EMPTY_DEFAULT() },                  /* channel */                                 \
+            { 0x0001, ZAP_TYPE(ENUM8), 1, 0, ZAP_EMPTY_DEFAULT() },                  /* RoutingRole */                             \
+            { 0x0002, ZAP_TYPE(OCTET_STRING), 16, 0, ZAP_LONG_DEFAULTS_INDEX(506) }, /* NetworkName */                             \
+            { 0x0003, ZAP_TYPE(INT16U), 2, 0, ZAP_SIMPLE_DEFAULT(0x0000) },          /* PanId */                                   \
+            { 0x0004, ZAP_TYPE(INT64U), 8, 0, ZAP_LONG_DEFAULTS_INDEX(522) },        /* ExtendedPanId */                           \
+            { 0x0005, ZAP_TYPE(OCTET_STRING), 17, 0, ZAP_LONG_DEFAULTS_INDEX(530) }, /* MeshLocalPrefix */                         \
+            { 0x0006, ZAP_TYPE(INT64U), 8, 0, ZAP_LONG_DEFAULTS_INDEX(547) },        /* OverrunCount */                            \
+            { 0x0007, ZAP_TYPE(ARRAY), 254, 0, ZAP_LONG_DEFAULTS_INDEX(555) },       /* NeighborTableList */                       \
+            { 0x0008, ZAP_TYPE(ARRAY), 254, 0, ZAP_LONG_DEFAULTS_INDEX(809) },       /* RouteTableList */                          \
+            { 0x0009, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1063) },       /* PartitionId */                             \
+            { 0x000A, ZAP_TYPE(INT8U), 1, 0, ZAP_EMPTY_DEFAULT() },                  /* weighting */                               \
+            { 0x000B, ZAP_TYPE(INT8U), 1, 0, ZAP_EMPTY_DEFAULT() },                  /* DataVersion */                             \
+            { 0x000C, ZAP_TYPE(INT8U), 1, 0, ZAP_EMPTY_DEFAULT() },                  /* StableDataVersion */                       \
+            { 0x000D, ZAP_TYPE(INT8U), 1, 0, ZAP_EMPTY_DEFAULT() },                  /* LeaderRouterId */                          \
+            { 0x000E, ZAP_TYPE(INT16U), 2, 0, ZAP_SIMPLE_DEFAULT(0x0000) },          /* DetachedRoleCount */                       \
+            { 0x000F, ZAP_TYPE(INT16U), 2, 0, ZAP_SIMPLE_DEFAULT(0x0000) },          /* ChildRoleCount */                          \
+            { 0x0010, ZAP_TYPE(INT16U), 2, 0, ZAP_SIMPLE_DEFAULT(0x0000) },          /* RouterRoleCount */                         \
+            { 0x0011, ZAP_TYPE(INT16U), 2, 0, ZAP_SIMPLE_DEFAULT(0x0000) },          /* LeaderRoleCount */                         \
+            { 0x0012, ZAP_TYPE(INT16U), 2, 0, ZAP_SIMPLE_DEFAULT(0x0000) },          /* AttachAttemptCount */                      \
+            { 0x0013, ZAP_TYPE(INT16U), 2, 0, ZAP_SIMPLE_DEFAULT(0x0000) },          /* PartitionIdChangeCount */                  \
+            { 0x0014, ZAP_TYPE(INT16U), 2, 0, ZAP_SIMPLE_DEFAULT(0x0000) },          /* BetterPartitionAttachAttemptCount */       \
+            { 0x0015, ZAP_TYPE(INT16U), 2, 0, ZAP_SIMPLE_DEFAULT(0x0000) },          /* ParentChangeCount */                       \
+            { 0x0016, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1067) },       /* TxTotalCount */                            \
+            { 0x0017, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1071) },       /* TxUnicastCount */                          \
+            { 0x0018, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1075) },       /* TxBroadcastCount */                        \
+            { 0x0019, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1079) },       /* TxAckRequestedCount */                     \
+            { 0x001A, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1083) },       /* TxAckedCount */                            \
+            { 0x001B, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1087) },       /* TxNoAckRequestedCount */                   \
+            { 0x001C, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1091) },       /* TxDataCount */                             \
+            { 0x001D, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1095) },       /* TxDataPollCount */                         \
+            { 0x001E, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1099) },       /* TxBeaconCount */                           \
+            { 0x001F, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1103) },       /* TxBeaconRequestCount */                    \
+            { 0x0020, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1107) },       /* TxOtherCount */                            \
+            { 0x0021, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1111) },       /* TxRetryCount */                            \
+            { 0x0022, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1115) },       /* TxDirectMaxRetryExpiryCount */             \
+            { 0x0023, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1119) },       /* TxIndirectMaxRetryExpiryCount */           \
+            { 0x0024, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1123) },       /* TxErrCcaCount */                           \
+            { 0x0025, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1127) },       /* TxErrAbortCount */                         \
+            { 0x0026, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1131) },       /* TxErrBusyChannelCount */                   \
+            { 0x0027, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1135) },       /* RxTotalCount */                            \
+            { 0x0028, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1139) },       /* RxUnicastCount */                          \
+            { 0x0029, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1143) },       /* RxBroadcastCount */                        \
+            { 0x002A, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1147) },       /* RxDataCount */                             \
+            { 0x002B, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1151) },       /* RxDataPollCount */                         \
+            { 0x002C, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1155) },       /* RxBeaconCount */                           \
+            { 0x002D, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1159) },       /* RxBeaconRequestCount */                    \
+            { 0x002E, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1163) },       /* RxOtherCount */                            \
+            { 0x002F, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1167) },       /* RxAddressFilteredCount */                  \
+            { 0x0030, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1171) },       /* RxDestAddrFilteredCount */                 \
+            { 0x0031, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1175) },       /* RxDuplicatedCount */                       \
+            { 0x0032, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1179) },       /* RxErrNoFrameCount */                       \
+            { 0x0033, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1183) },       /* RxErrUnknownNeighborCount */               \
+            { 0x0034, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1187) },       /* RxErrInvalidSrcAddrCount */                \
+            { 0x0035, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1191) },       /* RxErrSecCount */                           \
+            { 0x0036, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1195) },       /* RxErrFcsCount */                           \
+            { 0x0037, ZAP_TYPE(INT32U), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1199) },       /* RxErrOtherCount */                         \
+            { 0x003B, ZAP_TYPE(ARRAY), 5, 0, ZAP_LONG_DEFAULTS_INDEX(1203) },        /* SecurityPolicy */                          \
+            { 0x003C, ZAP_TYPE(INT8U), 1, 0, ZAP_SIMPLE_DEFAULT(0x0000) },           /* ChannelMask */                             \
+            { 0x003D, ZAP_TYPE(ARRAY), 14, 0, ZAP_LONG_DEFAULTS_INDEX(1208) },       /* OperationalDatasetComponents */            \
+            { 0x003E, ZAP_TYPE(ARRAY), 4, 0, ZAP_LONG_DEFAULTS_INDEX(1222) },        /* ActiveNetworkFaultsList */                 \
+            { 0xFFFD, ZAP_TYPE(INT16U), 2, 0, ZAP_SIMPLE_DEFAULT(0x0001) },          /* cluster revision */                        \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: WiFi Network Diagnostics (server) */                                                          \
+            { 0x0000, ZAP_TYPE(OCTET_STRING), 6, 0, ZAP_LONG_DEFAULTS_INDEX(1226) }, /* bssid */                                   \
+            { 0x0001, ZAP_TYPE(ENUM8), 1, 0, ZAP_EMPTY_DEFAULT() },                  /* SecurityType */                            \
+            { 0x0002, ZAP_TYPE(ENUM8), 1, 0, ZAP_EMPTY_DEFAULT() },                  /* WiFiVersion */                             \
+            { 0x0003, ZAP_TYPE(INT16U), 2, 0, ZAP_SIMPLE_DEFAULT(0x0000) },          /* ChannelNumber */                           \
+            { 0x0004, ZAP_TYPE(INT8S), 1, 0, ZAP_SIMPLE_DEFAULT(0x00) },             /* Rssi */                                    \
+            { 0xFFFD, ZAP_TYPE(INT16U), 2, 0, ZAP_SIMPLE_DEFAULT(0x0001) },          /* cluster revision */                        \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: Ethernet Network Diagnostics (server) */                                                      \
+            { 0x0002, ZAP_TYPE(INT64U), 8, 0, ZAP_LONG_DEFAULTS_INDEX(1232) }, /* PacketRxCount */                                 \
+            { 0x0003, ZAP_TYPE(INT64U), 8, 0, ZAP_LONG_DEFAULTS_INDEX(1240) }, /* PacketTxCount */                                 \
+            { 0x0004, ZAP_TYPE(INT64U), 8, 0, ZAP_LONG_DEFAULTS_INDEX(1248) }, /* TxErrCount */                                    \
+            { 0x0005, ZAP_TYPE(INT64U), 8, 0, ZAP_LONG_DEFAULTS_INDEX(1256) }, /* CollisionCount */                                \
+            { 0x0006, ZAP_TYPE(INT64U), 8, 0, ZAP_LONG_DEFAULTS_INDEX(1264) }, /* OverrunCount */                                  \
+            { 0xFFFD, ZAP_TYPE(INT16U), 2, 0, ZAP_SIMPLE_DEFAULT(0x0001) },    /* cluster revision */                              \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: Operational Credentials (server) */                                                           \
+            { 0x0001, ZAP_TYPE(ARRAY), 254, 0, ZAP_LONG_DEFAULTS_INDEX(1272) }, /* fabrics list */                                 \
+            { 0xFFFD, ZAP_TYPE(INT16U), 2, 0, ZAP_SIMPLE_DEFAULT(0x0001) },     /* cluster revision */                             \
+                                                                                                                                   \
+            /* Endpoint: 1, Cluster: On/off (server) */                                                                            \
+            { 0x0000, ZAP_TYPE(BOOLEAN), 1, 0, ZAP_SIMPLE_DEFAULT(0x00) }, /* on/off */                                            \
+            { 0xFFFD, ZAP_TYPE(INT16U), 2, 0, ZAP_SIMPLE_DEFAULT(2) },     /* cluster revision */                                  \
+    }
+
+// This is an array of EmberAfCluster structures.
+#define ZAP_ATTRIBUTE_INDEX(index) ((EmberAfAttributeMetadata *) (&generatedAttributes[index]))
+
+// Cluster function static arrays
+#define GENERATED_FUNCTION_ARRAYS                                                                                                  \
+    const EmberAfGenericClusterFunction chipFuncArrayBasicServer[] = {                                                             \
+        (EmberAfGenericClusterFunction) emberAfBasicClusterServerInitCallback,                                                     \
+    };                                                                                                                             \
+    const EmberAfGenericClusterFunction chipFuncArrayOnOffServer[] = {                                                             \
+        (EmberAfGenericClusterFunction) emberAfOnOffClusterServerInitCallback,                                                     \
+    };
+
+#define ZAP_CLUSTER_MASK(mask) CLUSTER_MASK_##mask
+#define GENERATED_CLUSTER_COUNT 11
+#define GENERATED_CLUSTERS                                                                                                         \
+    {                                                                                                                              \
+        { 0x0028,                                                                                                                  \
+          ZAP_ATTRIBUTE_INDEX(0),                                                                                                  \
+          12,                                                                                                                      \
+          240,                                                                                                                     \
+          ZAP_CLUSTER_MASK(SERVER) | ZAP_CLUSTER_MASK(INIT_FUNCTION),                                                              \
+          chipFuncArrayBasicServer }, /* Endpoint: 0, Cluster: Basic (server) */                                                   \
+            {                                                                                                                      \
+                0x0030, ZAP_ATTRIBUTE_INDEX(12), 3, 18, ZAP_CLUSTER_MASK(SERVER), NULL                                             \
+            }, /* Endpoint: 0, Cluster: General Commissioning (server) */                                                          \
+            {                                                                                                                      \
+                0x0031, ZAP_ATTRIBUTE_INDEX(15), 1, 2, ZAP_CLUSTER_MASK(SERVER), NULL                                              \
+            }, /* Endpoint: 0, Cluster: Network Commissioning (server) */                                                          \
+            {                                                                                                                      \
+                0x0032, ZAP_ATTRIBUTE_INDEX(16), 0, 0, ZAP_CLUSTER_MASK(SERVER), NULL                                              \
+            }, /* Endpoint: 0, Cluster: Diagnostic Logs (server) */                                                                \
+            {                                                                                                                      \
+                0x0033, ZAP_ATTRIBUTE_INDEX(16), 3, 258, ZAP_CLUSTER_MASK(SERVER), NULL                                            \
+            }, /* Endpoint: 0, Cluster: General Diagnostics (server) */                                                            \
+            {                                                                                                                      \
+                0x0034, ZAP_ATTRIBUTE_INDEX(19), 2, 10, ZAP_CLUSTER_MASK(SERVER), NULL                                             \
+            }, /* Endpoint: 0, Cluster: Software Diagnostics (server) */                                                           \
+            {                                                                                                                      \
+                0x0035, ZAP_ATTRIBUTE_INDEX(21), 61, 747, ZAP_CLUSTER_MASK(SERVER), NULL                                           \
+            }, /* Endpoint: 0, Cluster: Thread Network Diagnostics (server) */                                                     \
+            {                                                                                                                      \
+                0x0036, ZAP_ATTRIBUTE_INDEX(82), 6, 13, ZAP_CLUSTER_MASK(SERVER), NULL                                             \
+            }, /* Endpoint: 0, Cluster: WiFi Network Diagnostics (server) */                                                       \
+            {                                                                                                                      \
+                0x0037, ZAP_ATTRIBUTE_INDEX(88), 6, 42, ZAP_CLUSTER_MASK(SERVER), NULL                                             \
+            }, /* Endpoint: 0, Cluster: Ethernet Network Diagnostics (server) */                                                   \
+            {                                                                                                                      \
+                0x003E, ZAP_ATTRIBUTE_INDEX(94), 2, 256, ZAP_CLUSTER_MASK(SERVER), NULL                                            \
+            }, /* Endpoint: 0, Cluster: Operational Credentials (server) */                                                        \
+            { 0x0006,                                                                                                              \
+              ZAP_ATTRIBUTE_INDEX(96),                                                                                             \
+              2,                                                                                                                   \
+              3,                                                                                                                   \
+              ZAP_CLUSTER_MASK(SERVER) | ZAP_CLUSTER_MASK(INIT_FUNCTION),                                                          \
+              chipFuncArrayOnOffServer }, /* Endpoint: 1, Cluster: On/off (server) */                                              \
+    }
+
+#define ZAP_CLUSTER_INDEX(index) ((EmberAfCluster *) (&generatedClusters[index]))
+
+// This is an array of EmberAfEndpointType structures.
+#define GENERATED_ENDPOINT_TYPES                                                                                                   \
+    {                                                                                                                              \
+        { ZAP_CLUSTER_INDEX(0), 10, 1586 }, { ZAP_CLUSTER_INDEX(10), 1, 3 },                                                       \
+    }
+
+// Largest attribute size is needed for various buffers
+#define ATTRIBUTE_LARGEST (255)
+
+// Total size of singleton attributes
+#define ATTRIBUTE_SINGLETONS_SIZE (240)
+
+// Total size of attribute storage
+#define ATTRIBUTE_MAX_SIZE (1589)
+
+// Number of fixed endpoints
+#define FIXED_ENDPOINT_COUNT (2)
+
+// Array of endpoints that are supported, the data inside
+// the array is the endpoint number.
+#define FIXED_ENDPOINT_ARRAY                                                                                                       \
+    {                                                                                                                              \
+        0x0000, 0x0001                                                                                                             \
+    }
+
+// Array of profile ids
+#define FIXED_PROFILE_IDS                                                                                                          \
+    {                                                                                                                              \
+        0x0109, 0x0105                                                                                                             \
+    }
+
+// Array of device ids
+#define FIXED_DEVICE_IDS                                                                                                           \
+    {                                                                                                                              \
+        0, 0                                                                                                                       \
+    }
+
+// Array of device versions
+#define FIXED_DEVICE_VERSIONS                                                                                                      \
+    {                                                                                                                              \
+        1, 1                                                                                                                       \
+    }
+
+// Array of endpoint types supported on each endpoint
+#define FIXED_ENDPOINT_TYPES                                                                                                       \
+    {                                                                                                                              \
+        0, 1                                                                                                                       \
+    }
+
+// Array of networks supported on each endpoint
+#define FIXED_NETWORKS                                                                                                             \
+    {                                                                                                                              \
+        0, 0                                                                                                                       \
+    }
+
+// Array of EmberAfCommandMetadata structs.
+#define ZAP_COMMAND_MASK(mask) COMMAND_MASK_##mask
+#define EMBER_AF_GENERATED_COMMAND_COUNT (43)
+#define GENERATED_COMMANDS                                                                                                         \
+    {                                                                                                                              \
+                                                                                                                                   \
+        /* Endpoint: 0, Cluster: Basic (server) */                                                                                 \
+        { 0x0028, 0x00, ZAP_COMMAND_MASK(INCOMING_CLIENT) },     /* StartUp */                                                     \
+            { 0x0028, 0x01, ZAP_COMMAND_MASK(INCOMING_CLIENT) }, /* ShutDown */                                                    \
+            { 0x0028, 0x02, ZAP_COMMAND_MASK(INCOMING_CLIENT) }, /* Leave */                                                       \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: General Commissioning (server) */                                                             \
+            { 0x0030, 0x00, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* ArmFailSafe */                                                 \
+            { 0x0030, 0x01, ZAP_COMMAND_MASK(INCOMING_CLIENT) }, /* ArmFailSafeResponse */                                         \
+            { 0x0030, 0x02, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* SetRegulatoryConfig */                                         \
+            { 0x0030, 0x03, ZAP_COMMAND_MASK(OUTGOING_SERVER) }, /* SetRegulatoryConfigResponse */                                 \
+            { 0x0030, 0x04, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* CommissioningComplete */                                       \
+            { 0x0030, 0x05, ZAP_COMMAND_MASK(INCOMING_CLIENT) }, /* CommissioningCompleteResponse */                               \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: Network Commissioning (server) */                                                             \
+            { 0x0031, 0x00, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* ScanNetworks */                                                \
+            { 0x0031, 0x01, ZAP_COMMAND_MASK(INCOMING_CLIENT) }, /* ScanNetworksResponse */                                        \
+            { 0x0031, 0x02, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* AddWiFiNetwork */                                              \
+            { 0x0031, 0x03, ZAP_COMMAND_MASK(OUTGOING_SERVER) }, /* AddWiFiNetworkResponse */                                      \
+            { 0x0031, 0x04, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* UpdateWiFiNetwork */                                           \
+            { 0x0031, 0x05, ZAP_COMMAND_MASK(OUTGOING_SERVER) }, /* UpdateWiFiNetworkResponse */                                   \
+            { 0x0031, 0x06, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* AddThreadNetwork */                                            \
+            { 0x0031, 0x07, ZAP_COMMAND_MASK(OUTGOING_SERVER) }, /* AddThreadNetworkResponse */                                    \
+            { 0x0031, 0x08, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* UpdateThreadNetwork */                                         \
+            { 0x0031, 0x09, ZAP_COMMAND_MASK(OUTGOING_SERVER) }, /* UpdateThreadNetworkResponse */                                 \
+            { 0x0031, 0x0A, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* RemoveNetwork */                                               \
+            { 0x0031, 0x0B, ZAP_COMMAND_MASK(INCOMING_CLIENT) }, /* RemoveNetworkResponse */                                       \
+            { 0x0031, 0x0C, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* EnableNetwork */                                               \
+            { 0x0031, 0x0D, ZAP_COMMAND_MASK(INCOMING_CLIENT) }, /* EnableNetworkResponse */                                       \
+            { 0x0031, 0x0E, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* DisableNetwork */                                              \
+            { 0x0031, 0x0F, ZAP_COMMAND_MASK(INCOMING_CLIENT) }, /* DisableNetworkResponse */                                      \
+            { 0x0031, 0x10, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* GetLastNetworkCommissioningResult */                           \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: Diagnostic Logs (server) */                                                                   \
+            { 0x0032, 0x00, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* RetrieveLogsRequest */                                         \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: Software Diagnostics (server) */                                                              \
+            { 0x0034, 0x00, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* ResetWatermarks */                                             \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: Ethernet Network Diagnostics (server) */                                                      \
+            { 0x0037, 0x00, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* ResetCounts */                                                 \
+                                                                                                                                   \
+            /* Endpoint: 0, Cluster: Operational Credentials (server) */                                                           \
+            { 0x003E, 0x00, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* SetFabric */                                                   \
+            { 0x003E, 0x01, ZAP_COMMAND_MASK(INCOMING_CLIENT) }, /* SetFabricResponse */                                           \
+            { 0x003E, 0x04, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* OpCSRRequest */                                                \
+            { 0x003E, 0x05, ZAP_COMMAND_MASK(INCOMING_CLIENT) }, /* OpCSRResponse */                                               \
+            { 0x003E, 0x06, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* AddOpCert */                                                   \
+            { 0x003E, 0x08, ZAP_COMMAND_MASK(INCOMING_CLIENT) }, /* OpCertResponse */                                              \
+            { 0x003E, 0x09, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* UpdateFabricLabel */                                           \
+            { 0x003E, 0x0A, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* RemoveFabric */                                                \
+            { 0x003E, 0x0B, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* RemoveAllFabrics */                                            \
+            { 0x003E, 0xA1, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* AddTrustedRootCertificate */                                   \
+            { 0x003E, 0xA2, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* RemoveTrustedRootCertificate */                                \
+                                                                                                                                   \
+            /* Endpoint: 1, Cluster: On/off (server) */                                                                            \
+            { 0x0006, 0x00, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* Off */                                                         \
+            { 0x0006, 0x01, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* On */                                                          \
+            { 0x0006, 0x02, ZAP_COMMAND_MASK(INCOMING_SERVER) }, /* Toggle */                                                      \
+    }
+
+// Array of EmberAfManufacturerCodeEntry structures for commands.
+#define GENERATED_COMMAND_MANUFACTURER_CODE_COUNT (0)
+#define GENERATED_COMMAND_MANUFACTURER_CODES                                                                                       \
+    {                                                                                                                              \
+        {                                                                                                                          \
+            0x00, 0x00                                                                                                             \
+        }                                                                                                                          \
+    }
+
+// This is an array of EmberAfManufacturerCodeEntry structures for clusters.
+#define GENERATED_CLUSTER_MANUFACTURER_CODE_COUNT (0)
+#define GENERATED_CLUSTER_MANUFACTURER_CODES                                                                                       \
+    {                                                                                                                              \
+        {                                                                                                                          \
+            0x00, 0x00                                                                                                             \
+        }                                                                                                                          \
+    }
+
+// This is an array of EmberAfManufacturerCodeEntry structures for attributes.
+#define GENERATED_ATTRIBUTE_MANUFACTURER_CODE_COUNT (0)
+#define GENERATED_ATTRIBUTE_MANUFACTURER_CODES                                                                                     \
+    {                                                                                                                              \
+        {                                                                                                                          \
+            0x00, 0x00                                                                                                             \
+        }                                                                                                                          \
+    }
+
+// Array of EmberAfPluginReportingEntry structures.
+#define ZRD(x) EMBER_ZCL_REPORTING_DIRECTION_##x
+#define ZAP_REPORT_DIRECTION(x) ZRD(x)
+
+// User options for plugin Reporting
+#define EMBER_AF_PLUGIN_REPORTING_TABLE_SIZE (1)
+#define EMBER_AF_PLUGIN_REPORTING_ENABLE_GROUP_BOUND_REPORTS
+
+#define EMBER_AF_GENERATED_REPORTING_CONFIG_DEFAULTS_TABLE_SIZE (1)
+#define EMBER_AF_GENERATED_REPORTING_CONFIG_DEFAULTS                                                                               \
+    {                                                                                                                              \
+                                                                                                                                   \
+        /* Endpoint: 1, Cluster: On/off (server) */                                                                                \
+        {                                                                                                                          \
+            ZAP_REPORT_DIRECTION(REPORTED), 0x0001, 0x0006, 0x0000, ZAP_CLUSTER_MASK(SERVER), 0x0000, { { 0, 65344, 0 } }          \
+        }, /* on/off */                                                                                                            \
+    }
diff --git a/cores/nRF5/nordic/config/nrf52840/gen/gen_config.h b/cores/nRF5/nordic/config/nrf52840/gen/gen_config.h
new file mode 100644
index 000000000..32a444f46
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/gen/gen_config.h
@@ -0,0 +1,99 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+// THIS FILE IS GENERATED BY ZAP
+
+// Prevent multiple inclusion
+#pragma once
+
+// User options for plugin Binding Table Library
+#define EMBER_BINDING_TABLE_SIZE 10
+
+/**** Network Section ****/
+#define EMBER_SUPPORTED_NETWORKS (1)
+
+#define EMBER_APS_UNICAST_MESSAGE_COUNT 10
+
+/**** Cluster endpoint counts ****/
+#define EMBER_AF_BASIC_CLUSTER_SERVER_ENDPOINT_COUNT (1)
+#define EMBER_AF_DIAGNOSTIC_LOGS_CLUSTER_SERVER_ENDPOINT_COUNT (1)
+#define EMBER_AF_ETHERNET_NETWORK_DIAGNOSTICS_CLUSTER_SERVER_ENDPOINT_COUNT (1)
+#define EMBER_AF_GENERAL_COMMISSIONING_CLUSTER_SERVER_ENDPOINT_COUNT (1)
+#define EMBER_AF_GENERAL_DIAGNOSTICS_CLUSTER_SERVER_ENDPOINT_COUNT (1)
+#define EMBER_AF_NETWORK_COMMISSIONING_CLUSTER_SERVER_ENDPOINT_COUNT (1)
+#define EMBER_AF_ON_OFF_CLUSTER_SERVER_ENDPOINT_COUNT (1)
+#define EMBER_AF_OPERATIONAL_CREDENTIALS_CLUSTER_SERVER_ENDPOINT_COUNT (1)
+#define EMBER_AF_SOFTWARE_DIAGNOSTICS_CLUSTER_SERVER_ENDPOINT_COUNT (1)
+#define EMBER_AF_THREAD_NETWORK_DIAGNOSTICS_CLUSTER_SERVER_ENDPOINT_COUNT (1)
+#define EMBER_AF_WIFI_NETWORK_DIAGNOSTICS_CLUSTER_SERVER_ENDPOINT_COUNT (1)
+
+/**** Cluster Plugins ****/
+
+// Use this macro to check if the server side of the Basic cluster is included
+#define ZCL_USING_BASIC_CLUSTER_SERVER
+#define EMBER_AF_PLUGIN_BASIC_SERVER
+#define EMBER_AF_PLUGIN_BASIC
+
+// Use this macro to check if the server side of the Diagnostic Logs cluster is included
+#define ZCL_USING_DIAGNOSTIC_LOGS_CLUSTER_SERVER
+#define EMBER_AF_PLUGIN_DIAGNOSTIC_LOGS_SERVER
+#define EMBER_AF_PLUGIN_DIAGNOSTIC_LOGS
+
+// Use this macro to check if the server side of the Ethernet Network Diagnostics cluster is included
+#define ZCL_USING_ETHERNET_NETWORK_DIAGNOSTICS_CLUSTER_SERVER
+#define EMBER_AF_PLUGIN_ETHERNET_NETWORK_DIAGNOSTICS_SERVER
+#define EMBER_AF_PLUGIN_ETHERNET_NETWORK_DIAGNOSTICS
+
+// Use this macro to check if the server side of the General Commissioning cluster is included
+#define ZCL_USING_GENERAL_COMMISSIONING_CLUSTER_SERVER
+#define EMBER_AF_PLUGIN_GENERAL_COMMISSIONING_SERVER
+#define EMBER_AF_PLUGIN_GENERAL_COMMISSIONING
+
+// Use this macro to check if the server side of the General Diagnostics cluster is included
+#define ZCL_USING_GENERAL_DIAGNOSTICS_CLUSTER_SERVER
+#define EMBER_AF_PLUGIN_GENERAL_DIAGNOSTICS_SERVER
+#define EMBER_AF_PLUGIN_GENERAL_DIAGNOSTICS
+
+// Use this macro to check if the server side of the Network Commissioning cluster is included
+#define ZCL_USING_NETWORK_COMMISSIONING_CLUSTER_SERVER
+#define EMBER_AF_PLUGIN_NETWORK_COMMISSIONING_SERVER
+#define EMBER_AF_PLUGIN_NETWORK_COMMISSIONING
+
+// Use this macro to check if the server side of the On/off cluster is included
+#define ZCL_USING_ON_OFF_CLUSTER_SERVER
+#define EMBER_AF_PLUGIN_ON_OFF_SERVER
+#define EMBER_AF_PLUGIN_ON_OFF
+
+// Use this macro to check if the server side of the Operational Credentials cluster is included
+#define ZCL_USING_OPERATIONAL_CREDENTIALS_CLUSTER_SERVER
+#define EMBER_AF_PLUGIN_OPERATIONAL_CREDENTIALS_SERVER
+#define EMBER_AF_PLUGIN_OPERATIONAL_CREDENTIALS
+
+// Use this macro to check if the server side of the Software Diagnostics cluster is included
+#define ZCL_USING_SOFTWARE_DIAGNOSTICS_CLUSTER_SERVER
+#define EMBER_AF_PLUGIN_SOFTWARE_DIAGNOSTICS_SERVER
+#define EMBER_AF_PLUGIN_SOFTWARE_DIAGNOSTICS
+
+// Use this macro to check if the server side of the Thread Network Diagnostics cluster is included
+#define ZCL_USING_THREAD_NETWORK_DIAGNOSTICS_CLUSTER_SERVER
+#define EMBER_AF_PLUGIN_THREAD_NETWORK_DIAGNOSTICS_SERVER
+#define EMBER_AF_PLUGIN_THREAD_NETWORK_DIAGNOSTICS
+
+// Use this macro to check if the server side of the WiFi Network Diagnostics cluster is included
+#define ZCL_USING_WIFI_NETWORK_DIAGNOSTICS_CLUSTER_SERVER
+#define EMBER_AF_PLUGIN_WI_FI_NETWORK_DIAGNOSTICS_SERVER
+#define EMBER_AF_PLUGIN_WI_FI_NETWORK_DIAGNOSTICS
diff --git a/cores/nRF5/nordic/config/nrf52840/gen/gen_tokens.h b/cores/nRF5/nordic/config/nrf52840/gen/gen_tokens.h
new file mode 100644
index 000000000..860bf575d
--- /dev/null
+++ b/cores/nRF5/nordic/config/nrf52840/gen/gen_tokens.h
@@ -0,0 +1,45 @@
+/*
+ *
+ *    Copyright (c) 2021 Project CHIP Authors
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *        http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+
+// THIS FILE IS GENERATED BY ZAP
+
+// Prevent multiple inclusion
+#pragma once
+
+// This file contains the tokens for attributes stored in flash
+
+// Identifier tags for tokens
+
+// Types for the tokens
+#ifdef DEFINETYPES
+#endif // DEFINETYPES
+
+// Actual token definitions
+#ifdef DEFINETOKENS
+#endif // DEFINETOKENS
+
+// Macro snippet that loads all the attributes from tokens
+#define GENERATED_TOKEN_LOADER(endpoint)                                                                                           \
+    do                                                                                                                             \
+    {                                                                                                                              \
+    } while (false)
+
+// Macro snippet that saves the attribute to token
+#define GENERATED_TOKEN_SAVER                                                                                                      \
+    do                                                                                                                             \
+    {                                                                                                                              \
+    } while (false)
